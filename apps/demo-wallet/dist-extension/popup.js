true              &&(function polyfill() {
	const relList = document.createElement("link").relList;
	if (relList && relList.supports && relList.supports("modulepreload")) return;
	for (const link of document.querySelectorAll("link[rel=\"modulepreload\"]")) processPreload(link);
	new MutationObserver((mutations) => {
		for (const mutation of mutations) {
			if (mutation.type !== "childList") continue;
			for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
		}
	}).observe(document, {
		childList: true,
		subtree: true
	});
	function getFetchOpts(link) {
		const fetchOpts = {};
		if (link.integrity) fetchOpts.integrity = link.integrity;
		if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
		if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
		else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
		else fetchOpts.credentials = "same-origin";
		return fetchOpts;
	}
	function processPreload(link) {
		if (link.ep) return;
		link.ep = true;
		const fetchOpts = getFetchOpts(link);
		fetch(link.href, fetchOpts);
	}
}());

function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      var isInstance = false;
      try {
        isInstance = this instanceof a2;
      } catch {
      }
      if (isInstance) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}

var buffer$1 = {};

var base64Js$1 = {};

var hasRequiredBase64Js$1;

function requireBase64Js$1 () {
	if (hasRequiredBase64Js$1) return base64Js$1;
	hasRequiredBase64Js$1 = 1;

	base64Js$1.byteLength = byteLength;
	base64Js$1.toByteArray = toByteArray;
	base64Js$1.fromByteArray = fromByteArray;

	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i];
	  revLookup[code.charCodeAt(i)] = i;
	}

	// Support decoding URL-safe base64 strings, as Node.js does.
	// See: https://en.wikipedia.org/wiki/Base64#URL_applications
	revLookup['-'.charCodeAt(0)] = 62;
	revLookup['_'.charCodeAt(0)] = 63;

	function getLens (b64) {
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // Trim off extra bytes after placeholder bytes are found
	  // See: https://github.com/beatgammit/base64-js/issues/42
	  var validLen = b64.indexOf('=');
	  if (validLen === -1) validLen = len;

	  var placeHoldersLen = validLen === len
	    ? 0
	    : 4 - (validLen % 4);

	  return [validLen, placeHoldersLen]
	}

	// base64 is 4/3 + up to two characters of the original data
	function byteLength (b64) {
	  var lens = getLens(b64);
	  var validLen = lens[0];
	  var placeHoldersLen = lens[1];
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}

	function _byteLength (b64, validLen, placeHoldersLen) {
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}

	function toByteArray (b64) {
	  var tmp;
	  var lens = getLens(b64);
	  var validLen = lens[0];
	  var placeHoldersLen = lens[1];

	  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

	  var curByte = 0;

	  // if there are placeholders, only get up to the last complete 4 chars
	  var len = placeHoldersLen > 0
	    ? validLen - 4
	    : validLen;

	  var i;
	  for (i = 0; i < len; i += 4) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 18) |
	      (revLookup[b64.charCodeAt(i + 1)] << 12) |
	      (revLookup[b64.charCodeAt(i + 2)] << 6) |
	      revLookup[b64.charCodeAt(i + 3)];
	    arr[curByte++] = (tmp >> 16) & 0xFF;
	    arr[curByte++] = (tmp >> 8) & 0xFF;
	    arr[curByte++] = tmp & 0xFF;
	  }

	  if (placeHoldersLen === 2) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 2) |
	      (revLookup[b64.charCodeAt(i + 1)] >> 4);
	    arr[curByte++] = tmp & 0xFF;
	  }

	  if (placeHoldersLen === 1) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 10) |
	      (revLookup[b64.charCodeAt(i + 1)] << 4) |
	      (revLookup[b64.charCodeAt(i + 2)] >> 2);
	    arr[curByte++] = (tmp >> 8) & 0xFF;
	    arr[curByte++] = tmp & 0xFF;
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] +
	    lookup[num >> 12 & 0x3F] +
	    lookup[num >> 6 & 0x3F] +
	    lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp =
	      ((uint8[i] << 16) & 0xFF0000) +
	      ((uint8[i + 1] << 8) & 0xFF00) +
	      (uint8[i + 2] & 0xFF);
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    parts.push(
	      lookup[tmp >> 2] +
	      lookup[(tmp << 4) & 0x3F] +
	      '=='
	    );
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
	    parts.push(
	      lookup[tmp >> 10] +
	      lookup[(tmp >> 4) & 0x3F] +
	      lookup[(tmp << 2) & 0x3F] +
	      '='
	    );
	  }

	  return parts.join('')
	}
	return base64Js$1;
}

var ieee754$1 = {};

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredIeee754$1;

function requireIeee754$1 () {
	if (hasRequiredIeee754$1) return ieee754$1;
	hasRequiredIeee754$1 = 1;
	ieee754$1.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = (nBytes * 8) - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	};

	ieee754$1.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = (nBytes * 8) - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = ((value * c) - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	};
	return ieee754$1;
}

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

var hasRequiredBuffer$1;

function requireBuffer$1 () {
	if (hasRequiredBuffer$1) return buffer$1;
	hasRequiredBuffer$1 = 1;
	(function (exports) {

		const base64 = requireBase64Js$1();
		const ieee754 = requireIeee754$1();
		const customInspectSymbol =
		  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
		    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
		    : null;

		exports.Buffer = Buffer;
		exports.SlowBuffer = SlowBuffer;
		exports.INSPECT_MAX_BYTES = 50;

		const K_MAX_LENGTH = 0x7fffffff;
		exports.kMaxLength = K_MAX_LENGTH;

		/**
		 * If `Buffer.TYPED_ARRAY_SUPPORT`:
		 *   === true    Use Uint8Array implementation (fastest)
		 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
		 *               implementation (most compatible, even IE6)
		 *
		 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
		 * Opera 11.6+, iOS 4.2+.
		 *
		 * We report that the browser does not support typed arrays if the are not subclassable
		 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
		 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
		 * for __proto__ and has a buggy typed array implementation.
		 */
		Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

		if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
		    typeof console.error === 'function') {
		  console.error(
		    'This browser lacks typed array (Uint8Array) support which is required by ' +
		    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
		  );
		}

		function typedArraySupport () {
		  // Can typed array instances can be augmented?
		  try {
		    const arr = new Uint8Array(1);
		    const proto = { foo: function () { return 42 } };
		    Object.setPrototypeOf(proto, Uint8Array.prototype);
		    Object.setPrototypeOf(arr, proto);
		    return arr.foo() === 42
		  } catch (e) {
		    return false
		  }
		}

		Object.defineProperty(Buffer.prototype, 'parent', {
		  enumerable: true,
		  get: function () {
		    if (!Buffer.isBuffer(this)) return undefined
		    return this.buffer
		  }
		});

		Object.defineProperty(Buffer.prototype, 'offset', {
		  enumerable: true,
		  get: function () {
		    if (!Buffer.isBuffer(this)) return undefined
		    return this.byteOffset
		  }
		});

		function createBuffer (length) {
		  if (length > K_MAX_LENGTH) {
		    throw new RangeError('The value "' + length + '" is invalid for option "size"')
		  }
		  // Return an augmented `Uint8Array` instance
		  const buf = new Uint8Array(length);
		  Object.setPrototypeOf(buf, Buffer.prototype);
		  return buf
		}

		/**
		 * The Buffer constructor returns instances of `Uint8Array` that have their
		 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
		 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
		 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
		 * returns a single octet.
		 *
		 * The `Uint8Array` prototype remains unmodified.
		 */

		function Buffer (arg, encodingOrOffset, length) {
		  // Common case.
		  if (typeof arg === 'number') {
		    if (typeof encodingOrOffset === 'string') {
		      throw new TypeError(
		        'The "string" argument must be of type string. Received type number'
		      )
		    }
		    return allocUnsafe(arg)
		  }
		  return from(arg, encodingOrOffset, length)
		}

		Buffer.poolSize = 8192; // not used by this implementation

		function from (value, encodingOrOffset, length) {
		  if (typeof value === 'string') {
		    return fromString(value, encodingOrOffset)
		  }

		  if (ArrayBuffer.isView(value)) {
		    return fromArrayView(value)
		  }

		  if (value == null) {
		    throw new TypeError(
		      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
		      'or Array-like Object. Received type ' + (typeof value)
		    )
		  }

		  if (isInstance(value, ArrayBuffer) ||
		      (value && isInstance(value.buffer, ArrayBuffer))) {
		    return fromArrayBuffer(value, encodingOrOffset, length)
		  }

		  if (typeof SharedArrayBuffer !== 'undefined' &&
		      (isInstance(value, SharedArrayBuffer) ||
		      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
		    return fromArrayBuffer(value, encodingOrOffset, length)
		  }

		  if (typeof value === 'number') {
		    throw new TypeError(
		      'The "value" argument must not be of type number. Received type number'
		    )
		  }

		  const valueOf = value.valueOf && value.valueOf();
		  if (valueOf != null && valueOf !== value) {
		    return Buffer.from(valueOf, encodingOrOffset, length)
		  }

		  const b = fromObject(value);
		  if (b) return b

		  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
		      typeof value[Symbol.toPrimitive] === 'function') {
		    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
		  }

		  throw new TypeError(
		    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
		    'or Array-like Object. Received type ' + (typeof value)
		  )
		}

		/**
		 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
		 * if value is a number.
		 * Buffer.from(str[, encoding])
		 * Buffer.from(array)
		 * Buffer.from(buffer)
		 * Buffer.from(arrayBuffer[, byteOffset[, length]])
		 **/
		Buffer.from = function (value, encodingOrOffset, length) {
		  return from(value, encodingOrOffset, length)
		};

		// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
		// https://github.com/feross/buffer/pull/148
		Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
		Object.setPrototypeOf(Buffer, Uint8Array);

		function assertSize (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('"size" argument must be of type number')
		  } else if (size < 0) {
		    throw new RangeError('The value "' + size + '" is invalid for option "size"')
		  }
		}

		function alloc (size, fill, encoding) {
		  assertSize(size);
		  if (size <= 0) {
		    return createBuffer(size)
		  }
		  if (fill !== undefined) {
		    // Only pay attention to encoding if it's a string. This
		    // prevents accidentally sending in a number that would
		    // be interpreted as a start offset.
		    return typeof encoding === 'string'
		      ? createBuffer(size).fill(fill, encoding)
		      : createBuffer(size).fill(fill)
		  }
		  return createBuffer(size)
		}

		/**
		 * Creates a new filled Buffer instance.
		 * alloc(size[, fill[, encoding]])
		 **/
		Buffer.alloc = function (size, fill, encoding) {
		  return alloc(size, fill, encoding)
		};

		function allocUnsafe (size) {
		  assertSize(size);
		  return createBuffer(size < 0 ? 0 : checked(size) | 0)
		}

		/**
		 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
		 * */
		Buffer.allocUnsafe = function (size) {
		  return allocUnsafe(size)
		};
		/**
		 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
		 */
		Buffer.allocUnsafeSlow = function (size) {
		  return allocUnsafe(size)
		};

		function fromString (string, encoding) {
		  if (typeof encoding !== 'string' || encoding === '') {
		    encoding = 'utf8';
		  }

		  if (!Buffer.isEncoding(encoding)) {
		    throw new TypeError('Unknown encoding: ' + encoding)
		  }

		  const length = byteLength(string, encoding) | 0;
		  let buf = createBuffer(length);

		  const actual = buf.write(string, encoding);

		  if (actual !== length) {
		    // Writing a hex string, for example, that contains invalid characters will
		    // cause everything after the first invalid character to be ignored. (e.g.
		    // 'abxxcd' will be treated as 'ab')
		    buf = buf.slice(0, actual);
		  }

		  return buf
		}

		function fromArrayLike (array) {
		  const length = array.length < 0 ? 0 : checked(array.length) | 0;
		  const buf = createBuffer(length);
		  for (let i = 0; i < length; i += 1) {
		    buf[i] = array[i] & 255;
		  }
		  return buf
		}

		function fromArrayView (arrayView) {
		  if (isInstance(arrayView, Uint8Array)) {
		    const copy = new Uint8Array(arrayView);
		    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
		  }
		  return fromArrayLike(arrayView)
		}

		function fromArrayBuffer (array, byteOffset, length) {
		  if (byteOffset < 0 || array.byteLength < byteOffset) {
		    throw new RangeError('"offset" is outside of buffer bounds')
		  }

		  if (array.byteLength < byteOffset + (length || 0)) {
		    throw new RangeError('"length" is outside of buffer bounds')
		  }

		  let buf;
		  if (byteOffset === undefined && length === undefined) {
		    buf = new Uint8Array(array);
		  } else if (length === undefined) {
		    buf = new Uint8Array(array, byteOffset);
		  } else {
		    buf = new Uint8Array(array, byteOffset, length);
		  }

		  // Return an augmented `Uint8Array` instance
		  Object.setPrototypeOf(buf, Buffer.prototype);

		  return buf
		}

		function fromObject (obj) {
		  if (Buffer.isBuffer(obj)) {
		    const len = checked(obj.length) | 0;
		    const buf = createBuffer(len);

		    if (buf.length === 0) {
		      return buf
		    }

		    obj.copy(buf, 0, 0, len);
		    return buf
		  }

		  if (obj.length !== undefined) {
		    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
		      return createBuffer(0)
		    }
		    return fromArrayLike(obj)
		  }

		  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
		    return fromArrayLike(obj.data)
		  }
		}

		function checked (length) {
		  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
		  // length is NaN (which is otherwise coerced to zero.)
		  if (length >= K_MAX_LENGTH) {
		    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
		                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
		  }
		  return length | 0
		}

		function SlowBuffer (length) {
		  if (+length != length) { // eslint-disable-line eqeqeq
		    length = 0;
		  }
		  return Buffer.alloc(+length)
		}

		Buffer.isBuffer = function isBuffer (b) {
		  return b != null && b._isBuffer === true &&
		    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
		};

		Buffer.compare = function compare (a, b) {
		  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
		  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
		  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
		    throw new TypeError(
		      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
		    )
		  }

		  if (a === b) return 0

		  let x = a.length;
		  let y = b.length;

		  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
		    if (a[i] !== b[i]) {
		      x = a[i];
		      y = b[i];
		      break
		    }
		  }

		  if (x < y) return -1
		  if (y < x) return 1
		  return 0
		};

		Buffer.isEncoding = function isEncoding (encoding) {
		  switch (String(encoding).toLowerCase()) {
		    case 'hex':
		    case 'utf8':
		    case 'utf-8':
		    case 'ascii':
		    case 'latin1':
		    case 'binary':
		    case 'base64':
		    case 'ucs2':
		    case 'ucs-2':
		    case 'utf16le':
		    case 'utf-16le':
		      return true
		    default:
		      return false
		  }
		};

		Buffer.concat = function concat (list, length) {
		  if (!Array.isArray(list)) {
		    throw new TypeError('"list" argument must be an Array of Buffers')
		  }

		  if (list.length === 0) {
		    return Buffer.alloc(0)
		  }

		  let i;
		  if (length === undefined) {
		    length = 0;
		    for (i = 0; i < list.length; ++i) {
		      length += list[i].length;
		    }
		  }

		  const buffer = Buffer.allocUnsafe(length);
		  let pos = 0;
		  for (i = 0; i < list.length; ++i) {
		    let buf = list[i];
		    if (isInstance(buf, Uint8Array)) {
		      if (pos + buf.length > buffer.length) {
		        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
		        buf.copy(buffer, pos);
		      } else {
		        Uint8Array.prototype.set.call(
		          buffer,
		          buf,
		          pos
		        );
		      }
		    } else if (!Buffer.isBuffer(buf)) {
		      throw new TypeError('"list" argument must be an Array of Buffers')
		    } else {
		      buf.copy(buffer, pos);
		    }
		    pos += buf.length;
		  }
		  return buffer
		};

		function byteLength (string, encoding) {
		  if (Buffer.isBuffer(string)) {
		    return string.length
		  }
		  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
		    return string.byteLength
		  }
		  if (typeof string !== 'string') {
		    throw new TypeError(
		      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
		      'Received type ' + typeof string
		    )
		  }

		  const len = string.length;
		  const mustMatch = (arguments.length > 2 && arguments[2] === true);
		  if (!mustMatch && len === 0) return 0

		  // Use a for loop to avoid recursion
		  let loweredCase = false;
		  for (;;) {
		    switch (encoding) {
		      case 'ascii':
		      case 'latin1':
		      case 'binary':
		        return len
		      case 'utf8':
		      case 'utf-8':
		        return utf8ToBytes(string).length
		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return len * 2
		      case 'hex':
		        return len >>> 1
		      case 'base64':
		        return base64ToBytes(string).length
		      default:
		        if (loweredCase) {
		          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
		        }
		        encoding = ('' + encoding).toLowerCase();
		        loweredCase = true;
		    }
		  }
		}
		Buffer.byteLength = byteLength;

		function slowToString (encoding, start, end) {
		  let loweredCase = false;

		  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
		  // property of a typed array.

		  // This behaves neither like String nor Uint8Array in that we set start/end
		  // to their upper/lower bounds if the value passed is out of range.
		  // undefined is handled specially as per ECMA-262 6th Edition,
		  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
		  if (start === undefined || start < 0) {
		    start = 0;
		  }
		  // Return early if start > this.length. Done here to prevent potential uint32
		  // coercion fail below.
		  if (start > this.length) {
		    return ''
		  }

		  if (end === undefined || end > this.length) {
		    end = this.length;
		  }

		  if (end <= 0) {
		    return ''
		  }

		  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
		  end >>>= 0;
		  start >>>= 0;

		  if (end <= start) {
		    return ''
		  }

		  if (!encoding) encoding = 'utf8';

		  while (true) {
		    switch (encoding) {
		      case 'hex':
		        return hexSlice(this, start, end)

		      case 'utf8':
		      case 'utf-8':
		        return utf8Slice(this, start, end)

		      case 'ascii':
		        return asciiSlice(this, start, end)

		      case 'latin1':
		      case 'binary':
		        return latin1Slice(this, start, end)

		      case 'base64':
		        return base64Slice(this, start, end)

		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return utf16leSlice(this, start, end)

		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = (encoding + '').toLowerCase();
		        loweredCase = true;
		    }
		  }
		}

		// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
		// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
		// reliably in a browserify context because there could be multiple different
		// copies of the 'buffer' package in use. This method works even for Buffer
		// instances that were created from another copy of the `buffer` package.
		// See: https://github.com/feross/buffer/issues/154
		Buffer.prototype._isBuffer = true;

		function swap (b, n, m) {
		  const i = b[n];
		  b[n] = b[m];
		  b[m] = i;
		}

		Buffer.prototype.swap16 = function swap16 () {
		  const len = this.length;
		  if (len % 2 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 16-bits')
		  }
		  for (let i = 0; i < len; i += 2) {
		    swap(this, i, i + 1);
		  }
		  return this
		};

		Buffer.prototype.swap32 = function swap32 () {
		  const len = this.length;
		  if (len % 4 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 32-bits')
		  }
		  for (let i = 0; i < len; i += 4) {
		    swap(this, i, i + 3);
		    swap(this, i + 1, i + 2);
		  }
		  return this
		};

		Buffer.prototype.swap64 = function swap64 () {
		  const len = this.length;
		  if (len % 8 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 64-bits')
		  }
		  for (let i = 0; i < len; i += 8) {
		    swap(this, i, i + 7);
		    swap(this, i + 1, i + 6);
		    swap(this, i + 2, i + 5);
		    swap(this, i + 3, i + 4);
		  }
		  return this
		};

		Buffer.prototype.toString = function toString () {
		  const length = this.length;
		  if (length === 0) return ''
		  if (arguments.length === 0) return utf8Slice(this, 0, length)
		  return slowToString.apply(this, arguments)
		};

		Buffer.prototype.toLocaleString = Buffer.prototype.toString;

		Buffer.prototype.equals = function equals (b) {
		  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
		  if (this === b) return true
		  return Buffer.compare(this, b) === 0
		};

		Buffer.prototype.inspect = function inspect () {
		  let str = '';
		  const max = exports.INSPECT_MAX_BYTES;
		  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
		  if (this.length > max) str += ' ... ';
		  return '<Buffer ' + str + '>'
		};
		if (customInspectSymbol) {
		  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
		}

		Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
		  if (isInstance(target, Uint8Array)) {
		    target = Buffer.from(target, target.offset, target.byteLength);
		  }
		  if (!Buffer.isBuffer(target)) {
		    throw new TypeError(
		      'The "target" argument must be one of type Buffer or Uint8Array. ' +
		      'Received type ' + (typeof target)
		    )
		  }

		  if (start === undefined) {
		    start = 0;
		  }
		  if (end === undefined) {
		    end = target ? target.length : 0;
		  }
		  if (thisStart === undefined) {
		    thisStart = 0;
		  }
		  if (thisEnd === undefined) {
		    thisEnd = this.length;
		  }

		  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
		    throw new RangeError('out of range index')
		  }

		  if (thisStart >= thisEnd && start >= end) {
		    return 0
		  }
		  if (thisStart >= thisEnd) {
		    return -1
		  }
		  if (start >= end) {
		    return 1
		  }

		  start >>>= 0;
		  end >>>= 0;
		  thisStart >>>= 0;
		  thisEnd >>>= 0;

		  if (this === target) return 0

		  let x = thisEnd - thisStart;
		  let y = end - start;
		  const len = Math.min(x, y);

		  const thisCopy = this.slice(thisStart, thisEnd);
		  const targetCopy = target.slice(start, end);

		  for (let i = 0; i < len; ++i) {
		    if (thisCopy[i] !== targetCopy[i]) {
		      x = thisCopy[i];
		      y = targetCopy[i];
		      break
		    }
		  }

		  if (x < y) return -1
		  if (y < x) return 1
		  return 0
		};

		// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
		// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
		//
		// Arguments:
		// - buffer - a Buffer to search
		// - val - a string, Buffer, or number
		// - byteOffset - an index into `buffer`; will be clamped to an int32
		// - encoding - an optional encoding, relevant is val is a string
		// - dir - true for indexOf, false for lastIndexOf
		function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
		  // Empty buffer means no match
		  if (buffer.length === 0) return -1

		  // Normalize byteOffset
		  if (typeof byteOffset === 'string') {
		    encoding = byteOffset;
		    byteOffset = 0;
		  } else if (byteOffset > 0x7fffffff) {
		    byteOffset = 0x7fffffff;
		  } else if (byteOffset < -2147483648) {
		    byteOffset = -2147483648;
		  }
		  byteOffset = +byteOffset; // Coerce to Number.
		  if (numberIsNaN(byteOffset)) {
		    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
		    byteOffset = dir ? 0 : (buffer.length - 1);
		  }

		  // Normalize byteOffset: negative offsets start from the end of the buffer
		  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
		  if (byteOffset >= buffer.length) {
		    if (dir) return -1
		    else byteOffset = buffer.length - 1;
		  } else if (byteOffset < 0) {
		    if (dir) byteOffset = 0;
		    else return -1
		  }

		  // Normalize val
		  if (typeof val === 'string') {
		    val = Buffer.from(val, encoding);
		  }

		  // Finally, search either indexOf (if dir is true) or lastIndexOf
		  if (Buffer.isBuffer(val)) {
		    // Special case: looking for empty string/buffer always fails
		    if (val.length === 0) {
		      return -1
		    }
		    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
		  } else if (typeof val === 'number') {
		    val = val & 0xFF; // Search for a byte value [0-255]
		    if (typeof Uint8Array.prototype.indexOf === 'function') {
		      if (dir) {
		        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
		      } else {
		        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
		      }
		    }
		    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
		  }

		  throw new TypeError('val must be string, number or Buffer')
		}

		function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
		  let indexSize = 1;
		  let arrLength = arr.length;
		  let valLength = val.length;

		  if (encoding !== undefined) {
		    encoding = String(encoding).toLowerCase();
		    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
		        encoding === 'utf16le' || encoding === 'utf-16le') {
		      if (arr.length < 2 || val.length < 2) {
		        return -1
		      }
		      indexSize = 2;
		      arrLength /= 2;
		      valLength /= 2;
		      byteOffset /= 2;
		    }
		  }

		  function read (buf, i) {
		    if (indexSize === 1) {
		      return buf[i]
		    } else {
		      return buf.readUInt16BE(i * indexSize)
		    }
		  }

		  let i;
		  if (dir) {
		    let foundIndex = -1;
		    for (i = byteOffset; i < arrLength; i++) {
		      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
		        if (foundIndex === -1) foundIndex = i;
		        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
		      } else {
		        if (foundIndex !== -1) i -= i - foundIndex;
		        foundIndex = -1;
		      }
		    }
		  } else {
		    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
		    for (i = byteOffset; i >= 0; i--) {
		      let found = true;
		      for (let j = 0; j < valLength; j++) {
		        if (read(arr, i + j) !== read(val, j)) {
		          found = false;
		          break
		        }
		      }
		      if (found) return i
		    }
		  }

		  return -1
		}

		Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
		  return this.indexOf(val, byteOffset, encoding) !== -1
		};

		Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
		  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
		};

		Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
		  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
		};

		function hexWrite (buf, string, offset, length) {
		  offset = Number(offset) || 0;
		  const remaining = buf.length - offset;
		  if (!length) {
		    length = remaining;
		  } else {
		    length = Number(length);
		    if (length > remaining) {
		      length = remaining;
		    }
		  }

		  const strLen = string.length;

		  if (length > strLen / 2) {
		    length = strLen / 2;
		  }
		  let i;
		  for (i = 0; i < length; ++i) {
		    const parsed = parseInt(string.substr(i * 2, 2), 16);
		    if (numberIsNaN(parsed)) return i
		    buf[offset + i] = parsed;
		  }
		  return i
		}

		function utf8Write (buf, string, offset, length) {
		  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
		}

		function asciiWrite (buf, string, offset, length) {
		  return blitBuffer(asciiToBytes(string), buf, offset, length)
		}

		function base64Write (buf, string, offset, length) {
		  return blitBuffer(base64ToBytes(string), buf, offset, length)
		}

		function ucs2Write (buf, string, offset, length) {
		  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
		}

		Buffer.prototype.write = function write (string, offset, length, encoding) {
		  // Buffer#write(string)
		  if (offset === undefined) {
		    encoding = 'utf8';
		    length = this.length;
		    offset = 0;
		  // Buffer#write(string, encoding)
		  } else if (length === undefined && typeof offset === 'string') {
		    encoding = offset;
		    length = this.length;
		    offset = 0;
		  // Buffer#write(string, offset[, length][, encoding])
		  } else if (isFinite(offset)) {
		    offset = offset >>> 0;
		    if (isFinite(length)) {
		      length = length >>> 0;
		      if (encoding === undefined) encoding = 'utf8';
		    } else {
		      encoding = length;
		      length = undefined;
		    }
		  } else {
		    throw new Error(
		      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
		    )
		  }

		  const remaining = this.length - offset;
		  if (length === undefined || length > remaining) length = remaining;

		  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
		    throw new RangeError('Attempt to write outside buffer bounds')
		  }

		  if (!encoding) encoding = 'utf8';

		  let loweredCase = false;
		  for (;;) {
		    switch (encoding) {
		      case 'hex':
		        return hexWrite(this, string, offset, length)

		      case 'utf8':
		      case 'utf-8':
		        return utf8Write(this, string, offset, length)

		      case 'ascii':
		      case 'latin1':
		      case 'binary':
		        return asciiWrite(this, string, offset, length)

		      case 'base64':
		        // Warning: maxLength not taken into account in base64Write
		        return base64Write(this, string, offset, length)

		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return ucs2Write(this, string, offset, length)

		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = ('' + encoding).toLowerCase();
		        loweredCase = true;
		    }
		  }
		};

		Buffer.prototype.toJSON = function toJSON () {
		  return {
		    type: 'Buffer',
		    data: Array.prototype.slice.call(this._arr || this, 0)
		  }
		};

		function base64Slice (buf, start, end) {
		  if (start === 0 && end === buf.length) {
		    return base64.fromByteArray(buf)
		  } else {
		    return base64.fromByteArray(buf.slice(start, end))
		  }
		}

		function utf8Slice (buf, start, end) {
		  end = Math.min(buf.length, end);
		  const res = [];

		  let i = start;
		  while (i < end) {
		    const firstByte = buf[i];
		    let codePoint = null;
		    let bytesPerSequence = (firstByte > 0xEF)
		      ? 4
		      : (firstByte > 0xDF)
		          ? 3
		          : (firstByte > 0xBF)
		              ? 2
		              : 1;

		    if (i + bytesPerSequence <= end) {
		      let secondByte, thirdByte, fourthByte, tempCodePoint;

		      switch (bytesPerSequence) {
		        case 1:
		          if (firstByte < 0x80) {
		            codePoint = firstByte;
		          }
		          break
		        case 2:
		          secondByte = buf[i + 1];
		          if ((secondByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
		            if (tempCodePoint > 0x7F) {
		              codePoint = tempCodePoint;
		            }
		          }
		          break
		        case 3:
		          secondByte = buf[i + 1];
		          thirdByte = buf[i + 2];
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
		            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
		              codePoint = tempCodePoint;
		            }
		          }
		          break
		        case 4:
		          secondByte = buf[i + 1];
		          thirdByte = buf[i + 2];
		          fourthByte = buf[i + 3];
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
		            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
		              codePoint = tempCodePoint;
		            }
		          }
		      }
		    }

		    if (codePoint === null) {
		      // we did not generate a valid codePoint so insert a
		      // replacement char (U+FFFD) and advance only 1 byte
		      codePoint = 0xFFFD;
		      bytesPerSequence = 1;
		    } else if (codePoint > 0xFFFF) {
		      // encode to utf16 (surrogate pair dance)
		      codePoint -= 0x10000;
		      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
		      codePoint = 0xDC00 | codePoint & 0x3FF;
		    }

		    res.push(codePoint);
		    i += bytesPerSequence;
		  }

		  return decodeCodePointsArray(res)
		}

		// Based on http://stackoverflow.com/a/22747272/680742, the browser with
		// the lowest limit is Chrome, with 0x10000 args.
		// We go 1 magnitude less, for safety
		const MAX_ARGUMENTS_LENGTH = 0x1000;

		function decodeCodePointsArray (codePoints) {
		  const len = codePoints.length;
		  if (len <= MAX_ARGUMENTS_LENGTH) {
		    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
		  }

		  // Decode in chunks to avoid "call stack size exceeded".
		  let res = '';
		  let i = 0;
		  while (i < len) {
		    res += String.fromCharCode.apply(
		      String,
		      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
		    );
		  }
		  return res
		}

		function asciiSlice (buf, start, end) {
		  let ret = '';
		  end = Math.min(buf.length, end);

		  for (let i = start; i < end; ++i) {
		    ret += String.fromCharCode(buf[i] & 0x7F);
		  }
		  return ret
		}

		function latin1Slice (buf, start, end) {
		  let ret = '';
		  end = Math.min(buf.length, end);

		  for (let i = start; i < end; ++i) {
		    ret += String.fromCharCode(buf[i]);
		  }
		  return ret
		}

		function hexSlice (buf, start, end) {
		  const len = buf.length;

		  if (!start || start < 0) start = 0;
		  if (!end || end < 0 || end > len) end = len;

		  let out = '';
		  for (let i = start; i < end; ++i) {
		    out += hexSliceLookupTable[buf[i]];
		  }
		  return out
		}

		function utf16leSlice (buf, start, end) {
		  const bytes = buf.slice(start, end);
		  let res = '';
		  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
		  for (let i = 0; i < bytes.length - 1; i += 2) {
		    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
		  }
		  return res
		}

		Buffer.prototype.slice = function slice (start, end) {
		  const len = this.length;
		  start = ~~start;
		  end = end === undefined ? len : ~~end;

		  if (start < 0) {
		    start += len;
		    if (start < 0) start = 0;
		  } else if (start > len) {
		    start = len;
		  }

		  if (end < 0) {
		    end += len;
		    if (end < 0) end = 0;
		  } else if (end > len) {
		    end = len;
		  }

		  if (end < start) end = start;

		  const newBuf = this.subarray(start, end);
		  // Return an augmented `Uint8Array` instance
		  Object.setPrototypeOf(newBuf, Buffer.prototype);

		  return newBuf
		};

		/*
		 * Need to make sure that buffer isn't trying to write out of bounds.
		 */
		function checkOffset (offset, ext, length) {
		  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
		  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
		}

		Buffer.prototype.readUintLE =
		Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) checkOffset(offset, byteLength, this.length);

		  let val = this[offset];
		  let mul = 1;
		  let i = 0;
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul;
		  }

		  return val
		};

		Buffer.prototype.readUintBE =
		Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) {
		    checkOffset(offset, byteLength, this.length);
		  }

		  let val = this[offset + --byteLength];
		  let mul = 1;
		  while (byteLength > 0 && (mul *= 0x100)) {
		    val += this[offset + --byteLength] * mul;
		  }

		  return val
		};

		Buffer.prototype.readUint8 =
		Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 1, this.length);
		  return this[offset]
		};

		Buffer.prototype.readUint16LE =
		Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  return this[offset] | (this[offset + 1] << 8)
		};

		Buffer.prototype.readUint16BE =
		Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  return (this[offset] << 8) | this[offset + 1]
		};

		Buffer.prototype.readUint32LE =
		Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return ((this[offset]) |
		      (this[offset + 1] << 8) |
		      (this[offset + 2] << 16)) +
		      (this[offset + 3] * 0x1000000)
		};

		Buffer.prototype.readUint32BE =
		Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return (this[offset] * 0x1000000) +
		    ((this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    this[offset + 3])
		};

		Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
		  offset = offset >>> 0;
		  validateNumber(offset, 'offset');
		  const first = this[offset];
		  const last = this[offset + 7];
		  if (first === undefined || last === undefined) {
		    boundsError(offset, this.length - 8);
		  }

		  const lo = first +
		    this[++offset] * 2 ** 8 +
		    this[++offset] * 2 ** 16 +
		    this[++offset] * 2 ** 24;

		  const hi = this[++offset] +
		    this[++offset] * 2 ** 8 +
		    this[++offset] * 2 ** 16 +
		    last * 2 ** 24;

		  return BigInt(lo) + (BigInt(hi) << BigInt(32))
		});

		Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
		  offset = offset >>> 0;
		  validateNumber(offset, 'offset');
		  const first = this[offset];
		  const last = this[offset + 7];
		  if (first === undefined || last === undefined) {
		    boundsError(offset, this.length - 8);
		  }

		  const hi = first * 2 ** 24 +
		    this[++offset] * 2 ** 16 +
		    this[++offset] * 2 ** 8 +
		    this[++offset];

		  const lo = this[++offset] * 2 ** 24 +
		    this[++offset] * 2 ** 16 +
		    this[++offset] * 2 ** 8 +
		    last;

		  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
		});

		Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) checkOffset(offset, byteLength, this.length);

		  let val = this[offset];
		  let mul = 1;
		  let i = 0;
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul;
		  }
		  mul *= 0x80;

		  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

		  return val
		};

		Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) checkOffset(offset, byteLength, this.length);

		  let i = byteLength;
		  let mul = 1;
		  let val = this[offset + --i];
		  while (i > 0 && (mul *= 0x100)) {
		    val += this[offset + --i] * mul;
		  }
		  mul *= 0x80;

		  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

		  return val
		};

		Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 1, this.length);
		  if (!(this[offset] & 0x80)) return (this[offset])
		  return ((0xff - this[offset] + 1) * -1)
		};

		Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  const val = this[offset] | (this[offset + 1] << 8);
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		};

		Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  const val = this[offset + 1] | (this[offset] << 8);
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		};

		Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return (this[offset]) |
		    (this[offset + 1] << 8) |
		    (this[offset + 2] << 16) |
		    (this[offset + 3] << 24)
		};

		Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return (this[offset] << 24) |
		    (this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    (this[offset + 3])
		};

		Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
		  offset = offset >>> 0;
		  validateNumber(offset, 'offset');
		  const first = this[offset];
		  const last = this[offset + 7];
		  if (first === undefined || last === undefined) {
		    boundsError(offset, this.length - 8);
		  }

		  const val = this[offset + 4] +
		    this[offset + 5] * 2 ** 8 +
		    this[offset + 6] * 2 ** 16 +
		    (last << 24); // Overflow

		  return (BigInt(val) << BigInt(32)) +
		    BigInt(first +
		    this[++offset] * 2 ** 8 +
		    this[++offset] * 2 ** 16 +
		    this[++offset] * 2 ** 24)
		});

		Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
		  offset = offset >>> 0;
		  validateNumber(offset, 'offset');
		  const first = this[offset];
		  const last = this[offset + 7];
		  if (first === undefined || last === undefined) {
		    boundsError(offset, this.length - 8);
		  }

		  const val = (first << 24) + // Overflow
		    this[++offset] * 2 ** 16 +
		    this[++offset] * 2 ** 8 +
		    this[++offset];

		  return (BigInt(val) << BigInt(32)) +
		    BigInt(this[++offset] * 2 ** 24 +
		    this[++offset] * 2 ** 16 +
		    this[++offset] * 2 ** 8 +
		    last)
		});

		Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);
		  return ieee754.read(this, offset, true, 23, 4)
		};

		Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);
		  return ieee754.read(this, offset, false, 23, 4)
		};

		Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 8, this.length);
		  return ieee754.read(this, offset, true, 52, 8)
		};

		Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 8, this.length);
		  return ieee754.read(this, offset, false, 52, 8)
		};

		function checkInt (buf, value, offset, ext, max, min) {
		  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
		  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
		  if (offset + ext > buf.length) throw new RangeError('Index out of range')
		}

		Buffer.prototype.writeUintLE =
		Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) {
		    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
		    checkInt(this, value, offset, byteLength, maxBytes, 0);
		  }

		  let mul = 1;
		  let i = 0;
		  this[offset] = value & 0xFF;
		  while (++i < byteLength && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeUintBE =
		Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) {
		    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
		    checkInt(this, value, offset, byteLength, maxBytes, 0);
		  }

		  let i = byteLength - 1;
		  let mul = 1;
		  this[offset + i] = value & 0xFF;
		  while (--i >= 0 && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeUint8 =
		Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
		  this[offset] = (value & 0xff);
		  return offset + 1
		};

		Buffer.prototype.writeUint16LE =
		Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
		  this[offset] = (value & 0xff);
		  this[offset + 1] = (value >>> 8);
		  return offset + 2
		};

		Buffer.prototype.writeUint16BE =
		Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
		  this[offset] = (value >>> 8);
		  this[offset + 1] = (value & 0xff);
		  return offset + 2
		};

		Buffer.prototype.writeUint32LE =
		Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
		  this[offset + 3] = (value >>> 24);
		  this[offset + 2] = (value >>> 16);
		  this[offset + 1] = (value >>> 8);
		  this[offset] = (value & 0xff);
		  return offset + 4
		};

		Buffer.prototype.writeUint32BE =
		Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
		  this[offset] = (value >>> 24);
		  this[offset + 1] = (value >>> 16);
		  this[offset + 2] = (value >>> 8);
		  this[offset + 3] = (value & 0xff);
		  return offset + 4
		};

		function wrtBigUInt64LE (buf, value, offset, min, max) {
		  checkIntBI(value, min, max, buf, offset, 7);

		  let lo = Number(value & BigInt(0xffffffff));
		  buf[offset++] = lo;
		  lo = lo >> 8;
		  buf[offset++] = lo;
		  lo = lo >> 8;
		  buf[offset++] = lo;
		  lo = lo >> 8;
		  buf[offset++] = lo;
		  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
		  buf[offset++] = hi;
		  hi = hi >> 8;
		  buf[offset++] = hi;
		  hi = hi >> 8;
		  buf[offset++] = hi;
		  hi = hi >> 8;
		  buf[offset++] = hi;
		  return offset
		}

		function wrtBigUInt64BE (buf, value, offset, min, max) {
		  checkIntBI(value, min, max, buf, offset, 7);

		  let lo = Number(value & BigInt(0xffffffff));
		  buf[offset + 7] = lo;
		  lo = lo >> 8;
		  buf[offset + 6] = lo;
		  lo = lo >> 8;
		  buf[offset + 5] = lo;
		  lo = lo >> 8;
		  buf[offset + 4] = lo;
		  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
		  buf[offset + 3] = hi;
		  hi = hi >> 8;
		  buf[offset + 2] = hi;
		  hi = hi >> 8;
		  buf[offset + 1] = hi;
		  hi = hi >> 8;
		  buf[offset] = hi;
		  return offset + 8
		}

		Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
		  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
		});

		Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
		  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
		});

		Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    const limit = Math.pow(2, (8 * byteLength) - 1);

		    checkInt(this, value, offset, byteLength, limit - 1, -limit);
		  }

		  let i = 0;
		  let mul = 1;
		  let sub = 0;
		  this[offset] = value & 0xFF;
		  while (++i < byteLength && (mul *= 0x100)) {
		    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
		      sub = 1;
		    }
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    const limit = Math.pow(2, (8 * byteLength) - 1);

		    checkInt(this, value, offset, byteLength, limit - 1, -limit);
		  }

		  let i = byteLength - 1;
		  let mul = 1;
		  let sub = 0;
		  this[offset + i] = value & 0xFF;
		  while (--i >= 0 && (mul *= 0x100)) {
		    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
		      sub = 1;
		    }
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
		  if (value < 0) value = 0xff + value + 1;
		  this[offset] = (value & 0xff);
		  return offset + 1
		};

		Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
		  this[offset] = (value & 0xff);
		  this[offset + 1] = (value >>> 8);
		  return offset + 2
		};

		Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
		  this[offset] = (value >>> 8);
		  this[offset + 1] = (value & 0xff);
		  return offset + 2
		};

		Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
		  this[offset] = (value & 0xff);
		  this[offset + 1] = (value >>> 8);
		  this[offset + 2] = (value >>> 16);
		  this[offset + 3] = (value >>> 24);
		  return offset + 4
		};

		Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
		  if (value < 0) value = 0xffffffff + value + 1;
		  this[offset] = (value >>> 24);
		  this[offset + 1] = (value >>> 16);
		  this[offset + 2] = (value >>> 8);
		  this[offset + 3] = (value & 0xff);
		  return offset + 4
		};

		Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
		  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
		});

		Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
		  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
		});

		function checkIEEE754 (buf, value, offset, ext, max, min) {
		  if (offset + ext > buf.length) throw new RangeError('Index out of range')
		  if (offset < 0) throw new RangeError('Index out of range')
		}

		function writeFloat (buf, value, offset, littleEndian, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 4);
		  }
		  ieee754.write(buf, value, offset, littleEndian, 23, 4);
		  return offset + 4
		}

		Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, true, noAssert)
		};

		Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, false, noAssert)
		};

		function writeDouble (buf, value, offset, littleEndian, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 8);
		  }
		  ieee754.write(buf, value, offset, littleEndian, 52, 8);
		  return offset + 8
		}

		Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, true, noAssert)
		};

		Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, false, noAssert)
		};

		// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
		Buffer.prototype.copy = function copy (target, targetStart, start, end) {
		  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
		  if (!start) start = 0;
		  if (!end && end !== 0) end = this.length;
		  if (targetStart >= target.length) targetStart = target.length;
		  if (!targetStart) targetStart = 0;
		  if (end > 0 && end < start) end = start;

		  // Copy 0 bytes; we're done
		  if (end === start) return 0
		  if (target.length === 0 || this.length === 0) return 0

		  // Fatal error conditions
		  if (targetStart < 0) {
		    throw new RangeError('targetStart out of bounds')
		  }
		  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
		  if (end < 0) throw new RangeError('sourceEnd out of bounds')

		  // Are we oob?
		  if (end > this.length) end = this.length;
		  if (target.length - targetStart < end - start) {
		    end = target.length - targetStart + start;
		  }

		  const len = end - start;

		  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
		    // Use built-in when available, missing from IE11
		    this.copyWithin(targetStart, start, end);
		  } else {
		    Uint8Array.prototype.set.call(
		      target,
		      this.subarray(start, end),
		      targetStart
		    );
		  }

		  return len
		};

		// Usage:
		//    buffer.fill(number[, offset[, end]])
		//    buffer.fill(buffer[, offset[, end]])
		//    buffer.fill(string[, offset[, end]][, encoding])
		Buffer.prototype.fill = function fill (val, start, end, encoding) {
		  // Handle string cases:
		  if (typeof val === 'string') {
		    if (typeof start === 'string') {
		      encoding = start;
		      start = 0;
		      end = this.length;
		    } else if (typeof end === 'string') {
		      encoding = end;
		      end = this.length;
		    }
		    if (encoding !== undefined && typeof encoding !== 'string') {
		      throw new TypeError('encoding must be a string')
		    }
		    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
		      throw new TypeError('Unknown encoding: ' + encoding)
		    }
		    if (val.length === 1) {
		      const code = val.charCodeAt(0);
		      if ((encoding === 'utf8' && code < 128) ||
		          encoding === 'latin1') {
		        // Fast path: If `val` fits into a single byte, use that numeric value.
		        val = code;
		      }
		    }
		  } else if (typeof val === 'number') {
		    val = val & 255;
		  } else if (typeof val === 'boolean') {
		    val = Number(val);
		  }

		  // Invalid ranges are not set to a default, so can range check early.
		  if (start < 0 || this.length < start || this.length < end) {
		    throw new RangeError('Out of range index')
		  }

		  if (end <= start) {
		    return this
		  }

		  start = start >>> 0;
		  end = end === undefined ? this.length : end >>> 0;

		  if (!val) val = 0;

		  let i;
		  if (typeof val === 'number') {
		    for (i = start; i < end; ++i) {
		      this[i] = val;
		    }
		  } else {
		    const bytes = Buffer.isBuffer(val)
		      ? val
		      : Buffer.from(val, encoding);
		    const len = bytes.length;
		    if (len === 0) {
		      throw new TypeError('The value "' + val +
		        '" is invalid for argument "value"')
		    }
		    for (i = 0; i < end - start; ++i) {
		      this[i + start] = bytes[i % len];
		    }
		  }

		  return this
		};

		// CUSTOM ERRORS
		// =============

		// Simplified versions from Node, changed for Buffer-only usage
		const errors = {};
		function E (sym, getMessage, Base) {
		  errors[sym] = class NodeError extends Base {
		    constructor () {
		      super();

		      Object.defineProperty(this, 'message', {
		        value: getMessage.apply(this, arguments),
		        writable: true,
		        configurable: true
		      });

		      // Add the error code to the name to include it in the stack trace.
		      this.name = `${this.name} [${sym}]`;
		      // Access the stack to generate the error message including the error code
		      // from the name.
		      this.stack; // eslint-disable-line no-unused-expressions
		      // Reset the name to the actual name.
		      delete this.name;
		    }

		    get code () {
		      return sym
		    }

		    set code (value) {
		      Object.defineProperty(this, 'code', {
		        configurable: true,
		        enumerable: true,
		        value,
		        writable: true
		      });
		    }

		    toString () {
		      return `${this.name} [${sym}]: ${this.message}`
		    }
		  };
		}

		E('ERR_BUFFER_OUT_OF_BOUNDS',
		  function (name) {
		    if (name) {
		      return `${name} is outside of buffer bounds`
		    }

		    return 'Attempt to access memory outside buffer bounds'
		  }, RangeError);
		E('ERR_INVALID_ARG_TYPE',
		  function (name, actual) {
		    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
		  }, TypeError);
		E('ERR_OUT_OF_RANGE',
		  function (str, range, input) {
		    let msg = `The value of "${str}" is out of range.`;
		    let received = input;
		    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
		      received = addNumericalSeparator(String(input));
		    } else if (typeof input === 'bigint') {
		      received = String(input);
		      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
		        received = addNumericalSeparator(received);
		      }
		      received += 'n';
		    }
		    msg += ` It must be ${range}. Received ${received}`;
		    return msg
		  }, RangeError);

		function addNumericalSeparator (val) {
		  let res = '';
		  let i = val.length;
		  const start = val[0] === '-' ? 1 : 0;
		  for (; i >= start + 4; i -= 3) {
		    res = `_${val.slice(i - 3, i)}${res}`;
		  }
		  return `${val.slice(0, i)}${res}`
		}

		// CHECK FUNCTIONS
		// ===============

		function checkBounds (buf, offset, byteLength) {
		  validateNumber(offset, 'offset');
		  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
		    boundsError(offset, buf.length - (byteLength + 1));
		  }
		}

		function checkIntBI (value, min, max, buf, offset, byteLength) {
		  if (value > max || value < min) {
		    const n = typeof min === 'bigint' ? 'n' : '';
		    let range;
		    {
		      if (min === 0 || min === BigInt(0)) {
		        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
		      } else {
		        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
		                `${(byteLength + 1) * 8 - 1}${n}`;
		      }
		    }
		    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
		  }
		  checkBounds(buf, offset, byteLength);
		}

		function validateNumber (value, name) {
		  if (typeof value !== 'number') {
		    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
		  }
		}

		function boundsError (value, length, type) {
		  if (Math.floor(value) !== value) {
		    validateNumber(value, type);
		    throw new errors.ERR_OUT_OF_RANGE('offset', 'an integer', value)
		  }

		  if (length < 0) {
		    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
		  }

		  throw new errors.ERR_OUT_OF_RANGE('offset',
		                                    `>= ${0} and <= ${length}`,
		                                    value)
		}

		// HELPER FUNCTIONS
		// ================

		const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

		function base64clean (str) {
		  // Node takes equal signs as end of the Base64 encoding
		  str = str.split('=')[0];
		  // Node strips out invalid characters like \n and \t from the string, base64-js does not
		  str = str.trim().replace(INVALID_BASE64_RE, '');
		  // Node converts strings with length < 2 to ''
		  if (str.length < 2) return ''
		  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
		  while (str.length % 4 !== 0) {
		    str = str + '=';
		  }
		  return str
		}

		function utf8ToBytes (string, units) {
		  units = units || Infinity;
		  let codePoint;
		  const length = string.length;
		  let leadSurrogate = null;
		  const bytes = [];

		  for (let i = 0; i < length; ++i) {
		    codePoint = string.charCodeAt(i);

		    // is surrogate component
		    if (codePoint > 0xD7FF && codePoint < 0xE000) {
		      // last char was a lead
		      if (!leadSurrogate) {
		        // no lead yet
		        if (codePoint > 0xDBFF) {
		          // unexpected trail
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		          continue
		        } else if (i + 1 === length) {
		          // unpaired lead
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		          continue
		        }

		        // valid lead
		        leadSurrogate = codePoint;

		        continue
		      }

		      // 2 leads in a row
		      if (codePoint < 0xDC00) {
		        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		        leadSurrogate = codePoint;
		        continue
		      }

		      // valid surrogate pair
		      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
		    } else if (leadSurrogate) {
		      // valid bmp char, but last char was a lead
		      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		    }

		    leadSurrogate = null;

		    // encode utf8
		    if (codePoint < 0x80) {
		      if ((units -= 1) < 0) break
		      bytes.push(codePoint);
		    } else if (codePoint < 0x800) {
		      if ((units -= 2) < 0) break
		      bytes.push(
		        codePoint >> 0x6 | 0xC0,
		        codePoint & 0x3F | 0x80
		      );
		    } else if (codePoint < 0x10000) {
		      if ((units -= 3) < 0) break
		      bytes.push(
		        codePoint >> 0xC | 0xE0,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      );
		    } else if (codePoint < 0x110000) {
		      if ((units -= 4) < 0) break
		      bytes.push(
		        codePoint >> 0x12 | 0xF0,
		        codePoint >> 0xC & 0x3F | 0x80,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      );
		    } else {
		      throw new Error('Invalid code point')
		    }
		  }

		  return bytes
		}

		function asciiToBytes (str) {
		  const byteArray = [];
		  for (let i = 0; i < str.length; ++i) {
		    // Node's code seems to be doing this and not & 0x7F..
		    byteArray.push(str.charCodeAt(i) & 0xFF);
		  }
		  return byteArray
		}

		function utf16leToBytes (str, units) {
		  let c, hi, lo;
		  const byteArray = [];
		  for (let i = 0; i < str.length; ++i) {
		    if ((units -= 2) < 0) break

		    c = str.charCodeAt(i);
		    hi = c >> 8;
		    lo = c % 256;
		    byteArray.push(lo);
		    byteArray.push(hi);
		  }

		  return byteArray
		}

		function base64ToBytes (str) {
		  return base64.toByteArray(base64clean(str))
		}

		function blitBuffer (src, dst, offset, length) {
		  let i;
		  for (i = 0; i < length; ++i) {
		    if ((i + offset >= dst.length) || (i >= src.length)) break
		    dst[i + offset] = src[i];
		  }
		  return i
		}

		// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
		// the `instanceof` check but they should be treated as of that type.
		// See: https://github.com/feross/buffer/issues/166
		function isInstance (obj, type) {
		  return obj instanceof type ||
		    (obj != null && obj.constructor != null && obj.constructor.name != null &&
		      obj.constructor.name === type.name)
		}
		function numberIsNaN (obj) {
		  // For IE11 support
		  return obj !== obj // eslint-disable-line no-self-compare
		}

		// Create lookup table for `toString('hex')`
		// See: https://github.com/feross/buffer/issues/219
		const hexSliceLookupTable = (function () {
		  const alphabet = '0123456789abcdef';
		  const table = new Array(256);
		  for (let i = 0; i < 16; ++i) {
		    const i16 = i * 16;
		    for (let j = 0; j < 16; ++j) {
		      table[i16 + j] = alphabet[i] + alphabet[j];
		    }
		  }
		  return table
		})();

		// Return not function with Error if BigInt not supported
		function defineBigIntMethod (fn) {
		  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
		}

		function BufferBigIntNotDefined () {
		  throw new Error('BigInt not supported')
		} 
	} (buffer$1));
	return buffer$1;
}

var bufferExports$1 = requireBuffer$1();

window.Buffer = bufferExports$1.Buffer;
        window.process = {};

var jsxRuntime = {exports: {}};

var reactJsxRuntime_production = {};

/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactJsxRuntime_production;

function requireReactJsxRuntime_production () {
	if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
	hasRequiredReactJsxRuntime_production = 1;
	var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
	  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
	function jsxProd(type, config, maybeKey) {
	  var key = null;
	  void 0 !== maybeKey && (key = "" + maybeKey);
	  void 0 !== config.key && (key = "" + config.key);
	  if ("key" in config) {
	    maybeKey = {};
	    for (var propName in config)
	      "key" !== propName && (maybeKey[propName] = config[propName]);
	  } else maybeKey = config;
	  config = maybeKey.ref;
	  return {
	    $$typeof: REACT_ELEMENT_TYPE,
	    type: type,
	    key: key,
	    ref: void 0 !== config ? config : null,
	    props: maybeKey
	  };
	}
	reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
	reactJsxRuntime_production.jsx = jsxProd;
	reactJsxRuntime_production.jsxs = jsxProd;
	return reactJsxRuntime_production;
}

var hasRequiredJsxRuntime;

function requireJsxRuntime () {
	if (hasRequiredJsxRuntime) return jsxRuntime.exports;
	hasRequiredJsxRuntime = 1;
	{
	  jsxRuntime.exports = requireReactJsxRuntime_production();
	}
	return jsxRuntime.exports;
}

var jsxRuntimeExports = requireJsxRuntime();

var react = {exports: {}};

var react_production = {};

/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReact_production;

function requireReact_production () {
	if (hasRequiredReact_production) return react_production;
	hasRequiredReact_production = 1;
	var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
	  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
	  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
	  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
	  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
	  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
	  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
	  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
	  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
	  REACT_MEMO_TYPE = Symbol.for("react.memo"),
	  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
	  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
	function getIteratorFn(maybeIterable) {
	  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
	  maybeIterable =
	    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
	    maybeIterable["@@iterator"];
	  return "function" === typeof maybeIterable ? maybeIterable : null;
	}
	var ReactNoopUpdateQueue = {
	    isMounted: function () {
	      return false;
	    },
	    enqueueForceUpdate: function () {},
	    enqueueReplaceState: function () {},
	    enqueueSetState: function () {}
	  },
	  assign = Object.assign,
	  emptyObject = {};
	function Component(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	Component.prototype.isReactComponent = {};
	Component.prototype.setState = function (partialState, callback) {
	  if (
	    "object" !== typeof partialState &&
	    "function" !== typeof partialState &&
	    null != partialState
	  )
	    throw Error(
	      "takes an object of state variables to update or a function which returns an object of state variables."
	    );
	  this.updater.enqueueSetState(this, partialState, callback, "setState");
	};
	Component.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
	};
	function ComponentDummy() {}
	ComponentDummy.prototype = Component.prototype;
	function PureComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	var pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());
	pureComponentPrototype.constructor = PureComponent;
	assign(pureComponentPrototype, Component.prototype);
	pureComponentPrototype.isPureReactComponent = true;
	var isArrayImpl = Array.isArray,
	  ReactSharedInternals = { H: null, A: null, T: null, S: null, V: null },
	  hasOwnProperty = Object.prototype.hasOwnProperty;
	function ReactElement(type, key, self, source, owner, props) {
	  self = props.ref;
	  return {
	    $$typeof: REACT_ELEMENT_TYPE,
	    type: type,
	    key: key,
	    ref: void 0 !== self ? self : null,
	    props: props
	  };
	}
	function cloneAndReplaceKey(oldElement, newKey) {
	  return ReactElement(
	    oldElement.type,
	    newKey,
	    void 0,
	    void 0,
	    void 0,
	    oldElement.props
	  );
	}
	function isValidElement(object) {
	  return (
	    "object" === typeof object &&
	    null !== object &&
	    object.$$typeof === REACT_ELEMENT_TYPE
	  );
	}
	function escape(key) {
	  var escaperLookup = { "=": "=0", ":": "=2" };
	  return (
	    "$" +
	    key.replace(/[=:]/g, function (match) {
	      return escaperLookup[match];
	    })
	  );
	}
	var userProvidedKeyEscapeRegex = /\/+/g;
	function getElementKey(element, index) {
	  return "object" === typeof element && null !== element && null != element.key
	    ? escape("" + element.key)
	    : index.toString(36);
	}
	function noop$1() {}
	function resolveThenable(thenable) {
	  switch (thenable.status) {
	    case "fulfilled":
	      return thenable.value;
	    case "rejected":
	      throw thenable.reason;
	    default:
	      switch (
	        ("string" === typeof thenable.status
	          ? thenable.then(noop$1, noop$1)
	          : ((thenable.status = "pending"),
	            thenable.then(
	              function (fulfilledValue) {
	                "pending" === thenable.status &&
	                  ((thenable.status = "fulfilled"),
	                  (thenable.value = fulfilledValue));
	              },
	              function (error) {
	                "pending" === thenable.status &&
	                  ((thenable.status = "rejected"), (thenable.reason = error));
	              }
	            )),
	        thenable.status)
	      ) {
	        case "fulfilled":
	          return thenable.value;
	        case "rejected":
	          throw thenable.reason;
	      }
	  }
	  throw thenable;
	}
	function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
	  var type = typeof children;
	  if ("undefined" === type || "boolean" === type) children = null;
	  var invokeCallback = false;
	  if (null === children) invokeCallback = true;
	  else
	    switch (type) {
	      case "bigint":
	      case "string":
	      case "number":
	        invokeCallback = true;
	        break;
	      case "object":
	        switch (children.$$typeof) {
	          case REACT_ELEMENT_TYPE:
	          case REACT_PORTAL_TYPE:
	            invokeCallback = true;
	            break;
	          case REACT_LAZY_TYPE:
	            return (
	              (invokeCallback = children._init),
	              mapIntoArray(
	                invokeCallback(children._payload),
	                array,
	                escapedPrefix,
	                nameSoFar,
	                callback
	              )
	            );
	        }
	    }
	  if (invokeCallback)
	    return (
	      (callback = callback(children)),
	      (invokeCallback =
	        "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar),
	      isArrayImpl(callback)
	        ? ((escapedPrefix = ""),
	          null != invokeCallback &&
	            (escapedPrefix =
	              invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),
	          mapIntoArray(callback, array, escapedPrefix, "", function (c) {
	            return c;
	          }))
	        : null != callback &&
	          (isValidElement(callback) &&
	            (callback = cloneAndReplaceKey(
	              callback,
	              escapedPrefix +
	                (null == callback.key ||
	                (children && children.key === callback.key)
	                  ? ""
	                  : ("" + callback.key).replace(
	                      userProvidedKeyEscapeRegex,
	                      "$&/"
	                    ) + "/") +
	                invokeCallback
	            )),
	          array.push(callback)),
	      1
	    );
	  invokeCallback = 0;
	  var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
	  if (isArrayImpl(children))
	    for (var i = 0; i < children.length; i++)
	      (nameSoFar = children[i]),
	        (type = nextNamePrefix + getElementKey(nameSoFar, i)),
	        (invokeCallback += mapIntoArray(
	          nameSoFar,
	          array,
	          escapedPrefix,
	          type,
	          callback
	        ));
	  else if (((i = getIteratorFn(children)), "function" === typeof i))
	    for (
	      children = i.call(children), i = 0;
	      !(nameSoFar = children.next()).done;

	    )
	      (nameSoFar = nameSoFar.value),
	        (type = nextNamePrefix + getElementKey(nameSoFar, i++)),
	        (invokeCallback += mapIntoArray(
	          nameSoFar,
	          array,
	          escapedPrefix,
	          type,
	          callback
	        ));
	  else if ("object" === type) {
	    if ("function" === typeof children.then)
	      return mapIntoArray(
	        resolveThenable(children),
	        array,
	        escapedPrefix,
	        nameSoFar,
	        callback
	      );
	    array = String(children);
	    throw Error(
	      "Objects are not valid as a React child (found: " +
	        ("[object Object]" === array
	          ? "object with keys {" + Object.keys(children).join(", ") + "}"
	          : array) +
	        "). If you meant to render a collection of children, use an array instead."
	    );
	  }
	  return invokeCallback;
	}
	function mapChildren(children, func, context) {
	  if (null == children) return children;
	  var result = [],
	    count = 0;
	  mapIntoArray(children, result, "", "", function (child) {
	    return func.call(context, child, count++);
	  });
	  return result;
	}
	function lazyInitializer(payload) {
	  if (-1 === payload._status) {
	    var ctor = payload._result;
	    ctor = ctor();
	    ctor.then(
	      function (moduleObject) {
	        if (0 === payload._status || -1 === payload._status)
	          (payload._status = 1), (payload._result = moduleObject);
	      },
	      function (error) {
	        if (0 === payload._status || -1 === payload._status)
	          (payload._status = 2), (payload._result = error);
	      }
	    );
	    -1 === payload._status && ((payload._status = 0), (payload._result = ctor));
	  }
	  if (1 === payload._status) return payload._result.default;
	  throw payload._result;
	}
	var reportGlobalError =
	  "function" === typeof reportError
	    ? reportError
	    : function (error) {
	        if (
	          "object" === typeof window &&
	          "function" === typeof window.ErrorEvent
	        ) {
	          var event = new window.ErrorEvent("error", {
	            bubbles: true,
	            cancelable: true,
	            message:
	              "object" === typeof error &&
	              null !== error &&
	              "string" === typeof error.message
	                ? String(error.message)
	                : String(error),
	            error: error
	          });
	          if (!window.dispatchEvent(event)) return;
	        } else if (
	          "object" === typeof process &&
	          "function" === typeof process.emit
	        ) {
	          process.emit("uncaughtException", error);
	          return;
	        }
	        console.error(error);
	      };
	function noop() {}
	react_production.Children = {
	  map: mapChildren,
	  forEach: function (children, forEachFunc, forEachContext) {
	    mapChildren(
	      children,
	      function () {
	        forEachFunc.apply(this, arguments);
	      },
	      forEachContext
	    );
	  },
	  count: function (children) {
	    var n = 0;
	    mapChildren(children, function () {
	      n++;
	    });
	    return n;
	  },
	  toArray: function (children) {
	    return (
	      mapChildren(children, function (child) {
	        return child;
	      }) || []
	    );
	  },
	  only: function (children) {
	    if (!isValidElement(children))
	      throw Error(
	        "React.Children.only expected to receive a single React element child."
	      );
	    return children;
	  }
	};
	react_production.Component = Component;
	react_production.Fragment = REACT_FRAGMENT_TYPE;
	react_production.Profiler = REACT_PROFILER_TYPE;
	react_production.PureComponent = PureComponent;
	react_production.StrictMode = REACT_STRICT_MODE_TYPE;
	react_production.Suspense = REACT_SUSPENSE_TYPE;
	react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
	  ReactSharedInternals;
	react_production.__COMPILER_RUNTIME = {
	  __proto__: null,
	  c: function (size) {
	    return ReactSharedInternals.H.useMemoCache(size);
	  }
	};
	react_production.cache = function (fn) {
	  return function () {
	    return fn.apply(null, arguments);
	  };
	};
	react_production.cloneElement = function (element, config, children) {
	  if (null === element || void 0 === element)
	    throw Error(
	      "The argument must be a React element, but you passed " + element + "."
	    );
	  var props = assign({}, element.props),
	    key = element.key,
	    owner = void 0;
	  if (null != config)
	    for (propName in (void 0 !== config.ref && (owner = void 0),
	    void 0 !== config.key && (key = "" + config.key),
	    config))
	      !hasOwnProperty.call(config, propName) ||
	        "key" === propName ||
	        "__self" === propName ||
	        "__source" === propName ||
	        ("ref" === propName && void 0 === config.ref) ||
	        (props[propName] = config[propName]);
	  var propName = arguments.length - 2;
	  if (1 === propName) props.children = children;
	  else if (1 < propName) {
	    for (var childArray = Array(propName), i = 0; i < propName; i++)
	      childArray[i] = arguments[i + 2];
	    props.children = childArray;
	  }
	  return ReactElement(element.type, key, void 0, void 0, owner, props);
	};
	react_production.createContext = function (defaultValue) {
	  defaultValue = {
	    $$typeof: REACT_CONTEXT_TYPE,
	    _currentValue: defaultValue,
	    _currentValue2: defaultValue,
	    _threadCount: 0,
	    Provider: null,
	    Consumer: null
	  };
	  defaultValue.Provider = defaultValue;
	  defaultValue.Consumer = {
	    $$typeof: REACT_CONSUMER_TYPE,
	    _context: defaultValue
	  };
	  return defaultValue;
	};
	react_production.createElement = function (type, config, children) {
	  var propName,
	    props = {},
	    key = null;
	  if (null != config)
	    for (propName in (void 0 !== config.key && (key = "" + config.key), config))
	      hasOwnProperty.call(config, propName) &&
	        "key" !== propName &&
	        "__self" !== propName &&
	        "__source" !== propName &&
	        (props[propName] = config[propName]);
	  var childrenLength = arguments.length - 2;
	  if (1 === childrenLength) props.children = children;
	  else if (1 < childrenLength) {
	    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
	      childArray[i] = arguments[i + 2];
	    props.children = childArray;
	  }
	  if (type && type.defaultProps)
	    for (propName in ((childrenLength = type.defaultProps), childrenLength))
	      void 0 === props[propName] &&
	        (props[propName] = childrenLength[propName]);
	  return ReactElement(type, key, void 0, void 0, null, props);
	};
	react_production.createRef = function () {
	  return { current: null };
	};
	react_production.forwardRef = function (render) {
	  return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };
	};
	react_production.isValidElement = isValidElement;
	react_production.lazy = function (ctor) {
	  return {
	    $$typeof: REACT_LAZY_TYPE,
	    _payload: { _status: -1, _result: ctor },
	    _init: lazyInitializer
	  };
	};
	react_production.memo = function (type, compare) {
	  return {
	    $$typeof: REACT_MEMO_TYPE,
	    type: type,
	    compare: void 0 === compare ? null : compare
	  };
	};
	react_production.startTransition = function (scope) {
	  var prevTransition = ReactSharedInternals.T,
	    currentTransition = {};
	  ReactSharedInternals.T = currentTransition;
	  try {
	    var returnValue = scope(),
	      onStartTransitionFinish = ReactSharedInternals.S;
	    null !== onStartTransitionFinish &&
	      onStartTransitionFinish(currentTransition, returnValue);
	    "object" === typeof returnValue &&
	      null !== returnValue &&
	      "function" === typeof returnValue.then &&
	      returnValue.then(noop, reportGlobalError);
	  } catch (error) {
	    reportGlobalError(error);
	  } finally {
	    ReactSharedInternals.T = prevTransition;
	  }
	};
	react_production.unstable_useCacheRefresh = function () {
	  return ReactSharedInternals.H.useCacheRefresh();
	};
	react_production.use = function (usable) {
	  return ReactSharedInternals.H.use(usable);
	};
	react_production.useActionState = function (action, initialState, permalink) {
	  return ReactSharedInternals.H.useActionState(action, initialState, permalink);
	};
	react_production.useCallback = function (callback, deps) {
	  return ReactSharedInternals.H.useCallback(callback, deps);
	};
	react_production.useContext = function (Context) {
	  return ReactSharedInternals.H.useContext(Context);
	};
	react_production.useDebugValue = function () {};
	react_production.useDeferredValue = function (value, initialValue) {
	  return ReactSharedInternals.H.useDeferredValue(value, initialValue);
	};
	react_production.useEffect = function (create, createDeps, update) {
	  var dispatcher = ReactSharedInternals.H;
	  if ("function" === typeof update)
	    throw Error(
	      "useEffect CRUD overload is not enabled in this build of React."
	    );
	  return dispatcher.useEffect(create, createDeps);
	};
	react_production.useId = function () {
	  return ReactSharedInternals.H.useId();
	};
	react_production.useImperativeHandle = function (ref, create, deps) {
	  return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
	};
	react_production.useInsertionEffect = function (create, deps) {
	  return ReactSharedInternals.H.useInsertionEffect(create, deps);
	};
	react_production.useLayoutEffect = function (create, deps) {
	  return ReactSharedInternals.H.useLayoutEffect(create, deps);
	};
	react_production.useMemo = function (create, deps) {
	  return ReactSharedInternals.H.useMemo(create, deps);
	};
	react_production.useOptimistic = function (passthrough, reducer) {
	  return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
	};
	react_production.useReducer = function (reducer, initialArg, init) {
	  return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
	};
	react_production.useRef = function (initialValue) {
	  return ReactSharedInternals.H.useRef(initialValue);
	};
	react_production.useState = function (initialState) {
	  return ReactSharedInternals.H.useState(initialState);
	};
	react_production.useSyncExternalStore = function (
	  subscribe,
	  getSnapshot,
	  getServerSnapshot
	) {
	  return ReactSharedInternals.H.useSyncExternalStore(
	    subscribe,
	    getSnapshot,
	    getServerSnapshot
	  );
	};
	react_production.useTransition = function () {
	  return ReactSharedInternals.H.useTransition();
	};
	react_production.version = "19.1.1";
	return react_production;
}

var hasRequiredReact;

function requireReact () {
	if (hasRequiredReact) return react.exports;
	hasRequiredReact = 1;
	{
	  react.exports = requireReact_production();
	}
	return react.exports;
}

var reactExports = requireReact();
const React = /*@__PURE__*/getDefaultExportFromCjs(reactExports);

var client = {exports: {}};

var reactDomClient_production = {};

var scheduler = {exports: {}};

var scheduler_production = {};

/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredScheduler_production;

function requireScheduler_production () {
	if (hasRequiredScheduler_production) return scheduler_production;
	hasRequiredScheduler_production = 1;
	(function (exports) {
		function push(heap, node) {
		  var index = heap.length;
		  heap.push(node);
		  a: for (; 0 < index; ) {
		    var parentIndex = (index - 1) >>> 1,
		      parent = heap[parentIndex];
		    if (0 < compare(parent, node))
		      (heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex);
		    else break a;
		  }
		}
		function peek(heap) {
		  return 0 === heap.length ? null : heap[0];
		}
		function pop(heap) {
		  if (0 === heap.length) return null;
		  var first = heap[0],
		    last = heap.pop();
		  if (last !== first) {
		    heap[0] = last;
		    a: for (
		      var index = 0, length = heap.length, halfLength = length >>> 1;
		      index < halfLength;

		    ) {
		      var leftIndex = 2 * (index + 1) - 1,
		        left = heap[leftIndex],
		        rightIndex = leftIndex + 1,
		        right = heap[rightIndex];
		      if (0 > compare(left, last))
		        rightIndex < length && 0 > compare(right, left)
		          ? ((heap[index] = right),
		            (heap[rightIndex] = last),
		            (index = rightIndex))
		          : ((heap[index] = left),
		            (heap[leftIndex] = last),
		            (index = leftIndex));
		      else if (rightIndex < length && 0 > compare(right, last))
		        (heap[index] = right), (heap[rightIndex] = last), (index = rightIndex);
		      else break a;
		    }
		  }
		  return first;
		}
		function compare(a, b) {
		  var diff = a.sortIndex - b.sortIndex;
		  return 0 !== diff ? diff : a.id - b.id;
		}
		exports.unstable_now = void 0;
		if ("object" === typeof performance && "function" === typeof performance.now) {
		  var localPerformance = performance;
		  exports.unstable_now = function () {
		    return localPerformance.now();
		  };
		} else {
		  var localDate = Date,
		    initialTime = localDate.now();
		  exports.unstable_now = function () {
		    return localDate.now() - initialTime;
		  };
		}
		var taskQueue = [],
		  timerQueue = [],
		  taskIdCounter = 1,
		  currentTask = null,
		  currentPriorityLevel = 3,
		  isPerformingWork = false,
		  isHostCallbackScheduled = false,
		  isHostTimeoutScheduled = false,
		  needsPaint = false,
		  localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
		  localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null,
		  localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
		function advanceTimers(currentTime) {
		  for (var timer = peek(timerQueue); null !== timer; ) {
		    if (null === timer.callback) pop(timerQueue);
		    else if (timer.startTime <= currentTime)
		      pop(timerQueue),
		        (timer.sortIndex = timer.expirationTime),
		        push(taskQueue, timer);
		    else break;
		    timer = peek(timerQueue);
		  }
		}
		function handleTimeout(currentTime) {
		  isHostTimeoutScheduled = false;
		  advanceTimers(currentTime);
		  if (!isHostCallbackScheduled)
		    if (null !== peek(taskQueue))
		      (isHostCallbackScheduled = true),
		        isMessageLoopRunning ||
		          ((isMessageLoopRunning = true), schedulePerformWorkUntilDeadline());
		    else {
		      var firstTimer = peek(timerQueue);
		      null !== firstTimer &&
		        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
		    }
		}
		var isMessageLoopRunning = false,
		  taskTimeoutID = -1,
		  frameInterval = 5,
		  startTime = -1;
		function shouldYieldToHost() {
		  return needsPaint
		    ? true
		    : exports.unstable_now() - startTime < frameInterval
		      ? false
		      : true;
		}
		function performWorkUntilDeadline() {
		  needsPaint = false;
		  if (isMessageLoopRunning) {
		    var currentTime = exports.unstable_now();
		    startTime = currentTime;
		    var hasMoreWork = true;
		    try {
		      a: {
		        isHostCallbackScheduled = !1;
		        isHostTimeoutScheduled &&
		          ((isHostTimeoutScheduled = !1),
		          localClearTimeout(taskTimeoutID),
		          (taskTimeoutID = -1));
		        isPerformingWork = !0;
		        var previousPriorityLevel = currentPriorityLevel;
		        try {
		          b: {
		            advanceTimers(currentTime);
		            for (
		              currentTask = peek(taskQueue);
		              null !== currentTask &&
		              !(
		                currentTask.expirationTime > currentTime && shouldYieldToHost()
		              );

		            ) {
		              var callback = currentTask.callback;
		              if ("function" === typeof callback) {
		                currentTask.callback = null;
		                currentPriorityLevel = currentTask.priorityLevel;
		                var continuationCallback = callback(
		                  currentTask.expirationTime <= currentTime
		                );
		                currentTime = exports.unstable_now();
		                if ("function" === typeof continuationCallback) {
		                  currentTask.callback = continuationCallback;
		                  advanceTimers(currentTime);
		                  hasMoreWork = !0;
		                  break b;
		                }
		                currentTask === peek(taskQueue) && pop(taskQueue);
		                advanceTimers(currentTime);
		              } else pop(taskQueue);
		              currentTask = peek(taskQueue);
		            }
		            if (null !== currentTask) hasMoreWork = !0;
		            else {
		              var firstTimer = peek(timerQueue);
		              null !== firstTimer &&
		                requestHostTimeout(
		                  handleTimeout,
		                  firstTimer.startTime - currentTime
		                );
		              hasMoreWork = !1;
		            }
		          }
		          break a;
		        } finally {
		          (currentTask = null),
		            (currentPriorityLevel = previousPriorityLevel),
		            (isPerformingWork = !1);
		        }
		        hasMoreWork = void 0;
		      }
		    } finally {
		      hasMoreWork
		        ? schedulePerformWorkUntilDeadline()
		        : (isMessageLoopRunning = false);
		    }
		  }
		}
		var schedulePerformWorkUntilDeadline;
		if ("function" === typeof localSetImmediate)
		  schedulePerformWorkUntilDeadline = function () {
		    localSetImmediate(performWorkUntilDeadline);
		  };
		else if ("undefined" !== typeof MessageChannel) {
		  var channel = new MessageChannel(),
		    port = channel.port2;
		  channel.port1.onmessage = performWorkUntilDeadline;
		  schedulePerformWorkUntilDeadline = function () {
		    port.postMessage(null);
		  };
		} else
		  schedulePerformWorkUntilDeadline = function () {
		    localSetTimeout(performWorkUntilDeadline, 0);
		  };
		function requestHostTimeout(callback, ms) {
		  taskTimeoutID = localSetTimeout(function () {
		    callback(exports.unstable_now());
		  }, ms);
		}
		exports.unstable_IdlePriority = 5;
		exports.unstable_ImmediatePriority = 1;
		exports.unstable_LowPriority = 4;
		exports.unstable_NormalPriority = 3;
		exports.unstable_Profiling = null;
		exports.unstable_UserBlockingPriority = 2;
		exports.unstable_cancelCallback = function (task) {
		  task.callback = null;
		};
		exports.unstable_forceFrameRate = function (fps) {
		  0 > fps || 125 < fps
		    ? console.error(
		        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
		      )
		    : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
		};
		exports.unstable_getCurrentPriorityLevel = function () {
		  return currentPriorityLevel;
		};
		exports.unstable_next = function (eventHandler) {
		  switch (currentPriorityLevel) {
		    case 1:
		    case 2:
		    case 3:
		      var priorityLevel = 3;
		      break;
		    default:
		      priorityLevel = currentPriorityLevel;
		  }
		  var previousPriorityLevel = currentPriorityLevel;
		  currentPriorityLevel = priorityLevel;
		  try {
		    return eventHandler();
		  } finally {
		    currentPriorityLevel = previousPriorityLevel;
		  }
		};
		exports.unstable_requestPaint = function () {
		  needsPaint = true;
		};
		exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
		  switch (priorityLevel) {
		    case 1:
		    case 2:
		    case 3:
		    case 4:
		    case 5:
		      break;
		    default:
		      priorityLevel = 3;
		  }
		  var previousPriorityLevel = currentPriorityLevel;
		  currentPriorityLevel = priorityLevel;
		  try {
		    return eventHandler();
		  } finally {
		    currentPriorityLevel = previousPriorityLevel;
		  }
		};
		exports.unstable_scheduleCallback = function (
		  priorityLevel,
		  callback,
		  options
		) {
		  var currentTime = exports.unstable_now();
		  "object" === typeof options && null !== options
		    ? ((options = options.delay),
		      (options =
		        "number" === typeof options && 0 < options
		          ? currentTime + options
		          : currentTime))
		    : (options = currentTime);
		  switch (priorityLevel) {
		    case 1:
		      var timeout = -1;
		      break;
		    case 2:
		      timeout = 250;
		      break;
		    case 5:
		      timeout = 1073741823;
		      break;
		    case 4:
		      timeout = 1e4;
		      break;
		    default:
		      timeout = 5e3;
		  }
		  timeout = options + timeout;
		  priorityLevel = {
		    id: taskIdCounter++,
		    callback: callback,
		    priorityLevel: priorityLevel,
		    startTime: options,
		    expirationTime: timeout,
		    sortIndex: -1
		  };
		  options > currentTime
		    ? ((priorityLevel.sortIndex = options),
		      push(timerQueue, priorityLevel),
		      null === peek(taskQueue) &&
		        priorityLevel === peek(timerQueue) &&
		        (isHostTimeoutScheduled
		          ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))
		          : (isHostTimeoutScheduled = true),
		        requestHostTimeout(handleTimeout, options - currentTime)))
		    : ((priorityLevel.sortIndex = timeout),
		      push(taskQueue, priorityLevel),
		      isHostCallbackScheduled ||
		        isPerformingWork ||
		        ((isHostCallbackScheduled = true),
		        isMessageLoopRunning ||
		          ((isMessageLoopRunning = true), schedulePerformWorkUntilDeadline())));
		  return priorityLevel;
		};
		exports.unstable_shouldYield = shouldYieldToHost;
		exports.unstable_wrapCallback = function (callback) {
		  var parentPriorityLevel = currentPriorityLevel;
		  return function () {
		    var previousPriorityLevel = currentPriorityLevel;
		    currentPriorityLevel = parentPriorityLevel;
		    try {
		      return callback.apply(this, arguments);
		    } finally {
		      currentPriorityLevel = previousPriorityLevel;
		    }
		  };
		}; 
	} (scheduler_production));
	return scheduler_production;
}

var hasRequiredScheduler;

function requireScheduler () {
	if (hasRequiredScheduler) return scheduler.exports;
	hasRequiredScheduler = 1;
	{
	  scheduler.exports = requireScheduler_production();
	}
	return scheduler.exports;
}

var reactDom = {exports: {}};

var reactDom_production = {};

/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactDom_production;

function requireReactDom_production () {
	if (hasRequiredReactDom_production) return reactDom_production;
	hasRequiredReactDom_production = 1;
	var React = requireReact();
	function formatProdErrorMessage(code) {
	  var url = "https://react.dev/errors/" + code;
	  if (1 < arguments.length) {
	    url += "?args[]=" + encodeURIComponent(arguments[1]);
	    for (var i = 2; i < arguments.length; i++)
	      url += "&args[]=" + encodeURIComponent(arguments[i]);
	  }
	  return (
	    "Minified React error #" +
	    code +
	    "; visit " +
	    url +
	    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
	  );
	}
	function noop() {}
	var Internals = {
	    d: {
	      f: noop,
	      r: function () {
	        throw Error(formatProdErrorMessage(522));
	      },
	      D: noop,
	      C: noop,
	      L: noop,
	      m: noop,
	      X: noop,
	      S: noop,
	      M: noop
	    },
	    p: 0,
	    findDOMNode: null
	  },
	  REACT_PORTAL_TYPE = Symbol.for("react.portal");
	function createPortal$1(children, containerInfo, implementation) {
	  var key =
	    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
	  return {
	    $$typeof: REACT_PORTAL_TYPE,
	    key: null == key ? null : "" + key,
	    children: children,
	    containerInfo: containerInfo,
	    implementation: implementation
	  };
	}
	var ReactSharedInternals =
	  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
	function getCrossOriginStringAs(as, input) {
	  if ("font" === as) return "";
	  if ("string" === typeof input)
	    return "use-credentials" === input ? input : "";
	}
	reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
	  Internals;
	reactDom_production.createPortal = function (children, container) {
	  var key =
	    2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
	  if (
	    !container ||
	    (1 !== container.nodeType &&
	      9 !== container.nodeType &&
	      11 !== container.nodeType)
	  )
	    throw Error(formatProdErrorMessage(299));
	  return createPortal$1(children, container, null, key);
	};
	reactDom_production.flushSync = function (fn) {
	  var previousTransition = ReactSharedInternals.T,
	    previousUpdatePriority = Internals.p;
	  try {
	    if (((ReactSharedInternals.T = null), (Internals.p = 2), fn)) return fn();
	  } finally {
	    (ReactSharedInternals.T = previousTransition),
	      (Internals.p = previousUpdatePriority),
	      Internals.d.f();
	  }
	};
	reactDom_production.preconnect = function (href, options) {
	  "string" === typeof href &&
	    (options
	      ? ((options = options.crossOrigin),
	        (options =
	          "string" === typeof options
	            ? "use-credentials" === options
	              ? options
	              : ""
	            : void 0))
	      : (options = null),
	    Internals.d.C(href, options));
	};
	reactDom_production.prefetchDNS = function (href) {
	  "string" === typeof href && Internals.d.D(href);
	};
	reactDom_production.preinit = function (href, options) {
	  if ("string" === typeof href && options && "string" === typeof options.as) {
	    var as = options.as,
	      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
	      integrity =
	        "string" === typeof options.integrity ? options.integrity : void 0,
	      fetchPriority =
	        "string" === typeof options.fetchPriority
	          ? options.fetchPriority
	          : void 0;
	    "style" === as
	      ? Internals.d.S(
	          href,
	          "string" === typeof options.precedence ? options.precedence : void 0,
	          {
	            crossOrigin: crossOrigin,
	            integrity: integrity,
	            fetchPriority: fetchPriority
	          }
	        )
	      : "script" === as &&
	        Internals.d.X(href, {
	          crossOrigin: crossOrigin,
	          integrity: integrity,
	          fetchPriority: fetchPriority,
	          nonce: "string" === typeof options.nonce ? options.nonce : void 0
	        });
	  }
	};
	reactDom_production.preinitModule = function (href, options) {
	  if ("string" === typeof href)
	    if ("object" === typeof options && null !== options) {
	      if (null == options.as || "script" === options.as) {
	        var crossOrigin = getCrossOriginStringAs(
	          options.as,
	          options.crossOrigin
	        );
	        Internals.d.M(href, {
	          crossOrigin: crossOrigin,
	          integrity:
	            "string" === typeof options.integrity ? options.integrity : void 0,
	          nonce: "string" === typeof options.nonce ? options.nonce : void 0
	        });
	      }
	    } else null == options && Internals.d.M(href);
	};
	reactDom_production.preload = function (href, options) {
	  if (
	    "string" === typeof href &&
	    "object" === typeof options &&
	    null !== options &&
	    "string" === typeof options.as
	  ) {
	    var as = options.as,
	      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
	    Internals.d.L(href, as, {
	      crossOrigin: crossOrigin,
	      integrity:
	        "string" === typeof options.integrity ? options.integrity : void 0,
	      nonce: "string" === typeof options.nonce ? options.nonce : void 0,
	      type: "string" === typeof options.type ? options.type : void 0,
	      fetchPriority:
	        "string" === typeof options.fetchPriority
	          ? options.fetchPriority
	          : void 0,
	      referrerPolicy:
	        "string" === typeof options.referrerPolicy
	          ? options.referrerPolicy
	          : void 0,
	      imageSrcSet:
	        "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
	      imageSizes:
	        "string" === typeof options.imageSizes ? options.imageSizes : void 0,
	      media: "string" === typeof options.media ? options.media : void 0
	    });
	  }
	};
	reactDom_production.preloadModule = function (href, options) {
	  if ("string" === typeof href)
	    if (options) {
	      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
	      Internals.d.m(href, {
	        as:
	          "string" === typeof options.as && "script" !== options.as
	            ? options.as
	            : void 0,
	        crossOrigin: crossOrigin,
	        integrity:
	          "string" === typeof options.integrity ? options.integrity : void 0
	      });
	    } else Internals.d.m(href);
	};
	reactDom_production.requestFormReset = function (form) {
	  Internals.d.r(form);
	};
	reactDom_production.unstable_batchedUpdates = function (fn, a) {
	  return fn(a);
	};
	reactDom_production.useFormState = function (action, initialState, permalink) {
	  return ReactSharedInternals.H.useFormState(action, initialState, permalink);
	};
	reactDom_production.useFormStatus = function () {
	  return ReactSharedInternals.H.useHostTransitionStatus();
	};
	reactDom_production.version = "19.1.1";
	return reactDom_production;
}

var hasRequiredReactDom;

function requireReactDom () {
	if (hasRequiredReactDom) return reactDom.exports;
	hasRequiredReactDom = 1;
	function checkDCE() {
	  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
	    return;
	  }
	  try {
	    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
	  } catch (err) {
	    console.error(err);
	  }
	}
	{
	  checkDCE();
	  reactDom.exports = requireReactDom_production();
	}
	return reactDom.exports;
}

var hasRequiredReactDomClient_production;

function requireReactDomClient_production () {
	if (hasRequiredReactDomClient_production) return reactDomClient_production;
	hasRequiredReactDomClient_production = 1;
	/**
	 * @license React
	 * react-dom-client.production.js
	 *
	 * Copyright (c) Meta Platforms, Inc. and affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var Scheduler = requireScheduler(), React = requireReact(), ReactDOM = requireReactDom();
	function formatProdErrorMessage(code) {
	  var url = "https://react.dev/errors/" + code;
	  if (1 < arguments.length) {
	    url += "?args[]=" + encodeURIComponent(arguments[1]);
	    for (var i = 2; i < arguments.length; i++)
	      url += "&args[]=" + encodeURIComponent(arguments[i]);
	  }
	  return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
	}
	function isValidContainer(node) {
	  return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
	}
	function getNearestMountedFiber(fiber) {
	  var node = fiber, nearestMounted = fiber;
	  if (fiber.alternate) for (; node.return; ) node = node.return;
	  else {
	    fiber = node;
	    do
	      node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
	    while (fiber);
	  }
	  return 3 === node.tag ? nearestMounted : null;
	}
	function getSuspenseInstanceFromFiber(fiber) {
	  if (13 === fiber.tag) {
	    var suspenseState = fiber.memoizedState;
	    null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
	    if (null !== suspenseState) return suspenseState.dehydrated;
	  }
	  return null;
	}
	function assertIsMounted(fiber) {
	  if (getNearestMountedFiber(fiber) !== fiber)
	    throw Error(formatProdErrorMessage(188));
	}
	function findCurrentFiberUsingSlowPath(fiber) {
	  var alternate = fiber.alternate;
	  if (!alternate) {
	    alternate = getNearestMountedFiber(fiber);
	    if (null === alternate) throw Error(formatProdErrorMessage(188));
	    return alternate !== fiber ? null : fiber;
	  }
	  for (var a = fiber, b = alternate; ; ) {
	    var parentA = a.return;
	    if (null === parentA) break;
	    var parentB = parentA.alternate;
	    if (null === parentB) {
	      b = parentA.return;
	      if (null !== b) {
	        a = b;
	        continue;
	      }
	      break;
	    }
	    if (parentA.child === parentB.child) {
	      for (parentB = parentA.child; parentB; ) {
	        if (parentB === a) return assertIsMounted(parentA), fiber;
	        if (parentB === b) return assertIsMounted(parentA), alternate;
	        parentB = parentB.sibling;
	      }
	      throw Error(formatProdErrorMessage(188));
	    }
	    if (a.return !== b.return) a = parentA, b = parentB;
	    else {
	      for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
	        if (child$0 === a) {
	          didFindChild = true;
	          a = parentA;
	          b = parentB;
	          break;
	        }
	        if (child$0 === b) {
	          didFindChild = true;
	          b = parentA;
	          a = parentB;
	          break;
	        }
	        child$0 = child$0.sibling;
	      }
	      if (!didFindChild) {
	        for (child$0 = parentB.child; child$0; ) {
	          if (child$0 === a) {
	            didFindChild = true;
	            a = parentB;
	            b = parentA;
	            break;
	          }
	          if (child$0 === b) {
	            didFindChild = true;
	            b = parentB;
	            a = parentA;
	            break;
	          }
	          child$0 = child$0.sibling;
	        }
	        if (!didFindChild) throw Error(formatProdErrorMessage(189));
	      }
	    }
	    if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
	  }
	  if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
	  return a.stateNode.current === a ? fiber : alternate;
	}
	function findCurrentHostFiberImpl(node) {
	  var tag = node.tag;
	  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
	  for (node = node.child; null !== node; ) {
	    tag = findCurrentHostFiberImpl(node);
	    if (null !== tag) return tag;
	    node = node.sibling;
	  }
	  return null;
	}
	var assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
	var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
	var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
	var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
	function getIteratorFn(maybeIterable) {
	  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
	  maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
	  return "function" === typeof maybeIterable ? maybeIterable : null;
	}
	var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
	function getComponentNameFromType(type) {
	  if (null == type) return null;
	  if ("function" === typeof type)
	    return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
	  if ("string" === typeof type) return type;
	  switch (type) {
	    case REACT_FRAGMENT_TYPE:
	      return "Fragment";
	    case REACT_PROFILER_TYPE:
	      return "Profiler";
	    case REACT_STRICT_MODE_TYPE:
	      return "StrictMode";
	    case REACT_SUSPENSE_TYPE:
	      return "Suspense";
	    case REACT_SUSPENSE_LIST_TYPE:
	      return "SuspenseList";
	    case REACT_ACTIVITY_TYPE:
	      return "Activity";
	  }
	  if ("object" === typeof type)
	    switch (type.$$typeof) {
	      case REACT_PORTAL_TYPE:
	        return "Portal";
	      case REACT_CONTEXT_TYPE:
	        return (type.displayName || "Context") + ".Provider";
	      case REACT_CONSUMER_TYPE:
	        return (type._context.displayName || "Context") + ".Consumer";
	      case REACT_FORWARD_REF_TYPE:
	        var innerType = type.render;
	        type = type.displayName;
	        type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
	        return type;
	      case REACT_MEMO_TYPE:
	        return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
	      case REACT_LAZY_TYPE:
	        innerType = type._payload;
	        type = type._init;
	        try {
	          return getComponentNameFromType(type(innerType));
	        } catch (x) {
	        }
	    }
	  return null;
	}
	var isArrayImpl = Array.isArray, ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
	  pending: false,
	  data: null,
	  method: null,
	  action: null
	}, valueStack = [], index = -1;
	function createCursor(defaultValue) {
	  return { current: defaultValue };
	}
	function pop(cursor) {
	  0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
	}
	function push(cursor, value) {
	  index++;
	  valueStack[index] = cursor.current;
	  cursor.current = value;
	}
	var contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null);
	function pushHostContainer(fiber, nextRootInstance) {
	  push(rootInstanceStackCursor, nextRootInstance);
	  push(contextFiberStackCursor, fiber);
	  push(contextStackCursor, null);
	  switch (nextRootInstance.nodeType) {
	    case 9:
	    case 11:
	      fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
	      break;
	    default:
	      if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
	        nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
	      else
	        switch (fiber) {
	          case "svg":
	            fiber = 1;
	            break;
	          case "math":
	            fiber = 2;
	            break;
	          default:
	            fiber = 0;
	        }
	  }
	  pop(contextStackCursor);
	  push(contextStackCursor, fiber);
	}
	function popHostContainer() {
	  pop(contextStackCursor);
	  pop(contextFiberStackCursor);
	  pop(rootInstanceStackCursor);
	}
	function pushHostContext(fiber) {
	  null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
	  var context = contextStackCursor.current;
	  var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
	  context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
	}
	function popHostContext(fiber) {
	  contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
	  hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
	}
	var hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null;
	function setIsStrictModeForDevtools(newIsStrictMode) {
	  "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
	  if (injectedHook && "function" === typeof injectedHook.setStrictMode)
	    try {
	      injectedHook.setStrictMode(rendererID, newIsStrictMode);
	    } catch (err) {
	    }
	}
	var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
	function clz32Fallback(x) {
	  x >>>= 0;
	  return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
	}
	var nextTransitionLane = 256, nextRetryLane = 4194304;
	function getHighestPriorityLanes(lanes) {
	  var pendingSyncLanes = lanes & 42;
	  if (0 !== pendingSyncLanes) return pendingSyncLanes;
	  switch (lanes & -lanes) {
	    case 1:
	      return 1;
	    case 2:
	      return 2;
	    case 4:
	      return 4;
	    case 8:
	      return 8;
	    case 16:
	      return 16;
	    case 32:
	      return 32;
	    case 64:
	      return 64;
	    case 128:
	      return 128;
	    case 256:
	    case 512:
	    case 1024:
	    case 2048:
	    case 4096:
	    case 8192:
	    case 16384:
	    case 32768:
	    case 65536:
	    case 131072:
	    case 262144:
	    case 524288:
	    case 1048576:
	    case 2097152:
	      return lanes & 4194048;
	    case 4194304:
	    case 8388608:
	    case 16777216:
	    case 33554432:
	      return lanes & 62914560;
	    case 67108864:
	      return 67108864;
	    case 134217728:
	      return 134217728;
	    case 268435456:
	      return 268435456;
	    case 536870912:
	      return 536870912;
	    case 1073741824:
	      return 0;
	    default:
	      return lanes;
	  }
	}
	function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
	  var pendingLanes = root2.pendingLanes;
	  if (0 === pendingLanes) return 0;
	  var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
	  root2 = root2.warmLanes;
	  var nonIdlePendingLanes = pendingLanes & 134217727;
	  0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
	  return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
	}
	function checkIfRootIsPrerendering(root2, renderLanes2) {
	  return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
	}
	function computeExpirationTime(lane, currentTime) {
	  switch (lane) {
	    case 1:
	    case 2:
	    case 4:
	    case 8:
	    case 64:
	      return currentTime + 250;
	    case 16:
	    case 32:
	    case 128:
	    case 256:
	    case 512:
	    case 1024:
	    case 2048:
	    case 4096:
	    case 8192:
	    case 16384:
	    case 32768:
	    case 65536:
	    case 131072:
	    case 262144:
	    case 524288:
	    case 1048576:
	    case 2097152:
	      return currentTime + 5e3;
	    case 4194304:
	    case 8388608:
	    case 16777216:
	    case 33554432:
	      return -1;
	    case 67108864:
	    case 134217728:
	    case 268435456:
	    case 536870912:
	    case 1073741824:
	      return -1;
	    default:
	      return -1;
	  }
	}
	function claimNextTransitionLane() {
	  var lane = nextTransitionLane;
	  nextTransitionLane <<= 1;
	  0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
	  return lane;
	}
	function claimNextRetryLane() {
	  var lane = nextRetryLane;
	  nextRetryLane <<= 1;
	  0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
	  return lane;
	}
	function createLaneMap(initial) {
	  for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
	  return laneMap;
	}
	function markRootUpdated$1(root2, updateLane) {
	  root2.pendingLanes |= updateLane;
	  268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
	}
	function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
	  var previouslyPendingLanes = root2.pendingLanes;
	  root2.pendingLanes = remainingLanes;
	  root2.suspendedLanes = 0;
	  root2.pingedLanes = 0;
	  root2.warmLanes = 0;
	  root2.expiredLanes &= remainingLanes;
	  root2.entangledLanes &= remainingLanes;
	  root2.errorRecoveryDisabledLanes &= remainingLanes;
	  root2.shellSuspendCounter = 0;
	  var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
	  for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
	    var index$5 = 31 - clz32(remainingLanes), lane = 1 << index$5;
	    entanglements[index$5] = 0;
	    expirationTimes[index$5] = -1;
	    var hiddenUpdatesForLane = hiddenUpdates[index$5];
	    if (null !== hiddenUpdatesForLane)
	      for (hiddenUpdates[index$5] = null, index$5 = 0; index$5 < hiddenUpdatesForLane.length; index$5++) {
	        var update = hiddenUpdatesForLane[index$5];
	        null !== update && (update.lane &= -536870913);
	      }
	    remainingLanes &= ~lane;
	  }
	  0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
	  0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
	}
	function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
	  root2.pendingLanes |= spawnedLane;
	  root2.suspendedLanes &= ~spawnedLane;
	  var spawnedLaneIndex = 31 - clz32(spawnedLane);
	  root2.entangledLanes |= spawnedLane;
	  root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
	}
	function markRootEntangled(root2, entangledLanes) {
	  var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
	  for (root2 = root2.entanglements; rootEntangledLanes; ) {
	    var index$6 = 31 - clz32(rootEntangledLanes), lane = 1 << index$6;
	    lane & entangledLanes | root2[index$6] & entangledLanes && (root2[index$6] |= entangledLanes);
	    rootEntangledLanes &= ~lane;
	  }
	}
	function getBumpedLaneForHydrationByLane(lane) {
	  switch (lane) {
	    case 2:
	      lane = 1;
	      break;
	    case 8:
	      lane = 4;
	      break;
	    case 32:
	      lane = 16;
	      break;
	    case 256:
	    case 512:
	    case 1024:
	    case 2048:
	    case 4096:
	    case 8192:
	    case 16384:
	    case 32768:
	    case 65536:
	    case 131072:
	    case 262144:
	    case 524288:
	    case 1048576:
	    case 2097152:
	    case 4194304:
	    case 8388608:
	    case 16777216:
	    case 33554432:
	      lane = 128;
	      break;
	    case 268435456:
	      lane = 134217728;
	      break;
	    default:
	      lane = 0;
	  }
	  return lane;
	}
	function lanesToEventPriority(lanes) {
	  lanes &= -lanes;
	  return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
	}
	function resolveUpdatePriority() {
	  var updatePriority = ReactDOMSharedInternals.p;
	  if (0 !== updatePriority) return updatePriority;
	  updatePriority = window.event;
	  return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
	}
	function runWithPriority(priority, fn) {
	  var previousPriority = ReactDOMSharedInternals.p;
	  try {
	    return ReactDOMSharedInternals.p = priority, fn();
	  } finally {
	    ReactDOMSharedInternals.p = previousPriority;
	  }
	}
	var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey;
	function detachDeletedInstance(node) {
	  delete node[internalInstanceKey];
	  delete node[internalPropsKey];
	  delete node[internalEventHandlersKey];
	  delete node[internalEventHandlerListenersKey];
	  delete node[internalEventHandlesSetKey];
	}
	function getClosestInstanceFromNode(targetNode) {
	  var targetInst = targetNode[internalInstanceKey];
	  if (targetInst) return targetInst;
	  for (var parentNode = targetNode.parentNode; parentNode; ) {
	    if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
	      parentNode = targetInst.alternate;
	      if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
	        for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode; ) {
	          if (parentNode = targetNode[internalInstanceKey]) return parentNode;
	          targetNode = getParentSuspenseInstance(targetNode);
	        }
	      return targetInst;
	    }
	    targetNode = parentNode;
	    parentNode = targetNode.parentNode;
	  }
	  return null;
	}
	function getInstanceFromNode(node) {
	  if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
	    var tag = node.tag;
	    if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag)
	      return node;
	  }
	  return null;
	}
	function getNodeFromInstance(inst) {
	  var tag = inst.tag;
	  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
	  throw Error(formatProdErrorMessage(33));
	}
	function getResourcesFromRoot(root2) {
	  var resources = root2[internalRootNodeResourcesKey];
	  resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
	  return resources;
	}
	function markNodeAsHoistable(node) {
	  node[internalHoistableMarker] = true;
	}
	var allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {};
	function registerTwoPhaseEvent(registrationName, dependencies) {
	  registerDirectEvent(registrationName, dependencies);
	  registerDirectEvent(registrationName + "Capture", dependencies);
	}
	function registerDirectEvent(registrationName, dependencies) {
	  registrationNameDependencies[registrationName] = dependencies;
	  for (registrationName = 0; registrationName < dependencies.length; registrationName++)
	    allNativeEvents.add(dependencies[registrationName]);
	}
	var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
	  "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
	), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
	function isAttributeNameSafe(attributeName) {
	  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
	    return true;
	  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
	    return validatedAttributeNameCache[attributeName] = true;
	  illegalAttributeNameCache[attributeName] = true;
	  return false;
	}
	function setValueForAttribute(node, name, value) {
	  if (isAttributeNameSafe(name))
	    if (null === value) node.removeAttribute(name);
	    else {
	      switch (typeof value) {
	        case "undefined":
	        case "function":
	        case "symbol":
	          node.removeAttribute(name);
	          return;
	        case "boolean":
	          var prefix$8 = name.toLowerCase().slice(0, 5);
	          if ("data-" !== prefix$8 && "aria-" !== prefix$8) {
	            node.removeAttribute(name);
	            return;
	          }
	      }
	      node.setAttribute(name, "" + value);
	    }
	}
	function setValueForKnownAttribute(node, name, value) {
	  if (null === value) node.removeAttribute(name);
	  else {
	    switch (typeof value) {
	      case "undefined":
	      case "function":
	      case "symbol":
	      case "boolean":
	        node.removeAttribute(name);
	        return;
	    }
	    node.setAttribute(name, "" + value);
	  }
	}
	function setValueForNamespacedAttribute(node, namespace, name, value) {
	  if (null === value) node.removeAttribute(name);
	  else {
	    switch (typeof value) {
	      case "undefined":
	      case "function":
	      case "symbol":
	      case "boolean":
	        node.removeAttribute(name);
	        return;
	    }
	    node.setAttributeNS(namespace, name, "" + value);
	  }
	}
	var prefix, suffix;
	function describeBuiltInComponentFrame(name) {
	  if (void 0 === prefix)
	    try {
	      throw Error();
	    } catch (x) {
	      var match = x.stack.trim().match(/\n( *(at )?)/);
	      prefix = match && match[1] || "";
	      suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
	    }
	  return "\n" + prefix + name + suffix;
	}
	var reentry = false;
	function describeNativeComponentFrame(fn, construct) {
	  if (!fn || reentry) return "";
	  reentry = true;
	  var previousPrepareStackTrace = Error.prepareStackTrace;
	  Error.prepareStackTrace = void 0;
	  try {
	    var RunInRootFrame = {
	      DetermineComponentFrameRoot: function() {
	        try {
	          if (construct) {
	            var Fake = function() {
	              throw Error();
	            };
	            Object.defineProperty(Fake.prototype, "props", {
	              set: function() {
	                throw Error();
	              }
	            });
	            if ("object" === typeof Reflect && Reflect.construct) {
	              try {
	                Reflect.construct(Fake, []);
	              } catch (x) {
	                var control = x;
	              }
	              Reflect.construct(fn, [], Fake);
	            } else {
	              try {
	                Fake.call();
	              } catch (x$9) {
	                control = x$9;
	              }
	              fn.call(Fake.prototype);
	            }
	          } else {
	            try {
	              throw Error();
	            } catch (x$10) {
	              control = x$10;
	            }
	            (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
	            });
	          }
	        } catch (sample) {
	          if (sample && control && "string" === typeof sample.stack)
	            return [sample.stack, control.stack];
	        }
	        return [null, null];
	      }
	    };
	    RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
	    var namePropDescriptor = Object.getOwnPropertyDescriptor(
	      RunInRootFrame.DetermineComponentFrameRoot,
	      "name"
	    );
	    namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
	      RunInRootFrame.DetermineComponentFrameRoot,
	      "name",
	      { value: "DetermineComponentFrameRoot" }
	    );
	    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
	    if (sampleStack && controlStack) {
	      var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
	      for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
	        RunInRootFrame++;
	      for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
	        "DetermineComponentFrameRoot"
	      ); )
	        namePropDescriptor++;
	      if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
	        for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
	          namePropDescriptor--;
	      for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
	        if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
	          if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
	            do
	              if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
	                var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
	                fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
	                return frame;
	              }
	            while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
	          }
	          break;
	        }
	    }
	  } finally {
	    reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
	  }
	  return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
	}
	function describeFiber(fiber) {
	  switch (fiber.tag) {
	    case 26:
	    case 27:
	    case 5:
	      return describeBuiltInComponentFrame(fiber.type);
	    case 16:
	      return describeBuiltInComponentFrame("Lazy");
	    case 13:
	      return describeBuiltInComponentFrame("Suspense");
	    case 19:
	      return describeBuiltInComponentFrame("SuspenseList");
	    case 0:
	    case 15:
	      return describeNativeComponentFrame(fiber.type, false);
	    case 11:
	      return describeNativeComponentFrame(fiber.type.render, false);
	    case 1:
	      return describeNativeComponentFrame(fiber.type, true);
	    case 31:
	      return describeBuiltInComponentFrame("Activity");
	    default:
	      return "";
	  }
	}
	function getStackByFiberInDevAndProd(workInProgress2) {
	  try {
	    var info = "";
	    do
	      info += describeFiber(workInProgress2), workInProgress2 = workInProgress2.return;
	    while (workInProgress2);
	    return info;
	  } catch (x) {
	    return "\nError generating stack: " + x.message + "\n" + x.stack;
	  }
	}
	function getToStringValue(value) {
	  switch (typeof value) {
	    case "bigint":
	    case "boolean":
	    case "number":
	    case "string":
	    case "undefined":
	      return value;
	    case "object":
	      return value;
	    default:
	      return "";
	  }
	}
	function isCheckable(elem) {
	  var type = elem.type;
	  return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
	}
	function trackValueOnNode(node) {
	  var valueField = isCheckable(node) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(
	    node.constructor.prototype,
	    valueField
	  ), currentValue = "" + node[valueField];
	  if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
	    var get = descriptor.get, set = descriptor.set;
	    Object.defineProperty(node, valueField, {
	      configurable: true,
	      get: function() {
	        return get.call(this);
	      },
	      set: function(value) {
	        currentValue = "" + value;
	        set.call(this, value);
	      }
	    });
	    Object.defineProperty(node, valueField, {
	      enumerable: descriptor.enumerable
	    });
	    return {
	      getValue: function() {
	        return currentValue;
	      },
	      setValue: function(value) {
	        currentValue = "" + value;
	      },
	      stopTracking: function() {
	        node._valueTracker = null;
	        delete node[valueField];
	      }
	    };
	  }
	}
	function track(node) {
	  node._valueTracker || (node._valueTracker = trackValueOnNode(node));
	}
	function updateValueIfChanged(node) {
	  if (!node) return false;
	  var tracker = node._valueTracker;
	  if (!tracker) return true;
	  var lastValue = tracker.getValue();
	  var value = "";
	  node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
	  node = value;
	  return node !== lastValue ? (tracker.setValue(node), true) : false;
	}
	function getActiveElement(doc) {
	  doc = doc || ("undefined" !== typeof document ? document : void 0);
	  if ("undefined" === typeof doc) return null;
	  try {
	    return doc.activeElement || doc.body;
	  } catch (e) {
	    return doc.body;
	  }
	}
	var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
	function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
	  return value.replace(
	    escapeSelectorAttributeValueInsideDoubleQuotesRegex,
	    function(ch) {
	      return "\\" + ch.charCodeAt(0).toString(16) + " ";
	    }
	  );
	}
	function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
	  element.name = "";
	  null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
	  if (null != value)
	    if ("number" === type) {
	      if (0 === value && "" === element.value || element.value != value)
	        element.value = "" + getToStringValue(value);
	    } else
	      element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
	  else
	    "submit" !== type && "reset" !== type || element.removeAttribute("value");
	  null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
	  null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
	  null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
	  null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
	}
	function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
	  null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
	  if (null != value || null != defaultValue) {
	    if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value))
	      return;
	    defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
	    value = null != value ? "" + getToStringValue(value) : defaultValue;
	    isHydrating2 || value === element.value || (element.value = value);
	    element.defaultValue = value;
	  }
	  checked = null != checked ? checked : defaultChecked;
	  checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
	  element.checked = isHydrating2 ? element.checked : !!checked;
	  element.defaultChecked = !!checked;
	  null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
	}
	function setDefaultValue(node, type, value) {
	  "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
	}
	function updateOptions(node, multiple, propValue, setDefaultSelected) {
	  node = node.options;
	  if (multiple) {
	    multiple = {};
	    for (var i = 0; i < propValue.length; i++)
	      multiple["$" + propValue[i]] = true;
	    for (propValue = 0; propValue < node.length; propValue++)
	      i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
	  } else {
	    propValue = "" + getToStringValue(propValue);
	    multiple = null;
	    for (i = 0; i < node.length; i++) {
	      if (node[i].value === propValue) {
	        node[i].selected = true;
	        setDefaultSelected && (node[i].defaultSelected = true);
	        return;
	      }
	      null !== multiple || node[i].disabled || (multiple = node[i]);
	    }
	    null !== multiple && (multiple.selected = true);
	  }
	}
	function updateTextarea(element, value, defaultValue) {
	  if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
	    element.defaultValue !== value && (element.defaultValue = value);
	    return;
	  }
	  element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
	}
	function initTextarea(element, value, defaultValue, children) {
	  if (null == value) {
	    if (null != children) {
	      if (null != defaultValue) throw Error(formatProdErrorMessage(92));
	      if (isArrayImpl(children)) {
	        if (1 < children.length) throw Error(formatProdErrorMessage(93));
	        children = children[0];
	      }
	      defaultValue = children;
	    }
	    null == defaultValue && (defaultValue = "");
	    value = defaultValue;
	  }
	  defaultValue = getToStringValue(value);
	  element.defaultValue = defaultValue;
	  children = element.textContent;
	  children === defaultValue && "" !== children && null !== children && (element.value = children);
	}
	function setTextContent(node, text) {
	  if (text) {
	    var firstChild = node.firstChild;
	    if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
	      firstChild.nodeValue = text;
	      return;
	    }
	  }
	  node.textContent = text;
	}
	var unitlessNumbers = new Set(
	  "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
	    " "
	  )
	);
	function setValueForStyle(style2, styleName, value) {
	  var isCustomProperty = 0 === styleName.indexOf("--");
	  null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
	}
	function setValueForStyles(node, styles, prevStyles) {
	  if (null != styles && "object" !== typeof styles)
	    throw Error(formatProdErrorMessage(62));
	  node = node.style;
	  if (null != prevStyles) {
	    for (var styleName in prevStyles)
	      !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
	    for (var styleName$16 in styles)
	      styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
	  } else
	    for (var styleName$17 in styles)
	      styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
	}
	function isCustomElement(tagName) {
	  if (-1 === tagName.indexOf("-")) return false;
	  switch (tagName) {
	    case "annotation-xml":
	    case "color-profile":
	    case "font-face":
	    case "font-face-src":
	    case "font-face-uri":
	    case "font-face-format":
	    case "font-face-name":
	    case "missing-glyph":
	      return false;
	    default:
	      return true;
	  }
	}
	var aliases = /* @__PURE__ */ new Map([
	  ["acceptCharset", "accept-charset"],
	  ["htmlFor", "for"],
	  ["httpEquiv", "http-equiv"],
	  ["crossOrigin", "crossorigin"],
	  ["accentHeight", "accent-height"],
	  ["alignmentBaseline", "alignment-baseline"],
	  ["arabicForm", "arabic-form"],
	  ["baselineShift", "baseline-shift"],
	  ["capHeight", "cap-height"],
	  ["clipPath", "clip-path"],
	  ["clipRule", "clip-rule"],
	  ["colorInterpolation", "color-interpolation"],
	  ["colorInterpolationFilters", "color-interpolation-filters"],
	  ["colorProfile", "color-profile"],
	  ["colorRendering", "color-rendering"],
	  ["dominantBaseline", "dominant-baseline"],
	  ["enableBackground", "enable-background"],
	  ["fillOpacity", "fill-opacity"],
	  ["fillRule", "fill-rule"],
	  ["floodColor", "flood-color"],
	  ["floodOpacity", "flood-opacity"],
	  ["fontFamily", "font-family"],
	  ["fontSize", "font-size"],
	  ["fontSizeAdjust", "font-size-adjust"],
	  ["fontStretch", "font-stretch"],
	  ["fontStyle", "font-style"],
	  ["fontVariant", "font-variant"],
	  ["fontWeight", "font-weight"],
	  ["glyphName", "glyph-name"],
	  ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
	  ["glyphOrientationVertical", "glyph-orientation-vertical"],
	  ["horizAdvX", "horiz-adv-x"],
	  ["horizOriginX", "horiz-origin-x"],
	  ["imageRendering", "image-rendering"],
	  ["letterSpacing", "letter-spacing"],
	  ["lightingColor", "lighting-color"],
	  ["markerEnd", "marker-end"],
	  ["markerMid", "marker-mid"],
	  ["markerStart", "marker-start"],
	  ["overlinePosition", "overline-position"],
	  ["overlineThickness", "overline-thickness"],
	  ["paintOrder", "paint-order"],
	  ["panose-1", "panose-1"],
	  ["pointerEvents", "pointer-events"],
	  ["renderingIntent", "rendering-intent"],
	  ["shapeRendering", "shape-rendering"],
	  ["stopColor", "stop-color"],
	  ["stopOpacity", "stop-opacity"],
	  ["strikethroughPosition", "strikethrough-position"],
	  ["strikethroughThickness", "strikethrough-thickness"],
	  ["strokeDasharray", "stroke-dasharray"],
	  ["strokeDashoffset", "stroke-dashoffset"],
	  ["strokeLinecap", "stroke-linecap"],
	  ["strokeLinejoin", "stroke-linejoin"],
	  ["strokeMiterlimit", "stroke-miterlimit"],
	  ["strokeOpacity", "stroke-opacity"],
	  ["strokeWidth", "stroke-width"],
	  ["textAnchor", "text-anchor"],
	  ["textDecoration", "text-decoration"],
	  ["textRendering", "text-rendering"],
	  ["transformOrigin", "transform-origin"],
	  ["underlinePosition", "underline-position"],
	  ["underlineThickness", "underline-thickness"],
	  ["unicodeBidi", "unicode-bidi"],
	  ["unicodeRange", "unicode-range"],
	  ["unitsPerEm", "units-per-em"],
	  ["vAlphabetic", "v-alphabetic"],
	  ["vHanging", "v-hanging"],
	  ["vIdeographic", "v-ideographic"],
	  ["vMathematical", "v-mathematical"],
	  ["vectorEffect", "vector-effect"],
	  ["vertAdvY", "vert-adv-y"],
	  ["vertOriginX", "vert-origin-x"],
	  ["vertOriginY", "vert-origin-y"],
	  ["wordSpacing", "word-spacing"],
	  ["writingMode", "writing-mode"],
	  ["xmlnsXlink", "xmlns:xlink"],
	  ["xHeight", "x-height"]
	]), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
	function sanitizeURL(url) {
	  return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
	}
	var currentReplayingEvent = null;
	function getEventTarget(nativeEvent) {
	  nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
	  nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
	  return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
	}
	var restoreTarget = null, restoreQueue = null;
	function restoreStateOfTarget(target) {
	  var internalInstance = getInstanceFromNode(target);
	  if (internalInstance && (target = internalInstance.stateNode)) {
	    var props = target[internalPropsKey] || null;
	    a: switch (target = internalInstance.stateNode, internalInstance.type) {
	      case "input":
	        updateInput(
	          target,
	          props.value,
	          props.defaultValue,
	          props.defaultValue,
	          props.checked,
	          props.defaultChecked,
	          props.type,
	          props.name
	        );
	        internalInstance = props.name;
	        if ("radio" === props.type && null != internalInstance) {
	          for (props = target; props.parentNode; ) props = props.parentNode;
	          props = props.querySelectorAll(
	            'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
	              "" + internalInstance
	            ) + '"][type="radio"]'
	          );
	          for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
	            var otherNode = props[internalInstance];
	            if (otherNode !== target && otherNode.form === target.form) {
	              var otherProps = otherNode[internalPropsKey] || null;
	              if (!otherProps) throw Error(formatProdErrorMessage(90));
	              updateInput(
	                otherNode,
	                otherProps.value,
	                otherProps.defaultValue,
	                otherProps.defaultValue,
	                otherProps.checked,
	                otherProps.defaultChecked,
	                otherProps.type,
	                otherProps.name
	              );
	            }
	          }
	          for (internalInstance = 0; internalInstance < props.length; internalInstance++)
	            otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
	        }
	        break a;
	      case "textarea":
	        updateTextarea(target, props.value, props.defaultValue);
	        break a;
	      case "select":
	        internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
	    }
	  }
	}
	var isInsideEventHandler = false;
	function batchedUpdates$1(fn, a, b) {
	  if (isInsideEventHandler) return fn(a, b);
	  isInsideEventHandler = true;
	  try {
	    var JSCompiler_inline_result = fn(a);
	    return JSCompiler_inline_result;
	  } finally {
	    if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
	      if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
	        for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
	    }
	  }
	}
	function getListener(inst, registrationName) {
	  var stateNode = inst.stateNode;
	  if (null === stateNode) return null;
	  var props = stateNode[internalPropsKey] || null;
	  if (null === props) return null;
	  stateNode = props[registrationName];
	  a: switch (registrationName) {
	    case "onClick":
	    case "onClickCapture":
	    case "onDoubleClick":
	    case "onDoubleClickCapture":
	    case "onMouseDown":
	    case "onMouseDownCapture":
	    case "onMouseMove":
	    case "onMouseMoveCapture":
	    case "onMouseUp":
	    case "onMouseUpCapture":
	    case "onMouseEnter":
	      (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
	      inst = !props;
	      break a;
	    default:
	      inst = false;
	  }
	  if (inst) return null;
	  if (stateNode && "function" !== typeof stateNode)
	    throw Error(
	      formatProdErrorMessage(231, registrationName, typeof stateNode)
	    );
	  return stateNode;
	}
	var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
	if (canUseDOM)
	  try {
	    var options = {};
	    Object.defineProperty(options, "passive", {
	      get: function() {
	        passiveBrowserEventsSupported = true;
	      }
	    });
	    window.addEventListener("test", options, options);
	    window.removeEventListener("test", options, options);
	  } catch (e) {
	    passiveBrowserEventsSupported = false;
	  }
	var root = null, startText = null, fallbackText = null;
	function getData() {
	  if (fallbackText) return fallbackText;
	  var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
	  for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
	  var minEnd = startLength - start;
	  for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
	  return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
	}
	function getEventCharCode(nativeEvent) {
	  var keyCode = nativeEvent.keyCode;
	  "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
	  10 === nativeEvent && (nativeEvent = 13);
	  return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
	}
	function functionThatReturnsTrue() {
	  return true;
	}
	function functionThatReturnsFalse() {
	  return false;
	}
	function createSyntheticEvent(Interface) {
	  function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
	    this._reactName = reactName;
	    this._targetInst = targetInst;
	    this.type = reactEventType;
	    this.nativeEvent = nativeEvent;
	    this.target = nativeEventTarget;
	    this.currentTarget = null;
	    for (var propName in Interface)
	      Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
	    this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
	    this.isPropagationStopped = functionThatReturnsFalse;
	    return this;
	  }
	  assign(SyntheticBaseEvent.prototype, {
	    preventDefault: function() {
	      this.defaultPrevented = true;
	      var event = this.nativeEvent;
	      event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
	    },
	    stopPropagation: function() {
	      var event = this.nativeEvent;
	      event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
	    },
	    persist: function() {
	    },
	    isPersistent: functionThatReturnsTrue
	  });
	  return SyntheticBaseEvent;
	}
	var EventInterface = {
	  eventPhase: 0,
	  bubbles: 0,
	  cancelable: 0,
	  timeStamp: function(event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: 0,
	  isTrusted: 0
	}, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
	  screenX: 0,
	  screenY: 0,
	  clientX: 0,
	  clientY: 0,
	  pageX: 0,
	  pageY: 0,
	  ctrlKey: 0,
	  shiftKey: 0,
	  altKey: 0,
	  metaKey: 0,
	  getModifierState: getEventModifierState,
	  button: 0,
	  buttons: 0,
	  relatedTarget: function(event) {
	    return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
	  },
	  movementX: function(event) {
	    if ("movementX" in event) return event.movementX;
	    event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
	    return lastMovementX;
	  },
	  movementY: function(event) {
	    return "movementY" in event ? event.movementY : lastMovementY;
	  }
	}), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
	  animationName: 0,
	  elapsedTime: 0,
	  pseudoElement: 0
	}), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
	  clipboardData: function(event) {
	    return "clipboardData" in event ? event.clipboardData : window.clipboardData;
	  }
	}), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), normalizeKey = {
	  Esc: "Escape",
	  Spacebar: " ",
	  Left: "ArrowLeft",
	  Up: "ArrowUp",
	  Right: "ArrowRight",
	  Down: "ArrowDown",
	  Del: "Delete",
	  Win: "OS",
	  Menu: "ContextMenu",
	  Apps: "ContextMenu",
	  Scroll: "ScrollLock",
	  MozPrintableKey: "Unidentified"
	}, translateToKey = {
	  8: "Backspace",
	  9: "Tab",
	  12: "Clear",
	  13: "Enter",
	  16: "Shift",
	  17: "Control",
	  18: "Alt",
	  19: "Pause",
	  20: "CapsLock",
	  27: "Escape",
	  32: " ",
	  33: "PageUp",
	  34: "PageDown",
	  35: "End",
	  36: "Home",
	  37: "ArrowLeft",
	  38: "ArrowUp",
	  39: "ArrowRight",
	  40: "ArrowDown",
	  45: "Insert",
	  46: "Delete",
	  112: "F1",
	  113: "F2",
	  114: "F3",
	  115: "F4",
	  116: "F5",
	  117: "F6",
	  118: "F7",
	  119: "F8",
	  120: "F9",
	  121: "F10",
	  122: "F11",
	  123: "F12",
	  144: "NumLock",
	  145: "ScrollLock",
	  224: "Meta"
	}, modifierKeyToProp = {
	  Alt: "altKey",
	  Control: "ctrlKey",
	  Meta: "metaKey",
	  Shift: "shiftKey"
	};
	function modifierStateGetter(keyArg) {
	  var nativeEvent = this.nativeEvent;
	  return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
	}
	function getEventModifierState() {
	  return modifierStateGetter;
	}
	var KeyboardEventInterface = assign({}, UIEventInterface, {
	  key: function(nativeEvent) {
	    if (nativeEvent.key) {
	      var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	      if ("Unidentified" !== key) return key;
	    }
	    return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
	  },
	  code: 0,
	  location: 0,
	  ctrlKey: 0,
	  shiftKey: 0,
	  altKey: 0,
	  metaKey: 0,
	  repeat: 0,
	  locale: 0,
	  getModifierState: getEventModifierState,
	  charCode: function(event) {
	    return "keypress" === event.type ? getEventCharCode(event) : 0;
	  },
	  keyCode: function(event) {
	    return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
	  },
	  which: function(event) {
	    return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
	  }
	}), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
	  pointerId: 0,
	  width: 0,
	  height: 0,
	  pressure: 0,
	  tangentialPressure: 0,
	  tiltX: 0,
	  tiltY: 0,
	  twist: 0,
	  pointerType: 0,
	  isPrimary: 0
	}), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
	  touches: 0,
	  targetTouches: 0,
	  changedTouches: 0,
	  altKey: 0,
	  metaKey: 0,
	  ctrlKey: 0,
	  shiftKey: 0,
	  getModifierState: getEventModifierState
	}), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
	  propertyName: 0,
	  elapsedTime: 0,
	  pseudoElement: 0
	}), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
	  deltaX: function(event) {
	    return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function(event) {
	    return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: 0,
	  deltaMode: 0
	}), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
	  newState: 0,
	  oldState: 0
	}), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
	canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
	var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CHAR = String.fromCharCode(32), hasSpaceKeypress = false;
	function isFallbackCompositionEnd(domEventName, nativeEvent) {
	  switch (domEventName) {
	    case "keyup":
	      return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
	    case "keydown":
	      return 229 !== nativeEvent.keyCode;
	    case "keypress":
	    case "mousedown":
	    case "focusout":
	      return true;
	    default:
	      return false;
	  }
	}
	function getDataFromCustomEvent(nativeEvent) {
	  nativeEvent = nativeEvent.detail;
	  return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
	}
	var isComposing = false;
	function getNativeBeforeInputChars(domEventName, nativeEvent) {
	  switch (domEventName) {
	    case "compositionend":
	      return getDataFromCustomEvent(nativeEvent);
	    case "keypress":
	      if (32 !== nativeEvent.which) return null;
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	    case "textInput":
	      return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
	    default:
	      return null;
	  }
	}
	function getFallbackBeforeInputChars(domEventName, nativeEvent) {
	  if (isComposing)
	    return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
	  switch (domEventName) {
	    case "paste":
	      return null;
	    case "keypress":
	      if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
	        if (nativeEvent.char && 1 < nativeEvent.char.length)
	          return nativeEvent.char;
	        if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case "compositionend":
	      return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	var supportedInputTypes = {
	  color: true,
	  date: true,
	  datetime: true,
	  "datetime-local": true,
	  email: true,
	  month: true,
	  number: true,
	  password: true,
	  range: true,
	  search: true,
	  tel: true,
	  text: true,
	  time: true,
	  url: true,
	  week: true
	};
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	  return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
	}
	function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
	  restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
	  inst = accumulateTwoPhaseListeners(inst, "onChange");
	  0 < inst.length && (nativeEvent = new SyntheticEvent(
	    "onChange",
	    "change",
	    null,
	    nativeEvent,
	    target
	  ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
	}
	var activeElement$1 = null, activeElementInst$1 = null;
	function runEventInBatch(dispatchQueue) {
	  processDispatchQueue(dispatchQueue, 0);
	}
	function getInstIfValueChanged(targetInst) {
	  var targetNode = getNodeFromInstance(targetInst);
	  if (updateValueIfChanged(targetNode)) return targetInst;
	}
	function getTargetInstForChangeEvent(domEventName, targetInst) {
	  if ("change" === domEventName) return targetInst;
	}
	var isInputEventSupported = false;
	if (canUseDOM) {
	  var JSCompiler_inline_result$jscomp$282;
	  if (canUseDOM) {
	    var isSupported$jscomp$inline_417 = "oninput" in document;
	    if (!isSupported$jscomp$inline_417) {
	      var element$jscomp$inline_418 = document.createElement("div");
	      element$jscomp$inline_418.setAttribute("oninput", "return;");
	      isSupported$jscomp$inline_417 = "function" === typeof element$jscomp$inline_418.oninput;
	    }
	    JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;
	  } else JSCompiler_inline_result$jscomp$282 = false;
	  isInputEventSupported = JSCompiler_inline_result$jscomp$282 && (!document.documentMode || 9 < document.documentMode);
	}
	function stopWatchingForValueChange() {
	  activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
	}
	function handlePropertyChange(nativeEvent) {
	  if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
	    var dispatchQueue = [];
	    createAndAccumulateChangeEvent(
	      dispatchQueue,
	      activeElementInst$1,
	      nativeEvent,
	      getEventTarget(nativeEvent)
	    );
	    batchedUpdates$1(runEventInBatch, dispatchQueue);
	  }
	}
	function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
	  "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
	}
	function getTargetInstForInputEventPolyfill(domEventName) {
	  if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
	    return getInstIfValueChanged(activeElementInst$1);
	}
	function getTargetInstForClickEvent(domEventName, targetInst) {
	  if ("click" === domEventName) return getInstIfValueChanged(targetInst);
	}
	function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
	  if ("input" === domEventName || "change" === domEventName)
	    return getInstIfValueChanged(targetInst);
	}
	function is(x, y) {
	  return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
	}
	var objectIs = "function" === typeof Object.is ? Object.is : is;
	function shallowEqual(objA, objB) {
	  if (objectIs(objA, objB)) return true;
	  if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
	    return false;
	  var keysA = Object.keys(objA), keysB = Object.keys(objB);
	  if (keysA.length !== keysB.length) return false;
	  for (keysB = 0; keysB < keysA.length; keysB++) {
	    var currentKey = keysA[keysB];
	    if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
	      return false;
	  }
	  return true;
	}
	function getLeafNode(node) {
	  for (; node && node.firstChild; ) node = node.firstChild;
	  return node;
	}
	function getNodeForCharacterOffset(root2, offset) {
	  var node = getLeafNode(root2);
	  root2 = 0;
	  for (var nodeEnd; node; ) {
	    if (3 === node.nodeType) {
	      nodeEnd = root2 + node.textContent.length;
	      if (root2 <= offset && nodeEnd >= offset)
	        return { node, offset: offset - root2 };
	      root2 = nodeEnd;
	    }
	    a: {
	      for (; node; ) {
	        if (node.nextSibling) {
	          node = node.nextSibling;
	          break a;
	        }
	        node = node.parentNode;
	      }
	      node = void 0;
	    }
	    node = getLeafNode(node);
	  }
	}
	function containsNode(outerNode, innerNode) {
	  return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
	}
	function getActiveElementDeep(containerInfo) {
	  containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
	  for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
	    try {
	      var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
	    } catch (err) {
	      JSCompiler_inline_result = false;
	    }
	    if (JSCompiler_inline_result) containerInfo = element.contentWindow;
	    else break;
	    element = getActiveElement(containerInfo.document);
	  }
	  return element;
	}
	function hasSelectionCapabilities(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
	}
	var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false;
	function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
	  var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
	  mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
	    anchorNode: doc.anchorNode,
	    anchorOffset: doc.anchorOffset,
	    focusNode: doc.focusNode,
	    focusOffset: doc.focusOffset
	  }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
	    "onSelect",
	    "select",
	    null,
	    nativeEvent,
	    nativeEventTarget
	  ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
	}
	function makePrefixMap(styleProp, eventName) {
	  var prefixes = {};
	  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	  prefixes["Webkit" + styleProp] = "webkit" + eventName;
	  prefixes["Moz" + styleProp] = "moz" + eventName;
	  return prefixes;
	}
	var vendorPrefixes = {
	  animationend: makePrefixMap("Animation", "AnimationEnd"),
	  animationiteration: makePrefixMap("Animation", "AnimationIteration"),
	  animationstart: makePrefixMap("Animation", "AnimationStart"),
	  transitionrun: makePrefixMap("Transition", "TransitionRun"),
	  transitionstart: makePrefixMap("Transition", "TransitionStart"),
	  transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
	  transitionend: makePrefixMap("Transition", "TransitionEnd")
	}, prefixedEventNames = {}, style = {};
	canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
	function getVendorPrefixedEventName(eventName) {
	  if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
	  if (!vendorPrefixes[eventName]) return eventName;
	  var prefixMap = vendorPrefixes[eventName], styleProp;
	  for (styleProp in prefixMap)
	    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
	      return prefixedEventNames[eventName] = prefixMap[styleProp];
	  return eventName;
	}
	var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
	  " "
	);
	simpleEventPluginEvents.push("scrollEnd");
	function registerSimpleEvent(domEventName, reactName) {
	  topLevelEventsToReactNames.set(domEventName, reactName);
	  registerTwoPhaseEvent(reactName, [domEventName]);
	}
	var CapturedStacks = /* @__PURE__ */ new WeakMap();
	function createCapturedValueAtFiber(value, source) {
	  if ("object" === typeof value && null !== value) {
	    var existing = CapturedStacks.get(value);
	    if (void 0 !== existing) return existing;
	    source = {
	      value,
	      source,
	      stack: getStackByFiberInDevAndProd(source)
	    };
	    CapturedStacks.set(value, source);
	    return source;
	  }
	  return {
	    value,
	    source,
	    stack: getStackByFiberInDevAndProd(source)
	  };
	}
	var concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0;
	function finishQueueingConcurrentUpdates() {
	  for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
	    var fiber = concurrentQueues[i];
	    concurrentQueues[i++] = null;
	    var queue = concurrentQueues[i];
	    concurrentQueues[i++] = null;
	    var update = concurrentQueues[i];
	    concurrentQueues[i++] = null;
	    var lane = concurrentQueues[i];
	    concurrentQueues[i++] = null;
	    if (null !== queue && null !== update) {
	      var pending = queue.pending;
	      null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
	      queue.pending = update;
	    }
	    0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
	  }
	}
	function enqueueUpdate$1(fiber, queue, update, lane) {
	  concurrentQueues[concurrentQueuesIndex++] = fiber;
	  concurrentQueues[concurrentQueuesIndex++] = queue;
	  concurrentQueues[concurrentQueuesIndex++] = update;
	  concurrentQueues[concurrentQueuesIndex++] = lane;
	  concurrentlyUpdatedLanes |= lane;
	  fiber.lanes |= lane;
	  fiber = fiber.alternate;
	  null !== fiber && (fiber.lanes |= lane);
	}
	function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
	  enqueueUpdate$1(fiber, queue, update, lane);
	  return getRootForUpdatedFiber(fiber);
	}
	function enqueueConcurrentRenderForLane(fiber, lane) {
	  enqueueUpdate$1(fiber, null, null, lane);
	  return getRootForUpdatedFiber(fiber);
	}
	function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
	  sourceFiber.lanes |= lane;
	  var alternate = sourceFiber.alternate;
	  null !== alternate && (alternate.lanes |= lane);
	  for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
	    parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
	  return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
	}
	function getRootForUpdatedFiber(sourceFiber) {
	  if (50 < nestedUpdateCount)
	    throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
	  for (var parent = sourceFiber.return; null !== parent; )
	    sourceFiber = parent, parent = sourceFiber.return;
	  return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
	}
	var emptyContextObject = {};
	function FiberNode(tag, pendingProps, key, mode) {
	  this.tag = tag;
	  this.key = key;
	  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
	  this.index = 0;
	  this.refCleanup = this.ref = null;
	  this.pendingProps = pendingProps;
	  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
	  this.mode = mode;
	  this.subtreeFlags = this.flags = 0;
	  this.deletions = null;
	  this.childLanes = this.lanes = 0;
	  this.alternate = null;
	}
	function createFiberImplClass(tag, pendingProps, key, mode) {
	  return new FiberNode(tag, pendingProps, key, mode);
	}
	function shouldConstruct(Component) {
	  Component = Component.prototype;
	  return !(!Component || !Component.isReactComponent);
	}
	function createWorkInProgress(current, pendingProps) {
	  var workInProgress2 = current.alternate;
	  null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
	    current.tag,
	    pendingProps,
	    current.key,
	    current.mode
	  ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
	  workInProgress2.flags = current.flags & 65011712;
	  workInProgress2.childLanes = current.childLanes;
	  workInProgress2.lanes = current.lanes;
	  workInProgress2.child = current.child;
	  workInProgress2.memoizedProps = current.memoizedProps;
	  workInProgress2.memoizedState = current.memoizedState;
	  workInProgress2.updateQueue = current.updateQueue;
	  pendingProps = current.dependencies;
	  workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
	  workInProgress2.sibling = current.sibling;
	  workInProgress2.index = current.index;
	  workInProgress2.ref = current.ref;
	  workInProgress2.refCleanup = current.refCleanup;
	  return workInProgress2;
	}
	function resetWorkInProgress(workInProgress2, renderLanes2) {
	  workInProgress2.flags &= 65011714;
	  var current = workInProgress2.alternate;
	  null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
	    lanes: renderLanes2.lanes,
	    firstContext: renderLanes2.firstContext
	  });
	  return workInProgress2;
	}
	function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
	  var fiberTag = 0;
	  owner = type;
	  if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
	  else if ("string" === typeof type)
	    fiberTag = isHostHoistableType(
	      type,
	      pendingProps,
	      contextStackCursor.current
	    ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
	  else
	    a: switch (type) {
	      case REACT_ACTIVITY_TYPE:
	        return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
	      case REACT_FRAGMENT_TYPE:
	        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
	      case REACT_STRICT_MODE_TYPE:
	        fiberTag = 8;
	        mode |= 24;
	        break;
	      case REACT_PROFILER_TYPE:
	        return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
	      case REACT_SUSPENSE_TYPE:
	        return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
	      case REACT_SUSPENSE_LIST_TYPE:
	        return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
	      default:
	        if ("object" === typeof type && null !== type)
	          switch (type.$$typeof) {
	            case REACT_PROVIDER_TYPE:
	            case REACT_CONTEXT_TYPE:
	              fiberTag = 10;
	              break a;
	            case REACT_CONSUMER_TYPE:
	              fiberTag = 9;
	              break a;
	            case REACT_FORWARD_REF_TYPE:
	              fiberTag = 11;
	              break a;
	            case REACT_MEMO_TYPE:
	              fiberTag = 14;
	              break a;
	            case REACT_LAZY_TYPE:
	              fiberTag = 16;
	              owner = null;
	              break a;
	          }
	        fiberTag = 29;
	        pendingProps = Error(
	          formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
	        );
	        owner = null;
	    }
	  key = createFiberImplClass(fiberTag, pendingProps, key, mode);
	  key.elementType = type;
	  key.type = owner;
	  key.lanes = lanes;
	  return key;
	}
	function createFiberFromFragment(elements, mode, lanes, key) {
	  elements = createFiberImplClass(7, elements, key, mode);
	  elements.lanes = lanes;
	  return elements;
	}
	function createFiberFromText(content, mode, lanes) {
	  content = createFiberImplClass(6, content, null, mode);
	  content.lanes = lanes;
	  return content;
	}
	function createFiberFromPortal(portal, mode, lanes) {
	  mode = createFiberImplClass(
	    4,
	    null !== portal.children ? portal.children : [],
	    portal.key,
	    mode
	  );
	  mode.lanes = lanes;
	  mode.stateNode = {
	    containerInfo: portal.containerInfo,
	    pendingChildren: null,
	    implementation: portal.implementation
	  };
	  return mode;
	}
	var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
	function pushTreeFork(workInProgress2, totalChildren) {
	  forkStack[forkStackIndex++] = treeForkCount;
	  forkStack[forkStackIndex++] = treeForkProvider;
	  treeForkProvider = workInProgress2;
	  treeForkCount = totalChildren;
	}
	function pushTreeId(workInProgress2, totalChildren, index2) {
	  idStack[idStackIndex++] = treeContextId;
	  idStack[idStackIndex++] = treeContextOverflow;
	  idStack[idStackIndex++] = treeContextProvider;
	  treeContextProvider = workInProgress2;
	  var baseIdWithLeadingBit = treeContextId;
	  workInProgress2 = treeContextOverflow;
	  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
	  baseIdWithLeadingBit &= ~(1 << baseLength);
	  index2 += 1;
	  var length = 32 - clz32(totalChildren) + baseLength;
	  if (30 < length) {
	    var numberOfOverflowBits = baseLength - baseLength % 5;
	    length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
	    baseIdWithLeadingBit >>= numberOfOverflowBits;
	    baseLength -= numberOfOverflowBits;
	    treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit;
	    treeContextOverflow = length + workInProgress2;
	  } else
	    treeContextId = 1 << length | index2 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
	}
	function pushMaterializedTreeId(workInProgress2) {
	  null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
	}
	function popTreeContext(workInProgress2) {
	  for (; workInProgress2 === treeForkProvider; )
	    treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
	  for (; workInProgress2 === treeContextProvider; )
	    treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
	}
	var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(formatProdErrorMessage(519));
	function throwOnHydrationMismatch(fiber) {
	  var error = Error(formatProdErrorMessage(418, ""));
	  queueHydrationError(createCapturedValueAtFiber(error, fiber));
	  throw HydrationMismatchException;
	}
	function prepareToHydrateHostInstance(fiber) {
	  var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
	  instance[internalInstanceKey] = fiber;
	  instance[internalPropsKey] = props;
	  switch (type) {
	    case "dialog":
	      listenToNonDelegatedEvent("cancel", instance);
	      listenToNonDelegatedEvent("close", instance);
	      break;
	    case "iframe":
	    case "object":
	    case "embed":
	      listenToNonDelegatedEvent("load", instance);
	      break;
	    case "video":
	    case "audio":
	      for (type = 0; type < mediaEventTypes.length; type++)
	        listenToNonDelegatedEvent(mediaEventTypes[type], instance);
	      break;
	    case "source":
	      listenToNonDelegatedEvent("error", instance);
	      break;
	    case "img":
	    case "image":
	    case "link":
	      listenToNonDelegatedEvent("error", instance);
	      listenToNonDelegatedEvent("load", instance);
	      break;
	    case "details":
	      listenToNonDelegatedEvent("toggle", instance);
	      break;
	    case "input":
	      listenToNonDelegatedEvent("invalid", instance);
	      initInput(
	        instance,
	        props.value,
	        props.defaultValue,
	        props.checked,
	        props.defaultChecked,
	        props.type,
	        props.name,
	        true
	      );
	      track(instance);
	      break;
	    case "select":
	      listenToNonDelegatedEvent("invalid", instance);
	      break;
	    case "textarea":
	      listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children), track(instance);
	  }
	  type = props.children;
	  "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), instance = true) : instance = false;
	  instance || throwOnHydrationMismatch(fiber);
	}
	function popToNextHostParent(fiber) {
	  for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
	    switch (hydrationParentFiber.tag) {
	      case 5:
	      case 13:
	        rootOrSingletonContext = false;
	        return;
	      case 27:
	      case 3:
	        rootOrSingletonContext = true;
	        return;
	      default:
	        hydrationParentFiber = hydrationParentFiber.return;
	    }
	}
	function popHydrationState(fiber) {
	  if (fiber !== hydrationParentFiber) return false;
	  if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
	  var tag = fiber.tag, JSCompiler_temp;
	  if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
	    if (JSCompiler_temp = 5 === tag)
	      JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
	    JSCompiler_temp = !JSCompiler_temp;
	  }
	  JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
	  popToNextHostParent(fiber);
	  if (13 === tag) {
	    fiber = fiber.memoizedState;
	    fiber = null !== fiber ? fiber.dehydrated : null;
	    if (!fiber) throw Error(formatProdErrorMessage(317));
	    a: {
	      fiber = fiber.nextSibling;
	      for (tag = 0; fiber; ) {
	        if (8 === fiber.nodeType)
	          if (JSCompiler_temp = fiber.data, "/$" === JSCompiler_temp) {
	            if (0 === tag) {
	              nextHydratableInstance = getNextHydratable(fiber.nextSibling);
	              break a;
	            }
	            tag--;
	          } else
	            "$" !== JSCompiler_temp && "$!" !== JSCompiler_temp && "$?" !== JSCompiler_temp || tag++;
	        fiber = fiber.nextSibling;
	      }
	      nextHydratableInstance = null;
	    }
	  } else
	    27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
	  return true;
	}
	function resetHydrationState() {
	  nextHydratableInstance = hydrationParentFiber = null;
	  isHydrating = false;
	}
	function upgradeHydrationErrorsToRecoverable() {
	  var queuedErrors = hydrationErrors;
	  null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
	    workInProgressRootRecoverableErrors,
	    queuedErrors
	  ), hydrationErrors = null);
	  return queuedErrors;
	}
	function queueHydrationError(error) {
	  null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
	}
	var valueCursor = createCursor(null), currentlyRenderingFiber$1 = null, lastContextDependency = null;
	function pushProvider(providerFiber, context, nextValue) {
	  push(valueCursor, context._currentValue);
	  context._currentValue = nextValue;
	}
	function popProvider(context) {
	  context._currentValue = valueCursor.current;
	  pop(valueCursor);
	}
	function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
	  for (; null !== parent; ) {
	    var alternate = parent.alternate;
	    (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
	    if (parent === propagationRoot) break;
	    parent = parent.return;
	  }
	}
	function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
	  var fiber = workInProgress2.child;
	  null !== fiber && (fiber.return = workInProgress2);
	  for (; null !== fiber; ) {
	    var list = fiber.dependencies;
	    if (null !== list) {
	      var nextFiber = fiber.child;
	      list = list.firstContext;
	      a: for (; null !== list; ) {
	        var dependency = list;
	        list = fiber;
	        for (var i = 0; i < contexts.length; i++)
	          if (dependency.context === contexts[i]) {
	            list.lanes |= renderLanes2;
	            dependency = list.alternate;
	            null !== dependency && (dependency.lanes |= renderLanes2);
	            scheduleContextWorkOnParentPath(
	              list.return,
	              renderLanes2,
	              workInProgress2
	            );
	            forcePropagateEntireTree || (nextFiber = null);
	            break a;
	          }
	        list = dependency.next;
	      }
	    } else if (18 === fiber.tag) {
	      nextFiber = fiber.return;
	      if (null === nextFiber) throw Error(formatProdErrorMessage(341));
	      nextFiber.lanes |= renderLanes2;
	      list = nextFiber.alternate;
	      null !== list && (list.lanes |= renderLanes2);
	      scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
	      nextFiber = null;
	    } else nextFiber = fiber.child;
	    if (null !== nextFiber) nextFiber.return = fiber;
	    else
	      for (nextFiber = fiber; null !== nextFiber; ) {
	        if (nextFiber === workInProgress2) {
	          nextFiber = null;
	          break;
	        }
	        fiber = nextFiber.sibling;
	        if (null !== fiber) {
	          fiber.return = nextFiber.return;
	          nextFiber = fiber;
	          break;
	        }
	        nextFiber = nextFiber.return;
	      }
	    fiber = nextFiber;
	  }
	}
	function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
	  current = null;
	  for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
	    if (!isInsidePropagationBailout) {
	      if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
	      else if (0 !== (parent.flags & 262144)) break;
	    }
	    if (10 === parent.tag) {
	      var currentParent = parent.alternate;
	      if (null === currentParent) throw Error(formatProdErrorMessage(387));
	      currentParent = currentParent.memoizedProps;
	      if (null !== currentParent) {
	        var context = parent.type;
	        objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
	      }
	    } else if (parent === hostTransitionProviderCursor.current) {
	      currentParent = parent.alternate;
	      if (null === currentParent) throw Error(formatProdErrorMessage(387));
	      currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
	    }
	    parent = parent.return;
	  }
	  null !== current && propagateContextChanges(
	    workInProgress2,
	    current,
	    renderLanes2,
	    forcePropagateEntireTree
	  );
	  workInProgress2.flags |= 262144;
	}
	function checkIfContextChanged(currentDependencies) {
	  for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
	    if (!objectIs(
	      currentDependencies.context._currentValue,
	      currentDependencies.memoizedValue
	    ))
	      return true;
	    currentDependencies = currentDependencies.next;
	  }
	  return false;
	}
	function prepareToReadContext(workInProgress2) {
	  currentlyRenderingFiber$1 = workInProgress2;
	  lastContextDependency = null;
	  workInProgress2 = workInProgress2.dependencies;
	  null !== workInProgress2 && (workInProgress2.firstContext = null);
	}
	function readContext(context) {
	  return readContextForConsumer(currentlyRenderingFiber$1, context);
	}
	function readContextDuringReconciliation(consumer, context) {
	  null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
	  return readContextForConsumer(consumer, context);
	}
	function readContextForConsumer(consumer, context) {
	  var value = context._currentValue;
	  context = { context, memoizedValue: value, next: null };
	  if (null === lastContextDependency) {
	    if (null === consumer) throw Error(formatProdErrorMessage(308));
	    lastContextDependency = context;
	    consumer.dependencies = { lanes: 0, firstContext: context };
	    consumer.flags |= 524288;
	  } else lastContextDependency = lastContextDependency.next = context;
	  return value;
	}
	var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
	  var listeners = [], signal = this.signal = {
	    aborted: false,
	    addEventListener: function(type, listener) {
	      listeners.push(listener);
	    }
	  };
	  this.abort = function() {
	    signal.aborted = true;
	    listeners.forEach(function(listener) {
	      return listener();
	    });
	  };
	}, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
	  $$typeof: REACT_CONTEXT_TYPE,
	  Consumer: null,
	  Provider: null,
	  _currentValue: null,
	  _currentValue2: null,
	  _threadCount: 0
	};
	function createCache() {
	  return {
	    controller: new AbortControllerLocal(),
	    data: /* @__PURE__ */ new Map(),
	    refCount: 0
	  };
	}
	function releaseCache(cache) {
	  cache.refCount--;
	  0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
	    cache.controller.abort();
	  });
	}
	var currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null;
	function entangleAsyncAction(transition, thenable) {
	  if (null === currentEntangledListeners) {
	    var entangledListeners = currentEntangledListeners = [];
	    currentEntangledPendingCount = 0;
	    currentEntangledLane = requestTransitionLane();
	    currentEntangledActionThenable = {
	      status: "pending",
	      value: void 0,
	      then: function(resolve) {
	        entangledListeners.push(resolve);
	      }
	    };
	  }
	  currentEntangledPendingCount++;
	  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
	  return thenable;
	}
	function pingEngtangledActionScope() {
	  if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
	    null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
	    var listeners = currentEntangledListeners;
	    currentEntangledListeners = null;
	    currentEntangledLane = 0;
	    currentEntangledActionThenable = null;
	    for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
	  }
	}
	function chainThenableValue(thenable, result) {
	  var listeners = [], thenableWithOverride = {
	    status: "pending",
	    value: null,
	    reason: null,
	    then: function(resolve) {
	      listeners.push(resolve);
	    }
	  };
	  thenable.then(
	    function() {
	      thenableWithOverride.status = "fulfilled";
	      thenableWithOverride.value = result;
	      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
	    },
	    function(error) {
	      thenableWithOverride.status = "rejected";
	      thenableWithOverride.reason = error;
	      for (error = 0; error < listeners.length; error++)
	        (0, listeners[error])(void 0);
	    }
	  );
	  return thenableWithOverride;
	}
	var prevOnStartTransitionFinish = ReactSharedInternals.S;
	ReactSharedInternals.S = function(transition, returnValue) {
	  "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
	  null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
	};
	var resumedCache = createCursor(null);
	function peekCacheFromPool() {
	  var cacheResumedFromPreviousRender = resumedCache.current;
	  return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
	}
	function pushTransition(offscreenWorkInProgress, prevCachePool) {
	  null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
	}
	function getSuspendedCache() {
	  var cacheFromPool = peekCacheFromPool();
	  return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
	}
	var SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), SuspenseActionException = Error(formatProdErrorMessage(542)), noopSuspenseyCommitThenable = { then: function() {
	} };
	function isThenableResolved(thenable) {
	  thenable = thenable.status;
	  return "fulfilled" === thenable || "rejected" === thenable;
	}
	function noop$3() {
	}
	function trackUsedThenable(thenableState2, thenable, index2) {
	  index2 = thenableState2[index2];
	  void 0 === index2 ? thenableState2.push(thenable) : index2 !== thenable && (thenable.then(noop$3, noop$3), thenable = index2);
	  switch (thenable.status) {
	    case "fulfilled":
	      return thenable.value;
	    case "rejected":
	      throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
	    default:
	      if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);
	      else {
	        thenableState2 = workInProgressRoot;
	        if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
	          throw Error(formatProdErrorMessage(482));
	        thenableState2 = thenable;
	        thenableState2.status = "pending";
	        thenableState2.then(
	          function(fulfilledValue) {
	            if ("pending" === thenable.status) {
	              var fulfilledThenable = thenable;
	              fulfilledThenable.status = "fulfilled";
	              fulfilledThenable.value = fulfilledValue;
	            }
	          },
	          function(error) {
	            if ("pending" === thenable.status) {
	              var rejectedThenable = thenable;
	              rejectedThenable.status = "rejected";
	              rejectedThenable.reason = error;
	            }
	          }
	        );
	      }
	      switch (thenable.status) {
	        case "fulfilled":
	          return thenable.value;
	        case "rejected":
	          throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
	      }
	      suspendedThenable = thenable;
	      throw SuspenseException;
	  }
	}
	var suspendedThenable = null;
	function getSuspendedThenable() {
	  if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
	  var thenable = suspendedThenable;
	  suspendedThenable = null;
	  return thenable;
	}
	function checkIfUseWrappedInAsyncCatch(rejectedReason) {
	  if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
	    throw Error(formatProdErrorMessage(483));
	}
	var hasForceUpdate = false;
	function initializeUpdateQueue(fiber) {
	  fiber.updateQueue = {
	    baseState: fiber.memoizedState,
	    firstBaseUpdate: null,
	    lastBaseUpdate: null,
	    shared: { pending: null, lanes: 0, hiddenCallbacks: null },
	    callbacks: null
	  };
	}
	function cloneUpdateQueue(current, workInProgress2) {
	  current = current.updateQueue;
	  workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
	    baseState: current.baseState,
	    firstBaseUpdate: current.firstBaseUpdate,
	    lastBaseUpdate: current.lastBaseUpdate,
	    shared: current.shared,
	    callbacks: null
	  });
	}
	function createUpdate(lane) {
	  return { lane, tag: 0, payload: null, callback: null, next: null };
	}
	function enqueueUpdate(fiber, update, lane) {
	  var updateQueue = fiber.updateQueue;
	  if (null === updateQueue) return null;
	  updateQueue = updateQueue.shared;
	  if (0 !== (executionContext & 2)) {
	    var pending = updateQueue.pending;
	    null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
	    updateQueue.pending = update;
	    update = getRootForUpdatedFiber(fiber);
	    markUpdateLaneFromFiberToRoot(fiber, null, lane);
	    return update;
	  }
	  enqueueUpdate$1(fiber, updateQueue, update, lane);
	  return getRootForUpdatedFiber(fiber);
	}
	function entangleTransitions(root2, fiber, lane) {
	  fiber = fiber.updateQueue;
	  if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
	    var queueLanes = fiber.lanes;
	    queueLanes &= root2.pendingLanes;
	    lane |= queueLanes;
	    fiber.lanes = lane;
	    markRootEntangled(root2, lane);
	  }
	}
	function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
	  var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
	  if (null !== current && (current = current.updateQueue, queue === current)) {
	    var newFirst = null, newLast = null;
	    queue = queue.firstBaseUpdate;
	    if (null !== queue) {
	      do {
	        var clone = {
	          lane: queue.lane,
	          tag: queue.tag,
	          payload: queue.payload,
	          callback: null,
	          next: null
	        };
	        null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
	        queue = queue.next;
	      } while (null !== queue);
	      null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
	    } else newFirst = newLast = capturedUpdate;
	    queue = {
	      baseState: current.baseState,
	      firstBaseUpdate: newFirst,
	      lastBaseUpdate: newLast,
	      shared: current.shared,
	      callbacks: current.callbacks
	    };
	    workInProgress2.updateQueue = queue;
	    return;
	  }
	  workInProgress2 = queue.lastBaseUpdate;
	  null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
	  queue.lastBaseUpdate = capturedUpdate;
	}
	var didReadFromEntangledAsyncAction = false;
	function suspendIfUpdateReadFromEntangledAsyncAction() {
	  if (didReadFromEntangledAsyncAction) {
	    var entangledActionThenable = currentEntangledActionThenable;
	    if (null !== entangledActionThenable) throw entangledActionThenable;
	  }
	}
	function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
	  didReadFromEntangledAsyncAction = false;
	  var queue = workInProgress$jscomp$0.updateQueue;
	  hasForceUpdate = false;
	  var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
	  if (null !== pendingQueue) {
	    queue.shared.pending = null;
	    var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
	    lastPendingUpdate.next = null;
	    null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
	    lastBaseUpdate = lastPendingUpdate;
	    var current = workInProgress$jscomp$0.alternate;
	    null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
	  }
	  if (null !== firstBaseUpdate) {
	    var newState = queue.baseState;
	    lastBaseUpdate = 0;
	    current = firstPendingUpdate = lastPendingUpdate = null;
	    pendingQueue = firstBaseUpdate;
	    do {
	      var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
	      if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
	        0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
	        null !== current && (current = current.next = {
	          lane: 0,
	          tag: pendingQueue.tag,
	          payload: pendingQueue.payload,
	          callback: null,
	          next: null
	        });
	        a: {
	          var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
	          updateLane = props;
	          var instance = instance$jscomp$0;
	          switch (update.tag) {
	            case 1:
	              workInProgress2 = update.payload;
	              if ("function" === typeof workInProgress2) {
	                newState = workInProgress2.call(instance, newState, updateLane);
	                break a;
	              }
	              newState = workInProgress2;
	              break a;
	            case 3:
	              workInProgress2.flags = workInProgress2.flags & -65537 | 128;
	            case 0:
	              workInProgress2 = update.payload;
	              updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
	              if (null === updateLane || void 0 === updateLane) break a;
	              newState = assign({}, newState, updateLane);
	              break a;
	            case 2:
	              hasForceUpdate = true;
	          }
	        }
	        updateLane = pendingQueue.callback;
	        null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
	      } else
	        isHiddenUpdate = {
	          lane: updateLane,
	          tag: pendingQueue.tag,
	          payload: pendingQueue.payload,
	          callback: pendingQueue.callback,
	          next: null
	        }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
	      pendingQueue = pendingQueue.next;
	      if (null === pendingQueue)
	        if (pendingQueue = queue.shared.pending, null === pendingQueue)
	          break;
	        else
	          isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
	    } while (1);
	    null === current && (lastPendingUpdate = newState);
	    queue.baseState = lastPendingUpdate;
	    queue.firstBaseUpdate = firstPendingUpdate;
	    queue.lastBaseUpdate = current;
	    null === firstBaseUpdate && (queue.shared.lanes = 0);
	    workInProgressRootSkippedLanes |= lastBaseUpdate;
	    workInProgress$jscomp$0.lanes = lastBaseUpdate;
	    workInProgress$jscomp$0.memoizedState = newState;
	  }
	}
	function callCallback(callback, context) {
	  if ("function" !== typeof callback)
	    throw Error(formatProdErrorMessage(191, callback));
	  callback.call(context);
	}
	function commitCallbacks(updateQueue, context) {
	  var callbacks = updateQueue.callbacks;
	  if (null !== callbacks)
	    for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
	      callCallback(callbacks[updateQueue], context);
	}
	var currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0);
	function pushHiddenContext(fiber, context) {
	  fiber = entangledRenderLanes;
	  push(prevEntangledRenderLanesCursor, fiber);
	  push(currentTreeHiddenStackCursor, context);
	  entangledRenderLanes = fiber | context.baseLanes;
	}
	function reuseHiddenContextOnStack() {
	  push(prevEntangledRenderLanesCursor, entangledRenderLanes);
	  push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
	}
	function popHiddenContext() {
	  entangledRenderLanes = prevEntangledRenderLanesCursor.current;
	  pop(currentTreeHiddenStackCursor);
	  pop(prevEntangledRenderLanesCursor);
	}
	var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter$1 = 0, thenableState$1 = null, globalClientIdCounter = 0;
	function throwInvalidHookError() {
	  throw Error(formatProdErrorMessage(321));
	}
	function areHookInputsEqual(nextDeps, prevDeps) {
	  if (null === prevDeps) return false;
	  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
	    if (!objectIs(nextDeps[i], prevDeps[i])) return false;
	  return true;
	}
	function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
	  renderLanes = nextRenderLanes;
	  currentlyRenderingFiber = workInProgress2;
	  workInProgress2.memoizedState = null;
	  workInProgress2.updateQueue = null;
	  workInProgress2.lanes = 0;
	  ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
	  shouldDoubleInvokeUserFnsInHooksDEV = false;
	  nextRenderLanes = Component(props, secondArg);
	  shouldDoubleInvokeUserFnsInHooksDEV = false;
	  didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
	    workInProgress2,
	    Component,
	    props,
	    secondArg
	  ));
	  finishRenderingHooks(current);
	  return nextRenderLanes;
	}
	function finishRenderingHooks(current) {
	  ReactSharedInternals.H = ContextOnlyDispatcher;
	  var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
	  renderLanes = 0;
	  workInProgressHook = currentHook = currentlyRenderingFiber = null;
	  didScheduleRenderPhaseUpdate = false;
	  thenableIndexCounter$1 = 0;
	  thenableState$1 = null;
	  if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
	  null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
	}
	function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
	  currentlyRenderingFiber = workInProgress2;
	  var numberOfReRenders = 0;
	  do {
	    didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
	    thenableIndexCounter$1 = 0;
	    didScheduleRenderPhaseUpdateDuringThisPass = false;
	    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
	    numberOfReRenders += 1;
	    workInProgressHook = currentHook = null;
	    if (null != workInProgress2.updateQueue) {
	      var children = workInProgress2.updateQueue;
	      children.lastEffect = null;
	      children.events = null;
	      children.stores = null;
	      null != children.memoCache && (children.memoCache.index = 0);
	    }
	    ReactSharedInternals.H = HooksDispatcherOnRerender;
	    children = Component(props, secondArg);
	  } while (didScheduleRenderPhaseUpdateDuringThisPass);
	  return children;
	}
	function TransitionAwareHostComponent() {
	  var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
	  maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
	  dispatcher = dispatcher.useState()[0];
	  (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
	  return maybeThenable;
	}
	function checkDidRenderIdHook() {
	  var didRenderIdHook = 0 !== localIdCounter;
	  localIdCounter = 0;
	  return didRenderIdHook;
	}
	function bailoutHooks(current, workInProgress2, lanes) {
	  workInProgress2.updateQueue = current.updateQueue;
	  workInProgress2.flags &= -2053;
	  current.lanes &= ~lanes;
	}
	function resetHooksOnUnwind(workInProgress2) {
	  if (didScheduleRenderPhaseUpdate) {
	    for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
	      var queue = workInProgress2.queue;
	      null !== queue && (queue.pending = null);
	      workInProgress2 = workInProgress2.next;
	    }
	    didScheduleRenderPhaseUpdate = false;
	  }
	  renderLanes = 0;
	  workInProgressHook = currentHook = currentlyRenderingFiber = null;
	  didScheduleRenderPhaseUpdateDuringThisPass = false;
	  thenableIndexCounter$1 = localIdCounter = 0;
	  thenableState$1 = null;
	}
	function mountWorkInProgressHook() {
	  var hook = {
	    memoizedState: null,
	    baseState: null,
	    baseQueue: null,
	    queue: null,
	    next: null
	  };
	  null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
	  return workInProgressHook;
	}
	function updateWorkInProgressHook() {
	  if (null === currentHook) {
	    var nextCurrentHook = currentlyRenderingFiber.alternate;
	    nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
	  } else nextCurrentHook = currentHook.next;
	  var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
	  if (null !== nextWorkInProgressHook)
	    workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
	  else {
	    if (null === nextCurrentHook) {
	      if (null === currentlyRenderingFiber.alternate)
	        throw Error(formatProdErrorMessage(467));
	      throw Error(formatProdErrorMessage(310));
	    }
	    currentHook = nextCurrentHook;
	    nextCurrentHook = {
	      memoizedState: currentHook.memoizedState,
	      baseState: currentHook.baseState,
	      baseQueue: currentHook.baseQueue,
	      queue: currentHook.queue,
	      next: null
	    };
	    null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
	  }
	  return workInProgressHook;
	}
	function createFunctionComponentUpdateQueue() {
	  return { lastEffect: null, events: null, stores: null, memoCache: null };
	}
	function useThenable(thenable) {
	  var index2 = thenableIndexCounter$1;
	  thenableIndexCounter$1 += 1;
	  null === thenableState$1 && (thenableState$1 = []);
	  thenable = trackUsedThenable(thenableState$1, thenable, index2);
	  index2 = currentlyRenderingFiber;
	  null === (null === workInProgressHook ? index2.memoizedState : workInProgressHook.next) && (index2 = index2.alternate, ReactSharedInternals.H = null === index2 || null === index2.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
	  return thenable;
	}
	function use(usable) {
	  if (null !== usable && "object" === typeof usable) {
	    if ("function" === typeof usable.then) return useThenable(usable);
	    if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
	  }
	  throw Error(formatProdErrorMessage(438, String(usable)));
	}
	function useMemoCache(size) {
	  var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
	  null !== updateQueue && (memoCache = updateQueue.memoCache);
	  if (null == memoCache) {
	    var current = currentlyRenderingFiber.alternate;
	    null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
	      data: current.data.map(function(array) {
	        return array.slice();
	      }),
	      index: 0
	    })));
	  }
	  null == memoCache && (memoCache = { data: [], index: 0 });
	  null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
	  updateQueue.memoCache = memoCache;
	  updateQueue = memoCache.data[memoCache.index];
	  if (void 0 === updateQueue)
	    for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
	      updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
	  memoCache.index++;
	  return updateQueue;
	}
	function basicStateReducer(state, action) {
	  return "function" === typeof action ? action(state) : action;
	}
	function updateReducer(reducer) {
	  var hook = updateWorkInProgressHook();
	  return updateReducerImpl(hook, currentHook, reducer);
	}
	function updateReducerImpl(hook, current, reducer) {
	  var queue = hook.queue;
	  if (null === queue) throw Error(formatProdErrorMessage(311));
	  queue.lastRenderedReducer = reducer;
	  var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
	  if (null !== pendingQueue) {
	    if (null !== baseQueue) {
	      var baseFirst = baseQueue.next;
	      baseQueue.next = pendingQueue.next;
	      pendingQueue.next = baseFirst;
	    }
	    current.baseQueue = baseQueue = pendingQueue;
	    queue.pending = null;
	  }
	  pendingQueue = hook.baseState;
	  if (null === baseQueue) hook.memoizedState = pendingQueue;
	  else {
	    current = baseQueue.next;
	    var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$32 = false;
	    do {
	      var updateLane = update.lane & -536870913;
	      if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
	        var revertLane = update.revertLane;
	        if (0 === revertLane)
	          null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
	            lane: 0,
	            revertLane: 0,
	            action: update.action,
	            hasEagerState: update.hasEagerState,
	            eagerState: update.eagerState,
	            next: null
	          }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
	        else if ((renderLanes & revertLane) === revertLane) {
	          update = update.next;
	          revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
	          continue;
	        } else
	          updateLane = {
	            lane: 0,
	            revertLane: update.revertLane,
	            action: update.action,
	            hasEagerState: update.hasEagerState,
	            eagerState: update.eagerState,
	            next: null
	          }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
	        updateLane = update.action;
	        shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
	        pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
	      } else
	        revertLane = {
	          lane: updateLane,
	          revertLane: update.revertLane,
	          action: update.action,
	          hasEagerState: update.hasEagerState,
	          eagerState: update.eagerState,
	          next: null
	        }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
	      update = update.next;
	    } while (null !== update && update !== current);
	    null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
	    if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$32 && (reducer = currentEntangledActionThenable, null !== reducer)))
	      throw reducer;
	    hook.memoizedState = pendingQueue;
	    hook.baseState = baseFirst;
	    hook.baseQueue = newBaseQueueLast;
	    queue.lastRenderedState = pendingQueue;
	  }
	  null === baseQueue && (queue.lanes = 0);
	  return [hook.memoizedState, queue.dispatch];
	}
	function rerenderReducer(reducer) {
	  var hook = updateWorkInProgressHook(), queue = hook.queue;
	  if (null === queue) throw Error(formatProdErrorMessage(311));
	  queue.lastRenderedReducer = reducer;
	  var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
	  if (null !== lastRenderPhaseUpdate) {
	    queue.pending = null;
	    var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
	    do
	      newState = reducer(newState, update.action), update = update.next;
	    while (update !== lastRenderPhaseUpdate);
	    objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
	    hook.memoizedState = newState;
	    null === hook.baseQueue && (hook.baseState = newState);
	    queue.lastRenderedState = newState;
	  }
	  return [newState, dispatch];
	}
	function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
	  var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
	  if (isHydrating$jscomp$0) {
	    if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
	    getServerSnapshot = getServerSnapshot();
	  } else getServerSnapshot = getSnapshot();
	  var snapshotChanged = !objectIs(
	    (currentHook || hook).memoizedState,
	    getServerSnapshot
	  );
	  snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
	  hook = hook.queue;
	  var create = subscribeToStore.bind(null, fiber, hook, subscribe);
	  updateEffectImpl(2048, 8, create, [subscribe]);
	  if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
	    fiber.flags |= 2048;
	    pushSimpleEffect(
	      9,
	      createEffectInstance(),
	      updateStoreInstance.bind(
	        null,
	        fiber,
	        hook,
	        getServerSnapshot,
	        getSnapshot
	      ),
	      null
	    );
	    if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
	    isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
	  }
	  return getServerSnapshot;
	}
	function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
	  fiber.flags |= 16384;
	  fiber = { getSnapshot, value: renderedSnapshot };
	  getSnapshot = currentlyRenderingFiber.updateQueue;
	  null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
	}
	function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
	  inst.value = nextSnapshot;
	  inst.getSnapshot = getSnapshot;
	  checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
	}
	function subscribeToStore(fiber, inst, subscribe) {
	  return subscribe(function() {
	    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
	  });
	}
	function checkIfSnapshotChanged(inst) {
	  var latestGetSnapshot = inst.getSnapshot;
	  inst = inst.value;
	  try {
	    var nextValue = latestGetSnapshot();
	    return !objectIs(inst, nextValue);
	  } catch (error) {
	    return true;
	  }
	}
	function forceStoreRerender(fiber) {
	  var root2 = enqueueConcurrentRenderForLane(fiber, 2);
	  null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
	}
	function mountStateImpl(initialState) {
	  var hook = mountWorkInProgressHook();
	  if ("function" === typeof initialState) {
	    var initialStateInitializer = initialState;
	    initialState = initialStateInitializer();
	    if (shouldDoubleInvokeUserFnsInHooksDEV) {
	      setIsStrictModeForDevtools(true);
	      try {
	        initialStateInitializer();
	      } finally {
	        setIsStrictModeForDevtools(false);
	      }
	    }
	  }
	  hook.memoizedState = hook.baseState = initialState;
	  hook.queue = {
	    pending: null,
	    lanes: 0,
	    dispatch: null,
	    lastRenderedReducer: basicStateReducer,
	    lastRenderedState: initialState
	  };
	  return hook;
	}
	function updateOptimisticImpl(hook, current, passthrough, reducer) {
	  hook.baseState = passthrough;
	  return updateReducerImpl(
	    hook,
	    currentHook,
	    "function" === typeof reducer ? reducer : basicStateReducer
	  );
	}
	function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
	  if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
	  fiber = actionQueue.action;
	  if (null !== fiber) {
	    var actionNode = {
	      payload,
	      action: fiber,
	      next: null,
	      isTransition: true,
	      status: "pending",
	      value: null,
	      reason: null,
	      listeners: [],
	      then: function(listener) {
	        actionNode.listeners.push(listener);
	      }
	    };
	    null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
	    setState(actionNode);
	    setPendingState = actionQueue.pending;
	    null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
	  }
	}
	function runActionStateAction(actionQueue, node) {
	  var action = node.action, payload = node.payload, prevState = actionQueue.state;
	  if (node.isTransition) {
	    var prevTransition = ReactSharedInternals.T, currentTransition = {};
	    ReactSharedInternals.T = currentTransition;
	    try {
	      var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
	      null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
	      handleActionReturnValue(actionQueue, node, returnValue);
	    } catch (error) {
	      onActionError(actionQueue, node, error);
	    } finally {
	      ReactSharedInternals.T = prevTransition;
	    }
	  } else
	    try {
	      prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
	    } catch (error$38) {
	      onActionError(actionQueue, node, error$38);
	    }
	}
	function handleActionReturnValue(actionQueue, node, returnValue) {
	  null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
	    function(nextState) {
	      onActionSuccess(actionQueue, node, nextState);
	    },
	    function(error) {
	      return onActionError(actionQueue, node, error);
	    }
	  ) : onActionSuccess(actionQueue, node, returnValue);
	}
	function onActionSuccess(actionQueue, actionNode, nextState) {
	  actionNode.status = "fulfilled";
	  actionNode.value = nextState;
	  notifyActionListeners(actionNode);
	  actionQueue.state = nextState;
	  actionNode = actionQueue.pending;
	  null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
	}
	function onActionError(actionQueue, actionNode, error) {
	  var last = actionQueue.pending;
	  actionQueue.pending = null;
	  if (null !== last) {
	    last = last.next;
	    do
	      actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
	    while (actionNode !== last);
	  }
	  actionQueue.action = null;
	}
	function notifyActionListeners(actionNode) {
	  actionNode = actionNode.listeners;
	  for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
	}
	function actionStateReducer(oldState, newState) {
	  return newState;
	}
	function mountActionState(action, initialStateProp) {
	  if (isHydrating) {
	    var ssrFormState = workInProgressRoot.formState;
	    if (null !== ssrFormState) {
	      a: {
	        var JSCompiler_inline_result = currentlyRenderingFiber;
	        if (isHydrating) {
	          if (nextHydratableInstance) {
	            b: {
	              var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
	              for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
	                if (!inRootOrSingleton) {
	                  JSCompiler_inline_result$jscomp$0 = null;
	                  break b;
	                }
	                JSCompiler_inline_result$jscomp$0 = getNextHydratable(
	                  JSCompiler_inline_result$jscomp$0.nextSibling
	                );
	                if (null === JSCompiler_inline_result$jscomp$0) {
	                  JSCompiler_inline_result$jscomp$0 = null;
	                  break b;
	                }
	              }
	              inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
	              JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
	            }
	            if (JSCompiler_inline_result$jscomp$0) {
	              nextHydratableInstance = getNextHydratable(
	                JSCompiler_inline_result$jscomp$0.nextSibling
	              );
	              JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
	              break a;
	            }
	          }
	          throwOnHydrationMismatch(JSCompiler_inline_result);
	        }
	        JSCompiler_inline_result = false;
	      }
	      JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
	    }
	  }
	  ssrFormState = mountWorkInProgressHook();
	  ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
	  JSCompiler_inline_result = {
	    pending: null,
	    lanes: 0,
	    dispatch: null,
	    lastRenderedReducer: actionStateReducer,
	    lastRenderedState: initialStateProp
	  };
	  ssrFormState.queue = JSCompiler_inline_result;
	  ssrFormState = dispatchSetState.bind(
	    null,
	    currentlyRenderingFiber,
	    JSCompiler_inline_result
	  );
	  JSCompiler_inline_result.dispatch = ssrFormState;
	  JSCompiler_inline_result = mountStateImpl(false);
	  inRootOrSingleton = dispatchOptimisticSetState.bind(
	    null,
	    currentlyRenderingFiber,
	    false,
	    JSCompiler_inline_result.queue
	  );
	  JSCompiler_inline_result = mountWorkInProgressHook();
	  JSCompiler_inline_result$jscomp$0 = {
	    state: initialStateProp,
	    dispatch: null,
	    action,
	    pending: null
	  };
	  JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
	  ssrFormState = dispatchActionState.bind(
	    null,
	    currentlyRenderingFiber,
	    JSCompiler_inline_result$jscomp$0,
	    inRootOrSingleton,
	    ssrFormState
	  );
	  JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
	  JSCompiler_inline_result.memoizedState = action;
	  return [initialStateProp, ssrFormState, false];
	}
	function updateActionState(action) {
	  var stateHook = updateWorkInProgressHook();
	  return updateActionStateImpl(stateHook, currentHook, action);
	}
	function updateActionStateImpl(stateHook, currentStateHook, action) {
	  currentStateHook = updateReducerImpl(
	    stateHook,
	    currentStateHook,
	    actionStateReducer
	  )[0];
	  stateHook = updateReducer(basicStateReducer)[0];
	  if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
	    try {
	      var state = useThenable(currentStateHook);
	    } catch (x) {
	      if (x === SuspenseException) throw SuspenseActionException;
	      throw x;
	    }
	  else state = currentStateHook;
	  currentStateHook = updateWorkInProgressHook();
	  var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
	  action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
	    9,
	    createEffectInstance(),
	    actionStateActionEffect.bind(null, actionQueue, action),
	    null
	  ));
	  return [state, dispatch, stateHook];
	}
	function actionStateActionEffect(actionQueue, action) {
	  actionQueue.action = action;
	}
	function rerenderActionState(action) {
	  var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
	  if (null !== currentStateHook)
	    return updateActionStateImpl(stateHook, currentStateHook, action);
	  updateWorkInProgressHook();
	  stateHook = stateHook.memoizedState;
	  currentStateHook = updateWorkInProgressHook();
	  var dispatch = currentStateHook.queue.dispatch;
	  currentStateHook.memoizedState = action;
	  return [stateHook, dispatch, false];
	}
	function pushSimpleEffect(tag, inst, create, createDeps) {
	  tag = { tag, create, deps: createDeps, inst, next: null };
	  inst = currentlyRenderingFiber.updateQueue;
	  null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
	  create = inst.lastEffect;
	  null === create ? inst.lastEffect = tag.next = tag : (createDeps = create.next, create.next = tag, tag.next = createDeps, inst.lastEffect = tag);
	  return tag;
	}
	function createEffectInstance() {
	  return { destroy: void 0, resource: void 0 };
	}
	function updateRef() {
	  return updateWorkInProgressHook().memoizedState;
	}
	function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
	  var hook = mountWorkInProgressHook();
	  createDeps = void 0 === createDeps ? null : createDeps;
	  currentlyRenderingFiber.flags |= fiberFlags;
	  hook.memoizedState = pushSimpleEffect(
	    1 | hookFlags,
	    createEffectInstance(),
	    create,
	    createDeps
	  );
	}
	function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
	  var hook = updateWorkInProgressHook();
	  deps = void 0 === deps ? null : deps;
	  var inst = hook.memoizedState.inst;
	  null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
	    1 | hookFlags,
	    inst,
	    create,
	    deps
	  ));
	}
	function mountEffect(create, createDeps) {
	  mountEffectImpl(8390656, 8, create, createDeps);
	}
	function updateEffect(create, createDeps) {
	  updateEffectImpl(2048, 8, create, createDeps);
	}
	function updateInsertionEffect(create, deps) {
	  return updateEffectImpl(4, 2, create, deps);
	}
	function updateLayoutEffect(create, deps) {
	  return updateEffectImpl(4, 4, create, deps);
	}
	function imperativeHandleEffect(create, ref) {
	  if ("function" === typeof ref) {
	    create = create();
	    var refCleanup = ref(create);
	    return function() {
	      "function" === typeof refCleanup ? refCleanup() : ref(null);
	    };
	  }
	  if (null !== ref && void 0 !== ref)
	    return create = create(), ref.current = create, function() {
	      ref.current = null;
	    };
	}
	function updateImperativeHandle(ref, create, deps) {
	  deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
	  updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
	}
	function mountDebugValue() {
	}
	function updateCallback(callback, deps) {
	  var hook = updateWorkInProgressHook();
	  deps = void 0 === deps ? null : deps;
	  var prevState = hook.memoizedState;
	  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
	    return prevState[0];
	  hook.memoizedState = [callback, deps];
	  return callback;
	}
	function updateMemo(nextCreate, deps) {
	  var hook = updateWorkInProgressHook();
	  deps = void 0 === deps ? null : deps;
	  var prevState = hook.memoizedState;
	  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
	    return prevState[0];
	  prevState = nextCreate();
	  if (shouldDoubleInvokeUserFnsInHooksDEV) {
	    setIsStrictModeForDevtools(true);
	    try {
	      nextCreate();
	    } finally {
	      setIsStrictModeForDevtools(false);
	    }
	  }
	  hook.memoizedState = [prevState, deps];
	  return prevState;
	}
	function mountDeferredValueImpl(hook, value, initialValue) {
	  if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
	    return hook.memoizedState = value;
	  hook.memoizedState = initialValue;
	  hook = requestDeferredLane();
	  currentlyRenderingFiber.lanes |= hook;
	  workInProgressRootSkippedLanes |= hook;
	  return initialValue;
	}
	function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
	  if (objectIs(value, prevValue)) return value;
	  if (null !== currentTreeHiddenStackCursor.current)
	    return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
	  if (0 === (renderLanes & 42))
	    return didReceiveUpdate = true, hook.memoizedState = value;
	  hook = requestDeferredLane();
	  currentlyRenderingFiber.lanes |= hook;
	  workInProgressRootSkippedLanes |= hook;
	  return prevValue;
	}
	function startTransition(fiber, queue, pendingState, finishedState, callback) {
	  var previousPriority = ReactDOMSharedInternals.p;
	  ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
	  var prevTransition = ReactSharedInternals.T, currentTransition = {};
	  ReactSharedInternals.T = currentTransition;
	  dispatchOptimisticSetState(fiber, false, queue, pendingState);
	  try {
	    var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
	    null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
	    if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
	      var thenableForFinishedState = chainThenableValue(
	        returnValue,
	        finishedState
	      );
	      dispatchSetStateInternal(
	        fiber,
	        queue,
	        thenableForFinishedState,
	        requestUpdateLane(fiber)
	      );
	    } else
	      dispatchSetStateInternal(
	        fiber,
	        queue,
	        finishedState,
	        requestUpdateLane(fiber)
	      );
	  } catch (error) {
	    dispatchSetStateInternal(
	      fiber,
	      queue,
	      { then: function() {
	      }, status: "rejected", reason: error },
	      requestUpdateLane()
	    );
	  } finally {
	    ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
	  }
	}
	function noop$2() {
	}
	function startHostTransition(formFiber, pendingState, action, formData) {
	  if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
	  var queue = ensureFormComponentIsStateful(formFiber).queue;
	  startTransition(
	    formFiber,
	    queue,
	    pendingState,
	    sharedNotPendingObject,
	    null === action ? noop$2 : function() {
	      requestFormReset$1(formFiber);
	      return action(formData);
	    }
	  );
	}
	function ensureFormComponentIsStateful(formFiber) {
	  var existingStateHook = formFiber.memoizedState;
	  if (null !== existingStateHook) return existingStateHook;
	  existingStateHook = {
	    memoizedState: sharedNotPendingObject,
	    baseState: sharedNotPendingObject,
	    baseQueue: null,
	    queue: {
	      pending: null,
	      lanes: 0,
	      dispatch: null,
	      lastRenderedReducer: basicStateReducer,
	      lastRenderedState: sharedNotPendingObject
	    },
	    next: null
	  };
	  var initialResetState = {};
	  existingStateHook.next = {
	    memoizedState: initialResetState,
	    baseState: initialResetState,
	    baseQueue: null,
	    queue: {
	      pending: null,
	      lanes: 0,
	      dispatch: null,
	      lastRenderedReducer: basicStateReducer,
	      lastRenderedState: initialResetState
	    },
	    next: null
	  };
	  formFiber.memoizedState = existingStateHook;
	  formFiber = formFiber.alternate;
	  null !== formFiber && (formFiber.memoizedState = existingStateHook);
	  return existingStateHook;
	}
	function requestFormReset$1(formFiber) {
	  var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
	  dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
	}
	function useHostTransitionStatus() {
	  return readContext(HostTransitionContext);
	}
	function updateId() {
	  return updateWorkInProgressHook().memoizedState;
	}
	function updateRefresh() {
	  return updateWorkInProgressHook().memoizedState;
	}
	function refreshCache(fiber) {
	  for (var provider = fiber.return; null !== provider; ) {
	    switch (provider.tag) {
	      case 24:
	      case 3:
	        var lane = requestUpdateLane();
	        fiber = createUpdate(lane);
	        var root$41 = enqueueUpdate(provider, fiber, lane);
	        null !== root$41 && (scheduleUpdateOnFiber(root$41, provider, lane), entangleTransitions(root$41, provider, lane));
	        provider = { cache: createCache() };
	        fiber.payload = provider;
	        return;
	    }
	    provider = provider.return;
	  }
	}
	function dispatchReducerAction(fiber, queue, action) {
	  var lane = requestUpdateLane();
	  action = {
	    lane,
	    revertLane: 0,
	    action,
	    hasEagerState: false,
	    eagerState: null,
	    next: null
	  };
	  isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
	}
	function dispatchSetState(fiber, queue, action) {
	  var lane = requestUpdateLane();
	  dispatchSetStateInternal(fiber, queue, action, lane);
	}
	function dispatchSetStateInternal(fiber, queue, action, lane) {
	  var update = {
	    lane,
	    revertLane: 0,
	    action,
	    hasEagerState: false,
	    eagerState: null,
	    next: null
	  };
	  if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
	  else {
	    var alternate = fiber.alternate;
	    if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
	      try {
	        var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
	        update.hasEagerState = true;
	        update.eagerState = eagerState;
	        if (objectIs(eagerState, currentState))
	          return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
	      } catch (error) {
	      } finally {
	      }
	    action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
	    if (null !== action)
	      return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
	  }
	  return false;
	}
	function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
	  action = {
	    lane: 2,
	    revertLane: requestTransitionLane(),
	    action,
	    hasEagerState: false,
	    eagerState: null,
	    next: null
	  };
	  if (isRenderPhaseUpdate(fiber)) {
	    if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
	  } else
	    throwIfDuringRender = enqueueConcurrentHookUpdate(
	      fiber,
	      queue,
	      action,
	      2
	    ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
	}
	function isRenderPhaseUpdate(fiber) {
	  var alternate = fiber.alternate;
	  return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
	}
	function enqueueRenderPhaseUpdate(queue, update) {
	  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
	  var pending = queue.pending;
	  null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
	  queue.pending = update;
	}
	function entangleTransitionUpdate(root2, queue, lane) {
	  if (0 !== (lane & 4194048)) {
	    var queueLanes = queue.lanes;
	    queueLanes &= root2.pendingLanes;
	    lane |= queueLanes;
	    queue.lanes = lane;
	    markRootEntangled(root2, lane);
	  }
	}
	var ContextOnlyDispatcher = {
	  readContext,
	  use,
	  useCallback: throwInvalidHookError,
	  useContext: throwInvalidHookError,
	  useEffect: throwInvalidHookError,
	  useImperativeHandle: throwInvalidHookError,
	  useLayoutEffect: throwInvalidHookError,
	  useInsertionEffect: throwInvalidHookError,
	  useMemo: throwInvalidHookError,
	  useReducer: throwInvalidHookError,
	  useRef: throwInvalidHookError,
	  useState: throwInvalidHookError,
	  useDebugValue: throwInvalidHookError,
	  useDeferredValue: throwInvalidHookError,
	  useTransition: throwInvalidHookError,
	  useSyncExternalStore: throwInvalidHookError,
	  useId: throwInvalidHookError,
	  useHostTransitionStatus: throwInvalidHookError,
	  useFormState: throwInvalidHookError,
	  useActionState: throwInvalidHookError,
	  useOptimistic: throwInvalidHookError,
	  useMemoCache: throwInvalidHookError,
	  useCacheRefresh: throwInvalidHookError
	}, HooksDispatcherOnMount = {
	  readContext,
	  use,
	  useCallback: function(callback, deps) {
	    mountWorkInProgressHook().memoizedState = [
	      callback,
	      void 0 === deps ? null : deps
	    ];
	    return callback;
	  },
	  useContext: readContext,
	  useEffect: mountEffect,
	  useImperativeHandle: function(ref, create, deps) {
	    deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
	    mountEffectImpl(
	      4194308,
	      4,
	      imperativeHandleEffect.bind(null, create, ref),
	      deps
	    );
	  },
	  useLayoutEffect: function(create, deps) {
	    return mountEffectImpl(4194308, 4, create, deps);
	  },
	  useInsertionEffect: function(create, deps) {
	    mountEffectImpl(4, 2, create, deps);
	  },
	  useMemo: function(nextCreate, deps) {
	    var hook = mountWorkInProgressHook();
	    deps = void 0 === deps ? null : deps;
	    var nextValue = nextCreate();
	    if (shouldDoubleInvokeUserFnsInHooksDEV) {
	      setIsStrictModeForDevtools(true);
	      try {
	        nextCreate();
	      } finally {
	        setIsStrictModeForDevtools(false);
	      }
	    }
	    hook.memoizedState = [nextValue, deps];
	    return nextValue;
	  },
	  useReducer: function(reducer, initialArg, init) {
	    var hook = mountWorkInProgressHook();
	    if (void 0 !== init) {
	      var initialState = init(initialArg);
	      if (shouldDoubleInvokeUserFnsInHooksDEV) {
	        setIsStrictModeForDevtools(true);
	        try {
	          init(initialArg);
	        } finally {
	          setIsStrictModeForDevtools(false);
	        }
	      }
	    } else initialState = initialArg;
	    hook.memoizedState = hook.baseState = initialState;
	    reducer = {
	      pending: null,
	      lanes: 0,
	      dispatch: null,
	      lastRenderedReducer: reducer,
	      lastRenderedState: initialState
	    };
	    hook.queue = reducer;
	    reducer = reducer.dispatch = dispatchReducerAction.bind(
	      null,
	      currentlyRenderingFiber,
	      reducer
	    );
	    return [hook.memoizedState, reducer];
	  },
	  useRef: function(initialValue) {
	    var hook = mountWorkInProgressHook();
	    initialValue = { current: initialValue };
	    return hook.memoizedState = initialValue;
	  },
	  useState: function(initialState) {
	    initialState = mountStateImpl(initialState);
	    var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
	    queue.dispatch = dispatch;
	    return [initialState.memoizedState, dispatch];
	  },
	  useDebugValue: mountDebugValue,
	  useDeferredValue: function(value, initialValue) {
	    var hook = mountWorkInProgressHook();
	    return mountDeferredValueImpl(hook, value, initialValue);
	  },
	  useTransition: function() {
	    var stateHook = mountStateImpl(false);
	    stateHook = startTransition.bind(
	      null,
	      currentlyRenderingFiber,
	      stateHook.queue,
	      true,
	      false
	    );
	    mountWorkInProgressHook().memoizedState = stateHook;
	    return [false, stateHook];
	  },
	  useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
	    var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
	    if (isHydrating) {
	      if (void 0 === getServerSnapshot)
	        throw Error(formatProdErrorMessage(407));
	      getServerSnapshot = getServerSnapshot();
	    } else {
	      getServerSnapshot = getSnapshot();
	      if (null === workInProgressRoot)
	        throw Error(formatProdErrorMessage(349));
	      0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
	    }
	    hook.memoizedState = getServerSnapshot;
	    var inst = { value: getServerSnapshot, getSnapshot };
	    hook.queue = inst;
	    mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
	      subscribe
	    ]);
	    fiber.flags |= 2048;
	    pushSimpleEffect(
	      9,
	      createEffectInstance(),
	      updateStoreInstance.bind(
	        null,
	        fiber,
	        inst,
	        getServerSnapshot,
	        getSnapshot
	      ),
	      null
	    );
	    return getServerSnapshot;
	  },
	  useId: function() {
	    var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
	    if (isHydrating) {
	      var JSCompiler_inline_result = treeContextOverflow;
	      var idWithLeadingBit = treeContextId;
	      JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
	      identifierPrefix = "" + identifierPrefix + "R" + JSCompiler_inline_result;
	      JSCompiler_inline_result = localIdCounter++;
	      0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
	      identifierPrefix += "";
	    } else
	      JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "" + identifierPrefix + "r" + JSCompiler_inline_result.toString(32) + "";
	    return hook.memoizedState = identifierPrefix;
	  },
	  useHostTransitionStatus,
	  useFormState: mountActionState,
	  useActionState: mountActionState,
	  useOptimistic: function(passthrough) {
	    var hook = mountWorkInProgressHook();
	    hook.memoizedState = hook.baseState = passthrough;
	    var queue = {
	      pending: null,
	      lanes: 0,
	      dispatch: null,
	      lastRenderedReducer: null,
	      lastRenderedState: null
	    };
	    hook.queue = queue;
	    hook = dispatchOptimisticSetState.bind(
	      null,
	      currentlyRenderingFiber,
	      true,
	      queue
	    );
	    queue.dispatch = hook;
	    return [passthrough, hook];
	  },
	  useMemoCache,
	  useCacheRefresh: function() {
	    return mountWorkInProgressHook().memoizedState = refreshCache.bind(
	      null,
	      currentlyRenderingFiber
	    );
	  }
	}, HooksDispatcherOnUpdate = {
	  readContext,
	  use,
	  useCallback: updateCallback,
	  useContext: readContext,
	  useEffect: updateEffect,
	  useImperativeHandle: updateImperativeHandle,
	  useInsertionEffect: updateInsertionEffect,
	  useLayoutEffect: updateLayoutEffect,
	  useMemo: updateMemo,
	  useReducer: updateReducer,
	  useRef: updateRef,
	  useState: function() {
	    return updateReducer(basicStateReducer);
	  },
	  useDebugValue: mountDebugValue,
	  useDeferredValue: function(value, initialValue) {
	    var hook = updateWorkInProgressHook();
	    return updateDeferredValueImpl(
	      hook,
	      currentHook.memoizedState,
	      value,
	      initialValue
	    );
	  },
	  useTransition: function() {
	    var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
	    return [
	      "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
	      start
	    ];
	  },
	  useSyncExternalStore: updateSyncExternalStore,
	  useId: updateId,
	  useHostTransitionStatus,
	  useFormState: updateActionState,
	  useActionState: updateActionState,
	  useOptimistic: function(passthrough, reducer) {
	    var hook = updateWorkInProgressHook();
	    return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
	  },
	  useMemoCache,
	  useCacheRefresh: updateRefresh
	}, HooksDispatcherOnRerender = {
	  readContext,
	  use,
	  useCallback: updateCallback,
	  useContext: readContext,
	  useEffect: updateEffect,
	  useImperativeHandle: updateImperativeHandle,
	  useInsertionEffect: updateInsertionEffect,
	  useLayoutEffect: updateLayoutEffect,
	  useMemo: updateMemo,
	  useReducer: rerenderReducer,
	  useRef: updateRef,
	  useState: function() {
	    return rerenderReducer(basicStateReducer);
	  },
	  useDebugValue: mountDebugValue,
	  useDeferredValue: function(value, initialValue) {
	    var hook = updateWorkInProgressHook();
	    return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
	      hook,
	      currentHook.memoizedState,
	      value,
	      initialValue
	    );
	  },
	  useTransition: function() {
	    var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
	    return [
	      "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
	      start
	    ];
	  },
	  useSyncExternalStore: updateSyncExternalStore,
	  useId: updateId,
	  useHostTransitionStatus,
	  useFormState: rerenderActionState,
	  useActionState: rerenderActionState,
	  useOptimistic: function(passthrough, reducer) {
	    var hook = updateWorkInProgressHook();
	    if (null !== currentHook)
	      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
	    hook.baseState = passthrough;
	    return [passthrough, hook.queue.dispatch];
	  },
	  useMemoCache,
	  useCacheRefresh: updateRefresh
	}, thenableState = null, thenableIndexCounter = 0;
	function unwrapThenable(thenable) {
	  var index2 = thenableIndexCounter;
	  thenableIndexCounter += 1;
	  null === thenableState && (thenableState = []);
	  return trackUsedThenable(thenableState, thenable, index2);
	}
	function coerceRef(workInProgress2, element) {
	  element = element.props.ref;
	  workInProgress2.ref = void 0 !== element ? element : null;
	}
	function throwOnInvalidObjectType(returnFiber, newChild) {
	  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
	    throw Error(formatProdErrorMessage(525));
	  returnFiber = Object.prototype.toString.call(newChild);
	  throw Error(
	    formatProdErrorMessage(
	      31,
	      "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
	    )
	  );
	}
	function resolveLazy(lazyType) {
	  var init = lazyType._init;
	  return init(lazyType._payload);
	}
	function createChildReconciler(shouldTrackSideEffects) {
	  function deleteChild(returnFiber, childToDelete) {
	    if (shouldTrackSideEffects) {
	      var deletions = returnFiber.deletions;
	      null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
	    }
	  }
	  function deleteRemainingChildren(returnFiber, currentFirstChild) {
	    if (!shouldTrackSideEffects) return null;
	    for (; null !== currentFirstChild; )
	      deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
	    return null;
	  }
	  function mapRemainingChildren(currentFirstChild) {
	    for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
	      null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
	    return existingChildren;
	  }
	  function useFiber(fiber, pendingProps) {
	    fiber = createWorkInProgress(fiber, pendingProps);
	    fiber.index = 0;
	    fiber.sibling = null;
	    return fiber;
	  }
	  function placeChild(newFiber, lastPlacedIndex, newIndex) {
	    newFiber.index = newIndex;
	    if (!shouldTrackSideEffects)
	      return newFiber.flags |= 1048576, lastPlacedIndex;
	    newIndex = newFiber.alternate;
	    if (null !== newIndex)
	      return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
	    newFiber.flags |= 67108866;
	    return lastPlacedIndex;
	  }
	  function placeSingleChild(newFiber) {
	    shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
	    return newFiber;
	  }
	  function updateTextNode(returnFiber, current, textContent, lanes) {
	    if (null === current || 6 !== current.tag)
	      return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
	    current = useFiber(current, textContent);
	    current.return = returnFiber;
	    return current;
	  }
	  function updateElement(returnFiber, current, element, lanes) {
	    var elementType = element.type;
	    if (elementType === REACT_FRAGMENT_TYPE)
	      return updateFragment(
	        returnFiber,
	        current,
	        element.props.children,
	        lanes,
	        element.key
	      );
	    if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
	      return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
	    current = createFiberFromTypeAndProps(
	      element.type,
	      element.key,
	      element.props,
	      null,
	      returnFiber.mode,
	      lanes
	    );
	    coerceRef(current, element);
	    current.return = returnFiber;
	    return current;
	  }
	  function updatePortal(returnFiber, current, portal, lanes) {
	    if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
	      return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
	    current = useFiber(current, portal.children || []);
	    current.return = returnFiber;
	    return current;
	  }
	  function updateFragment(returnFiber, current, fragment, lanes, key) {
	    if (null === current || 7 !== current.tag)
	      return current = createFiberFromFragment(
	        fragment,
	        returnFiber.mode,
	        lanes,
	        key
	      ), current.return = returnFiber, current;
	    current = useFiber(current, fragment);
	    current.return = returnFiber;
	    return current;
	  }
	  function createChild(returnFiber, newChild, lanes) {
	    if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
	      return newChild = createFiberFromText(
	        "" + newChild,
	        returnFiber.mode,
	        lanes
	      ), newChild.return = returnFiber, newChild;
	    if ("object" === typeof newChild && null !== newChild) {
	      switch (newChild.$$typeof) {
	        case REACT_ELEMENT_TYPE:
	          return lanes = createFiberFromTypeAndProps(
	            newChild.type,
	            newChild.key,
	            newChild.props,
	            null,
	            returnFiber.mode,
	            lanes
	          ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
	        case REACT_PORTAL_TYPE:
	          return newChild = createFiberFromPortal(
	            newChild,
	            returnFiber.mode,
	            lanes
	          ), newChild.return = returnFiber, newChild;
	        case REACT_LAZY_TYPE:
	          var init = newChild._init;
	          newChild = init(newChild._payload);
	          return createChild(returnFiber, newChild, lanes);
	      }
	      if (isArrayImpl(newChild) || getIteratorFn(newChild))
	        return newChild = createFiberFromFragment(
	          newChild,
	          returnFiber.mode,
	          lanes,
	          null
	        ), newChild.return = returnFiber, newChild;
	      if ("function" === typeof newChild.then)
	        return createChild(returnFiber, unwrapThenable(newChild), lanes);
	      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
	        return createChild(
	          returnFiber,
	          readContextDuringReconciliation(returnFiber, newChild),
	          lanes
	        );
	      throwOnInvalidObjectType(returnFiber, newChild);
	    }
	    return null;
	  }
	  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
	    var key = null !== oldFiber ? oldFiber.key : null;
	    if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
	      return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
	    if ("object" === typeof newChild && null !== newChild) {
	      switch (newChild.$$typeof) {
	        case REACT_ELEMENT_TYPE:
	          return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
	        case REACT_PORTAL_TYPE:
	          return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
	        case REACT_LAZY_TYPE:
	          return key = newChild._init, newChild = key(newChild._payload), updateSlot(returnFiber, oldFiber, newChild, lanes);
	      }
	      if (isArrayImpl(newChild) || getIteratorFn(newChild))
	        return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
	      if ("function" === typeof newChild.then)
	        return updateSlot(
	          returnFiber,
	          oldFiber,
	          unwrapThenable(newChild),
	          lanes
	        );
	      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
	        return updateSlot(
	          returnFiber,
	          oldFiber,
	          readContextDuringReconciliation(returnFiber, newChild),
	          lanes
	        );
	      throwOnInvalidObjectType(returnFiber, newChild);
	    }
	    return null;
	  }
	  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
	    if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
	      return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
	    if ("object" === typeof newChild && null !== newChild) {
	      switch (newChild.$$typeof) {
	        case REACT_ELEMENT_TYPE:
	          return existingChildren = existingChildren.get(
	            null === newChild.key ? newIdx : newChild.key
	          ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
	        case REACT_PORTAL_TYPE:
	          return existingChildren = existingChildren.get(
	            null === newChild.key ? newIdx : newChild.key
	          ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
	        case REACT_LAZY_TYPE:
	          var init = newChild._init;
	          newChild = init(newChild._payload);
	          return updateFromMap(
	            existingChildren,
	            returnFiber,
	            newIdx,
	            newChild,
	            lanes
	          );
	      }
	      if (isArrayImpl(newChild) || getIteratorFn(newChild))
	        return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
	      if ("function" === typeof newChild.then)
	        return updateFromMap(
	          existingChildren,
	          returnFiber,
	          newIdx,
	          unwrapThenable(newChild),
	          lanes
	        );
	      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
	        return updateFromMap(
	          existingChildren,
	          returnFiber,
	          newIdx,
	          readContextDuringReconciliation(returnFiber, newChild),
	          lanes
	        );
	      throwOnInvalidObjectType(returnFiber, newChild);
	    }
	    return null;
	  }
	  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
	    for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
	      oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
	      var newFiber = updateSlot(
	        returnFiber,
	        oldFiber,
	        newChildren[newIdx],
	        lanes
	      );
	      if (null === newFiber) {
	        null === oldFiber && (oldFiber = nextOldFiber);
	        break;
	      }
	      shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
	      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
	      null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
	      previousNewFiber = newFiber;
	      oldFiber = nextOldFiber;
	    }
	    if (newIdx === newChildren.length)
	      return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
	    if (null === oldFiber) {
	      for (; newIdx < newChildren.length; newIdx++)
	        oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
	          oldFiber,
	          currentFirstChild,
	          newIdx
	        ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
	      isHydrating && pushTreeFork(returnFiber, newIdx);
	      return resultingFirstChild;
	    }
	    for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
	      nextOldFiber = updateFromMap(
	        oldFiber,
	        returnFiber,
	        newIdx,
	        newChildren[newIdx],
	        lanes
	      ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
	        null === nextOldFiber.key ? newIdx : nextOldFiber.key
	      ), currentFirstChild = placeChild(
	        nextOldFiber,
	        currentFirstChild,
	        newIdx
	      ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
	    shouldTrackSideEffects && oldFiber.forEach(function(child) {
	      return deleteChild(returnFiber, child);
	    });
	    isHydrating && pushTreeFork(returnFiber, newIdx);
	    return resultingFirstChild;
	  }
	  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
	    if (null == newChildren) throw Error(formatProdErrorMessage(151));
	    for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
	      oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
	      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
	      if (null === newFiber) {
	        null === oldFiber && (oldFiber = nextOldFiber);
	        break;
	      }
	      shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
	      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
	      null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
	      previousNewFiber = newFiber;
	      oldFiber = nextOldFiber;
	    }
	    if (step.done)
	      return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
	    if (null === oldFiber) {
	      for (; !step.done; newIdx++, step = newChildren.next())
	        step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
	      isHydrating && pushTreeFork(returnFiber, newIdx);
	      return resultingFirstChild;
	    }
	    for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
	      step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
	    shouldTrackSideEffects && oldFiber.forEach(function(child) {
	      return deleteChild(returnFiber, child);
	    });
	    isHydrating && pushTreeFork(returnFiber, newIdx);
	    return resultingFirstChild;
	  }
	  function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
	    "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
	    if ("object" === typeof newChild && null !== newChild) {
	      switch (newChild.$$typeof) {
	        case REACT_ELEMENT_TYPE:
	          a: {
	            for (var key = newChild.key; null !== currentFirstChild; ) {
	              if (currentFirstChild.key === key) {
	                key = newChild.type;
	                if (key === REACT_FRAGMENT_TYPE) {
	                  if (7 === currentFirstChild.tag) {
	                    deleteRemainingChildren(
	                      returnFiber,
	                      currentFirstChild.sibling
	                    );
	                    lanes = useFiber(
	                      currentFirstChild,
	                      newChild.props.children
	                    );
	                    lanes.return = returnFiber;
	                    returnFiber = lanes;
	                    break a;
	                  }
	                } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
	                  deleteRemainingChildren(
	                    returnFiber,
	                    currentFirstChild.sibling
	                  );
	                  lanes = useFiber(currentFirstChild, newChild.props);
	                  coerceRef(lanes, newChild);
	                  lanes.return = returnFiber;
	                  returnFiber = lanes;
	                  break a;
	                }
	                deleteRemainingChildren(returnFiber, currentFirstChild);
	                break;
	              } else deleteChild(returnFiber, currentFirstChild);
	              currentFirstChild = currentFirstChild.sibling;
	            }
	            newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
	              newChild.props.children,
	              returnFiber.mode,
	              lanes,
	              newChild.key
	            ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
	              newChild.type,
	              newChild.key,
	              newChild.props,
	              null,
	              returnFiber.mode,
	              lanes
	            ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
	          }
	          return placeSingleChild(returnFiber);
	        case REACT_PORTAL_TYPE:
	          a: {
	            for (key = newChild.key; null !== currentFirstChild; ) {
	              if (currentFirstChild.key === key)
	                if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
	                  deleteRemainingChildren(
	                    returnFiber,
	                    currentFirstChild.sibling
	                  );
	                  lanes = useFiber(currentFirstChild, newChild.children || []);
	                  lanes.return = returnFiber;
	                  returnFiber = lanes;
	                  break a;
	                } else {
	                  deleteRemainingChildren(returnFiber, currentFirstChild);
	                  break;
	                }
	              else deleteChild(returnFiber, currentFirstChild);
	              currentFirstChild = currentFirstChild.sibling;
	            }
	            lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
	            lanes.return = returnFiber;
	            returnFiber = lanes;
	          }
	          return placeSingleChild(returnFiber);
	        case REACT_LAZY_TYPE:
	          return key = newChild._init, newChild = key(newChild._payload), reconcileChildFibersImpl(
	            returnFiber,
	            currentFirstChild,
	            newChild,
	            lanes
	          );
	      }
	      if (isArrayImpl(newChild))
	        return reconcileChildrenArray(
	          returnFiber,
	          currentFirstChild,
	          newChild,
	          lanes
	        );
	      if (getIteratorFn(newChild)) {
	        key = getIteratorFn(newChild);
	        if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
	        newChild = key.call(newChild);
	        return reconcileChildrenIterator(
	          returnFiber,
	          currentFirstChild,
	          newChild,
	          lanes
	        );
	      }
	      if ("function" === typeof newChild.then)
	        return reconcileChildFibersImpl(
	          returnFiber,
	          currentFirstChild,
	          unwrapThenable(newChild),
	          lanes
	        );
	      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
	        return reconcileChildFibersImpl(
	          returnFiber,
	          currentFirstChild,
	          readContextDuringReconciliation(returnFiber, newChild),
	          lanes
	        );
	      throwOnInvalidObjectType(returnFiber, newChild);
	    }
	    return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
	  }
	  return function(returnFiber, currentFirstChild, newChild, lanes) {
	    try {
	      thenableIndexCounter = 0;
	      var firstChildFiber = reconcileChildFibersImpl(
	        returnFiber,
	        currentFirstChild,
	        newChild,
	        lanes
	      );
	      thenableState = null;
	      return firstChildFiber;
	    } catch (x) {
	      if (x === SuspenseException || x === SuspenseActionException) throw x;
	      var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
	      fiber.lanes = lanes;
	      fiber.return = returnFiber;
	      return fiber;
	    } finally {
	    }
	  };
	}
	var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null;
	function pushPrimaryTreeSuspenseHandler(handler) {
	  var current = handler.alternate;
	  push(suspenseStackCursor, suspenseStackCursor.current & 1);
	  push(suspenseHandlerStackCursor, handler);
	  null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
	}
	function pushOffscreenSuspenseHandler(fiber) {
	  if (22 === fiber.tag) {
	    if (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary) {
	      var current = fiber.alternate;
	      null !== current && null !== current.memoizedState && (shellBoundary = fiber);
	    }
	  } else reuseSuspenseHandlerOnStack();
	}
	function reuseSuspenseHandlerOnStack() {
	  push(suspenseStackCursor, suspenseStackCursor.current);
	  push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
	}
	function popSuspenseHandler(fiber) {
	  pop(suspenseHandlerStackCursor);
	  shellBoundary === fiber && (shellBoundary = null);
	  pop(suspenseStackCursor);
	}
	var suspenseStackCursor = createCursor(0);
	function findFirstSuspended(row) {
	  for (var node = row; null !== node; ) {
	    if (13 === node.tag) {
	      var state = node.memoizedState;
	      if (null !== state && (state = state.dehydrated, null === state || "$?" === state.data || isSuspenseInstanceFallback(state)))
	        return node;
	    } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
	      if (0 !== (node.flags & 128)) return node;
	    } else if (null !== node.child) {
	      node.child.return = node;
	      node = node.child;
	      continue;
	    }
	    if (node === row) break;
	    for (; null === node.sibling; ) {
	      if (null === node.return || node.return === row) return null;
	      node = node.return;
	    }
	    node.sibling.return = node.return;
	    node = node.sibling;
	  }
	  return null;
	}
	function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
	  ctor = workInProgress2.memoizedState;
	  getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
	  getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
	  workInProgress2.memoizedState = getDerivedStateFromProps;
	  0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
	}
	var classComponentUpdater = {
	  enqueueSetState: function(inst, payload, callback) {
	    inst = inst._reactInternals;
	    var lane = requestUpdateLane(), update = createUpdate(lane);
	    update.payload = payload;
	    void 0 !== callback && null !== callback && (update.callback = callback);
	    payload = enqueueUpdate(inst, update, lane);
	    null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
	  },
	  enqueueReplaceState: function(inst, payload, callback) {
	    inst = inst._reactInternals;
	    var lane = requestUpdateLane(), update = createUpdate(lane);
	    update.tag = 1;
	    update.payload = payload;
	    void 0 !== callback && null !== callback && (update.callback = callback);
	    payload = enqueueUpdate(inst, update, lane);
	    null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
	  },
	  enqueueForceUpdate: function(inst, callback) {
	    inst = inst._reactInternals;
	    var lane = requestUpdateLane(), update = createUpdate(lane);
	    update.tag = 2;
	    void 0 !== callback && null !== callback && (update.callback = callback);
	    callback = enqueueUpdate(inst, update, lane);
	    null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
	  }
	};
	function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
	  workInProgress2 = workInProgress2.stateNode;
	  return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
	}
	function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
	  workInProgress2 = instance.state;
	  "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
	  "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
	  instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
	}
	function resolveClassComponentProps(Component, baseProps) {
	  var newProps = baseProps;
	  if ("ref" in baseProps) {
	    newProps = {};
	    for (var propName in baseProps)
	      "ref" !== propName && (newProps[propName] = baseProps[propName]);
	  }
	  if (Component = Component.defaultProps) {
	    newProps === baseProps && (newProps = assign({}, newProps));
	    for (var propName$73 in Component)
	      void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
	  }
	  return newProps;
	}
	var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
	  if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
	    var event = new window.ErrorEvent("error", {
	      bubbles: true,
	      cancelable: true,
	      message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
	      error
	    });
	    if (!window.dispatchEvent(event)) return;
	  } else if ("object" === typeof process && "function" === typeof process.emit) {
	    process.emit("uncaughtException", error);
	    return;
	  }
	  console.error(error);
	};
	function defaultOnUncaughtError(error) {
	  reportGlobalError(error);
	}
	function defaultOnCaughtError(error) {
	  console.error(error);
	}
	function defaultOnRecoverableError(error) {
	  reportGlobalError(error);
	}
	function logUncaughtError(root2, errorInfo) {
	  try {
	    var onUncaughtError = root2.onUncaughtError;
	    onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
	  } catch (e$74) {
	    setTimeout(function() {
	      throw e$74;
	    });
	  }
	}
	function logCaughtError(root2, boundary, errorInfo) {
	  try {
	    var onCaughtError = root2.onCaughtError;
	    onCaughtError(errorInfo.value, {
	      componentStack: errorInfo.stack,
	      errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
	    });
	  } catch (e$75) {
	    setTimeout(function() {
	      throw e$75;
	    });
	  }
	}
	function createRootErrorUpdate(root2, errorInfo, lane) {
	  lane = createUpdate(lane);
	  lane.tag = 3;
	  lane.payload = { element: null };
	  lane.callback = function() {
	    logUncaughtError(root2, errorInfo);
	  };
	  return lane;
	}
	function createClassErrorUpdate(lane) {
	  lane = createUpdate(lane);
	  lane.tag = 3;
	  return lane;
	}
	function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
	  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
	  if ("function" === typeof getDerivedStateFromError) {
	    var error = errorInfo.value;
	    update.payload = function() {
	      return getDerivedStateFromError(error);
	    };
	    update.callback = function() {
	      logCaughtError(root2, fiber, errorInfo);
	    };
	  }
	  var inst = fiber.stateNode;
	  null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
	    logCaughtError(root2, fiber, errorInfo);
	    "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
	    var stack = errorInfo.stack;
	    this.componentDidCatch(errorInfo.value, {
	      componentStack: null !== stack ? stack : ""
	    });
	  });
	}
	function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
	  sourceFiber.flags |= 32768;
	  if (null !== value && "object" === typeof value && "function" === typeof value.then) {
	    returnFiber = sourceFiber.alternate;
	    null !== returnFiber && propagateParentContextChanges(
	      returnFiber,
	      sourceFiber,
	      rootRenderLanes,
	      true
	    );
	    sourceFiber = suspenseHandlerStackCursor.current;
	    if (null !== sourceFiber) {
	      switch (sourceFiber.tag) {
	        case 13:
	          return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
	        case 22:
	          return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
	            transitions: null,
	            markerInstances: null,
	            retryQueue: /* @__PURE__ */ new Set([value])
	          }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
	      }
	      throw Error(formatProdErrorMessage(435, sourceFiber.tag));
	    }
	    attachPingListener(root2, value, rootRenderLanes);
	    renderDidSuspendDelayIfPossible();
	    return false;
	  }
	  if (isHydrating)
	    return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root2 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root2, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
	      cause: value
	    }), queueHydrationError(
	      createCapturedValueAtFiber(returnFiber, sourceFiber)
	    )), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
	      root2.stateNode,
	      value,
	      rootRenderLanes
	    ), enqueueCapturedUpdate(root2, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
	  var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
	  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
	  null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
	  4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
	  if (null === returnFiber) return true;
	  value = createCapturedValueAtFiber(value, sourceFiber);
	  sourceFiber = returnFiber;
	  do {
	    switch (sourceFiber.tag) {
	      case 3:
	        return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(sourceFiber.stateNode, value, root2), enqueueCapturedUpdate(sourceFiber, root2), false;
	      case 1:
	        if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
	          return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
	            rootRenderLanes,
	            root2,
	            sourceFiber,
	            value
	          ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
	    }
	    sourceFiber = sourceFiber.return;
	  } while (null !== sourceFiber);
	  return false;
	}
	var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = false;
	function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
	  workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
	    workInProgress2,
	    current.child,
	    nextChildren,
	    renderLanes2
	  );
	}
	function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
	  Component = Component.render;
	  var ref = workInProgress2.ref;
	  if ("ref" in nextProps) {
	    var propsWithoutRef = {};
	    for (var key in nextProps)
	      "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
	  } else propsWithoutRef = nextProps;
	  prepareToReadContext(workInProgress2);
	  nextProps = renderWithHooks(
	    current,
	    workInProgress2,
	    Component,
	    propsWithoutRef,
	    ref,
	    renderLanes2
	  );
	  key = checkDidRenderIdHook();
	  if (null !== current && !didReceiveUpdate)
	    return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
	  isHydrating && key && pushMaterializedTreeId(workInProgress2);
	  workInProgress2.flags |= 1;
	  reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
	  return workInProgress2.child;
	}
	function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
	  if (null === current) {
	    var type = Component.type;
	    if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
	      return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
	        current,
	        workInProgress2,
	        type,
	        nextProps,
	        renderLanes2
	      );
	    current = createFiberFromTypeAndProps(
	      Component.type,
	      null,
	      nextProps,
	      workInProgress2,
	      workInProgress2.mode,
	      renderLanes2
	    );
	    current.ref = workInProgress2.ref;
	    current.return = workInProgress2;
	    return workInProgress2.child = current;
	  }
	  type = current.child;
	  if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
	    var prevProps = type.memoizedProps;
	    Component = Component.compare;
	    Component = null !== Component ? Component : shallowEqual;
	    if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
	      return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
	  }
	  workInProgress2.flags |= 1;
	  current = createWorkInProgress(type, nextProps);
	  current.ref = workInProgress2.ref;
	  current.return = workInProgress2;
	  return workInProgress2.child = current;
	}
	function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
	  if (null !== current) {
	    var prevProps = current.memoizedProps;
	    if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
	      if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
	        0 !== (current.flags & 131072) && (didReceiveUpdate = true);
	      else
	        return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
	  }
	  return updateFunctionComponent(
	    current,
	    workInProgress2,
	    Component,
	    nextProps,
	    renderLanes2
	  );
	}
	function updateOffscreenComponent(current, workInProgress2, renderLanes2) {
	  var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
	  if ("hidden" === nextProps.mode) {
	    if (0 !== (workInProgress2.flags & 128)) {
	      nextProps = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
	      if (null !== current) {
	        nextChildren = workInProgress2.child = current.child;
	        for (prevState = 0; null !== nextChildren; )
	          prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
	        workInProgress2.childLanes = prevState & ~nextProps;
	      } else workInProgress2.childLanes = 0, workInProgress2.child = null;
	      return deferHiddenOffscreenComponent(
	        current,
	        workInProgress2,
	        nextProps,
	        renderLanes2
	      );
	    }
	    if (0 !== (renderLanes2 & 536870912))
	      workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
	        workInProgress2,
	        null !== prevState ? prevState.cachePool : null
	      ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
	    else
	      return workInProgress2.lanes = workInProgress2.childLanes = 536870912, deferHiddenOffscreenComponent(
	        current,
	        workInProgress2,
	        null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
	        renderLanes2
	      );
	  } else
	    null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack());
	  reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
	  return workInProgress2.child;
	}
	function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2) {
	  var JSCompiler_inline_result = peekCacheFromPool();
	  JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
	  workInProgress2.memoizedState = {
	    baseLanes: nextBaseLanes,
	    cachePool: JSCompiler_inline_result
	  };
	  null !== current && pushTransition(workInProgress2, null);
	  reuseHiddenContextOnStack();
	  pushOffscreenSuspenseHandler(workInProgress2);
	  null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
	  return null;
	}
	function markRef(current, workInProgress2) {
	  var ref = workInProgress2.ref;
	  if (null === ref)
	    null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
	  else {
	    if ("function" !== typeof ref && "object" !== typeof ref)
	      throw Error(formatProdErrorMessage(284));
	    if (null === current || current.ref !== ref)
	      workInProgress2.flags |= 4194816;
	  }
	}
	function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
	  prepareToReadContext(workInProgress2);
	  Component = renderWithHooks(
	    current,
	    workInProgress2,
	    Component,
	    nextProps,
	    void 0,
	    renderLanes2
	  );
	  nextProps = checkDidRenderIdHook();
	  if (null !== current && !didReceiveUpdate)
	    return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
	  isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
	  workInProgress2.flags |= 1;
	  reconcileChildren(current, workInProgress2, Component, renderLanes2);
	  return workInProgress2.child;
	}
	function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
	  prepareToReadContext(workInProgress2);
	  workInProgress2.updateQueue = null;
	  nextProps = renderWithHooksAgain(
	    workInProgress2,
	    Component,
	    nextProps,
	    secondArg
	  );
	  finishRenderingHooks(current);
	  Component = checkDidRenderIdHook();
	  if (null !== current && !didReceiveUpdate)
	    return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
	  isHydrating && Component && pushMaterializedTreeId(workInProgress2);
	  workInProgress2.flags |= 1;
	  reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
	  return workInProgress2.child;
	}
	function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
	  prepareToReadContext(workInProgress2);
	  if (null === workInProgress2.stateNode) {
	    var context = emptyContextObject, contextType = Component.contextType;
	    "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
	    context = new Component(nextProps, context);
	    workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
	    context.updater = classComponentUpdater;
	    workInProgress2.stateNode = context;
	    context._reactInternals = workInProgress2;
	    context = workInProgress2.stateNode;
	    context.props = nextProps;
	    context.state = workInProgress2.memoizedState;
	    context.refs = {};
	    initializeUpdateQueue(workInProgress2);
	    contextType = Component.contextType;
	    context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
	    context.state = workInProgress2.memoizedState;
	    contextType = Component.getDerivedStateFromProps;
	    "function" === typeof contextType && (applyDerivedStateFromProps(
	      workInProgress2,
	      Component,
	      contextType,
	      nextProps
	    ), context.state = workInProgress2.memoizedState);
	    "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
	    "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
	    nextProps = true;
	  } else if (null === current) {
	    context = workInProgress2.stateNode;
	    var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
	    context.props = oldProps;
	    var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
	    contextType = emptyContextObject;
	    "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
	    var getDerivedStateFromProps = Component.getDerivedStateFromProps;
	    contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
	    unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
	    contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
	      workInProgress2,
	      context,
	      nextProps,
	      contextType
	    );
	    hasForceUpdate = false;
	    var oldState = workInProgress2.memoizedState;
	    context.state = oldState;
	    processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
	    suspendIfUpdateReadFromEntangledAsyncAction();
	    oldContext = workInProgress2.memoizedState;
	    unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
	      workInProgress2,
	      Component,
	      getDerivedStateFromProps,
	      nextProps
	    ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
	      workInProgress2,
	      Component,
	      oldProps,
	      nextProps,
	      oldState,
	      oldContext,
	      contextType
	    )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
	  } else {
	    context = workInProgress2.stateNode;
	    cloneUpdateQueue(current, workInProgress2);
	    contextType = workInProgress2.memoizedProps;
	    contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
	    context.props = contextType$jscomp$0;
	    getDerivedStateFromProps = workInProgress2.pendingProps;
	    oldState = context.context;
	    oldContext = Component.contextType;
	    oldProps = emptyContextObject;
	    "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
	    unresolvedOldProps = Component.getDerivedStateFromProps;
	    (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
	      workInProgress2,
	      context,
	      nextProps,
	      oldProps
	    );
	    hasForceUpdate = false;
	    oldState = workInProgress2.memoizedState;
	    context.state = oldState;
	    processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
	    suspendIfUpdateReadFromEntangledAsyncAction();
	    var newState = workInProgress2.memoizedState;
	    contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
	      workInProgress2,
	      Component,
	      unresolvedOldProps,
	      nextProps
	    ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
	      workInProgress2,
	      Component,
	      contextType$jscomp$0,
	      nextProps,
	      oldState,
	      newState,
	      oldProps
	    ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
	      nextProps,
	      newState,
	      oldProps
	    )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
	  }
	  context = nextProps;
	  markRef(current, workInProgress2);
	  nextProps = 0 !== (workInProgress2.flags & 128);
	  context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
	    workInProgress2,
	    current.child,
	    null,
	    renderLanes2
	  ), workInProgress2.child = reconcileChildFibers(
	    workInProgress2,
	    null,
	    Component,
	    renderLanes2
	  )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
	    current,
	    workInProgress2,
	    renderLanes2
	  );
	  return current;
	}
	function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
	  resetHydrationState();
	  workInProgress2.flags |= 256;
	  reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
	  return workInProgress2.child;
	}
	var SUSPENDED_MARKER = {
	  dehydrated: null,
	  treeContext: null,
	  retryLane: 0,
	  hydrationErrors: null
	};
	function mountSuspenseOffscreenState(renderLanes2) {
	  return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
	}
	function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
	  current = null !== current ? current.childLanes & ~renderLanes2 : 0;
	  primaryTreeDidDefer && (current |= workInProgressDeferredLane);
	  return current;
	}
	function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
	  var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
	  (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
	  JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
	  JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
	  workInProgress2.flags &= -33;
	  if (null === current) {
	    if (isHydrating) {
	      showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack();
	      if (isHydrating) {
	        var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;
	        if (JSCompiler_temp$jscomp$0 = nextInstance) {
	          c: {
	            JSCompiler_temp$jscomp$0 = nextInstance;
	            for (nextInstance = rootOrSingletonContext; 8 !== JSCompiler_temp$jscomp$0.nodeType; ) {
	              if (!nextInstance) {
	                nextInstance = null;
	                break c;
	              }
	              JSCompiler_temp$jscomp$0 = getNextHydratable(
	                JSCompiler_temp$jscomp$0.nextSibling
	              );
	              if (null === JSCompiler_temp$jscomp$0) {
	                nextInstance = null;
	                break c;
	              }
	            }
	            nextInstance = JSCompiler_temp$jscomp$0;
	          }
	          null !== nextInstance ? (workInProgress2.memoizedState = {
	            dehydrated: nextInstance,
	            treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
	            retryLane: 536870912,
	            hydrationErrors: null
	          }, JSCompiler_temp$jscomp$0 = createFiberImplClass(
	            18,
	            null,
	            null,
	            0
	          ), JSCompiler_temp$jscomp$0.stateNode = nextInstance, JSCompiler_temp$jscomp$0.return = workInProgress2, workInProgress2.child = JSCompiler_temp$jscomp$0, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = true) : JSCompiler_temp$jscomp$0 = false;
	        }
	        JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress2);
	      }
	      nextInstance = workInProgress2.memoizedState;
	      if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance))
	        return isSuspenseInstanceFallback(nextInstance) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912, null;
	      popSuspenseHandler(workInProgress2);
	    }
	    nextInstance = nextProps.children;
	    nextProps = nextProps.fallback;
	    if (showFallback)
	      return reuseSuspenseHandlerOnStack(), showFallback = workInProgress2.mode, nextInstance = mountWorkInProgressOffscreenFiber(
	        { mode: "hidden", children: nextInstance },
	        showFallback
	      ), nextProps = createFiberFromFragment(
	        nextProps,
	        showFallback,
	        renderLanes2,
	        null
	      ), nextInstance.return = workInProgress2, nextProps.return = workInProgress2, nextInstance.sibling = nextProps, workInProgress2.child = nextInstance, showFallback = workInProgress2.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes2), showFallback.childLanes = getRemainingWorkInPrimaryTree(
	        current,
	        JSCompiler_temp,
	        renderLanes2
	      ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
	    pushPrimaryTreeSuspenseHandler(workInProgress2);
	    return mountSuspensePrimaryChildren(workInProgress2, nextInstance);
	  }
	  JSCompiler_temp$jscomp$0 = current.memoizedState;
	  if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {
	    if (didSuspend)
	      workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
	        current,
	        workInProgress2,
	        renderLanes2
	      )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
	        { mode: "visible", children: nextProps.children },
	        nextInstance
	      ), showFallback = createFiberFromFragment(
	        showFallback,
	        nextInstance,
	        renderLanes2,
	        null
	      ), showFallback.flags |= 2, nextProps.return = workInProgress2, showFallback.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, reconcileChildFibers(
	        workInProgress2,
	        current.child,
	        null,
	        renderLanes2
	      ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
	        current,
	        JSCompiler_temp,
	        renderLanes2
	      ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = showFallback);
	    else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextInstance)) {
	      JSCompiler_temp = nextInstance.nextSibling && nextInstance.nextSibling.dataset;
	      if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
	      JSCompiler_temp = digest;
	      nextProps = Error(formatProdErrorMessage(419));
	      nextProps.stack = "";
	      nextProps.digest = JSCompiler_temp;
	      queueHydrationError({ value: nextProps, source: null, stack: null });
	      workInProgress2 = retrySuspenseComponentWithoutHydrating(
	        current,
	        workInProgress2,
	        renderLanes2
	      );
	    } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
	      JSCompiler_temp = workInProgressRoot;
	      if (null !== JSCompiler_temp && (nextProps = renderLanes2 & -renderLanes2, nextProps = 0 !== (nextProps & 42) ? 1 : getBumpedLaneForHydrationByLane(nextProps), nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes2)) ? 0 : nextProps, 0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane))
	        throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
	      "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
	      workInProgress2 = retrySuspenseComponentWithoutHydrating(
	        current,
	        workInProgress2,
	        renderLanes2
	      );
	    } else
	      "$?" === nextInstance.data ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = JSCompiler_temp$jscomp$0.treeContext, nextHydratableInstance = getNextHydratable(
	        nextInstance.nextSibling
	      ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && (idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress2), workInProgress2 = mountSuspensePrimaryChildren(
	        workInProgress2,
	        nextProps.children
	      ), workInProgress2.flags |= 4096);
	    return workInProgress2;
	  }
	  if (showFallback)
	    return reuseSuspenseHandlerOnStack(), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, JSCompiler_temp$jscomp$0 = current.child, digest = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
	      mode: "hidden",
	      children: nextProps.children
	    }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 65011712, null !== digest ? showFallback = createWorkInProgress(digest, showFallback) : (showFallback = createFiberFromFragment(
	      showFallback,
	      nextInstance,
	      renderLanes2,
	      null
	    ), showFallback.flags |= 2), showFallback.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, nextProps = showFallback, showFallback = workInProgress2.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (digest = CacheContext._currentValue, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== digest ? { parent: digest, pool: digest } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {
	      baseLanes: nextInstance.baseLanes | renderLanes2,
	      cachePool: JSCompiler_temp$jscomp$0
	    }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(
	      current,
	      JSCompiler_temp,
	      renderLanes2
	    ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
	  pushPrimaryTreeSuspenseHandler(workInProgress2);
	  renderLanes2 = current.child;
	  current = renderLanes2.sibling;
	  renderLanes2 = createWorkInProgress(renderLanes2, {
	    mode: "visible",
	    children: nextProps.children
	  });
	  renderLanes2.return = workInProgress2;
	  renderLanes2.sibling = null;
	  null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
	  workInProgress2.child = renderLanes2;
	  workInProgress2.memoizedState = null;
	  return renderLanes2;
	}
	function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
	  primaryChildren = mountWorkInProgressOffscreenFiber(
	    { mode: "visible", children: primaryChildren },
	    workInProgress2.mode
	  );
	  primaryChildren.return = workInProgress2;
	  return workInProgress2.child = primaryChildren;
	}
	function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
	  offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
	  offscreenProps.lanes = 0;
	  offscreenProps.stateNode = {
	    _visibility: 1,
	    _pendingMarkers: null,
	    _retryCache: null,
	    _transitions: null
	  };
	  return offscreenProps;
	}
	function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
	  reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
	  current = mountSuspensePrimaryChildren(
	    workInProgress2,
	    workInProgress2.pendingProps.children
	  );
	  current.flags |= 2;
	  workInProgress2.memoizedState = null;
	  return current;
	}
	function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
	  fiber.lanes |= renderLanes2;
	  var alternate = fiber.alternate;
	  null !== alternate && (alternate.lanes |= renderLanes2);
	  scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
	}
	function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
	  var renderState = workInProgress2.memoizedState;
	  null === renderState ? workInProgress2.memoizedState = {
	    isBackwards,
	    rendering: null,
	    renderingStartTime: 0,
	    last: lastContentRow,
	    tail,
	    tailMode
	  } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
	}
	function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
	  var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
	  reconcileChildren(current, workInProgress2, nextProps.children, renderLanes2);
	  nextProps = suspenseStackCursor.current;
	  if (0 !== (nextProps & 2))
	    nextProps = nextProps & 1 | 2, workInProgress2.flags |= 128;
	  else {
	    if (null !== current && 0 !== (current.flags & 128))
	      a: for (current = workInProgress2.child; null !== current; ) {
	        if (13 === current.tag)
	          null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
	        else if (19 === current.tag)
	          scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
	        else if (null !== current.child) {
	          current.child.return = current;
	          current = current.child;
	          continue;
	        }
	        if (current === workInProgress2) break a;
	        for (; null === current.sibling; ) {
	          if (null === current.return || current.return === workInProgress2)
	            break a;
	          current = current.return;
	        }
	        current.sibling.return = current.return;
	        current = current.sibling;
	      }
	    nextProps &= 1;
	  }
	  push(suspenseStackCursor, nextProps);
	  switch (revealOrder) {
	    case "forwards":
	      renderLanes2 = workInProgress2.child;
	      for (revealOrder = null; null !== renderLanes2; )
	        current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
	      renderLanes2 = revealOrder;
	      null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
	      initSuspenseListRenderState(
	        workInProgress2,
	        false,
	        revealOrder,
	        renderLanes2,
	        tailMode
	      );
	      break;
	    case "backwards":
	      renderLanes2 = null;
	      revealOrder = workInProgress2.child;
	      for (workInProgress2.child = null; null !== revealOrder; ) {
	        current = revealOrder.alternate;
	        if (null !== current && null === findFirstSuspended(current)) {
	          workInProgress2.child = revealOrder;
	          break;
	        }
	        current = revealOrder.sibling;
	        revealOrder.sibling = renderLanes2;
	        renderLanes2 = revealOrder;
	        revealOrder = current;
	      }
	      initSuspenseListRenderState(
	        workInProgress2,
	        true,
	        renderLanes2,
	        null,
	        tailMode
	      );
	      break;
	    case "together":
	      initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
	      break;
	    default:
	      workInProgress2.memoizedState = null;
	  }
	  return workInProgress2.child;
	}
	function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
	  null !== current && (workInProgress2.dependencies = current.dependencies);
	  workInProgressRootSkippedLanes |= workInProgress2.lanes;
	  if (0 === (renderLanes2 & workInProgress2.childLanes))
	    if (null !== current) {
	      if (propagateParentContextChanges(
	        current,
	        workInProgress2,
	        renderLanes2,
	        false
	      ), 0 === (renderLanes2 & workInProgress2.childLanes))
	        return null;
	    } else return null;
	  if (null !== current && workInProgress2.child !== current.child)
	    throw Error(formatProdErrorMessage(153));
	  if (null !== workInProgress2.child) {
	    current = workInProgress2.child;
	    renderLanes2 = createWorkInProgress(current, current.pendingProps);
	    workInProgress2.child = renderLanes2;
	    for (renderLanes2.return = workInProgress2; null !== current.sibling; )
	      current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
	    renderLanes2.sibling = null;
	  }
	  return workInProgress2.child;
	}
	function checkScheduledUpdateOrContext(current, renderLanes2) {
	  if (0 !== (current.lanes & renderLanes2)) return true;
	  current = current.dependencies;
	  return null !== current && checkIfContextChanged(current) ? true : false;
	}
	function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
	  switch (workInProgress2.tag) {
	    case 3:
	      pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
	      pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
	      resetHydrationState();
	      break;
	    case 27:
	    case 5:
	      pushHostContext(workInProgress2);
	      break;
	    case 4:
	      pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
	      break;
	    case 10:
	      pushProvider(
	        workInProgress2,
	        workInProgress2.type,
	        workInProgress2.memoizedProps.value
	      );
	      break;
	    case 13:
	      var state = workInProgress2.memoizedState;
	      if (null !== state) {
	        if (null !== state.dehydrated)
	          return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
	        if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
	          return updateSuspenseComponent(current, workInProgress2, renderLanes2);
	        pushPrimaryTreeSuspenseHandler(workInProgress2);
	        current = bailoutOnAlreadyFinishedWork(
	          current,
	          workInProgress2,
	          renderLanes2
	        );
	        return null !== current ? current.sibling : null;
	      }
	      pushPrimaryTreeSuspenseHandler(workInProgress2);
	      break;
	    case 19:
	      var didSuspendBefore = 0 !== (current.flags & 128);
	      state = 0 !== (renderLanes2 & workInProgress2.childLanes);
	      state || (propagateParentContextChanges(
	        current,
	        workInProgress2,
	        renderLanes2,
	        false
	      ), state = 0 !== (renderLanes2 & workInProgress2.childLanes));
	      if (didSuspendBefore) {
	        if (state)
	          return updateSuspenseListComponent(
	            current,
	            workInProgress2,
	            renderLanes2
	          );
	        workInProgress2.flags |= 128;
	      }
	      didSuspendBefore = workInProgress2.memoizedState;
	      null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
	      push(suspenseStackCursor, suspenseStackCursor.current);
	      if (state) break;
	      else return null;
	    case 22:
	    case 23:
	      return workInProgress2.lanes = 0, updateOffscreenComponent(current, workInProgress2, renderLanes2);
	    case 24:
	      pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
	  }
	  return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
	}
	function beginWork(current, workInProgress2, renderLanes2) {
	  if (null !== current)
	    if (current.memoizedProps !== workInProgress2.pendingProps)
	      didReceiveUpdate = true;
	    else {
	      if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
	        return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
	          current,
	          workInProgress2,
	          renderLanes2
	        );
	      didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
	    }
	  else
	    didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
	  workInProgress2.lanes = 0;
	  switch (workInProgress2.tag) {
	    case 16:
	      a: {
	        current = workInProgress2.pendingProps;
	        var lazyComponent = workInProgress2.elementType, init = lazyComponent._init;
	        lazyComponent = init(lazyComponent._payload);
	        workInProgress2.type = lazyComponent;
	        if ("function" === typeof lazyComponent)
	          shouldConstruct(lazyComponent) ? (current = resolveClassComponentProps(lazyComponent, current), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
	            null,
	            workInProgress2,
	            lazyComponent,
	            current,
	            renderLanes2
	          )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
	            null,
	            workInProgress2,
	            lazyComponent,
	            current,
	            renderLanes2
	          ));
	        else {
	          if (void 0 !== lazyComponent && null !== lazyComponent) {
	            if (init = lazyComponent.$$typeof, init === REACT_FORWARD_REF_TYPE) {
	              workInProgress2.tag = 11;
	              workInProgress2 = updateForwardRef(
	                null,
	                workInProgress2,
	                lazyComponent,
	                current,
	                renderLanes2
	              );
	              break a;
	            } else if (init === REACT_MEMO_TYPE) {
	              workInProgress2.tag = 14;
	              workInProgress2 = updateMemoComponent(
	                null,
	                workInProgress2,
	                lazyComponent,
	                current,
	                renderLanes2
	              );
	              break a;
	            }
	          }
	          workInProgress2 = getComponentNameFromType(lazyComponent) || lazyComponent;
	          throw Error(formatProdErrorMessage(306, workInProgress2, ""));
	        }
	      }
	      return workInProgress2;
	    case 0:
	      return updateFunctionComponent(
	        current,
	        workInProgress2,
	        workInProgress2.type,
	        workInProgress2.pendingProps,
	        renderLanes2
	      );
	    case 1:
	      return lazyComponent = workInProgress2.type, init = resolveClassComponentProps(
	        lazyComponent,
	        workInProgress2.pendingProps
	      ), updateClassComponent(
	        current,
	        workInProgress2,
	        lazyComponent,
	        init,
	        renderLanes2
	      );
	    case 3:
	      a: {
	        pushHostContainer(
	          workInProgress2,
	          workInProgress2.stateNode.containerInfo
	        );
	        if (null === current) throw Error(formatProdErrorMessage(387));
	        lazyComponent = workInProgress2.pendingProps;
	        var prevState = workInProgress2.memoizedState;
	        init = prevState.element;
	        cloneUpdateQueue(current, workInProgress2);
	        processUpdateQueue(workInProgress2, lazyComponent, null, renderLanes2);
	        var nextState = workInProgress2.memoizedState;
	        lazyComponent = nextState.cache;
	        pushProvider(workInProgress2, CacheContext, lazyComponent);
	        lazyComponent !== prevState.cache && propagateContextChanges(
	          workInProgress2,
	          [CacheContext],
	          renderLanes2,
	          true
	        );
	        suspendIfUpdateReadFromEntangledAsyncAction();
	        lazyComponent = nextState.element;
	        if (prevState.isDehydrated)
	          if (prevState = {
	            element: lazyComponent,
	            isDehydrated: false,
	            cache: nextState.cache
	          }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
	            workInProgress2 = mountHostRootWithoutHydrating(
	              current,
	              workInProgress2,
	              lazyComponent,
	              renderLanes2
	            );
	            break a;
	          } else if (lazyComponent !== init) {
	            init = createCapturedValueAtFiber(
	              Error(formatProdErrorMessage(424)),
	              workInProgress2
	            );
	            queueHydrationError(init);
	            workInProgress2 = mountHostRootWithoutHydrating(
	              current,
	              workInProgress2,
	              lazyComponent,
	              renderLanes2
	            );
	            break a;
	          } else {
	            current = workInProgress2.stateNode.containerInfo;
	            switch (current.nodeType) {
	              case 9:
	                current = current.body;
	                break;
	              default:
	                current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
	            }
	            nextHydratableInstance = getNextHydratable(current.firstChild);
	            hydrationParentFiber = workInProgress2;
	            isHydrating = true;
	            hydrationErrors = null;
	            rootOrSingletonContext = true;
	            renderLanes2 = mountChildFibers(
	              workInProgress2,
	              null,
	              lazyComponent,
	              renderLanes2
	            );
	            for (workInProgress2.child = renderLanes2; renderLanes2; )
	              renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
	          }
	        else {
	          resetHydrationState();
	          if (lazyComponent === init) {
	            workInProgress2 = bailoutOnAlreadyFinishedWork(
	              current,
	              workInProgress2,
	              renderLanes2
	            );
	            break a;
	          }
	          reconcileChildren(
	            current,
	            workInProgress2,
	            lazyComponent,
	            renderLanes2
	          );
	        }
	        workInProgress2 = workInProgress2.child;
	      }
	      return workInProgress2;
	    case 26:
	      return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
	        workInProgress2.type,
	        null,
	        workInProgress2.pendingProps,
	        null
	      )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, lazyComponent = getOwnerDocumentFromRootContainer(
	        rootInstanceStackCursor.current
	      ).createElement(renderLanes2), lazyComponent[internalInstanceKey] = workInProgress2, lazyComponent[internalPropsKey] = current, setInitialProperties(lazyComponent, renderLanes2, current), markNodeAsHoistable(lazyComponent), workInProgress2.stateNode = lazyComponent) : workInProgress2.memoizedState = getResource(
	        workInProgress2.type,
	        current.memoizedProps,
	        workInProgress2.pendingProps,
	        current.memoizedState
	      ), null;
	    case 27:
	      return pushHostContext(workInProgress2), null === current && isHydrating && (lazyComponent = workInProgress2.stateNode = resolveSingletonInstance(
	        workInProgress2.type,
	        workInProgress2.pendingProps,
	        rootInstanceStackCursor.current
	      ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, init = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = init, nextHydratableInstance = getNextHydratable(
	        lazyComponent.firstChild
	      )) : nextHydratableInstance = init), reconcileChildren(
	        current,
	        workInProgress2,
	        workInProgress2.pendingProps.children,
	        renderLanes2
	      ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
	    case 5:
	      if (null === current && isHydrating) {
	        if (init = lazyComponent = nextHydratableInstance)
	          lazyComponent = canHydrateInstance(
	            lazyComponent,
	            workInProgress2.type,
	            workInProgress2.pendingProps,
	            rootOrSingletonContext
	          ), null !== lazyComponent ? (workInProgress2.stateNode = lazyComponent, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
	            lazyComponent.firstChild
	          ), rootOrSingletonContext = false, init = true) : init = false;
	        init || throwOnHydrationMismatch(workInProgress2);
	      }
	      pushHostContext(workInProgress2);
	      init = workInProgress2.type;
	      prevState = workInProgress2.pendingProps;
	      nextState = null !== current ? current.memoizedProps : null;
	      lazyComponent = prevState.children;
	      shouldSetTextContent(init, prevState) ? lazyComponent = null : null !== nextState && shouldSetTextContent(init, nextState) && (workInProgress2.flags |= 32);
	      null !== workInProgress2.memoizedState && (init = renderWithHooks(
	        current,
	        workInProgress2,
	        TransitionAwareHostComponent,
	        null,
	        null,
	        renderLanes2
	      ), HostTransitionContext._currentValue = init);
	      markRef(current, workInProgress2);
	      reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2);
	      return workInProgress2.child;
	    case 6:
	      if (null === current && isHydrating) {
	        if (current = renderLanes2 = nextHydratableInstance)
	          renderLanes2 = canHydrateTextInstance(
	            renderLanes2,
	            workInProgress2.pendingProps,
	            rootOrSingletonContext
	          ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
	        current || throwOnHydrationMismatch(workInProgress2);
	      }
	      return null;
	    case 13:
	      return updateSuspenseComponent(current, workInProgress2, renderLanes2);
	    case 4:
	      return pushHostContainer(
	        workInProgress2,
	        workInProgress2.stateNode.containerInfo
	      ), lazyComponent = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
	        workInProgress2,
	        null,
	        lazyComponent,
	        renderLanes2
	      ) : reconcileChildren(
	        current,
	        workInProgress2,
	        lazyComponent,
	        renderLanes2
	      ), workInProgress2.child;
	    case 11:
	      return updateForwardRef(
	        current,
	        workInProgress2,
	        workInProgress2.type,
	        workInProgress2.pendingProps,
	        renderLanes2
	      );
	    case 7:
	      return reconcileChildren(
	        current,
	        workInProgress2,
	        workInProgress2.pendingProps,
	        renderLanes2
	      ), workInProgress2.child;
	    case 8:
	      return reconcileChildren(
	        current,
	        workInProgress2,
	        workInProgress2.pendingProps.children,
	        renderLanes2
	      ), workInProgress2.child;
	    case 12:
	      return reconcileChildren(
	        current,
	        workInProgress2,
	        workInProgress2.pendingProps.children,
	        renderLanes2
	      ), workInProgress2.child;
	    case 10:
	      return lazyComponent = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, lazyComponent.value), reconcileChildren(
	        current,
	        workInProgress2,
	        lazyComponent.children,
	        renderLanes2
	      ), workInProgress2.child;
	    case 9:
	      return init = workInProgress2.type._context, lazyComponent = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), init = readContext(init), lazyComponent = lazyComponent(init), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2), workInProgress2.child;
	    case 14:
	      return updateMemoComponent(
	        current,
	        workInProgress2,
	        workInProgress2.type,
	        workInProgress2.pendingProps,
	        renderLanes2
	      );
	    case 15:
	      return updateSimpleMemoComponent(
	        current,
	        workInProgress2,
	        workInProgress2.type,
	        workInProgress2.pendingProps,
	        renderLanes2
	      );
	    case 19:
	      return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
	    case 31:
	      return lazyComponent = workInProgress2.pendingProps, renderLanes2 = workInProgress2.mode, lazyComponent = {
	        mode: lazyComponent.mode,
	        children: lazyComponent.children
	      }, null === current ? (renderLanes2 = mountWorkInProgressOffscreenFiber(
	        lazyComponent,
	        renderLanes2
	      ), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2) : (renderLanes2 = createWorkInProgress(current.child, lazyComponent), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2), workInProgress2;
	    case 22:
	      return updateOffscreenComponent(current, workInProgress2, renderLanes2);
	    case 24:
	      return prepareToReadContext(workInProgress2), lazyComponent = readContext(CacheContext), null === current ? (init = peekCacheFromPool(), null === init && (init = workInProgressRoot, prevState = createCache(), init.pooledCache = prevState, prevState.refCount++, null !== prevState && (init.pooledCacheLanes |= renderLanes2), init = prevState), workInProgress2.memoizedState = {
	        parent: lazyComponent,
	        cache: init
	      }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, init)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), init = current.memoizedState, prevState = workInProgress2.memoizedState, init.parent !== lazyComponent ? (init = { parent: lazyComponent, cache: lazyComponent }, workInProgress2.memoizedState = init, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = init), pushProvider(workInProgress2, CacheContext, lazyComponent)) : (lazyComponent = prevState.cache, pushProvider(workInProgress2, CacheContext, lazyComponent), lazyComponent !== init.cache && propagateContextChanges(
	        workInProgress2,
	        [CacheContext],
	        renderLanes2,
	        true
	      ))), reconcileChildren(
	        current,
	        workInProgress2,
	        workInProgress2.pendingProps.children,
	        renderLanes2
	      ), workInProgress2.child;
	    case 29:
	      throw workInProgress2.pendingProps;
	  }
	  throw Error(formatProdErrorMessage(156, workInProgress2.tag));
	}
	function markUpdate(workInProgress2) {
	  workInProgress2.flags |= 4;
	}
	function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
	  if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
	    workInProgress2.flags &= -16777217;
	  else if (workInProgress2.flags |= 16777216, !preloadResource(resource)) {
	    resource = suspenseHandlerStackCursor.current;
	    if (null !== resource && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary))
	      throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
	    workInProgress2.flags |= 8192;
	  }
	}
	function scheduleRetryEffect(workInProgress2, retryQueue) {
	  null !== retryQueue && (workInProgress2.flags |= 4);
	  workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
	}
	function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
	  if (!isHydrating)
	    switch (renderState.tailMode) {
	      case "hidden":
	        hasRenderedATailFallback = renderState.tail;
	        for (var lastTailNode = null; null !== hasRenderedATailFallback; )
	          null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
	        null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
	        break;
	      case "collapsed":
	        lastTailNode = renderState.tail;
	        for (var lastTailNode$113 = null; null !== lastTailNode; )
	          null !== lastTailNode.alternate && (lastTailNode$113 = lastTailNode), lastTailNode = lastTailNode.sibling;
	        null === lastTailNode$113 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$113.sibling = null;
	    }
	}
	function bubbleProperties(completedWork) {
	  var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
	  if (didBailout)
	    for (var child$114 = completedWork.child; null !== child$114; )
	      newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags & 65011712, subtreeFlags |= child$114.flags & 65011712, child$114.return = completedWork, child$114 = child$114.sibling;
	  else
	    for (child$114 = completedWork.child; null !== child$114; )
	      newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags, subtreeFlags |= child$114.flags, child$114.return = completedWork, child$114 = child$114.sibling;
	  completedWork.subtreeFlags |= subtreeFlags;
	  completedWork.childLanes = newChildLanes;
	  return didBailout;
	}
	function completeWork(current, workInProgress2, renderLanes2) {
	  var newProps = workInProgress2.pendingProps;
	  popTreeContext(workInProgress2);
	  switch (workInProgress2.tag) {
	    case 31:
	    case 16:
	    case 15:
	    case 0:
	    case 11:
	    case 7:
	    case 8:
	    case 12:
	    case 9:
	    case 14:
	      return bubbleProperties(workInProgress2), null;
	    case 1:
	      return bubbleProperties(workInProgress2), null;
	    case 3:
	      renderLanes2 = workInProgress2.stateNode;
	      newProps = null;
	      null !== current && (newProps = current.memoizedState.cache);
	      workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
	      popProvider(CacheContext);
	      popHostContainer();
	      renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
	      if (null === current || null === current.child)
	        popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
	      bubbleProperties(workInProgress2);
	      return null;
	    case 26:
	      return renderLanes2 = workInProgress2.memoizedState, null === current ? (markUpdate(workInProgress2), null !== renderLanes2 ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217)) : renderLanes2 ? renderLanes2 !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current.memoizedProps !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217), null;
	    case 27:
	      popHostContext(workInProgress2);
	      renderLanes2 = rootInstanceStackCursor.current;
	      var type = workInProgress2.type;
	      if (null !== current && null != workInProgress2.stateNode)
	        current.memoizedProps !== newProps && markUpdate(workInProgress2);
	      else {
	        if (!newProps) {
	          if (null === workInProgress2.stateNode)
	            throw Error(formatProdErrorMessage(166));
	          bubbleProperties(workInProgress2);
	          return null;
	        }
	        current = contextStackCursor.current;
	        popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
	      }
	      bubbleProperties(workInProgress2);
	      return null;
	    case 5:
	      popHostContext(workInProgress2);
	      renderLanes2 = workInProgress2.type;
	      if (null !== current && null != workInProgress2.stateNode)
	        current.memoizedProps !== newProps && markUpdate(workInProgress2);
	      else {
	        if (!newProps) {
	          if (null === workInProgress2.stateNode)
	            throw Error(formatProdErrorMessage(166));
	          bubbleProperties(workInProgress2);
	          return null;
	        }
	        current = contextStackCursor.current;
	        if (popHydrationState(workInProgress2))
	          prepareToHydrateHostInstance(workInProgress2);
	        else {
	          type = getOwnerDocumentFromRootContainer(
	            rootInstanceStackCursor.current
	          );
	          switch (current) {
	            case 1:
	              current = type.createElementNS(
	                "http://www.w3.org/2000/svg",
	                renderLanes2
	              );
	              break;
	            case 2:
	              current = type.createElementNS(
	                "http://www.w3.org/1998/Math/MathML",
	                renderLanes2
	              );
	              break;
	            default:
	              switch (renderLanes2) {
	                case "svg":
	                  current = type.createElementNS(
	                    "http://www.w3.org/2000/svg",
	                    renderLanes2
	                  );
	                  break;
	                case "math":
	                  current = type.createElementNS(
	                    "http://www.w3.org/1998/Math/MathML",
	                    renderLanes2
	                  );
	                  break;
	                case "script":
	                  current = type.createElement("div");
	                  current.innerHTML = "<script></script>";
	                  current = current.removeChild(current.firstChild);
	                  break;
	                case "select":
	                  current = "string" === typeof newProps.is ? type.createElement("select", { is: newProps.is }) : type.createElement("select");
	                  newProps.multiple ? current.multiple = true : newProps.size && (current.size = newProps.size);
	                  break;
	                default:
	                  current = "string" === typeof newProps.is ? type.createElement(renderLanes2, { is: newProps.is }) : type.createElement(renderLanes2);
	              }
	          }
	          current[internalInstanceKey] = workInProgress2;
	          current[internalPropsKey] = newProps;
	          a: for (type = workInProgress2.child; null !== type; ) {
	            if (5 === type.tag || 6 === type.tag)
	              current.appendChild(type.stateNode);
	            else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
	              type.child.return = type;
	              type = type.child;
	              continue;
	            }
	            if (type === workInProgress2) break a;
	            for (; null === type.sibling; ) {
	              if (null === type.return || type.return === workInProgress2)
	                break a;
	              type = type.return;
	            }
	            type.sibling.return = type.return;
	            type = type.sibling;
	          }
	          workInProgress2.stateNode = current;
	          a: switch (setInitialProperties(current, renderLanes2, newProps), renderLanes2) {
	            case "button":
	            case "input":
	            case "select":
	            case "textarea":
	              current = !!newProps.autoFocus;
	              break a;
	            case "img":
	              current = true;
	              break a;
	            default:
	              current = false;
	          }
	          current && markUpdate(workInProgress2);
	        }
	      }
	      bubbleProperties(workInProgress2);
	      workInProgress2.flags &= -16777217;
	      return null;
	    case 6:
	      if (current && null != workInProgress2.stateNode)
	        current.memoizedProps !== newProps && markUpdate(workInProgress2);
	      else {
	        if ("string" !== typeof newProps && null === workInProgress2.stateNode)
	          throw Error(formatProdErrorMessage(166));
	        current = rootInstanceStackCursor.current;
	        if (popHydrationState(workInProgress2)) {
	          current = workInProgress2.stateNode;
	          renderLanes2 = workInProgress2.memoizedProps;
	          newProps = null;
	          type = hydrationParentFiber;
	          if (null !== type)
	            switch (type.tag) {
	              case 27:
	              case 5:
	                newProps = type.memoizedProps;
	            }
	          current[internalInstanceKey] = workInProgress2;
	          current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
	          current || throwOnHydrationMismatch(workInProgress2);
	        } else
	          current = getOwnerDocumentFromRootContainer(current).createTextNode(
	            newProps
	          ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
	      }
	      bubbleProperties(workInProgress2);
	      return null;
	    case 13:
	      newProps = workInProgress2.memoizedState;
	      if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
	        type = popHydrationState(workInProgress2);
	        if (null !== newProps && null !== newProps.dehydrated) {
	          if (null === current) {
	            if (!type) throw Error(formatProdErrorMessage(318));
	            type = workInProgress2.memoizedState;
	            type = null !== type ? type.dehydrated : null;
	            if (!type) throw Error(formatProdErrorMessage(317));
	            type[internalInstanceKey] = workInProgress2;
	          } else
	            resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
	          bubbleProperties(workInProgress2);
	          type = false;
	        } else
	          type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
	        if (!type) {
	          if (workInProgress2.flags & 256)
	            return popSuspenseHandler(workInProgress2), workInProgress2;
	          popSuspenseHandler(workInProgress2);
	          return null;
	        }
	      }
	      popSuspenseHandler(workInProgress2);
	      if (0 !== (workInProgress2.flags & 128))
	        return workInProgress2.lanes = renderLanes2, workInProgress2;
	      renderLanes2 = null !== newProps;
	      current = null !== current && null !== current.memoizedState;
	      if (renderLanes2) {
	        newProps = workInProgress2.child;
	        type = null;
	        null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool);
	        var cache$127 = null;
	        null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (cache$127 = newProps.memoizedState.cachePool.pool);
	        cache$127 !== type && (newProps.flags |= 2048);
	      }
	      renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
	      scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
	      bubbleProperties(workInProgress2);
	      return null;
	    case 4:
	      return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
	    case 10:
	      return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
	    case 19:
	      pop(suspenseStackCursor);
	      type = workInProgress2.memoizedState;
	      if (null === type) return bubbleProperties(workInProgress2), null;
	      newProps = 0 !== (workInProgress2.flags & 128);
	      cache$127 = type.rendering;
	      if (null === cache$127)
	        if (newProps) cutOffTailIfNeeded(type, false);
	        else {
	          if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
	            for (current = workInProgress2.child; null !== current; ) {
	              cache$127 = findFirstSuspended(current);
	              if (null !== cache$127) {
	                workInProgress2.flags |= 128;
	                cutOffTailIfNeeded(type, false);
	                current = cache$127.updateQueue;
	                workInProgress2.updateQueue = current;
	                scheduleRetryEffect(workInProgress2, current);
	                workInProgress2.subtreeFlags = 0;
	                current = renderLanes2;
	                for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
	                  resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
	                push(
	                  suspenseStackCursor,
	                  suspenseStackCursor.current & 1 | 2
	                );
	                return workInProgress2.child;
	              }
	              current = current.sibling;
	            }
	          null !== type.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
	        }
	      else {
	        if (!newProps)
	          if (current = findFirstSuspended(cache$127), null !== current) {
	            if (workInProgress2.flags |= 128, newProps = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(type, true), null === type.tail && "hidden" === type.tailMode && !cache$127.alternate && !isHydrating)
	              return bubbleProperties(workInProgress2), null;
	          } else
	            2 * now() - type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
	        type.isBackwards ? (cache$127.sibling = workInProgress2.child, workInProgress2.child = cache$127) : (current = type.last, null !== current ? current.sibling = cache$127 : workInProgress2.child = cache$127, type.last = cache$127);
	      }
	      if (null !== type.tail)
	        return workInProgress2 = type.tail, type.rendering = workInProgress2, type.tail = workInProgress2.sibling, type.renderingStartTime = now(), workInProgress2.sibling = null, current = suspenseStackCursor.current, push(suspenseStackCursor, newProps ? current & 1 | 2 : current & 1), workInProgress2;
	      bubbleProperties(workInProgress2);
	      return null;
	    case 22:
	    case 23:
	      return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
	    case 24:
	      return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
	    case 25:
	      return null;
	    case 30:
	      return null;
	  }
	  throw Error(formatProdErrorMessage(156, workInProgress2.tag));
	}
	function unwindWork(current, workInProgress2) {
	  popTreeContext(workInProgress2);
	  switch (workInProgress2.tag) {
	    case 1:
	      return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
	    case 3:
	      return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
	    case 26:
	    case 27:
	    case 5:
	      return popHostContext(workInProgress2), null;
	    case 13:
	      popSuspenseHandler(workInProgress2);
	      current = workInProgress2.memoizedState;
	      if (null !== current && null !== current.dehydrated) {
	        if (null === workInProgress2.alternate)
	          throw Error(formatProdErrorMessage(340));
	        resetHydrationState();
	      }
	      current = workInProgress2.flags;
	      return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
	    case 19:
	      return pop(suspenseStackCursor), null;
	    case 4:
	      return popHostContainer(), null;
	    case 10:
	      return popProvider(workInProgress2.type), null;
	    case 22:
	    case 23:
	      return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
	    case 24:
	      return popProvider(CacheContext), null;
	    case 25:
	      return null;
	    default:
	      return null;
	  }
	}
	function unwindInterruptedWork(current, interruptedWork) {
	  popTreeContext(interruptedWork);
	  switch (interruptedWork.tag) {
	    case 3:
	      popProvider(CacheContext);
	      popHostContainer();
	      break;
	    case 26:
	    case 27:
	    case 5:
	      popHostContext(interruptedWork);
	      break;
	    case 4:
	      popHostContainer();
	      break;
	    case 13:
	      popSuspenseHandler(interruptedWork);
	      break;
	    case 19:
	      pop(suspenseStackCursor);
	      break;
	    case 10:
	      popProvider(interruptedWork.type);
	      break;
	    case 22:
	    case 23:
	      popSuspenseHandler(interruptedWork);
	      popHiddenContext();
	      null !== current && pop(resumedCache);
	      break;
	    case 24:
	      popProvider(CacheContext);
	  }
	}
	function commitHookEffectListMount(flags, finishedWork) {
	  try {
	    var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
	    if (null !== lastEffect) {
	      var firstEffect = lastEffect.next;
	      updateQueue = firstEffect;
	      do {
	        if ((updateQueue.tag & flags) === flags) {
	          lastEffect = void 0;
	          var create = updateQueue.create, inst = updateQueue.inst;
	          lastEffect = create();
	          inst.destroy = lastEffect;
	        }
	        updateQueue = updateQueue.next;
	      } while (updateQueue !== firstEffect);
	    }
	  } catch (error) {
	    captureCommitPhaseError(finishedWork, finishedWork.return, error);
	  }
	}
	function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
	  try {
	    var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
	    if (null !== lastEffect) {
	      var firstEffect = lastEffect.next;
	      updateQueue = firstEffect;
	      do {
	        if ((updateQueue.tag & flags) === flags) {
	          var inst = updateQueue.inst, destroy = inst.destroy;
	          if (void 0 !== destroy) {
	            inst.destroy = void 0;
	            lastEffect = finishedWork;
	            var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
	            try {
	              destroy_();
	            } catch (error) {
	              captureCommitPhaseError(
	                lastEffect,
	                nearestMountedAncestor,
	                error
	              );
	            }
	          }
	        }
	        updateQueue = updateQueue.next;
	      } while (updateQueue !== firstEffect);
	    }
	  } catch (error) {
	    captureCommitPhaseError(finishedWork, finishedWork.return, error);
	  }
	}
	function commitClassCallbacks(finishedWork) {
	  var updateQueue = finishedWork.updateQueue;
	  if (null !== updateQueue) {
	    var instance = finishedWork.stateNode;
	    try {
	      commitCallbacks(updateQueue, instance);
	    } catch (error) {
	      captureCommitPhaseError(finishedWork, finishedWork.return, error);
	    }
	  }
	}
	function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
	  instance.props = resolveClassComponentProps(
	    current.type,
	    current.memoizedProps
	  );
	  instance.state = current.memoizedState;
	  try {
	    instance.componentWillUnmount();
	  } catch (error) {
	    captureCommitPhaseError(current, nearestMountedAncestor, error);
	  }
	}
	function safelyAttachRef(current, nearestMountedAncestor) {
	  try {
	    var ref = current.ref;
	    if (null !== ref) {
	      switch (current.tag) {
	        case 26:
	        case 27:
	        case 5:
	          var instanceToUse = current.stateNode;
	          break;
	        case 30:
	          instanceToUse = current.stateNode;
	          break;
	        default:
	          instanceToUse = current.stateNode;
	      }
	      "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
	    }
	  } catch (error) {
	    captureCommitPhaseError(current, nearestMountedAncestor, error);
	  }
	}
	function safelyDetachRef(current, nearestMountedAncestor) {
	  var ref = current.ref, refCleanup = current.refCleanup;
	  if (null !== ref)
	    if ("function" === typeof refCleanup)
	      try {
	        refCleanup();
	      } catch (error) {
	        captureCommitPhaseError(current, nearestMountedAncestor, error);
	      } finally {
	        current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
	      }
	    else if ("function" === typeof ref)
	      try {
	        ref(null);
	      } catch (error$143) {
	        captureCommitPhaseError(current, nearestMountedAncestor, error$143);
	      }
	    else ref.current = null;
	}
	function commitHostMount(finishedWork) {
	  var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
	  try {
	    a: switch (type) {
	      case "button":
	      case "input":
	      case "select":
	      case "textarea":
	        props.autoFocus && instance.focus();
	        break a;
	      case "img":
	        props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
	    }
	  } catch (error) {
	    captureCommitPhaseError(finishedWork, finishedWork.return, error);
	  }
	}
	function commitHostUpdate(finishedWork, newProps, oldProps) {
	  try {
	    var domElement = finishedWork.stateNode;
	    updateProperties(domElement, finishedWork.type, oldProps, newProps);
	    domElement[internalPropsKey] = newProps;
	  } catch (error) {
	    captureCommitPhaseError(finishedWork, finishedWork.return, error);
	  }
	}
	function isHostParent(fiber) {
	  return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
	}
	function getHostSibling(fiber) {
	  a: for (; ; ) {
	    for (; null === fiber.sibling; ) {
	      if (null === fiber.return || isHostParent(fiber.return)) return null;
	      fiber = fiber.return;
	    }
	    fiber.sibling.return = fiber.return;
	    for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
	      if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
	      if (fiber.flags & 2) continue a;
	      if (null === fiber.child || 4 === fiber.tag) continue a;
	      else fiber.child.return = fiber, fiber = fiber.child;
	    }
	    if (!(fiber.flags & 2)) return fiber.stateNode;
	  }
	}
	function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
	  var tag = node.tag;
	  if (5 === tag || 6 === tag)
	    node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
	  else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
	    for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
	      insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
	}
	function insertOrAppendPlacementNode(node, before, parent) {
	  var tag = node.tag;
	  if (5 === tag || 6 === tag)
	    node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
	  else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
	    for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
	      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
	}
	function commitHostSingletonAcquisition(finishedWork) {
	  var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
	  try {
	    for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
	      singleton.removeAttributeNode(attributes[0]);
	    setInitialProperties(singleton, type, props);
	    singleton[internalInstanceKey] = finishedWork;
	    singleton[internalPropsKey] = props;
	  } catch (error) {
	    captureCommitPhaseError(finishedWork, finishedWork.return, error);
	  }
	}
	var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null;
	function commitBeforeMutationEffects(root2, firstChild) {
	  root2 = root2.containerInfo;
	  eventsEnabled = _enabled;
	  root2 = getActiveElementDeep(root2);
	  if (hasSelectionCapabilities(root2)) {
	    if ("selectionStart" in root2)
	      var JSCompiler_temp = {
	        start: root2.selectionStart,
	        end: root2.selectionEnd
	      };
	    else
	      a: {
	        JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
	        var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
	        if (selection && 0 !== selection.rangeCount) {
	          JSCompiler_temp = selection.anchorNode;
	          var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
	          selection = selection.focusOffset;
	          try {
	            JSCompiler_temp.nodeType, focusNode.nodeType;
	          } catch (e$20) {
	            JSCompiler_temp = null;
	            break a;
	          }
	          var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
	          b: for (; ; ) {
	            for (var next; ; ) {
	              node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
	              node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
	              3 === node.nodeType && (length += node.nodeValue.length);
	              if (null === (next = node.firstChild)) break;
	              parentNode = node;
	              node = next;
	            }
	            for (; ; ) {
	              if (node === root2) break b;
	              parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
	              parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
	              if (null !== (next = node.nextSibling)) break;
	              node = parentNode;
	              parentNode = node.parentNode;
	            }
	            node = next;
	          }
	          JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
	        } else JSCompiler_temp = null;
	      }
	    JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
	  } else JSCompiler_temp = null;
	  selectionInformation = { focusedElem: root2, selectionRange: JSCompiler_temp };
	  _enabled = false;
	  for (nextEffect = firstChild; null !== nextEffect; )
	    if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1024) && null !== root2)
	      root2.return = firstChild, nextEffect = root2;
	    else
	      for (; null !== nextEffect; ) {
	        firstChild = nextEffect;
	        focusNode = firstChild.alternate;
	        root2 = firstChild.flags;
	        switch (firstChild.tag) {
	          case 0:
	            break;
	          case 11:
	          case 15:
	            break;
	          case 1:
	            if (0 !== (root2 & 1024) && null !== focusNode) {
	              root2 = void 0;
	              JSCompiler_temp = firstChild;
	              anchorOffset = focusNode.memoizedProps;
	              focusNode = focusNode.memoizedState;
	              selection = JSCompiler_temp.stateNode;
	              try {
	                var resolvedPrevProps = resolveClassComponentProps(
	                  JSCompiler_temp.type,
	                  anchorOffset,
	                  JSCompiler_temp.elementType === JSCompiler_temp.type
	                );
	                root2 = selection.getSnapshotBeforeUpdate(
	                  resolvedPrevProps,
	                  focusNode
	                );
	                selection.__reactInternalSnapshotBeforeUpdate = root2;
	              } catch (error) {
	                captureCommitPhaseError(
	                  JSCompiler_temp,
	                  JSCompiler_temp.return,
	                  error
	                );
	              }
	            }
	            break;
	          case 3:
	            if (0 !== (root2 & 1024)) {
	              if (root2 = firstChild.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
	                clearContainerSparingly(root2);
	              else if (1 === JSCompiler_temp)
	                switch (root2.nodeName) {
	                  case "HEAD":
	                  case "HTML":
	                  case "BODY":
	                    clearContainerSparingly(root2);
	                    break;
	                  default:
	                    root2.textContent = "";
	                }
	            }
	            break;
	          case 5:
	          case 26:
	          case 27:
	          case 6:
	          case 4:
	          case 17:
	            break;
	          default:
	            if (0 !== (root2 & 1024)) throw Error(formatProdErrorMessage(163));
	        }
	        root2 = firstChild.sibling;
	        if (null !== root2) {
	          root2.return = firstChild.return;
	          nextEffect = root2;
	          break;
	        }
	        nextEffect = firstChild.return;
	      }
	}
	function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
	  var flags = finishedWork.flags;
	  switch (finishedWork.tag) {
	    case 0:
	    case 11:
	    case 15:
	      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	      flags & 4 && commitHookEffectListMount(5, finishedWork);
	      break;
	    case 1:
	      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	      if (flags & 4)
	        if (finishedRoot = finishedWork.stateNode, null === current)
	          try {
	            finishedRoot.componentDidMount();
	          } catch (error) {
	            captureCommitPhaseError(finishedWork, finishedWork.return, error);
	          }
	        else {
	          var prevProps = resolveClassComponentProps(
	            finishedWork.type,
	            current.memoizedProps
	          );
	          current = current.memoizedState;
	          try {
	            finishedRoot.componentDidUpdate(
	              prevProps,
	              current,
	              finishedRoot.__reactInternalSnapshotBeforeUpdate
	            );
	          } catch (error$142) {
	            captureCommitPhaseError(
	              finishedWork,
	              finishedWork.return,
	              error$142
	            );
	          }
	        }
	      flags & 64 && commitClassCallbacks(finishedWork);
	      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
	      break;
	    case 3:
	      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	      if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
	        current = null;
	        if (null !== finishedWork.child)
	          switch (finishedWork.child.tag) {
	            case 27:
	            case 5:
	              current = finishedWork.child.stateNode;
	              break;
	            case 1:
	              current = finishedWork.child.stateNode;
	          }
	        try {
	          commitCallbacks(finishedRoot, current);
	        } catch (error) {
	          captureCommitPhaseError(finishedWork, finishedWork.return, error);
	        }
	      }
	      break;
	    case 27:
	      null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
	    case 26:
	    case 5:
	      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	      null === current && flags & 4 && commitHostMount(finishedWork);
	      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
	      break;
	    case 12:
	      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	      break;
	    case 13:
	      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	      flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
	      flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
	        null,
	        finishedWork
	      ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
	      break;
	    case 22:
	      flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
	      if (!flags) {
	        current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
	        prevProps = offscreenSubtreeIsHidden;
	        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
	        offscreenSubtreeIsHidden = flags;
	        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          0 !== (finishedWork.subtreeFlags & 8772)
	        ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	        offscreenSubtreeIsHidden = prevProps;
	        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
	      }
	      break;
	    case 30:
	      break;
	    default:
	      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	  }
	}
	function detachFiberAfterEffects(fiber) {
	  var alternate = fiber.alternate;
	  null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
	  fiber.child = null;
	  fiber.deletions = null;
	  fiber.sibling = null;
	  5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
	  fiber.stateNode = null;
	  fiber.return = null;
	  fiber.dependencies = null;
	  fiber.memoizedProps = null;
	  fiber.memoizedState = null;
	  fiber.pendingProps = null;
	  fiber.stateNode = null;
	  fiber.updateQueue = null;
	}
	var hostParent = null, hostParentIsContainer = false;
	function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
	  for (parent = parent.child; null !== parent; )
	    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
	}
	function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
	  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
	    try {
	      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
	    } catch (err) {
	    }
	  switch (deletedFiber.tag) {
	    case 26:
	      offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
	      recursivelyTraverseDeletionEffects(
	        finishedRoot,
	        nearestMountedAncestor,
	        deletedFiber
	      );
	      deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
	      break;
	    case 27:
	      offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
	      var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
	      isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
	      recursivelyTraverseDeletionEffects(
	        finishedRoot,
	        nearestMountedAncestor,
	        deletedFiber
	      );
	      releaseSingletonInstance(deletedFiber.stateNode);
	      hostParent = prevHostParent;
	      hostParentIsContainer = prevHostParentIsContainer;
	      break;
	    case 5:
	      offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
	    case 6:
	      prevHostParent = hostParent;
	      prevHostParentIsContainer = hostParentIsContainer;
	      hostParent = null;
	      recursivelyTraverseDeletionEffects(
	        finishedRoot,
	        nearestMountedAncestor,
	        deletedFiber
	      );
	      hostParent = prevHostParent;
	      hostParentIsContainer = prevHostParentIsContainer;
	      if (null !== hostParent)
	        if (hostParentIsContainer)
	          try {
	            (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
	          } catch (error) {
	            captureCommitPhaseError(
	              deletedFiber,
	              nearestMountedAncestor,
	              error
	            );
	          }
	        else
	          try {
	            hostParent.removeChild(deletedFiber.stateNode);
	          } catch (error) {
	            captureCommitPhaseError(
	              deletedFiber,
	              nearestMountedAncestor,
	              error
	            );
	          }
	      break;
	    case 18:
	      null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearSuspenseBoundary(
	        9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
	        deletedFiber.stateNode
	      ), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
	      break;
	    case 4:
	      prevHostParent = hostParent;
	      prevHostParentIsContainer = hostParentIsContainer;
	      hostParent = deletedFiber.stateNode.containerInfo;
	      hostParentIsContainer = true;
	      recursivelyTraverseDeletionEffects(
	        finishedRoot,
	        nearestMountedAncestor,
	        deletedFiber
	      );
	      hostParent = prevHostParent;
	      hostParentIsContainer = prevHostParentIsContainer;
	      break;
	    case 0:
	    case 11:
	    case 14:
	    case 15:
	      offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
	      offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
	      recursivelyTraverseDeletionEffects(
	        finishedRoot,
	        nearestMountedAncestor,
	        deletedFiber
	      );
	      break;
	    case 1:
	      offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
	        deletedFiber,
	        nearestMountedAncestor,
	        prevHostParent
	      ));
	      recursivelyTraverseDeletionEffects(
	        finishedRoot,
	        nearestMountedAncestor,
	        deletedFiber
	      );
	      break;
	    case 21:
	      recursivelyTraverseDeletionEffects(
	        finishedRoot,
	        nearestMountedAncestor,
	        deletedFiber
	      );
	      break;
	    case 22:
	      offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
	      recursivelyTraverseDeletionEffects(
	        finishedRoot,
	        nearestMountedAncestor,
	        deletedFiber
	      );
	      offscreenSubtreeWasHidden = prevHostParent;
	      break;
	    default:
	      recursivelyTraverseDeletionEffects(
	        finishedRoot,
	        nearestMountedAncestor,
	        deletedFiber
	      );
	  }
	}
	function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
	  if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
	    try {
	      retryIfBlockedOn(finishedRoot);
	    } catch (error) {
	      captureCommitPhaseError(finishedWork, finishedWork.return, error);
	    }
	}
	function getRetryCache(finishedWork) {
	  switch (finishedWork.tag) {
	    case 13:
	    case 19:
	      var retryCache = finishedWork.stateNode;
	      null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
	      return retryCache;
	    case 22:
	      return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
	    default:
	      throw Error(formatProdErrorMessage(435, finishedWork.tag));
	  }
	}
	function attachSuspenseRetryListeners(finishedWork, wakeables) {
	  var retryCache = getRetryCache(finishedWork);
	  wakeables.forEach(function(wakeable) {
	    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
	    retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
	  });
	}
	function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
	  var deletions = parentFiber.deletions;
	  if (null !== deletions)
	    for (var i = 0; i < deletions.length; i++) {
	      var childToDelete = deletions[i], root2 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
	      a: for (; null !== parent; ) {
	        switch (parent.tag) {
	          case 27:
	            if (isSingletonScope(parent.type)) {
	              hostParent = parent.stateNode;
	              hostParentIsContainer = false;
	              break a;
	            }
	            break;
	          case 5:
	            hostParent = parent.stateNode;
	            hostParentIsContainer = false;
	            break a;
	          case 3:
	          case 4:
	            hostParent = parent.stateNode.containerInfo;
	            hostParentIsContainer = true;
	            break a;
	        }
	        parent = parent.return;
	      }
	      if (null === hostParent) throw Error(formatProdErrorMessage(160));
	      commitDeletionEffectsOnFiber(root2, returnFiber, childToDelete);
	      hostParent = null;
	      hostParentIsContainer = false;
	      root2 = childToDelete.alternate;
	      null !== root2 && (root2.return = null);
	      childToDelete.return = null;
	    }
	  if (parentFiber.subtreeFlags & 13878)
	    for (parentFiber = parentFiber.child; null !== parentFiber; )
	      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
	}
	var currentHoistableRoot = null;
	function commitMutationEffectsOnFiber(finishedWork, root2) {
	  var current = finishedWork.alternate, flags = finishedWork.flags;
	  switch (finishedWork.tag) {
	    case 0:
	    case 11:
	    case 14:
	    case 15:
	      recursivelyTraverseMutationEffects(root2, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
	      break;
	    case 1:
	      recursivelyTraverseMutationEffects(root2, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
	      flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
	      break;
	    case 26:
	      var hoistableRoot = currentHoistableRoot;
	      recursivelyTraverseMutationEffects(root2, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
	      if (flags & 4) {
	        var currentResource = null !== current ? current.memoizedState : null;
	        flags = finishedWork.memoizedState;
	        if (null === current)
	          if (null === flags)
	            if (null === finishedWork.stateNode) {
	              a: {
	                flags = finishedWork.type;
	                current = finishedWork.memoizedProps;
	                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
	                b: switch (flags) {
	                  case "title":
	                    currentResource = hoistableRoot.getElementsByTagName("title")[0];
	                    if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
	                      currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
	                        currentResource,
	                        hoistableRoot.querySelector("head > title")
	                      );
	                    setInitialProperties(currentResource, flags, current);
	                    currentResource[internalInstanceKey] = finishedWork;
	                    markNodeAsHoistable(currentResource);
	                    flags = currentResource;
	                    break a;
	                  case "link":
	                    var maybeNodes = getHydratableHoistableCache(
	                      "link",
	                      "href",
	                      hoistableRoot
	                    ).get(flags + (current.href || ""));
	                    if (maybeNodes) {
	                      for (var i = 0; i < maybeNodes.length; i++)
	                        if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
	                          maybeNodes.splice(i, 1);
	                          break b;
	                        }
	                    }
	                    currentResource = hoistableRoot.createElement(flags);
	                    setInitialProperties(currentResource, flags, current);
	                    hoistableRoot.head.appendChild(currentResource);
	                    break;
	                  case "meta":
	                    if (maybeNodes = getHydratableHoistableCache(
	                      "meta",
	                      "content",
	                      hoistableRoot
	                    ).get(flags + (current.content || ""))) {
	                      for (i = 0; i < maybeNodes.length; i++)
	                        if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
	                          maybeNodes.splice(i, 1);
	                          break b;
	                        }
	                    }
	                    currentResource = hoistableRoot.createElement(flags);
	                    setInitialProperties(currentResource, flags, current);
	                    hoistableRoot.head.appendChild(currentResource);
	                    break;
	                  default:
	                    throw Error(formatProdErrorMessage(468, flags));
	                }
	                currentResource[internalInstanceKey] = finishedWork;
	                markNodeAsHoistable(currentResource);
	                flags = currentResource;
	              }
	              finishedWork.stateNode = flags;
	            } else
	              mountHoistable(
	                hoistableRoot,
	                finishedWork.type,
	                finishedWork.stateNode
	              );
	          else
	            finishedWork.stateNode = acquireResource(
	              hoistableRoot,
	              flags,
	              finishedWork.memoizedProps
	            );
	        else
	          currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
	            hoistableRoot,
	            finishedWork.type,
	            finishedWork.stateNode
	          ) : acquireResource(
	            hoistableRoot,
	            flags,
	            finishedWork.memoizedProps
	          )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
	            finishedWork,
	            finishedWork.memoizedProps,
	            current.memoizedProps
	          );
	      }
	      break;
	    case 27:
	      recursivelyTraverseMutationEffects(root2, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
	      null !== current && flags & 4 && commitHostUpdate(
	        finishedWork,
	        finishedWork.memoizedProps,
	        current.memoizedProps
	      );
	      break;
	    case 5:
	      recursivelyTraverseMutationEffects(root2, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
	      if (finishedWork.flags & 32) {
	        hoistableRoot = finishedWork.stateNode;
	        try {
	          setTextContent(hoistableRoot, "");
	        } catch (error) {
	          captureCommitPhaseError(finishedWork, finishedWork.return, error);
	        }
	      }
	      flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
	        finishedWork,
	        hoistableRoot,
	        null !== current ? current.memoizedProps : hoistableRoot
	      ));
	      flags & 1024 && (needsFormReset = true);
	      break;
	    case 6:
	      recursivelyTraverseMutationEffects(root2, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      if (flags & 4) {
	        if (null === finishedWork.stateNode)
	          throw Error(formatProdErrorMessage(162));
	        flags = finishedWork.memoizedProps;
	        current = finishedWork.stateNode;
	        try {
	          current.nodeValue = flags;
	        } catch (error) {
	          captureCommitPhaseError(finishedWork, finishedWork.return, error);
	        }
	      }
	      break;
	    case 3:
	      tagCaches = null;
	      hoistableRoot = currentHoistableRoot;
	      currentHoistableRoot = getHoistableRoot(root2.containerInfo);
	      recursivelyTraverseMutationEffects(root2, finishedWork);
	      currentHoistableRoot = hoistableRoot;
	      commitReconciliationEffects(finishedWork);
	      if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
	        try {
	          retryIfBlockedOn(root2.containerInfo);
	        } catch (error) {
	          captureCommitPhaseError(finishedWork, finishedWork.return, error);
	        }
	      needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
	      break;
	    case 4:
	      flags = currentHoistableRoot;
	      currentHoistableRoot = getHoistableRoot(
	        finishedWork.stateNode.containerInfo
	      );
	      recursivelyTraverseMutationEffects(root2, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      currentHoistableRoot = flags;
	      break;
	    case 12:
	      recursivelyTraverseMutationEffects(root2, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      break;
	    case 13:
	      recursivelyTraverseMutationEffects(root2, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
	      flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
	      break;
	    case 22:
	      hoistableRoot = null !== finishedWork.memoizedState;
	      var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
	      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
	      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
	      recursivelyTraverseMutationEffects(root2, finishedWork);
	      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
	      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
	      commitReconciliationEffects(finishedWork);
	      if (flags & 8192)
	        a: for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & -2 : root2._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root2 = finishedWork; ; ) {
	          if (5 === root2.tag || 26 === root2.tag) {
	            if (null === current) {
	              wasHidden = current = root2;
	              try {
	                if (currentResource = wasHidden.stateNode, hoistableRoot)
	                  maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
	                else {
	                  i = wasHidden.stateNode;
	                  var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
	                  i.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
	                }
	              } catch (error) {
	                captureCommitPhaseError(wasHidden, wasHidden.return, error);
	              }
	            }
	          } else if (6 === root2.tag) {
	            if (null === current) {
	              wasHidden = root2;
	              try {
	                wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
	              } catch (error) {
	                captureCommitPhaseError(wasHidden, wasHidden.return, error);
	              }
	            }
	          } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
	            root2.child.return = root2;
	            root2 = root2.child;
	            continue;
	          }
	          if (root2 === finishedWork) break a;
	          for (; null === root2.sibling; ) {
	            if (null === root2.return || root2.return === finishedWork) break a;
	            current === root2 && (current = null);
	            root2 = root2.return;
	          }
	          current === root2 && (current = null);
	          root2.sibling.return = root2.return;
	          root2 = root2.sibling;
	        }
	      flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
	      break;
	    case 19:
	      recursivelyTraverseMutationEffects(root2, finishedWork);
	      commitReconciliationEffects(finishedWork);
	      flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
	      break;
	    case 30:
	      break;
	    case 21:
	      break;
	    default:
	      recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
	  }
	}
	function commitReconciliationEffects(finishedWork) {
	  var flags = finishedWork.flags;
	  if (flags & 2) {
	    try {
	      for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
	        if (isHostParent(parentFiber)) {
	          hostParentFiber = parentFiber;
	          break;
	        }
	        parentFiber = parentFiber.return;
	      }
	      if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
	      switch (hostParentFiber.tag) {
	        case 27:
	          var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
	          insertOrAppendPlacementNode(finishedWork, before, parent);
	          break;
	        case 5:
	          var parent$144 = hostParentFiber.stateNode;
	          hostParentFiber.flags & 32 && (setTextContent(parent$144, ""), hostParentFiber.flags &= -33);
	          var before$145 = getHostSibling(finishedWork);
	          insertOrAppendPlacementNode(finishedWork, before$145, parent$144);
	          break;
	        case 3:
	        case 4:
	          var parent$146 = hostParentFiber.stateNode.containerInfo, before$147 = getHostSibling(finishedWork);
	          insertOrAppendPlacementNodeIntoContainer(
	            finishedWork,
	            before$147,
	            parent$146
	          );
	          break;
	        default:
	          throw Error(formatProdErrorMessage(161));
	      }
	    } catch (error) {
	      captureCommitPhaseError(finishedWork, finishedWork.return, error);
	    }
	    finishedWork.flags &= -3;
	  }
	  flags & 4096 && (finishedWork.flags &= -4097);
	}
	function recursivelyResetForms(parentFiber) {
	  if (parentFiber.subtreeFlags & 1024)
	    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
	      var fiber = parentFiber;
	      recursivelyResetForms(fiber);
	      5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
	      parentFiber = parentFiber.sibling;
	    }
	}
	function recursivelyTraverseLayoutEffects(root2, parentFiber) {
	  if (parentFiber.subtreeFlags & 8772)
	    for (parentFiber = parentFiber.child; null !== parentFiber; )
	      commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
	}
	function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
	  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
	    var finishedWork = parentFiber;
	    switch (finishedWork.tag) {
	      case 0:
	      case 11:
	      case 14:
	      case 15:
	        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
	        recursivelyTraverseDisappearLayoutEffects(finishedWork);
	        break;
	      case 1:
	        safelyDetachRef(finishedWork, finishedWork.return);
	        var instance = finishedWork.stateNode;
	        "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
	          finishedWork,
	          finishedWork.return,
	          instance
	        );
	        recursivelyTraverseDisappearLayoutEffects(finishedWork);
	        break;
	      case 27:
	        releaseSingletonInstance(finishedWork.stateNode);
	      case 26:
	      case 5:
	        safelyDetachRef(finishedWork, finishedWork.return);
	        recursivelyTraverseDisappearLayoutEffects(finishedWork);
	        break;
	      case 22:
	        null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
	        break;
	      case 30:
	        recursivelyTraverseDisappearLayoutEffects(finishedWork);
	        break;
	      default:
	        recursivelyTraverseDisappearLayoutEffects(finishedWork);
	    }
	    parentFiber = parentFiber.sibling;
	  }
	}
	function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
	  includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
	  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
	    var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
	    switch (finishedWork.tag) {
	      case 0:
	      case 11:
	      case 15:
	        recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          includeWorkInProgressEffects
	        );
	        commitHookEffectListMount(4, finishedWork);
	        break;
	      case 1:
	        recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          includeWorkInProgressEffects
	        );
	        current = finishedWork;
	        finishedRoot = current.stateNode;
	        if ("function" === typeof finishedRoot.componentDidMount)
	          try {
	            finishedRoot.componentDidMount();
	          } catch (error) {
	            captureCommitPhaseError(current, current.return, error);
	          }
	        current = finishedWork;
	        finishedRoot = current.updateQueue;
	        if (null !== finishedRoot) {
	          var instance = current.stateNode;
	          try {
	            var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
	            if (null !== hiddenCallbacks)
	              for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
	                callCallback(hiddenCallbacks[finishedRoot], instance);
	          } catch (error) {
	            captureCommitPhaseError(current, current.return, error);
	          }
	        }
	        includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
	        safelyAttachRef(finishedWork, finishedWork.return);
	        break;
	      case 27:
	        commitHostSingletonAcquisition(finishedWork);
	      case 26:
	      case 5:
	        recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          includeWorkInProgressEffects
	        );
	        includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
	        safelyAttachRef(finishedWork, finishedWork.return);
	        break;
	      case 12:
	        recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          includeWorkInProgressEffects
	        );
	        break;
	      case 13:
	        recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          includeWorkInProgressEffects
	        );
	        includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
	        break;
	      case 22:
	        null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          includeWorkInProgressEffects
	        );
	        safelyAttachRef(finishedWork, finishedWork.return);
	        break;
	      case 30:
	        break;
	      default:
	        recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          includeWorkInProgressEffects
	        );
	    }
	    parentFiber = parentFiber.sibling;
	  }
	}
	function commitOffscreenPassiveMountEffects(current, finishedWork) {
	  var previousCache = null;
	  null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
	  current = null;
	  null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
	  current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
	}
	function commitCachePassiveMountEffect(current, finishedWork) {
	  current = null;
	  null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
	  finishedWork = finishedWork.memoizedState.cache;
	  finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
	}
	function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
	  if (parentFiber.subtreeFlags & 10256)
	    for (parentFiber = parentFiber.child; null !== parentFiber; )
	      commitPassiveMountOnFiber(
	        root2,
	        parentFiber,
	        committedLanes,
	        committedTransitions
	      ), parentFiber = parentFiber.sibling;
	}
	function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
	  var flags = finishedWork.flags;
	  switch (finishedWork.tag) {
	    case 0:
	    case 11:
	    case 15:
	      recursivelyTraversePassiveMountEffects(
	        finishedRoot,
	        finishedWork,
	        committedLanes,
	        committedTransitions
	      );
	      flags & 2048 && commitHookEffectListMount(9, finishedWork);
	      break;
	    case 1:
	      recursivelyTraversePassiveMountEffects(
	        finishedRoot,
	        finishedWork,
	        committedLanes,
	        committedTransitions
	      );
	      break;
	    case 3:
	      recursivelyTraversePassiveMountEffects(
	        finishedRoot,
	        finishedWork,
	        committedLanes,
	        committedTransitions
	      );
	      flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
	      break;
	    case 12:
	      if (flags & 2048) {
	        recursivelyTraversePassiveMountEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions
	        );
	        finishedRoot = finishedWork.stateNode;
	        try {
	          var _finishedWork$memoize2 = finishedWork.memoizedProps, id = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
	          "function" === typeof onPostCommit && onPostCommit(
	            id,
	            null === finishedWork.alternate ? "mount" : "update",
	            finishedRoot.passiveEffectDuration,
	            -0
	          );
	        } catch (error) {
	          captureCommitPhaseError(finishedWork, finishedWork.return, error);
	        }
	      } else
	        recursivelyTraversePassiveMountEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions
	        );
	      break;
	    case 13:
	      recursivelyTraversePassiveMountEffects(
	        finishedRoot,
	        finishedWork,
	        committedLanes,
	        committedTransitions
	      );
	      break;
	    case 23:
	      break;
	    case 22:
	      _finishedWork$memoize2 = finishedWork.stateNode;
	      id = finishedWork.alternate;
	      null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
	        finishedRoot,
	        finishedWork,
	        committedLanes,
	        committedTransitions
	      ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
	        finishedRoot,
	        finishedWork,
	        committedLanes,
	        committedTransitions
	      ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
	        finishedRoot,
	        finishedWork,
	        committedLanes,
	        committedTransitions,
	        0 !== (finishedWork.subtreeFlags & 10256)
	      ));
	      flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
	      break;
	    case 24:
	      recursivelyTraversePassiveMountEffects(
	        finishedRoot,
	        finishedWork,
	        committedLanes,
	        committedTransitions
	      );
	      flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
	      break;
	    default:
	      recursivelyTraversePassiveMountEffects(
	        finishedRoot,
	        finishedWork,
	        committedLanes,
	        committedTransitions
	      );
	  }
	}
	function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
	  includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
	  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
	    var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
	    switch (finishedWork.tag) {
	      case 0:
	      case 11:
	      case 15:
	        recursivelyTraverseReconnectPassiveEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions,
	          includeWorkInProgressEffects
	        );
	        commitHookEffectListMount(8, finishedWork);
	        break;
	      case 23:
	        break;
	      case 22:
	        var instance = finishedWork.stateNode;
	        null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions,
	          includeWorkInProgressEffects
	        ) : recursivelyTraverseAtomicPassiveEffects(
	          finishedRoot,
	          finishedWork
	        ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions,
	          includeWorkInProgressEffects
	        ));
	        includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
	          finishedWork.alternate,
	          finishedWork
	        );
	        break;
	      case 24:
	        recursivelyTraverseReconnectPassiveEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions,
	          includeWorkInProgressEffects
	        );
	        includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
	        break;
	      default:
	        recursivelyTraverseReconnectPassiveEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions,
	          includeWorkInProgressEffects
	        );
	    }
	    parentFiber = parentFiber.sibling;
	  }
	}
	function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
	  if (parentFiber.subtreeFlags & 10256)
	    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
	      var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
	      switch (finishedWork.tag) {
	        case 22:
	          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
	          flags & 2048 && commitOffscreenPassiveMountEffects(
	            finishedWork.alternate,
	            finishedWork
	          );
	          break;
	        case 24:
	          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
	          flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
	          break;
	        default:
	          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
	      }
	      parentFiber = parentFiber.sibling;
	    }
	}
	var suspenseyCommitFlag = 8192;
	function recursivelyAccumulateSuspenseyCommit(parentFiber) {
	  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
	    for (parentFiber = parentFiber.child; null !== parentFiber; )
	      accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
	}
	function accumulateSuspenseyCommitOnFiber(fiber) {
	  switch (fiber.tag) {
	    case 26:
	      recursivelyAccumulateSuspenseyCommit(fiber);
	      fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
	        currentHoistableRoot,
	        fiber.memoizedState,
	        fiber.memoizedProps
	      );
	      break;
	    case 5:
	      recursivelyAccumulateSuspenseyCommit(fiber);
	      break;
	    case 3:
	    case 4:
	      var previousHoistableRoot = currentHoistableRoot;
	      currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
	      recursivelyAccumulateSuspenseyCommit(fiber);
	      currentHoistableRoot = previousHoistableRoot;
	      break;
	    case 22:
	      null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
	      break;
	    default:
	      recursivelyAccumulateSuspenseyCommit(fiber);
	  }
	}
	function detachAlternateSiblings(parentFiber) {
	  var previousFiber = parentFiber.alternate;
	  if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
	    previousFiber.child = null;
	    do
	      previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
	    while (null !== parentFiber);
	  }
	}
	function recursivelyTraversePassiveUnmountEffects(parentFiber) {
	  var deletions = parentFiber.deletions;
	  if (0 !== (parentFiber.flags & 16)) {
	    if (null !== deletions)
	      for (var i = 0; i < deletions.length; i++) {
	        var childToDelete = deletions[i];
	        nextEffect = childToDelete;
	        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
	          childToDelete,
	          parentFiber
	        );
	      }
	    detachAlternateSiblings(parentFiber);
	  }
	  if (parentFiber.subtreeFlags & 10256)
	    for (parentFiber = parentFiber.child; null !== parentFiber; )
	      commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
	}
	function commitPassiveUnmountOnFiber(finishedWork) {
	  switch (finishedWork.tag) {
	    case 0:
	    case 11:
	    case 15:
	      recursivelyTraversePassiveUnmountEffects(finishedWork);
	      finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
	      break;
	    case 3:
	      recursivelyTraversePassiveUnmountEffects(finishedWork);
	      break;
	    case 12:
	      recursivelyTraversePassiveUnmountEffects(finishedWork);
	      break;
	    case 22:
	      var instance = finishedWork.stateNode;
	      null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
	      break;
	    default:
	      recursivelyTraversePassiveUnmountEffects(finishedWork);
	  }
	}
	function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
	  var deletions = parentFiber.deletions;
	  if (0 !== (parentFiber.flags & 16)) {
	    if (null !== deletions)
	      for (var i = 0; i < deletions.length; i++) {
	        var childToDelete = deletions[i];
	        nextEffect = childToDelete;
	        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
	          childToDelete,
	          parentFiber
	        );
	      }
	    detachAlternateSiblings(parentFiber);
	  }
	  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
	    deletions = parentFiber;
	    switch (deletions.tag) {
	      case 0:
	      case 11:
	      case 15:
	        commitHookEffectListUnmount(8, deletions, deletions.return);
	        recursivelyTraverseDisconnectPassiveEffects(deletions);
	        break;
	      case 22:
	        i = deletions.stateNode;
	        i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
	        break;
	      default:
	        recursivelyTraverseDisconnectPassiveEffects(deletions);
	    }
	    parentFiber = parentFiber.sibling;
	  }
	}
	function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
	  for (; null !== nextEffect; ) {
	    var fiber = nextEffect;
	    switch (fiber.tag) {
	      case 0:
	      case 11:
	      case 15:
	        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
	        break;
	      case 23:
	      case 22:
	        if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
	          var cache = fiber.memoizedState.cachePool.pool;
	          null != cache && cache.refCount++;
	        }
	        break;
	      case 24:
	        releaseCache(fiber.memoizedState.cache);
	    }
	    cache = fiber.child;
	    if (null !== cache) cache.return = fiber, nextEffect = cache;
	    else
	      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
	        cache = nextEffect;
	        var sibling = cache.sibling, returnFiber = cache.return;
	        detachFiberAfterEffects(cache);
	        if (cache === fiber) {
	          nextEffect = null;
	          break a;
	        }
	        if (null !== sibling) {
	          sibling.return = returnFiber;
	          nextEffect = sibling;
	          break a;
	        }
	        nextEffect = returnFiber;
	      }
	  }
	}
	var DefaultAsyncDispatcher = {
	  getCacheForType: function(resourceType) {
	    var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
	    void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
	    return cacheForType;
	  }
	}, PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
	function requestUpdateLane() {
	  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
	    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
	  if (null !== ReactSharedInternals.T) {
	    var actionScopeLane = currentEntangledLane;
	    return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
	  }
	  return resolveUpdatePriority();
	}
	function requestDeferredLane() {
	  0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
	  var suspenseHandler = suspenseHandlerStackCursor.current;
	  null !== suspenseHandler && (suspenseHandler.flags |= 32);
	  return workInProgressDeferredLane;
	}
	function scheduleUpdateOnFiber(root2, fiber, lane) {
	  if (root2 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
	    prepareFreshStack(root2, 0), markRootSuspended(
	      root2,
	      workInProgressRootRenderLanes,
	      workInProgressDeferredLane,
	      false
	    );
	  markRootUpdated$1(root2, lane);
	  if (0 === (executionContext & 2) || root2 !== workInProgressRoot)
	    root2 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
	      root2,
	      workInProgressRootRenderLanes,
	      workInProgressDeferredLane,
	      false
	    )), ensureRootIsScheduled(root2);
	}
	function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
	  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
	  var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
	  do {
	    if (0 === exitStatus) {
	      workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
	      break;
	    } else {
	      forceSync = root$jscomp$0.current.alternate;
	      if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
	        exitStatus = renderRootSync(root$jscomp$0, lanes, false);
	        renderWasConcurrent = false;
	        continue;
	      }
	      if (2 === exitStatus) {
	        renderWasConcurrent = lanes;
	        if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
	          var JSCompiler_inline_result = 0;
	        else
	          JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
	        if (0 !== JSCompiler_inline_result) {
	          lanes = JSCompiler_inline_result;
	          a: {
	            var root2 = root$jscomp$0;
	            exitStatus = workInProgressRootConcurrentErrors;
	            var wasRootDehydrated = root2.current.memoizedState.isDehydrated;
	            wasRootDehydrated && (prepareFreshStack(root2, JSCompiler_inline_result).flags |= 256);
	            JSCompiler_inline_result = renderRootSync(
	              root2,
	              JSCompiler_inline_result,
	              false
	            );
	            if (2 !== JSCompiler_inline_result) {
	              if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
	                root2.errorRecoveryDisabledLanes |= renderWasConcurrent;
	                workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
	                exitStatus = 4;
	                break a;
	              }
	              renderWasConcurrent = workInProgressRootRecoverableErrors;
	              workInProgressRootRecoverableErrors = exitStatus;
	              null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
	                workInProgressRootRecoverableErrors,
	                renderWasConcurrent
	              ));
	            }
	            exitStatus = JSCompiler_inline_result;
	          }
	          renderWasConcurrent = false;
	          if (2 !== exitStatus) continue;
	        }
	      }
	      if (1 === exitStatus) {
	        prepareFreshStack(root$jscomp$0, 0);
	        markRootSuspended(root$jscomp$0, lanes, 0, true);
	        break;
	      }
	      a: {
	        shouldTimeSlice = root$jscomp$0;
	        renderWasConcurrent = exitStatus;
	        switch (renderWasConcurrent) {
	          case 0:
	          case 1:
	            throw Error(formatProdErrorMessage(345));
	          case 4:
	            if ((lanes & 4194048) !== lanes) break;
	          case 6:
	            markRootSuspended(
	              shouldTimeSlice,
	              lanes,
	              workInProgressDeferredLane,
	              !workInProgressRootDidSkipSuspendedSiblings
	            );
	            break a;
	          case 2:
	            workInProgressRootRecoverableErrors = null;
	            break;
	          case 3:
	          case 5:
	            break;
	          default:
	            throw Error(formatProdErrorMessage(329));
	        }
	        if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
	          markRootSuspended(
	            shouldTimeSlice,
	            lanes,
	            workInProgressDeferredLane,
	            !workInProgressRootDidSkipSuspendedSiblings
	          );
	          if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
	          shouldTimeSlice.timeoutHandle = scheduleTimeout(
	            commitRootWhenReady.bind(
	              null,
	              shouldTimeSlice,
	              forceSync,
	              workInProgressRootRecoverableErrors,
	              workInProgressTransitions,
	              workInProgressRootDidIncludeRecursiveRenderUpdate,
	              lanes,
	              workInProgressDeferredLane,
	              workInProgressRootInterleavedUpdatedLanes,
	              workInProgressSuspendedRetryLanes,
	              workInProgressRootDidSkipSuspendedSiblings,
	              renderWasConcurrent,
	              2,
	              -0,
	              0
	            ),
	            exitStatus
	          );
	          break a;
	        }
	        commitRootWhenReady(
	          shouldTimeSlice,
	          forceSync,
	          workInProgressRootRecoverableErrors,
	          workInProgressTransitions,
	          workInProgressRootDidIncludeRecursiveRenderUpdate,
	          lanes,
	          workInProgressDeferredLane,
	          workInProgressRootInterleavedUpdatedLanes,
	          workInProgressSuspendedRetryLanes,
	          workInProgressRootDidSkipSuspendedSiblings,
	          renderWasConcurrent,
	          0,
	          -0,
	          0
	        );
	      }
	    }
	    break;
	  } while (1);
	  ensureRootIsScheduled(root$jscomp$0);
	}
	function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
	  root2.timeoutHandle = -1;
	  suspendedCommitReason = finishedWork.subtreeFlags;
	  if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
	    if (suspendedState = { stylesheets: null, count: 0, unsuspend: noop }, accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {
	      root2.cancelPendingCommit = suspendedCommitReason(
	        commitRoot.bind(
	          null,
	          root2,
	          finishedWork,
	          lanes,
	          recoverableErrors,
	          transitions,
	          didIncludeRenderPhaseUpdate,
	          spawnedLane,
	          updatedLanes,
	          suspendedRetryLanes,
	          exitStatus,
	          1,
	          completedRenderStartTime,
	          completedRenderEndTime
	        )
	      );
	      markRootSuspended(root2, lanes, spawnedLane, !didSkipSuspendedSiblings);
	      return;
	    }
	  }
	  commitRoot(
	    root2,
	    finishedWork,
	    lanes,
	    recoverableErrors,
	    transitions,
	    didIncludeRenderPhaseUpdate,
	    spawnedLane,
	    updatedLanes,
	    suspendedRetryLanes
	  );
	}
	function isRenderConsistentWithExternalStores(finishedWork) {
	  for (var node = finishedWork; ; ) {
	    var tag = node.tag;
	    if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
	      for (var i = 0; i < tag.length; i++) {
	        var check = tag[i], getSnapshot = check.getSnapshot;
	        check = check.value;
	        try {
	          if (!objectIs(getSnapshot(), check)) return false;
	        } catch (error) {
	          return false;
	        }
	      }
	    tag = node.child;
	    if (node.subtreeFlags & 16384 && null !== tag)
	      tag.return = node, node = tag;
	    else {
	      if (node === finishedWork) break;
	      for (; null === node.sibling; ) {
	        if (null === node.return || node.return === finishedWork) return true;
	        node = node.return;
	      }
	      node.sibling.return = node.return;
	      node = node.sibling;
	    }
	  }
	  return true;
	}
	function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
	  suspendedLanes &= ~workInProgressRootPingedLanes;
	  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
	  root2.suspendedLanes |= suspendedLanes;
	  root2.pingedLanes &= ~suspendedLanes;
	  didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
	  didAttemptEntireTree = root2.expirationTimes;
	  for (var lanes = suspendedLanes; 0 < lanes; ) {
	    var index$4 = 31 - clz32(lanes), lane = 1 << index$4;
	    didAttemptEntireTree[index$4] = -1;
	    lanes &= ~lane;
	  }
	  0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
	}
	function flushSyncWork$1() {
	  return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0), false) : true;
	}
	function resetWorkInProgressStack() {
	  if (null !== workInProgress) {
	    if (0 === workInProgressSuspendedReason)
	      var interruptedWork = workInProgress.return;
	    else
	      interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
	    for (; null !== interruptedWork; )
	      unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
	    workInProgress = null;
	  }
	}
	function prepareFreshStack(root2, lanes) {
	  var timeoutHandle = root2.timeoutHandle;
	  -1 !== timeoutHandle && (root2.timeoutHandle = -1, cancelTimeout(timeoutHandle));
	  timeoutHandle = root2.cancelPendingCommit;
	  null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
	  resetWorkInProgressStack();
	  workInProgressRoot = root2;
	  workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
	  workInProgressRootRenderLanes = lanes;
	  workInProgressSuspendedReason = 0;
	  workInProgressThrownValue = null;
	  workInProgressRootDidSkipSuspendedSiblings = false;
	  workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
	  workInProgressRootDidAttachPingListener = false;
	  workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
	  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
	  workInProgressRootDidIncludeRecursiveRenderUpdate = false;
	  0 !== (lanes & 8) && (lanes |= lanes & 32);
	  var allEntangledLanes = root2.entangledLanes;
	  if (0 !== allEntangledLanes)
	    for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
	      var index$2 = 31 - clz32(allEntangledLanes), lane = 1 << index$2;
	      lanes |= root2[index$2];
	      allEntangledLanes &= ~lane;
	    }
	  entangledRenderLanes = lanes;
	  finishQueueingConcurrentUpdates();
	  return timeoutHandle;
	}
	function handleThrow(root2, thrownValue) {
	  currentlyRenderingFiber = null;
	  ReactSharedInternals.H = ContextOnlyDispatcher;
	  thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
	  workInProgressThrownValue = thrownValue;
	  null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
	    root2,
	    createCapturedValueAtFiber(thrownValue, root2.current)
	  ));
	}
	function pushDispatcher() {
	  var prevDispatcher = ReactSharedInternals.H;
	  ReactSharedInternals.H = ContextOnlyDispatcher;
	  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
	}
	function pushAsyncDispatcher() {
	  var prevAsyncDispatcher = ReactSharedInternals.A;
	  ReactSharedInternals.A = DefaultAsyncDispatcher;
	  return prevAsyncDispatcher;
	}
	function renderDidSuspendDelayIfPossible() {
	  workInProgressRootExitStatus = 4;
	  workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
	  0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
	    workInProgressRoot,
	    workInProgressRootRenderLanes,
	    workInProgressDeferredLane,
	    false
	  );
	}
	function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
	  var prevExecutionContext = executionContext;
	  executionContext |= 2;
	  var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
	  if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes)
	    workInProgressTransitions = null, prepareFreshStack(root2, lanes);
	  lanes = false;
	  var exitStatus = workInProgressRootExitStatus;
	  a: do
	    try {
	      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
	        var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
	        switch (workInProgressSuspendedReason) {
	          case 8:
	            resetWorkInProgressStack();
	            exitStatus = 6;
	            break a;
	          case 3:
	          case 2:
	          case 9:
	          case 6:
	            null === suspenseHandlerStackCursor.current && (lanes = true);
	            var reason = workInProgressSuspendedReason;
	            workInProgressSuspendedReason = 0;
	            workInProgressThrownValue = null;
	            throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
	            if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
	              exitStatus = 0;
	              break a;
	            }
	            break;
	          default:
	            reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
	        }
	      }
	      workLoopSync();
	      exitStatus = workInProgressRootExitStatus;
	      break;
	    } catch (thrownValue$167) {
	      handleThrow(root2, thrownValue$167);
	    }
	  while (1);
	  lanes && root2.shellSuspendCounter++;
	  lastContextDependency = currentlyRenderingFiber$1 = null;
	  executionContext = prevExecutionContext;
	  ReactSharedInternals.H = prevDispatcher;
	  ReactSharedInternals.A = prevAsyncDispatcher;
	  null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
	  return exitStatus;
	}
	function workLoopSync() {
	  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
	}
	function renderRootConcurrent(root2, lanes) {
	  var prevExecutionContext = executionContext;
	  executionContext |= 2;
	  var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
	  workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root2, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
	    root2,
	    lanes
	  );
	  a: do
	    try {
	      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
	        lanes = workInProgress;
	        var thrownValue = workInProgressThrownValue;
	        b: switch (workInProgressSuspendedReason) {
	          case 1:
	            workInProgressSuspendedReason = 0;
	            workInProgressThrownValue = null;
	            throwAndUnwindWorkLoop(root2, lanes, thrownValue, 1);
	            break;
	          case 2:
	          case 9:
	            if (isThenableResolved(thrownValue)) {
	              workInProgressSuspendedReason = 0;
	              workInProgressThrownValue = null;
	              replaySuspendedUnitOfWork(lanes);
	              break;
	            }
	            lanes = function() {
	              2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root2 || (workInProgressSuspendedReason = 7);
	              ensureRootIsScheduled(root2);
	            };
	            thrownValue.then(lanes, lanes);
	            break a;
	          case 3:
	            workInProgressSuspendedReason = 7;
	            break a;
	          case 4:
	            workInProgressSuspendedReason = 5;
	            break a;
	          case 7:
	            isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, lanes, thrownValue, 7));
	            break;
	          case 5:
	            var resource = null;
	            switch (workInProgress.tag) {
	              case 26:
	                resource = workInProgress.memoizedState;
	              case 5:
	              case 27:
	                var hostFiber = workInProgress;
	                if (resource ? preloadResource(resource) : 1) {
	                  workInProgressSuspendedReason = 0;
	                  workInProgressThrownValue = null;
	                  var sibling = hostFiber.sibling;
	                  if (null !== sibling) workInProgress = sibling;
	                  else {
	                    var returnFiber = hostFiber.return;
	                    null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
	                  }
	                  break b;
	                }
	            }
	            workInProgressSuspendedReason = 0;
	            workInProgressThrownValue = null;
	            throwAndUnwindWorkLoop(root2, lanes, thrownValue, 5);
	            break;
	          case 6:
	            workInProgressSuspendedReason = 0;
	            workInProgressThrownValue = null;
	            throwAndUnwindWorkLoop(root2, lanes, thrownValue, 6);
	            break;
	          case 8:
	            resetWorkInProgressStack();
	            workInProgressRootExitStatus = 6;
	            break a;
	          default:
	            throw Error(formatProdErrorMessage(462));
	        }
	      }
	      workLoopConcurrentByScheduler();
	      break;
	    } catch (thrownValue$169) {
	      handleThrow(root2, thrownValue$169);
	    }
	  while (1);
	  lastContextDependency = currentlyRenderingFiber$1 = null;
	  ReactSharedInternals.H = prevDispatcher;
	  ReactSharedInternals.A = prevAsyncDispatcher;
	  executionContext = prevExecutionContext;
	  if (null !== workInProgress) return 0;
	  workInProgressRoot = null;
	  workInProgressRootRenderLanes = 0;
	  finishQueueingConcurrentUpdates();
	  return workInProgressRootExitStatus;
	}
	function workLoopConcurrentByScheduler() {
	  for (; null !== workInProgress && !shouldYield(); )
	    performUnitOfWork(workInProgress);
	}
	function performUnitOfWork(unitOfWork) {
	  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
	  unitOfWork.memoizedProps = unitOfWork.pendingProps;
	  null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
	}
	function replaySuspendedUnitOfWork(unitOfWork) {
	  var next = unitOfWork;
	  var current = next.alternate;
	  switch (next.tag) {
	    case 15:
	    case 0:
	      next = replayFunctionComponent(
	        current,
	        next,
	        next.pendingProps,
	        next.type,
	        void 0,
	        workInProgressRootRenderLanes
	      );
	      break;
	    case 11:
	      next = replayFunctionComponent(
	        current,
	        next,
	        next.pendingProps,
	        next.type.render,
	        next.ref,
	        workInProgressRootRenderLanes
	      );
	      break;
	    case 5:
	      resetHooksOnUnwind(next);
	    default:
	      unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
	  }
	  unitOfWork.memoizedProps = unitOfWork.pendingProps;
	  null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
	}
	function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
	  lastContextDependency = currentlyRenderingFiber$1 = null;
	  resetHooksOnUnwind(unitOfWork);
	  thenableState = null;
	  thenableIndexCounter = 0;
	  var returnFiber = unitOfWork.return;
	  try {
	    if (throwException(
	      root2,
	      returnFiber,
	      unitOfWork,
	      thrownValue,
	      workInProgressRootRenderLanes
	    )) {
	      workInProgressRootExitStatus = 1;
	      logUncaughtError(
	        root2,
	        createCapturedValueAtFiber(thrownValue, root2.current)
	      );
	      workInProgress = null;
	      return;
	    }
	  } catch (error) {
	    if (null !== returnFiber) throw workInProgress = returnFiber, error;
	    workInProgressRootExitStatus = 1;
	    logUncaughtError(
	      root2,
	      createCapturedValueAtFiber(thrownValue, root2.current)
	    );
	    workInProgress = null;
	    return;
	  }
	  if (unitOfWork.flags & 32768) {
	    if (isHydrating || 1 === suspendedReason) root2 = true;
	    else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
	      root2 = false;
	    else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
	      suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
	    unwindUnitOfWork(unitOfWork, root2);
	  } else completeUnitOfWork(unitOfWork);
	}
	function completeUnitOfWork(unitOfWork) {
	  var completedWork = unitOfWork;
	  do {
	    if (0 !== (completedWork.flags & 32768)) {
	      unwindUnitOfWork(
	        completedWork,
	        workInProgressRootDidSkipSuspendedSiblings
	      );
	      return;
	    }
	    unitOfWork = completedWork.return;
	    var next = completeWork(
	      completedWork.alternate,
	      completedWork,
	      entangledRenderLanes
	    );
	    if (null !== next) {
	      workInProgress = next;
	      return;
	    }
	    completedWork = completedWork.sibling;
	    if (null !== completedWork) {
	      workInProgress = completedWork;
	      return;
	    }
	    workInProgress = completedWork = unitOfWork;
	  } while (null !== completedWork);
	  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
	}
	function unwindUnitOfWork(unitOfWork, skipSiblings) {
	  do {
	    var next = unwindWork(unitOfWork.alternate, unitOfWork);
	    if (null !== next) {
	      next.flags &= 32767;
	      workInProgress = next;
	      return;
	    }
	    next = unitOfWork.return;
	    null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
	    if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
	      workInProgress = unitOfWork;
	      return;
	    }
	    workInProgress = unitOfWork = next;
	  } while (null !== unitOfWork);
	  workInProgressRootExitStatus = 6;
	  workInProgress = null;
	}
	function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
	  root2.cancelPendingCommit = null;
	  do
	    flushPendingEffects();
	  while (0 !== pendingEffectsStatus);
	  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
	  if (null !== finishedWork) {
	    if (finishedWork === root2.current) throw Error(formatProdErrorMessage(177));
	    didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
	    didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
	    markRootFinished(
	      root2,
	      lanes,
	      didIncludeRenderPhaseUpdate,
	      spawnedLane,
	      updatedLanes,
	      suspendedRetryLanes
	    );
	    root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
	    pendingFinishedWork = finishedWork;
	    pendingEffectsRoot = root2;
	    pendingEffectsLanes = lanes;
	    pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
	    pendingPassiveTransitions = transitions;
	    pendingRecoverableErrors = recoverableErrors;
	    0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
	      flushPassiveEffects();
	      return null;
	    })) : (root2.callbackNode = null, root2.callbackPriority = 0);
	    recoverableErrors = 0 !== (finishedWork.flags & 13878);
	    if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
	      recoverableErrors = ReactSharedInternals.T;
	      ReactSharedInternals.T = null;
	      transitions = ReactDOMSharedInternals.p;
	      ReactDOMSharedInternals.p = 2;
	      spawnedLane = executionContext;
	      executionContext |= 4;
	      try {
	        commitBeforeMutationEffects(root2, finishedWork, lanes);
	      } finally {
	        executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
	      }
	    }
	    pendingEffectsStatus = 1;
	    flushMutationEffects();
	    flushLayoutEffects();
	    flushSpawnedWork();
	  }
	}
	function flushMutationEffects() {
	  if (1 === pendingEffectsStatus) {
	    pendingEffectsStatus = 0;
	    var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
	    if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
	      rootMutationHasEffect = ReactSharedInternals.T;
	      ReactSharedInternals.T = null;
	      var previousPriority = ReactDOMSharedInternals.p;
	      ReactDOMSharedInternals.p = 2;
	      var prevExecutionContext = executionContext;
	      executionContext |= 4;
	      try {
	        commitMutationEffectsOnFiber(finishedWork, root2);
	        var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
	        if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
	          priorFocusedElem.ownerDocument.documentElement,
	          priorFocusedElem
	        )) {
	          if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
	            var start = priorSelectionRange.start, end = priorSelectionRange.end;
	            void 0 === end && (end = start);
	            if ("selectionStart" in priorFocusedElem)
	              priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
	                end,
	                priorFocusedElem.value.length
	              );
	            else {
	              var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
	              if (win.getSelection) {
	                var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
	                !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
	                var startMarker = getNodeForCharacterOffset(
	                  priorFocusedElem,
	                  start$jscomp$0
	                ), endMarker = getNodeForCharacterOffset(
	                  priorFocusedElem,
	                  end$jscomp$0
	                );
	                if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
	                  var range = doc.createRange();
	                  range.setStart(startMarker.node, startMarker.offset);
	                  selection.removeAllRanges();
	                  start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
	                }
	              }
	            }
	          }
	          doc = [];
	          for (selection = priorFocusedElem; selection = selection.parentNode; )
	            1 === selection.nodeType && doc.push({
	              element: selection,
	              left: selection.scrollLeft,
	              top: selection.scrollTop
	            });
	          "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
	          for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
	            var info = doc[priorFocusedElem];
	            info.element.scrollLeft = info.left;
	            info.element.scrollTop = info.top;
	          }
	        }
	        _enabled = !!eventsEnabled;
	        selectionInformation = eventsEnabled = null;
	      } finally {
	        executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
	      }
	    }
	    root2.current = finishedWork;
	    pendingEffectsStatus = 2;
	  }
	}
	function flushLayoutEffects() {
	  if (2 === pendingEffectsStatus) {
	    pendingEffectsStatus = 0;
	    var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
	    if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
	      rootHasLayoutEffect = ReactSharedInternals.T;
	      ReactSharedInternals.T = null;
	      var previousPriority = ReactDOMSharedInternals.p;
	      ReactDOMSharedInternals.p = 2;
	      var prevExecutionContext = executionContext;
	      executionContext |= 4;
	      try {
	        commitLayoutEffectOnFiber(root2, finishedWork.alternate, finishedWork);
	      } finally {
	        executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
	      }
	    }
	    pendingEffectsStatus = 3;
	  }
	}
	function flushSpawnedWork() {
	  if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
	    pendingEffectsStatus = 0;
	    requestPaint();
	    var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
	    0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes));
	    var remainingLanes = root2.pendingLanes;
	    0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
	    lanesToEventPriority(lanes);
	    finishedWork = finishedWork.stateNode;
	    if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
	      try {
	        injectedHook.onCommitFiberRoot(
	          rendererID,
	          finishedWork,
	          void 0,
	          128 === (finishedWork.current.flags & 128)
	        );
	      } catch (err) {
	      }
	    if (null !== recoverableErrors) {
	      finishedWork = ReactSharedInternals.T;
	      remainingLanes = ReactDOMSharedInternals.p;
	      ReactDOMSharedInternals.p = 2;
	      ReactSharedInternals.T = null;
	      try {
	        for (var onRecoverableError = root2.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
	          var recoverableError = recoverableErrors[i];
	          onRecoverableError(recoverableError.value, {
	            componentStack: recoverableError.stack
	          });
	        }
	      } finally {
	        ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
	      }
	    }
	    0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
	    ensureRootIsScheduled(root2);
	    remainingLanes = root2.pendingLanes;
	    0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2) : nestedUpdateCount = 0;
	    flushSyncWorkAcrossRoots_impl(0);
	  }
	}
	function releaseRootPooledCache(root2, remainingLanes) {
	  0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
	}
	function flushPendingEffects(wasDelayedCommit) {
	  flushMutationEffects();
	  flushLayoutEffects();
	  flushSpawnedWork();
	  return flushPassiveEffects();
	}
	function flushPassiveEffects() {
	  if (5 !== pendingEffectsStatus) return false;
	  var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
	  pendingEffectsRemainingLanes = 0;
	  var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
	  try {
	    ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
	    ReactSharedInternals.T = null;
	    renderPriority = pendingPassiveTransitions;
	    pendingPassiveTransitions = null;
	    var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
	    pendingEffectsStatus = 0;
	    pendingFinishedWork = pendingEffectsRoot = null;
	    pendingEffectsLanes = 0;
	    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
	    var prevExecutionContext = executionContext;
	    executionContext |= 4;
	    commitPassiveUnmountOnFiber(root$jscomp$0.current);
	    commitPassiveMountOnFiber(
	      root$jscomp$0,
	      root$jscomp$0.current,
	      lanes,
	      renderPriority
	    );
	    executionContext = prevExecutionContext;
	    flushSyncWorkAcrossRoots_impl(0, false);
	    if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
	      try {
	        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
	      } catch (err) {
	      }
	    return true;
	  } finally {
	    ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root2, remainingLanes);
	  }
	}
	function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
	  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
	  sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
	  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
	  null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
	}
	function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
	  if (3 === sourceFiber.tag)
	    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
	  else
	    for (; null !== nearestMountedAncestor; ) {
	      if (3 === nearestMountedAncestor.tag) {
	        captureCommitPhaseErrorOnRoot(
	          nearestMountedAncestor,
	          sourceFiber,
	          error
	        );
	        break;
	      } else if (1 === nearestMountedAncestor.tag) {
	        var instance = nearestMountedAncestor.stateNode;
	        if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
	          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
	          error = createClassErrorUpdate(2);
	          instance = enqueueUpdate(nearestMountedAncestor, error, 2);
	          null !== instance && (initializeClassErrorUpdate(
	            error,
	            instance,
	            nearestMountedAncestor,
	            sourceFiber
	          ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
	          break;
	        }
	      }
	      nearestMountedAncestor = nearestMountedAncestor.return;
	    }
	}
	function attachPingListener(root2, wakeable, lanes) {
	  var pingCache = root2.pingCache;
	  if (null === pingCache) {
	    pingCache = root2.pingCache = new PossiblyWeakMap();
	    var threadIDs = /* @__PURE__ */ new Set();
	    pingCache.set(wakeable, threadIDs);
	  } else
	    threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
	  threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root2 = pingSuspendedRoot.bind(null, root2, wakeable, lanes), wakeable.then(root2, root2));
	}
	function pingSuspendedRoot(root2, wakeable, pingedLanes) {
	  var pingCache = root2.pingCache;
	  null !== pingCache && pingCache.delete(wakeable);
	  root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
	  root2.warmLanes &= ~pingedLanes;
	  workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
	  ensureRootIsScheduled(root2);
	}
	function retryTimedOutBoundary(boundaryFiber, retryLane) {
	  0 === retryLane && (retryLane = claimNextRetryLane());
	  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
	  null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
	}
	function retryDehydratedSuspenseBoundary(boundaryFiber) {
	  var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
	  null !== suspenseState && (retryLane = suspenseState.retryLane);
	  retryTimedOutBoundary(boundaryFiber, retryLane);
	}
	function resolveRetryWakeable(boundaryFiber, wakeable) {
	  var retryLane = 0;
	  switch (boundaryFiber.tag) {
	    case 13:
	      var retryCache = boundaryFiber.stateNode;
	      var suspenseState = boundaryFiber.memoizedState;
	      null !== suspenseState && (retryLane = suspenseState.retryLane);
	      break;
	    case 19:
	      retryCache = boundaryFiber.stateNode;
	      break;
	    case 22:
	      retryCache = boundaryFiber.stateNode._retryCache;
	      break;
	    default:
	      throw Error(formatProdErrorMessage(314));
	  }
	  null !== retryCache && retryCache.delete(wakeable);
	  retryTimedOutBoundary(boundaryFiber, retryLane);
	}
	function scheduleCallback$1(priorityLevel, callback) {
	  return scheduleCallback$3(priorityLevel, callback);
	}
	var firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0;
	function ensureRootIsScheduled(root2) {
	  root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
	  mightHavePendingSyncWork = true;
	  didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
	}
	function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
	  if (!isFlushingWork && mightHavePendingSyncWork) {
	    isFlushingWork = true;
	    do {
	      var didPerformSomeWork = false;
	      for (var root$174 = firstScheduledRoot; null !== root$174; ) {
	        if (0 !== syncTransitionLanes) {
	            var pendingLanes = root$174.pendingLanes;
	            if (0 === pendingLanes) var JSCompiler_inline_result = 0;
	            else {
	              var suspendedLanes = root$174.suspendedLanes, pingedLanes = root$174.pingedLanes;
	              JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
	              JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
	              JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
	            }
	            0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
	          } else
	            JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
	              root$174,
	              root$174 === workInProgressRoot ? JSCompiler_inline_result : 0,
	              null !== root$174.cancelPendingCommit || -1 !== root$174.timeoutHandle
	            ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$174, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
	        root$174 = root$174.next;
	      }
	    } while (didPerformSomeWork);
	    isFlushingWork = false;
	  }
	}
	function processRootScheduleInImmediateTask() {
	  processRootScheduleInMicrotask();
	}
	function processRootScheduleInMicrotask() {
	  mightHavePendingSyncWork = didScheduleMicrotask = false;
	  var syncTransitionLanes = 0;
	  0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
	  for (var currentTime = now(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
	    var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
	    if (0 === nextLanes)
	      root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
	    else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
	      mightHavePendingSyncWork = true;
	    root2 = next;
	  }
	  flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
	}
	function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
	  for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
	    var index$3 = 31 - clz32(lanes), lane = 1 << index$3, expirationTime = expirationTimes[index$3];
	    if (-1 === expirationTime) {
	      if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
	        expirationTimes[index$3] = computeExpirationTime(lane, currentTime);
	    } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
	    lanes &= ~lane;
	  }
	  currentTime = workInProgressRoot;
	  suspendedLanes = workInProgressRootRenderLanes;
	  suspendedLanes = getNextLanes(
	    root2,
	    root2 === currentTime ? suspendedLanes : 0,
	    null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
	  );
	  pingedLanes = root2.callbackNode;
	  if (0 === suspendedLanes || root2 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
	    return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
	  if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
	    currentTime = suspendedLanes & -suspendedLanes;
	    if (currentTime === root2.callbackPriority) return currentTime;
	    null !== pingedLanes && cancelCallback$1(pingedLanes);
	    switch (lanesToEventPriority(suspendedLanes)) {
	      case 2:
	      case 8:
	        suspendedLanes = UserBlockingPriority;
	        break;
	      case 32:
	        suspendedLanes = NormalPriority$1;
	        break;
	      case 268435456:
	        suspendedLanes = IdlePriority;
	        break;
	      default:
	        suspendedLanes = NormalPriority$1;
	    }
	    pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
	    suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
	    root2.callbackPriority = currentTime;
	    root2.callbackNode = suspendedLanes;
	    return currentTime;
	  }
	  null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
	  root2.callbackPriority = 2;
	  root2.callbackNode = null;
	  return 2;
	}
	function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
	  if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
	    return root2.callbackNode = null, root2.callbackPriority = 0, null;
	  var originalCallbackNode = root2.callbackNode;
	  if (flushPendingEffects() && root2.callbackNode !== originalCallbackNode)
	    return null;
	  var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
	  workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
	    root2,
	    root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
	    null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
	  );
	  if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
	  performWorkOnRoot(root2, workInProgressRootRenderLanes$jscomp$0, didTimeout);
	  scheduleTaskForRootDuringMicrotask(root2, now());
	  return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
	}
	function performSyncWorkOnRoot(root2, lanes) {
	  if (flushPendingEffects()) return null;
	  performWorkOnRoot(root2, lanes, true);
	}
	function scheduleImmediateRootScheduleTask() {
	  scheduleMicrotask(function() {
	    0 !== (executionContext & 6) ? scheduleCallback$3(
	      ImmediatePriority,
	      processRootScheduleInImmediateTask
	    ) : processRootScheduleInMicrotask();
	  });
	}
	function requestTransitionLane() {
	  0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
	  return currentEventTransitionLane;
	}
	function coerceFormActionProp(actionProp) {
	  return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
	}
	function createFormDataWithSubmitter(form, submitter) {
	  var temp = submitter.ownerDocument.createElement("input");
	  temp.name = submitter.name;
	  temp.value = submitter.value;
	  form.id && temp.setAttribute("form", form.id);
	  submitter.parentNode.insertBefore(temp, submitter);
	  form = new FormData(form);
	  temp.parentNode.removeChild(temp);
	  return form;
	}
	function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
	  if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
	    var action = coerceFormActionProp(
	      (nativeEventTarget[internalPropsKey] || null).action
	    ), submitter = nativeEvent.submitter;
	    submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
	    var event = new SyntheticEvent(
	      "action",
	      "action",
	      null,
	      nativeEvent,
	      nativeEventTarget
	    );
	    dispatchQueue.push({
	      event,
	      listeners: [
	        {
	          instance: null,
	          listener: function() {
	            if (nativeEvent.defaultPrevented) {
	              if (0 !== currentEventTransitionLane) {
	                var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
	                startHostTransition(
	                  maybeTargetInst,
	                  {
	                    pending: true,
	                    data: formData,
	                    method: nativeEventTarget.method,
	                    action
	                  },
	                  null,
	                  formData
	                );
	              }
	            } else
	              "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
	                maybeTargetInst,
	                {
	                  pending: true,
	                  data: formData,
	                  method: nativeEventTarget.method,
	                  action
	                },
	                action,
	                formData
	              ));
	          },
	          currentTarget: nativeEventTarget
	        }
	      ]
	    });
	  }
	}
	for (var i$jscomp$inline_1528 = 0; i$jscomp$inline_1528 < simpleEventPluginEvents.length; i$jscomp$inline_1528++) {
	  var eventName$jscomp$inline_1529 = simpleEventPluginEvents[i$jscomp$inline_1528], domEventName$jscomp$inline_1530 = eventName$jscomp$inline_1529.toLowerCase(), capitalizedEvent$jscomp$inline_1531 = eventName$jscomp$inline_1529[0].toUpperCase() + eventName$jscomp$inline_1529.slice(1);
	  registerSimpleEvent(
	    domEventName$jscomp$inline_1530,
	    "on" + capitalizedEvent$jscomp$inline_1531
	  );
	}
	registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
	registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
	registerSimpleEvent(ANIMATION_START, "onAnimationStart");
	registerSimpleEvent("dblclick", "onDoubleClick");
	registerSimpleEvent("focusin", "onFocus");
	registerSimpleEvent("focusout", "onBlur");
	registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
	registerSimpleEvent(TRANSITION_START, "onTransitionStart");
	registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
	registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
	registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
	registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
	registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
	registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
	registerTwoPhaseEvent(
	  "onChange",
	  "change click focusin focusout input keydown keyup selectionchange".split(" ")
	);
	registerTwoPhaseEvent(
	  "onSelect",
	  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
	    " "
	  )
	);
	registerTwoPhaseEvent("onBeforeInput", [
	  "compositionend",
	  "keypress",
	  "textInput",
	  "paste"
	]);
	registerTwoPhaseEvent(
	  "onCompositionEnd",
	  "compositionend focusout keydown keypress keyup mousedown".split(" ")
	);
	registerTwoPhaseEvent(
	  "onCompositionStart",
	  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
	);
	registerTwoPhaseEvent(
	  "onCompositionUpdate",
	  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
	);
	var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
	  " "
	), nonDelegatedEvents = new Set(
	  "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
	);
	function processDispatchQueue(dispatchQueue, eventSystemFlags) {
	  eventSystemFlags = 0 !== (eventSystemFlags & 4);
	  for (var i = 0; i < dispatchQueue.length; i++) {
	    var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
	    _dispatchQueue$i = _dispatchQueue$i.listeners;
	    a: {
	      var previousInstance = void 0;
	      if (eventSystemFlags)
	        for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
	          var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
	          _dispatchListeners$i = _dispatchListeners$i.listener;
	          if (instance !== previousInstance && event.isPropagationStopped())
	            break a;
	          previousInstance = _dispatchListeners$i;
	          event.currentTarget = currentTarget;
	          try {
	            previousInstance(event);
	          } catch (error) {
	            reportGlobalError(error);
	          }
	          event.currentTarget = null;
	          previousInstance = instance;
	        }
	      else
	        for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
	          _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
	          instance = _dispatchListeners$i.instance;
	          currentTarget = _dispatchListeners$i.currentTarget;
	          _dispatchListeners$i = _dispatchListeners$i.listener;
	          if (instance !== previousInstance && event.isPropagationStopped())
	            break a;
	          previousInstance = _dispatchListeners$i;
	          event.currentTarget = currentTarget;
	          try {
	            previousInstance(event);
	          } catch (error) {
	            reportGlobalError(error);
	          }
	          event.currentTarget = null;
	          previousInstance = instance;
	        }
	    }
	  }
	}
	function listenToNonDelegatedEvent(domEventName, targetElement) {
	  var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
	  void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
	  var listenerSetKey = domEventName + "__bubble";
	  JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
	}
	function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
	  var eventSystemFlags = 0;
	  isCapturePhaseListener && (eventSystemFlags |= 4);
	  addTrappedEventListener(
	    target,
	    domEventName,
	    eventSystemFlags,
	    isCapturePhaseListener
	  );
	}
	var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
	function listenToAllSupportedEvents(rootContainerElement) {
	  if (!rootContainerElement[listeningMarker]) {
	    rootContainerElement[listeningMarker] = true;
	    allNativeEvents.forEach(function(domEventName) {
	      "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
	    });
	    var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
	    null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
	  }
	}
	function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
	  switch (getEventPriority(domEventName)) {
	    case 2:
	      var listenerWrapper = dispatchDiscreteEvent;
	      break;
	    case 8:
	      listenerWrapper = dispatchContinuousEvent;
	      break;
	    default:
	      listenerWrapper = dispatchEvent;
	  }
	  eventSystemFlags = listenerWrapper.bind(
	    null,
	    domEventName,
	    eventSystemFlags,
	    targetContainer
	  );
	  listenerWrapper = void 0;
	  !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
	  isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
	    capture: true,
	    passive: listenerWrapper
	  }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
	    passive: listenerWrapper
	  }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
	}
	function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
	  var ancestorInst = targetInst$jscomp$0;
	  if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
	    a: for (; ; ) {
	      if (null === targetInst$jscomp$0) return;
	      var nodeTag = targetInst$jscomp$0.tag;
	      if (3 === nodeTag || 4 === nodeTag) {
	        var container = targetInst$jscomp$0.stateNode.containerInfo;
	        if (container === targetContainer) break;
	        if (4 === nodeTag)
	          for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
	            var grandTag = nodeTag.tag;
	            if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
	              return;
	            nodeTag = nodeTag.return;
	          }
	        for (; null !== container; ) {
	          nodeTag = getClosestInstanceFromNode(container);
	          if (null === nodeTag) return;
	          grandTag = nodeTag.tag;
	          if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
	            targetInst$jscomp$0 = ancestorInst = nodeTag;
	            continue a;
	          }
	          container = container.parentNode;
	        }
	      }
	      targetInst$jscomp$0 = targetInst$jscomp$0.return;
	    }
	  batchedUpdates$1(function() {
	    var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
	    a: {
	      var reactName = topLevelEventsToReactNames.get(domEventName);
	      if (void 0 !== reactName) {
	        var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
	        switch (domEventName) {
	          case "keypress":
	            if (0 === getEventCharCode(nativeEvent)) break a;
	          case "keydown":
	          case "keyup":
	            SyntheticEventCtor = SyntheticKeyboardEvent;
	            break;
	          case "focusin":
	            reactEventType = "focus";
	            SyntheticEventCtor = SyntheticFocusEvent;
	            break;
	          case "focusout":
	            reactEventType = "blur";
	            SyntheticEventCtor = SyntheticFocusEvent;
	            break;
	          case "beforeblur":
	          case "afterblur":
	            SyntheticEventCtor = SyntheticFocusEvent;
	            break;
	          case "click":
	            if (2 === nativeEvent.button) break a;
	          case "auxclick":
	          case "dblclick":
	          case "mousedown":
	          case "mousemove":
	          case "mouseup":
	          case "mouseout":
	          case "mouseover":
	          case "contextmenu":
	            SyntheticEventCtor = SyntheticMouseEvent;
	            break;
	          case "drag":
	          case "dragend":
	          case "dragenter":
	          case "dragexit":
	          case "dragleave":
	          case "dragover":
	          case "dragstart":
	          case "drop":
	            SyntheticEventCtor = SyntheticDragEvent;
	            break;
	          case "touchcancel":
	          case "touchend":
	          case "touchmove":
	          case "touchstart":
	            SyntheticEventCtor = SyntheticTouchEvent;
	            break;
	          case ANIMATION_END:
	          case ANIMATION_ITERATION:
	          case ANIMATION_START:
	            SyntheticEventCtor = SyntheticAnimationEvent;
	            break;
	          case TRANSITION_END:
	            SyntheticEventCtor = SyntheticTransitionEvent;
	            break;
	          case "scroll":
	          case "scrollend":
	            SyntheticEventCtor = SyntheticUIEvent;
	            break;
	          case "wheel":
	            SyntheticEventCtor = SyntheticWheelEvent;
	            break;
	          case "copy":
	          case "cut":
	          case "paste":
	            SyntheticEventCtor = SyntheticClipboardEvent;
	            break;
	          case "gotpointercapture":
	          case "lostpointercapture":
	          case "pointercancel":
	          case "pointerdown":
	          case "pointermove":
	          case "pointerout":
	          case "pointerover":
	          case "pointerup":
	            SyntheticEventCtor = SyntheticPointerEvent;
	            break;
	          case "toggle":
	          case "beforetoggle":
	            SyntheticEventCtor = SyntheticToggleEvent;
	        }
	        var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
	        inCapturePhase = [];
	        for (var instance = targetInst, lastHostComponent; null !== instance; ) {
	          var _instance = instance;
	          lastHostComponent = _instance.stateNode;
	          _instance = _instance.tag;
	          5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
	            createDispatchListener(instance, _instance, lastHostComponent)
	          ));
	          if (accumulateTargetOnly) break;
	          instance = instance.return;
	        }
	        0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
	          reactName,
	          reactEventType,
	          null,
	          nativeEvent,
	          nativeEventTarget
	        ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
	      }
	    }
	    if (0 === (eventSystemFlags & 7)) {
	      a: {
	        reactName = "mouseover" === domEventName || "pointerover" === domEventName;
	        SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
	        if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
	          break a;
	        if (SyntheticEventCtor || reactName) {
	          reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
	          if (SyntheticEventCtor) {
	            if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
	              reactEventType = null;
	          } else SyntheticEventCtor = null, reactEventType = targetInst;
	          if (SyntheticEventCtor !== reactEventType) {
	            inCapturePhase = SyntheticMouseEvent;
	            _instance = "onMouseLeave";
	            reactEventName = "onMouseEnter";
	            instance = "mouse";
	            if ("pointerout" === domEventName || "pointerover" === domEventName)
	              inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
	            accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
	            lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
	            reactName = new inCapturePhase(
	              _instance,
	              instance + "leave",
	              SyntheticEventCtor,
	              nativeEvent,
	              nativeEventTarget
	            );
	            reactName.target = accumulateTargetOnly;
	            reactName.relatedTarget = lastHostComponent;
	            _instance = null;
	            getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
	              reactEventName,
	              instance + "enter",
	              reactEventType,
	              nativeEvent,
	              nativeEventTarget
	            ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
	            accumulateTargetOnly = _instance;
	            if (SyntheticEventCtor && reactEventType)
	              b: {
	                inCapturePhase = SyntheticEventCtor;
	                reactEventName = reactEventType;
	                instance = 0;
	                for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))
	                  instance++;
	                lastHostComponent = 0;
	                for (_instance = reactEventName; _instance; _instance = getParent(_instance))
	                  lastHostComponent++;
	                for (; 0 < instance - lastHostComponent; )
	                  inCapturePhase = getParent(inCapturePhase), instance--;
	                for (; 0 < lastHostComponent - instance; )
	                  reactEventName = getParent(reactEventName), lastHostComponent--;
	                for (; instance--; ) {
	                  if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate)
	                    break b;
	                  inCapturePhase = getParent(inCapturePhase);
	                  reactEventName = getParent(reactEventName);
	                }
	                inCapturePhase = null;
	              }
	            else inCapturePhase = null;
	            null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
	              dispatchQueue,
	              reactName,
	              SyntheticEventCtor,
	              inCapturePhase,
	              false
	            );
	            null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
	              dispatchQueue,
	              accumulateTargetOnly,
	              reactEventType,
	              inCapturePhase,
	              true
	            );
	          }
	        }
	      }
	      a: {
	        reactName = targetInst ? getNodeFromInstance(targetInst) : window;
	        SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
	        if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
	          var getTargetInstFunc = getTargetInstForChangeEvent;
	        else if (isTextInputElement(reactName))
	          if (isInputEventSupported)
	            getTargetInstFunc = getTargetInstForInputOrChangeEvent;
	          else {
	            getTargetInstFunc = getTargetInstForInputEventPolyfill;
	            var handleEventFunc = handleEventsForInputEventPolyfill;
	          }
	        else
	          SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
	        if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
	          createAndAccumulateChangeEvent(
	            dispatchQueue,
	            getTargetInstFunc,
	            nativeEvent,
	            nativeEventTarget
	          );
	          break a;
	        }
	        handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
	        "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
	      }
	      handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
	      switch (domEventName) {
	        case "focusin":
	          if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
	            activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
	          break;
	        case "focusout":
	          lastSelection = activeElementInst = activeElement = null;
	          break;
	        case "mousedown":
	          mouseDown = true;
	          break;
	        case "contextmenu":
	        case "mouseup":
	        case "dragend":
	          mouseDown = false;
	          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
	          break;
	        case "selectionchange":
	          if (skipSelectionChangeEvent) break;
	        case "keydown":
	        case "keyup":
	          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
	      }
	      var fallbackData;
	      if (canUseCompositionEvent)
	        b: {
	          switch (domEventName) {
	            case "compositionstart":
	              var eventType = "onCompositionStart";
	              break b;
	            case "compositionend":
	              eventType = "onCompositionEnd";
	              break b;
	            case "compositionupdate":
	              eventType = "onCompositionUpdate";
	              break b;
	          }
	          eventType = void 0;
	        }
	      else
	        isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
	      eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
	        eventType,
	        domEventName,
	        null,
	        nativeEvent,
	        nativeEventTarget
	      ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
	      if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
	        eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
	          "onBeforeInput",
	          "beforeinput",
	          null,
	          nativeEvent,
	          nativeEventTarget
	        ), dispatchQueue.push({
	          event: handleEventFunc,
	          listeners: eventType
	        }), handleEventFunc.data = fallbackData);
	      extractEvents$1(
	        dispatchQueue,
	        domEventName,
	        targetInst,
	        nativeEvent,
	        nativeEventTarget
	      );
	    }
	    processDispatchQueue(dispatchQueue, eventSystemFlags);
	  });
	}
	function createDispatchListener(instance, listener, currentTarget) {
	  return {
	    instance,
	    listener,
	    currentTarget
	  };
	}
	function accumulateTwoPhaseListeners(targetFiber, reactName) {
	  for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
	    var _instance2 = targetFiber, stateNode = _instance2.stateNode;
	    _instance2 = _instance2.tag;
	    5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
	      createDispatchListener(targetFiber, _instance2, stateNode)
	    ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
	      createDispatchListener(targetFiber, _instance2, stateNode)
	    ));
	    if (3 === targetFiber.tag) return listeners;
	    targetFiber = targetFiber.return;
	  }
	  return [];
	}
	function getParent(inst) {
	  if (null === inst) return null;
	  do
	    inst = inst.return;
	  while (inst && 5 !== inst.tag && 27 !== inst.tag);
	  return inst ? inst : null;
	}
	function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
	  for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
	    var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
	    _instance3 = _instance3.tag;
	    if (null !== alternate && alternate === common) break;
	    5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
	      createDispatchListener(target, stateNode, alternate)
	    )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
	      createDispatchListener(target, stateNode, alternate)
	    )));
	    target = target.return;
	  }
	  0 !== listeners.length && dispatchQueue.push({ event, listeners });
	}
	var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
	function normalizeMarkupForTextOrAttribute(markup) {
	  return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
	}
	function checkForUnmatchedText(serverText, clientText) {
	  clientText = normalizeMarkupForTextOrAttribute(clientText);
	  return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
	}
	function noop$1() {
	}
	function setProp(domElement, tag, key, value, props, prevValue) {
	  switch (key) {
	    case "children":
	      "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
	      break;
	    case "className":
	      setValueForKnownAttribute(domElement, "class", value);
	      break;
	    case "tabIndex":
	      setValueForKnownAttribute(domElement, "tabindex", value);
	      break;
	    case "dir":
	    case "role":
	    case "viewBox":
	    case "width":
	    case "height":
	      setValueForKnownAttribute(domElement, key, value);
	      break;
	    case "style":
	      setValueForStyles(domElement, value, prevValue);
	      break;
	    case "data":
	      if ("object" !== tag) {
	        setValueForKnownAttribute(domElement, "data", value);
	        break;
	      }
	    case "src":
	    case "href":
	      if ("" === value && ("a" !== tag || "href" !== key)) {
	        domElement.removeAttribute(key);
	        break;
	      }
	      if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
	        domElement.removeAttribute(key);
	        break;
	      }
	      value = sanitizeURL("" + value);
	      domElement.setAttribute(key, value);
	      break;
	    case "action":
	    case "formAction":
	      if ("function" === typeof value) {
	        domElement.setAttribute(
	          key,
	          "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
	        );
	        break;
	      } else
	        "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
	          domElement,
	          tag,
	          "formEncType",
	          props.formEncType,
	          props,
	          null
	        ), setProp(
	          domElement,
	          tag,
	          "formMethod",
	          props.formMethod,
	          props,
	          null
	        ), setProp(
	          domElement,
	          tag,
	          "formTarget",
	          props.formTarget,
	          props,
	          null
	        )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
	      if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
	        domElement.removeAttribute(key);
	        break;
	      }
	      value = sanitizeURL("" + value);
	      domElement.setAttribute(key, value);
	      break;
	    case "onClick":
	      null != value && (domElement.onclick = noop$1);
	      break;
	    case "onScroll":
	      null != value && listenToNonDelegatedEvent("scroll", domElement);
	      break;
	    case "onScrollEnd":
	      null != value && listenToNonDelegatedEvent("scrollend", domElement);
	      break;
	    case "dangerouslySetInnerHTML":
	      if (null != value) {
	        if ("object" !== typeof value || !("__html" in value))
	          throw Error(formatProdErrorMessage(61));
	        key = value.__html;
	        if (null != key) {
	          if (null != props.children) throw Error(formatProdErrorMessage(60));
	          domElement.innerHTML = key;
	        }
	      }
	      break;
	    case "multiple":
	      domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
	      break;
	    case "muted":
	      domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
	      break;
	    case "suppressContentEditableWarning":
	    case "suppressHydrationWarning":
	    case "defaultValue":
	    case "defaultChecked":
	    case "innerHTML":
	    case "ref":
	      break;
	    case "autoFocus":
	      break;
	    case "xlinkHref":
	      if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
	        domElement.removeAttribute("xlink:href");
	        break;
	      }
	      key = sanitizeURL("" + value);
	      domElement.setAttributeNS(
	        "http://www.w3.org/1999/xlink",
	        "xlink:href",
	        key
	      );
	      break;
	    case "contentEditable":
	    case "spellCheck":
	    case "draggable":
	    case "value":
	    case "autoReverse":
	    case "externalResourcesRequired":
	    case "focusable":
	    case "preserveAlpha":
	      null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
	      break;
	    case "inert":
	    case "allowFullScreen":
	    case "async":
	    case "autoPlay":
	    case "controls":
	    case "default":
	    case "defer":
	    case "disabled":
	    case "disablePictureInPicture":
	    case "disableRemotePlayback":
	    case "formNoValidate":
	    case "hidden":
	    case "loop":
	    case "noModule":
	    case "noValidate":
	    case "open":
	    case "playsInline":
	    case "readOnly":
	    case "required":
	    case "reversed":
	    case "scoped":
	    case "seamless":
	    case "itemScope":
	      value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
	      break;
	    case "capture":
	    case "download":
	      true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
	      break;
	    case "cols":
	    case "rows":
	    case "size":
	    case "span":
	      null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
	      break;
	    case "rowSpan":
	    case "start":
	      null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
	      break;
	    case "popover":
	      listenToNonDelegatedEvent("beforetoggle", domElement);
	      listenToNonDelegatedEvent("toggle", domElement);
	      setValueForAttribute(domElement, "popover", value);
	      break;
	    case "xlinkActuate":
	      setValueForNamespacedAttribute(
	        domElement,
	        "http://www.w3.org/1999/xlink",
	        "xlink:actuate",
	        value
	      );
	      break;
	    case "xlinkArcrole":
	      setValueForNamespacedAttribute(
	        domElement,
	        "http://www.w3.org/1999/xlink",
	        "xlink:arcrole",
	        value
	      );
	      break;
	    case "xlinkRole":
	      setValueForNamespacedAttribute(
	        domElement,
	        "http://www.w3.org/1999/xlink",
	        "xlink:role",
	        value
	      );
	      break;
	    case "xlinkShow":
	      setValueForNamespacedAttribute(
	        domElement,
	        "http://www.w3.org/1999/xlink",
	        "xlink:show",
	        value
	      );
	      break;
	    case "xlinkTitle":
	      setValueForNamespacedAttribute(
	        domElement,
	        "http://www.w3.org/1999/xlink",
	        "xlink:title",
	        value
	      );
	      break;
	    case "xlinkType":
	      setValueForNamespacedAttribute(
	        domElement,
	        "http://www.w3.org/1999/xlink",
	        "xlink:type",
	        value
	      );
	      break;
	    case "xmlBase":
	      setValueForNamespacedAttribute(
	        domElement,
	        "http://www.w3.org/XML/1998/namespace",
	        "xml:base",
	        value
	      );
	      break;
	    case "xmlLang":
	      setValueForNamespacedAttribute(
	        domElement,
	        "http://www.w3.org/XML/1998/namespace",
	        "xml:lang",
	        value
	      );
	      break;
	    case "xmlSpace":
	      setValueForNamespacedAttribute(
	        domElement,
	        "http://www.w3.org/XML/1998/namespace",
	        "xml:space",
	        value
	      );
	      break;
	    case "is":
	      setValueForAttribute(domElement, "is", value);
	      break;
	    case "innerText":
	    case "textContent":
	      break;
	    default:
	      if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
	        key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
	  }
	}
	function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
	  switch (key) {
	    case "style":
	      setValueForStyles(domElement, value, prevValue);
	      break;
	    case "dangerouslySetInnerHTML":
	      if (null != value) {
	        if ("object" !== typeof value || !("__html" in value))
	          throw Error(formatProdErrorMessage(61));
	        key = value.__html;
	        if (null != key) {
	          if (null != props.children) throw Error(formatProdErrorMessage(60));
	          domElement.innerHTML = key;
	        }
	      }
	      break;
	    case "children":
	      "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
	      break;
	    case "onScroll":
	      null != value && listenToNonDelegatedEvent("scroll", domElement);
	      break;
	    case "onScrollEnd":
	      null != value && listenToNonDelegatedEvent("scrollend", domElement);
	      break;
	    case "onClick":
	      null != value && (domElement.onclick = noop$1);
	      break;
	    case "suppressContentEditableWarning":
	    case "suppressHydrationWarning":
	    case "innerHTML":
	    case "ref":
	      break;
	    case "innerText":
	    case "textContent":
	      break;
	    default:
	      if (!registrationNameDependencies.hasOwnProperty(key))
	        a: {
	          if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
	            "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
	            domElement.addEventListener(tag, value, props);
	            break a;
	          }
	          key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
	        }
	  }
	}
	function setInitialProperties(domElement, tag, props) {
	  switch (tag) {
	    case "div":
	    case "span":
	    case "svg":
	    case "path":
	    case "a":
	    case "g":
	    case "p":
	    case "li":
	      break;
	    case "img":
	      listenToNonDelegatedEvent("error", domElement);
	      listenToNonDelegatedEvent("load", domElement);
	      var hasSrc = false, hasSrcSet = false, propKey;
	      for (propKey in props)
	        if (props.hasOwnProperty(propKey)) {
	          var propValue = props[propKey];
	          if (null != propValue)
	            switch (propKey) {
	              case "src":
	                hasSrc = true;
	                break;
	              case "srcSet":
	                hasSrcSet = true;
	                break;
	              case "children":
	              case "dangerouslySetInnerHTML":
	                throw Error(formatProdErrorMessage(137, tag));
	              default:
	                setProp(domElement, tag, propKey, propValue, props, null);
	            }
	        }
	      hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
	      hasSrc && setProp(domElement, tag, "src", props.src, props, null);
	      return;
	    case "input":
	      listenToNonDelegatedEvent("invalid", domElement);
	      var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
	      for (hasSrc in props)
	        if (props.hasOwnProperty(hasSrc)) {
	          var propValue$188 = props[hasSrc];
	          if (null != propValue$188)
	            switch (hasSrc) {
	              case "name":
	                hasSrcSet = propValue$188;
	                break;
	              case "type":
	                propValue = propValue$188;
	                break;
	              case "checked":
	                checked = propValue$188;
	                break;
	              case "defaultChecked":
	                defaultChecked = propValue$188;
	                break;
	              case "value":
	                propKey = propValue$188;
	                break;
	              case "defaultValue":
	                defaultValue = propValue$188;
	                break;
	              case "children":
	              case "dangerouslySetInnerHTML":
	                if (null != propValue$188)
	                  throw Error(formatProdErrorMessage(137, tag));
	                break;
	              default:
	                setProp(domElement, tag, hasSrc, propValue$188, props, null);
	            }
	        }
	      initInput(
	        domElement,
	        propKey,
	        defaultValue,
	        checked,
	        defaultChecked,
	        propValue,
	        hasSrcSet,
	        false
	      );
	      track(domElement);
	      return;
	    case "select":
	      listenToNonDelegatedEvent("invalid", domElement);
	      hasSrc = propValue = propKey = null;
	      for (hasSrcSet in props)
	        if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
	          switch (hasSrcSet) {
	            case "value":
	              propKey = defaultValue;
	              break;
	            case "defaultValue":
	              propValue = defaultValue;
	              break;
	            case "multiple":
	              hasSrc = defaultValue;
	            default:
	              setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
	          }
	      tag = propKey;
	      props = propValue;
	      domElement.multiple = !!hasSrc;
	      null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
	      return;
	    case "textarea":
	      listenToNonDelegatedEvent("invalid", domElement);
	      propKey = hasSrcSet = hasSrc = null;
	      for (propValue in props)
	        if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
	          switch (propValue) {
	            case "value":
	              hasSrc = defaultValue;
	              break;
	            case "defaultValue":
	              hasSrcSet = defaultValue;
	              break;
	            case "children":
	              propKey = defaultValue;
	              break;
	            case "dangerouslySetInnerHTML":
	              if (null != defaultValue) throw Error(formatProdErrorMessage(91));
	              break;
	            default:
	              setProp(domElement, tag, propValue, defaultValue, props, null);
	          }
	      initTextarea(domElement, hasSrc, hasSrcSet, propKey);
	      track(domElement);
	      return;
	    case "option":
	      for (checked in props)
	        if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
	          switch (checked) {
	            case "selected":
	              domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
	              break;
	            default:
	              setProp(domElement, tag, checked, hasSrc, props, null);
	          }
	      return;
	    case "dialog":
	      listenToNonDelegatedEvent("beforetoggle", domElement);
	      listenToNonDelegatedEvent("toggle", domElement);
	      listenToNonDelegatedEvent("cancel", domElement);
	      listenToNonDelegatedEvent("close", domElement);
	      break;
	    case "iframe":
	    case "object":
	      listenToNonDelegatedEvent("load", domElement);
	      break;
	    case "video":
	    case "audio":
	      for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
	        listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
	      break;
	    case "image":
	      listenToNonDelegatedEvent("error", domElement);
	      listenToNonDelegatedEvent("load", domElement);
	      break;
	    case "details":
	      listenToNonDelegatedEvent("toggle", domElement);
	      break;
	    case "embed":
	    case "source":
	    case "link":
	      listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
	    case "area":
	    case "base":
	    case "br":
	    case "col":
	    case "hr":
	    case "keygen":
	    case "meta":
	    case "param":
	    case "track":
	    case "wbr":
	    case "menuitem":
	      for (defaultChecked in props)
	        if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
	          switch (defaultChecked) {
	            case "children":
	            case "dangerouslySetInnerHTML":
	              throw Error(formatProdErrorMessage(137, tag));
	            default:
	              setProp(domElement, tag, defaultChecked, hasSrc, props, null);
	          }
	      return;
	    default:
	      if (isCustomElement(tag)) {
	        for (propValue$188 in props)
	          props.hasOwnProperty(propValue$188) && (hasSrc = props[propValue$188], void 0 !== hasSrc && setPropOnCustomElement(
	            domElement,
	            tag,
	            propValue$188,
	            hasSrc,
	            props,
	            void 0
	          ));
	        return;
	      }
	  }
	  for (defaultValue in props)
	    props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
	}
	function updateProperties(domElement, tag, lastProps, nextProps) {
	  switch (tag) {
	    case "div":
	    case "span":
	    case "svg":
	    case "path":
	    case "a":
	    case "g":
	    case "p":
	    case "li":
	      break;
	    case "input":
	      var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
	      for (propKey in lastProps) {
	        var lastProp = lastProps[propKey];
	        if (lastProps.hasOwnProperty(propKey) && null != lastProp)
	          switch (propKey) {
	            case "checked":
	              break;
	            case "value":
	              break;
	            case "defaultValue":
	              lastDefaultValue = lastProp;
	            default:
	              nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
	          }
	      }
	      for (var propKey$205 in nextProps) {
	        var propKey = nextProps[propKey$205];
	        lastProp = lastProps[propKey$205];
	        if (nextProps.hasOwnProperty(propKey$205) && (null != propKey || null != lastProp))
	          switch (propKey$205) {
	            case "type":
	              type = propKey;
	              break;
	            case "name":
	              name = propKey;
	              break;
	            case "checked":
	              checked = propKey;
	              break;
	            case "defaultChecked":
	              defaultChecked = propKey;
	              break;
	            case "value":
	              value = propKey;
	              break;
	            case "defaultValue":
	              defaultValue = propKey;
	              break;
	            case "children":
	            case "dangerouslySetInnerHTML":
	              if (null != propKey)
	                throw Error(formatProdErrorMessage(137, tag));
	              break;
	            default:
	              propKey !== lastProp && setProp(
	                domElement,
	                tag,
	                propKey$205,
	                propKey,
	                nextProps,
	                lastProp
	              );
	          }
	      }
	      updateInput(
	        domElement,
	        value,
	        defaultValue,
	        lastDefaultValue,
	        checked,
	        defaultChecked,
	        type,
	        name
	      );
	      return;
	    case "select":
	      propKey = value = defaultValue = propKey$205 = null;
	      for (type in lastProps)
	        if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
	          switch (type) {
	            case "value":
	              break;
	            case "multiple":
	              propKey = lastDefaultValue;
	            default:
	              nextProps.hasOwnProperty(type) || setProp(
	                domElement,
	                tag,
	                type,
	                null,
	                nextProps,
	                lastDefaultValue
	              );
	          }
	      for (name in nextProps)
	        if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
	          switch (name) {
	            case "value":
	              propKey$205 = type;
	              break;
	            case "defaultValue":
	              defaultValue = type;
	              break;
	            case "multiple":
	              value = type;
	            default:
	              type !== lastDefaultValue && setProp(
	                domElement,
	                tag,
	                name,
	                type,
	                nextProps,
	                lastDefaultValue
	              );
	          }
	      tag = defaultValue;
	      lastProps = value;
	      nextProps = propKey;
	      null != propKey$205 ? updateOptions(domElement, !!lastProps, propKey$205, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
	      return;
	    case "textarea":
	      propKey = propKey$205 = null;
	      for (defaultValue in lastProps)
	        if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
	          switch (defaultValue) {
	            case "value":
	              break;
	            case "children":
	              break;
	            default:
	              setProp(domElement, tag, defaultValue, null, nextProps, name);
	          }
	      for (value in nextProps)
	        if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
	          switch (value) {
	            case "value":
	              propKey$205 = name;
	              break;
	            case "defaultValue":
	              propKey = name;
	              break;
	            case "children":
	              break;
	            case "dangerouslySetInnerHTML":
	              if (null != name) throw Error(formatProdErrorMessage(91));
	              break;
	            default:
	              name !== type && setProp(domElement, tag, value, name, nextProps, type);
	          }
	      updateTextarea(domElement, propKey$205, propKey);
	      return;
	    case "option":
	      for (var propKey$221 in lastProps)
	        if (propKey$205 = lastProps[propKey$221], lastProps.hasOwnProperty(propKey$221) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$221))
	          switch (propKey$221) {
	            case "selected":
	              domElement.selected = false;
	              break;
	            default:
	              setProp(
	                domElement,
	                tag,
	                propKey$221,
	                null,
	                nextProps,
	                propKey$205
	              );
	          }
	      for (lastDefaultValue in nextProps)
	        if (propKey$205 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))
	          switch (lastDefaultValue) {
	            case "selected":
	              domElement.selected = propKey$205 && "function" !== typeof propKey$205 && "symbol" !== typeof propKey$205;
	              break;
	            default:
	              setProp(
	                domElement,
	                tag,
	                lastDefaultValue,
	                propKey$205,
	                nextProps,
	                propKey
	              );
	          }
	      return;
	    case "img":
	    case "link":
	    case "area":
	    case "base":
	    case "br":
	    case "col":
	    case "embed":
	    case "hr":
	    case "keygen":
	    case "meta":
	    case "param":
	    case "source":
	    case "track":
	    case "wbr":
	    case "menuitem":
	      for (var propKey$226 in lastProps)
	        propKey$205 = lastProps[propKey$226], lastProps.hasOwnProperty(propKey$226) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$226) && setProp(domElement, tag, propKey$226, null, nextProps, propKey$205);
	      for (checked in nextProps)
	        if (propKey$205 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))
	          switch (checked) {
	            case "children":
	            case "dangerouslySetInnerHTML":
	              if (null != propKey$205)
	                throw Error(formatProdErrorMessage(137, tag));
	              break;
	            default:
	              setProp(
	                domElement,
	                tag,
	                checked,
	                propKey$205,
	                nextProps,
	                propKey
	              );
	          }
	      return;
	    default:
	      if (isCustomElement(tag)) {
	        for (var propKey$231 in lastProps)
	          propKey$205 = lastProps[propKey$231], lastProps.hasOwnProperty(propKey$231) && void 0 !== propKey$205 && !nextProps.hasOwnProperty(propKey$231) && setPropOnCustomElement(
	            domElement,
	            tag,
	            propKey$231,
	            void 0,
	            nextProps,
	            propKey$205
	          );
	        for (defaultChecked in nextProps)
	          propKey$205 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$205 === propKey || void 0 === propKey$205 && void 0 === propKey || setPropOnCustomElement(
	            domElement,
	            tag,
	            defaultChecked,
	            propKey$205,
	            nextProps,
	            propKey
	          );
	        return;
	      }
	  }
	  for (var propKey$236 in lastProps)
	    propKey$205 = lastProps[propKey$236], lastProps.hasOwnProperty(propKey$236) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$236) && setProp(domElement, tag, propKey$236, null, nextProps, propKey$205);
	  for (lastProp in nextProps)
	    propKey$205 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$205 === propKey || null == propKey$205 && null == propKey || setProp(domElement, tag, lastProp, propKey$205, nextProps, propKey);
	}
	var eventsEnabled = null, selectionInformation = null;
	function getOwnerDocumentFromRootContainer(rootContainerElement) {
	  return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
	}
	function getOwnHostContext(namespaceURI) {
	  switch (namespaceURI) {
	    case "http://www.w3.org/2000/svg":
	      return 1;
	    case "http://www.w3.org/1998/Math/MathML":
	      return 2;
	    default:
	      return 0;
	  }
	}
	function getChildHostContextProd(parentNamespace, type) {
	  if (0 === parentNamespace)
	    switch (type) {
	      case "svg":
	        return 1;
	      case "math":
	        return 2;
	      default:
	        return 0;
	    }
	  return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
	}
	function shouldSetTextContent(type, props) {
	  return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
	}
	var currentPopstateTransitionEvent = null;
	function shouldAttemptEagerTransition() {
	  var event = window.event;
	  if (event && "popstate" === event.type) {
	    if (event === currentPopstateTransitionEvent) return false;
	    currentPopstateTransitionEvent = event;
	    return true;
	  }
	  currentPopstateTransitionEvent = null;
	  return false;
	}
	var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
	  return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
	} : scheduleTimeout;
	function handleErrorInNextTick(error) {
	  setTimeout(function() {
	    throw error;
	  });
	}
	function isSingletonScope(type) {
	  return "head" === type;
	}
	function clearSuspenseBoundary(parentInstance, suspenseInstance) {
	  var node = suspenseInstance, possiblePreambleContribution = 0, depth = 0;
	  do {
	    var nextNode = node.nextSibling;
	    parentInstance.removeChild(node);
	    if (nextNode && 8 === nextNode.nodeType)
	      if (node = nextNode.data, "/$" === node) {
	        if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
	          node = possiblePreambleContribution;
	          var ownerDocument = parentInstance.ownerDocument;
	          node & 1 && releaseSingletonInstance(ownerDocument.documentElement);
	          node & 2 && releaseSingletonInstance(ownerDocument.body);
	          if (node & 4)
	            for (node = ownerDocument.head, releaseSingletonInstance(node), ownerDocument = node.firstChild; ownerDocument; ) {
	              var nextNode$jscomp$0 = ownerDocument.nextSibling, nodeName = ownerDocument.nodeName;
	              ownerDocument[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === ownerDocument.rel.toLowerCase() || node.removeChild(ownerDocument);
	              ownerDocument = nextNode$jscomp$0;
	            }
	        }
	        if (0 === depth) {
	          parentInstance.removeChild(nextNode);
	          retryIfBlockedOn(suspenseInstance);
	          return;
	        }
	        depth--;
	      } else
	        "$" === node || "$?" === node || "$!" === node ? depth++ : possiblePreambleContribution = node.charCodeAt(0) - 48;
	    else possiblePreambleContribution = 0;
	    node = nextNode;
	  } while (node);
	  retryIfBlockedOn(suspenseInstance);
	}
	function clearContainerSparingly(container) {
	  var nextNode = container.firstChild;
	  nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
	  for (; nextNode; ) {
	    var node = nextNode;
	    nextNode = nextNode.nextSibling;
	    switch (node.nodeName) {
	      case "HTML":
	      case "HEAD":
	      case "BODY":
	        clearContainerSparingly(node);
	        detachDeletedInstance(node);
	        continue;
	      case "SCRIPT":
	      case "STYLE":
	        continue;
	      case "LINK":
	        if ("stylesheet" === node.rel.toLowerCase()) continue;
	    }
	    container.removeChild(node);
	  }
	}
	function canHydrateInstance(instance, type, props, inRootOrSingleton) {
	  for (; 1 === instance.nodeType; ) {
	    var anyProps = props;
	    if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
	      if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
	        break;
	    } else if (!inRootOrSingleton)
	      if ("input" === type && "hidden" === instance.type) {
	        var name = null == anyProps.name ? null : "" + anyProps.name;
	        if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
	          return instance;
	      } else return instance;
	    else if (!instance[internalHoistableMarker])
	      switch (type) {
	        case "meta":
	          if (!instance.hasAttribute("itemprop")) break;
	          return instance;
	        case "link":
	          name = instance.getAttribute("rel");
	          if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
	            break;
	          else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
	            break;
	          return instance;
	        case "style":
	          if (instance.hasAttribute("data-precedence")) break;
	          return instance;
	        case "script":
	          name = instance.getAttribute("src");
	          if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
	            break;
	          return instance;
	        default:
	          return instance;
	      }
	    instance = getNextHydratable(instance.nextSibling);
	    if (null === instance) break;
	  }
	  return null;
	}
	function canHydrateTextInstance(instance, text, inRootOrSingleton) {
	  if ("" === text) return null;
	  for (; 3 !== instance.nodeType; ) {
	    if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
	      return null;
	    instance = getNextHydratable(instance.nextSibling);
	    if (null === instance) return null;
	  }
	  return instance;
	}
	function isSuspenseInstanceFallback(instance) {
	  return "$!" === instance.data || "$?" === instance.data && "complete" === instance.ownerDocument.readyState;
	}
	function registerSuspenseInstanceRetry(instance, callback) {
	  var ownerDocument = instance.ownerDocument;
	  if ("$?" !== instance.data || "complete" === ownerDocument.readyState)
	    callback();
	  else {
	    var listener = function() {
	      callback();
	      ownerDocument.removeEventListener("DOMContentLoaded", listener);
	    };
	    ownerDocument.addEventListener("DOMContentLoaded", listener);
	    instance._reactRetry = listener;
	  }
	}
	function getNextHydratable(node) {
	  for (; null != node; node = node.nextSibling) {
	    var nodeType = node.nodeType;
	    if (1 === nodeType || 3 === nodeType) break;
	    if (8 === nodeType) {
	      nodeType = node.data;
	      if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "F!" === nodeType || "F" === nodeType)
	        break;
	      if ("/$" === nodeType) return null;
	    }
	  }
	  return node;
	}
	var previousHydratableOnEnteringScopedSingleton = null;
	function getParentSuspenseInstance(targetInstance) {
	  targetInstance = targetInstance.previousSibling;
	  for (var depth = 0; targetInstance; ) {
	    if (8 === targetInstance.nodeType) {
	      var data = targetInstance.data;
	      if ("$" === data || "$!" === data || "$?" === data) {
	        if (0 === depth) return targetInstance;
	        depth--;
	      } else "/$" === data && depth++;
	    }
	    targetInstance = targetInstance.previousSibling;
	  }
	  return null;
	}
	function resolveSingletonInstance(type, props, rootContainerInstance) {
	  props = getOwnerDocumentFromRootContainer(rootContainerInstance);
	  switch (type) {
	    case "html":
	      type = props.documentElement;
	      if (!type) throw Error(formatProdErrorMessage(452));
	      return type;
	    case "head":
	      type = props.head;
	      if (!type) throw Error(formatProdErrorMessage(453));
	      return type;
	    case "body":
	      type = props.body;
	      if (!type) throw Error(formatProdErrorMessage(454));
	      return type;
	    default:
	      throw Error(formatProdErrorMessage(451));
	  }
	}
	function releaseSingletonInstance(instance) {
	  for (var attributes = instance.attributes; attributes.length; )
	    instance.removeAttributeNode(attributes[0]);
	  detachDeletedInstance(instance);
	}
	var preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set();
	function getHoistableRoot(container) {
	  return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
	}
	var previousDispatcher = ReactDOMSharedInternals.d;
	ReactDOMSharedInternals.d = {
	  f: flushSyncWork,
	  r: requestFormReset,
	  D: prefetchDNS,
	  C: preconnect,
	  L: preload,
	  m: preloadModule,
	  X: preinitScript,
	  S: preinitStyle,
	  M: preinitModuleScript
	};
	function flushSyncWork() {
	  var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
	  return previousWasRendering || wasRendering;
	}
	function requestFormReset(form) {
	  var formInst = getInstanceFromNode(form);
	  null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
	}
	var globalDocument = "undefined" === typeof document ? null : document;
	function preconnectAs(rel, href, crossOrigin) {
	  var ownerDocument = globalDocument;
	  if (ownerDocument && "string" === typeof href && href) {
	    var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
	    limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
	    "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
	    preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
	  }
	}
	function prefetchDNS(href) {
	  previousDispatcher.D(href);
	  preconnectAs("dns-prefetch", href, null);
	}
	function preconnect(href, crossOrigin) {
	  previousDispatcher.C(href, crossOrigin);
	  preconnectAs("preconnect", href, crossOrigin);
	}
	function preload(href, as, options2) {
	  previousDispatcher.L(href, as, options2);
	  var ownerDocument = globalDocument;
	  if (ownerDocument && href && as) {
	    var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
	    "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
	      options2.imageSrcSet
	    ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
	      options2.imageSizes
	    ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
	    var key = preloadSelector;
	    switch (as) {
	      case "style":
	        key = getStyleKey(href);
	        break;
	      case "script":
	        key = getScriptKey(href);
	    }
	    preloadPropsMap.has(key) || (href = assign(
	      {
	        rel: "preload",
	        href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
	        as
	      },
	      options2
	    ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
	  }
	}
	function preloadModule(href, options2) {
	  previousDispatcher.m(href, options2);
	  var ownerDocument = globalDocument;
	  if (ownerDocument && href) {
	    var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
	    switch (as) {
	      case "audioworklet":
	      case "paintworklet":
	      case "serviceworker":
	      case "sharedworker":
	      case "worker":
	      case "script":
	        key = getScriptKey(href);
	    }
	    if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
	      switch (as) {
	        case "audioworklet":
	        case "paintworklet":
	        case "serviceworker":
	        case "sharedworker":
	        case "worker":
	        case "script":
	          if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
	            return;
	      }
	      as = ownerDocument.createElement("link");
	      setInitialProperties(as, "link", href);
	      markNodeAsHoistable(as);
	      ownerDocument.head.appendChild(as);
	    }
	  }
	}
	function preinitStyle(href, precedence, options2) {
	  previousDispatcher.S(href, precedence, options2);
	  var ownerDocument = globalDocument;
	  if (ownerDocument && href) {
	    var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
	    precedence = precedence || "default";
	    var resource = styles.get(key);
	    if (!resource) {
	      var state = { loading: 0, preload: null };
	      if (resource = ownerDocument.querySelector(
	        getStylesheetSelectorFromKey(key)
	      ))
	        state.loading = 5;
	      else {
	        href = assign(
	          { rel: "stylesheet", href, "data-precedence": precedence },
	          options2
	        );
	        (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
	        var link = resource = ownerDocument.createElement("link");
	        markNodeAsHoistable(link);
	        setInitialProperties(link, "link", href);
	        link._p = new Promise(function(resolve, reject) {
	          link.onload = resolve;
	          link.onerror = reject;
	        });
	        link.addEventListener("load", function() {
	          state.loading |= 1;
	        });
	        link.addEventListener("error", function() {
	          state.loading |= 2;
	        });
	        state.loading |= 4;
	        insertStylesheet(resource, precedence, ownerDocument);
	      }
	      resource = {
	        type: "stylesheet",
	        instance: resource,
	        count: 1,
	        state
	      };
	      styles.set(key, resource);
	    }
	  }
	}
	function preinitScript(src, options2) {
	  previousDispatcher.X(src, options2);
	  var ownerDocument = globalDocument;
	  if (ownerDocument && src) {
	    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
	    resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
	      type: "script",
	      instance: resource,
	      count: 1,
	      state: null
	    }, scripts.set(key, resource));
	  }
	}
	function preinitModuleScript(src, options2) {
	  previousDispatcher.M(src, options2);
	  var ownerDocument = globalDocument;
	  if (ownerDocument && src) {
	    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
	    resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
	      type: "script",
	      instance: resource,
	      count: 1,
	      state: null
	    }, scripts.set(key, resource));
	  }
	}
	function getResource(type, currentProps, pendingProps, currentResource) {
	  var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
	  if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
	  switch (type) {
	    case "meta":
	    case "title":
	      return null;
	    case "style":
	      return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
	        JSCompiler_inline_result
	      ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
	        type: "style",
	        instance: null,
	        count: 0,
	        state: null
	      }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
	    case "link":
	      if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
	        type = getStyleKey(pendingProps.href);
	        var styles$244 = getResourcesFromRoot(
	          JSCompiler_inline_result
	        ).hoistableStyles, resource$245 = styles$244.get(type);
	        resource$245 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$245 = {
	          type: "stylesheet",
	          instance: null,
	          count: 0,
	          state: { loading: 0, preload: null }
	        }, styles$244.set(type, resource$245), (styles$244 = JSCompiler_inline_result.querySelector(
	          getStylesheetSelectorFromKey(type)
	        )) && !styles$244._p && (resource$245.instance = styles$244, resource$245.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
	          rel: "preload",
	          as: "style",
	          href: pendingProps.href,
	          crossOrigin: pendingProps.crossOrigin,
	          integrity: pendingProps.integrity,
	          media: pendingProps.media,
	          hrefLang: pendingProps.hrefLang,
	          referrerPolicy: pendingProps.referrerPolicy
	        }, preloadPropsMap.set(type, pendingProps), styles$244 || preloadStylesheet(
	          JSCompiler_inline_result,
	          type,
	          pendingProps,
	          resource$245.state
	        )));
	        if (currentProps && null === currentResource)
	          throw Error(formatProdErrorMessage(528, ""));
	        return resource$245;
	      }
	      if (currentProps && null !== currentResource)
	        throw Error(formatProdErrorMessage(529, ""));
	      return null;
	    case "script":
	      return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
	        JSCompiler_inline_result
	      ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
	        type: "script",
	        instance: null,
	        count: 0,
	        state: null
	      }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
	    default:
	      throw Error(formatProdErrorMessage(444, type));
	  }
	}
	function getStyleKey(href) {
	  return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
	}
	function getStylesheetSelectorFromKey(key) {
	  return 'link[rel="stylesheet"][' + key + "]";
	}
	function stylesheetPropsFromRawProps(rawProps) {
	  return assign({}, rawProps, {
	    "data-precedence": rawProps.precedence,
	    precedence: null
	  });
	}
	function preloadStylesheet(ownerDocument, key, preloadProps, state) {
	  ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
	    return state.loading |= 1;
	  }), key.addEventListener("error", function() {
	    return state.loading |= 2;
	  }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
	}
	function getScriptKey(src) {
	  return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
	}
	function getScriptSelectorFromKey(key) {
	  return "script[async]" + key;
	}
	function acquireResource(hoistableRoot, resource, props) {
	  resource.count++;
	  if (null === resource.instance)
	    switch (resource.type) {
	      case "style":
	        var instance = hoistableRoot.querySelector(
	          'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
	        );
	        if (instance)
	          return resource.instance = instance, markNodeAsHoistable(instance), instance;
	        var styleProps = assign({}, props, {
	          "data-href": props.href,
	          "data-precedence": props.precedence,
	          href: null,
	          precedence: null
	        });
	        instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
	          "style"
	        );
	        markNodeAsHoistable(instance);
	        setInitialProperties(instance, "style", styleProps);
	        insertStylesheet(instance, props.precedence, hoistableRoot);
	        return resource.instance = instance;
	      case "stylesheet":
	        styleProps = getStyleKey(props.href);
	        var instance$250 = hoistableRoot.querySelector(
	          getStylesheetSelectorFromKey(styleProps)
	        );
	        if (instance$250)
	          return resource.state.loading |= 4, resource.instance = instance$250, markNodeAsHoistable(instance$250), instance$250;
	        instance = stylesheetPropsFromRawProps(props);
	        (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
	        instance$250 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
	        markNodeAsHoistable(instance$250);
	        var linkInstance = instance$250;
	        linkInstance._p = new Promise(function(resolve, reject) {
	          linkInstance.onload = resolve;
	          linkInstance.onerror = reject;
	        });
	        setInitialProperties(instance$250, "link", instance);
	        resource.state.loading |= 4;
	        insertStylesheet(instance$250, props.precedence, hoistableRoot);
	        return resource.instance = instance$250;
	      case "script":
	        instance$250 = getScriptKey(props.src);
	        if (styleProps = hoistableRoot.querySelector(
	          getScriptSelectorFromKey(instance$250)
	        ))
	          return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
	        instance = props;
	        if (styleProps = preloadPropsMap.get(instance$250))
	          instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
	        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
	        styleProps = hoistableRoot.createElement("script");
	        markNodeAsHoistable(styleProps);
	        setInitialProperties(styleProps, "link", instance);
	        hoistableRoot.head.appendChild(styleProps);
	        return resource.instance = styleProps;
	      case "void":
	        return null;
	      default:
	        throw Error(formatProdErrorMessage(443, resource.type));
	    }
	  else
	    "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
	  return resource.instance;
	}
	function insertStylesheet(instance, precedence, root2) {
	  for (var nodes = root2.querySelectorAll(
	    'link[rel="stylesheet"][data-precedence],style[data-precedence]'
	  ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
	    var node = nodes[i];
	    if (node.dataset.precedence === precedence) prior = node;
	    else if (prior !== last) break;
	  }
	  prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
	}
	function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
	  null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
	  null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
	  null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
	}
	function adoptPreloadPropsForScript(scriptProps, preloadProps) {
	  null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
	  null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
	  null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
	}
	var tagCaches = null;
	function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
	  if (null === tagCaches) {
	    var cache = /* @__PURE__ */ new Map();
	    var caches = tagCaches = /* @__PURE__ */ new Map();
	    caches.set(ownerDocument, cache);
	  } else
	    caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
	  if (cache.has(type)) return cache;
	  cache.set(type, null);
	  ownerDocument = ownerDocument.getElementsByTagName(type);
	  for (caches = 0; caches < ownerDocument.length; caches++) {
	    var node = ownerDocument[caches];
	    if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
	      var nodeKey = node.getAttribute(keyAttribute) || "";
	      nodeKey = type + nodeKey;
	      var existing = cache.get(nodeKey);
	      existing ? existing.push(node) : cache.set(nodeKey, [node]);
	    }
	  }
	  return cache;
	}
	function mountHoistable(hoistableRoot, type, instance) {
	  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
	  hoistableRoot.head.insertBefore(
	    instance,
	    "title" === type ? hoistableRoot.querySelector("head > title") : null
	  );
	}
	function isHostHoistableType(type, props, hostContext) {
	  if (1 === hostContext || null != props.itemProp) return false;
	  switch (type) {
	    case "meta":
	    case "title":
	      return true;
	    case "style":
	      if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
	        break;
	      return true;
	    case "link":
	      if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
	        break;
	      switch (props.rel) {
	        case "stylesheet":
	          return type = props.disabled, "string" === typeof props.precedence && null == type;
	        default:
	          return true;
	      }
	    case "script":
	      if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
	        return true;
	  }
	  return false;
	}
	function preloadResource(resource) {
	  return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
	}
	var suspendedState = null;
	function noop() {
	}
	function suspendResource(hoistableRoot, resource, props) {
	  if (null === suspendedState) throw Error(formatProdErrorMessage(475));
	  var state = suspendedState;
	  if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
	    if (null === resource.instance) {
	      var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
	        getStylesheetSelectorFromKey(key)
	      );
	      if (instance) {
	        hoistableRoot = instance._p;
	        null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
	        resource.state.loading |= 4;
	        resource.instance = instance;
	        markNodeAsHoistable(instance);
	        return;
	      }
	      instance = hoistableRoot.ownerDocument || hoistableRoot;
	      props = stylesheetPropsFromRawProps(props);
	      (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
	      instance = instance.createElement("link");
	      markNodeAsHoistable(instance);
	      var linkInstance = instance;
	      linkInstance._p = new Promise(function(resolve, reject) {
	        linkInstance.onload = resolve;
	        linkInstance.onerror = reject;
	      });
	      setInitialProperties(instance, "link", props);
	      resource.instance = instance;
	    }
	    null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
	    state.stylesheets.set(resource, hoistableRoot);
	    (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
	  }
	}
	function waitForCommitToBeReady() {
	  if (null === suspendedState) throw Error(formatProdErrorMessage(475));
	  var state = suspendedState;
	  state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
	  return 0 < state.count ? function(commit) {
	    var stylesheetTimer = setTimeout(function() {
	      state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
	      if (state.unsuspend) {
	        var unsuspend = state.unsuspend;
	        state.unsuspend = null;
	        unsuspend();
	      }
	    }, 6e4);
	    state.unsuspend = commit;
	    return function() {
	      state.unsuspend = null;
	      clearTimeout(stylesheetTimer);
	    };
	  } : null;
	}
	function onUnsuspend() {
	  this.count--;
	  if (0 === this.count) {
	    if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
	    else if (this.unsuspend) {
	      var unsuspend = this.unsuspend;
	      this.unsuspend = null;
	      unsuspend();
	    }
	  }
	}
	var precedencesByRoot = null;
	function insertSuspendedStylesheets(state, resources) {
	  state.stylesheets = null;
	  null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
	}
	function insertStylesheetIntoRoot(root2, resource) {
	  if (!(resource.state.loading & 4)) {
	    var precedences = precedencesByRoot.get(root2);
	    if (precedences) var last = precedences.get(null);
	    else {
	      precedences = /* @__PURE__ */ new Map();
	      precedencesByRoot.set(root2, precedences);
	      for (var nodes = root2.querySelectorAll(
	        "link[data-precedence],style[data-precedence]"
	      ), i = 0; i < nodes.length; i++) {
	        var node = nodes[i];
	        if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
	          precedences.set(node.dataset.precedence, node), last = node;
	      }
	      last && precedences.set(null, last);
	    }
	    nodes = resource.instance;
	    node = nodes.getAttribute("data-precedence");
	    i = precedences.get(node) || last;
	    i === last && precedences.set(null, nodes);
	    precedences.set(node, nodes);
	    this.count++;
	    last = onUnsuspend.bind(this);
	    nodes.addEventListener("load", last);
	    nodes.addEventListener("error", last);
	    i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
	    resource.state.loading |= 4;
	  }
	}
	var HostTransitionContext = {
	  $$typeof: REACT_CONTEXT_TYPE,
	  Provider: null,
	  Consumer: null,
	  _currentValue: sharedNotPendingObject,
	  _currentValue2: sharedNotPendingObject,
	  _threadCount: 0
	};
	function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
	  this.tag = 1;
	  this.containerInfo = containerInfo;
	  this.pingCache = this.current = this.pendingChildren = null;
	  this.timeoutHandle = -1;
	  this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
	  this.callbackPriority = 0;
	  this.expirationTimes = createLaneMap(-1);
	  this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
	  this.entanglements = createLaneMap(0);
	  this.hiddenUpdates = createLaneMap(null);
	  this.identifierPrefix = identifierPrefix;
	  this.onUncaughtError = onUncaughtError;
	  this.onCaughtError = onCaughtError;
	  this.onRecoverableError = onRecoverableError;
	  this.pooledCache = null;
	  this.pooledCacheLanes = 0;
	  this.formState = formState;
	  this.incompleteTransitions = /* @__PURE__ */ new Map();
	}
	function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
	  containerInfo = new FiberRootNode(
	    containerInfo,
	    tag,
	    hydrate,
	    identifierPrefix,
	    onUncaughtError,
	    onCaughtError,
	    onRecoverableError,
	    formState
	  );
	  tag = 1;
	  true === isStrictMode && (tag |= 24);
	  isStrictMode = createFiberImplClass(3, null, null, tag);
	  containerInfo.current = isStrictMode;
	  isStrictMode.stateNode = containerInfo;
	  tag = createCache();
	  tag.refCount++;
	  containerInfo.pooledCache = tag;
	  tag.refCount++;
	  isStrictMode.memoizedState = {
	    element: initialChildren,
	    isDehydrated: hydrate,
	    cache: tag
	  };
	  initializeUpdateQueue(isStrictMode);
	  return containerInfo;
	}
	function getContextForSubtree(parentComponent) {
	  if (!parentComponent) return emptyContextObject;
	  parentComponent = emptyContextObject;
	  return parentComponent;
	}
	function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
	  parentComponent = getContextForSubtree(parentComponent);
	  null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
	  container = createUpdate(lane);
	  container.payload = { element };
	  callback = void 0 === callback ? null : callback;
	  null !== callback && (container.callback = callback);
	  element = enqueueUpdate(rootFiber, container, lane);
	  null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
	}
	function markRetryLaneImpl(fiber, retryLane) {
	  fiber = fiber.memoizedState;
	  if (null !== fiber && null !== fiber.dehydrated) {
	    var a = fiber.retryLane;
	    fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
	  }
	}
	function markRetryLaneIfNotHydrated(fiber, retryLane) {
	  markRetryLaneImpl(fiber, retryLane);
	  (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
	}
	function attemptContinuousHydration(fiber) {
	  if (13 === fiber.tag) {
	    var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
	    null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
	    markRetryLaneIfNotHydrated(fiber, 67108864);
	  }
	}
	var _enabled = true;
	function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
	  var prevTransition = ReactSharedInternals.T;
	  ReactSharedInternals.T = null;
	  var previousPriority = ReactDOMSharedInternals.p;
	  try {
	    ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
	  } finally {
	    ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
	  }
	}
	function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
	  var prevTransition = ReactSharedInternals.T;
	  ReactSharedInternals.T = null;
	  var previousPriority = ReactDOMSharedInternals.p;
	  try {
	    ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
	  } finally {
	    ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
	  }
	}
	function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
	  if (_enabled) {
	    var blockedOn = findInstanceBlockingEvent(nativeEvent);
	    if (null === blockedOn)
	      dispatchEventForPluginEventSystem(
	        domEventName,
	        eventSystemFlags,
	        nativeEvent,
	        return_targetInst,
	        targetContainer
	      ), clearIfContinuousEvent(domEventName, nativeEvent);
	    else if (queueIfContinuousEvent(
	      blockedOn,
	      domEventName,
	      eventSystemFlags,
	      targetContainer,
	      nativeEvent
	    ))
	      nativeEvent.stopPropagation();
	    else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
	      for (; null !== blockedOn; ) {
	        var fiber = getInstanceFromNode(blockedOn);
	        if (null !== fiber)
	          switch (fiber.tag) {
	            case 3:
	              fiber = fiber.stateNode;
	              if (fiber.current.memoizedState.isDehydrated) {
	                var lanes = getHighestPriorityLanes(fiber.pendingLanes);
	                if (0 !== lanes) {
	                  var root2 = fiber;
	                  root2.pendingLanes |= 2;
	                  for (root2.entangledLanes |= 2; lanes; ) {
	                    var lane = 1 << 31 - clz32(lanes);
	                    root2.entanglements[1] |= lane;
	                    lanes &= ~lane;
	                  }
	                  ensureRootIsScheduled(fiber);
	                  0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0));
	                }
	              }
	              break;
	            case 13:
	              root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
	          }
	        fiber = findInstanceBlockingEvent(nativeEvent);
	        null === fiber && dispatchEventForPluginEventSystem(
	          domEventName,
	          eventSystemFlags,
	          nativeEvent,
	          return_targetInst,
	          targetContainer
	        );
	        if (fiber === blockedOn) break;
	        blockedOn = fiber;
	      }
	      null !== blockedOn && nativeEvent.stopPropagation();
	    } else
	      dispatchEventForPluginEventSystem(
	        domEventName,
	        eventSystemFlags,
	        nativeEvent,
	        null,
	        targetContainer
	      );
	  }
	}
	function findInstanceBlockingEvent(nativeEvent) {
	  nativeEvent = getEventTarget(nativeEvent);
	  return findInstanceBlockingTarget(nativeEvent);
	}
	var return_targetInst = null;
	function findInstanceBlockingTarget(targetNode) {
	  return_targetInst = null;
	  targetNode = getClosestInstanceFromNode(targetNode);
	  if (null !== targetNode) {
	    var nearestMounted = getNearestMountedFiber(targetNode);
	    if (null === nearestMounted) targetNode = null;
	    else {
	      var tag = nearestMounted.tag;
	      if (13 === tag) {
	        targetNode = getSuspenseInstanceFromFiber(nearestMounted);
	        if (null !== targetNode) return targetNode;
	        targetNode = null;
	      } else if (3 === tag) {
	        if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
	          return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
	        targetNode = null;
	      } else nearestMounted !== targetNode && (targetNode = null);
	    }
	  }
	  return_targetInst = targetNode;
	  return null;
	}
	function getEventPriority(domEventName) {
	  switch (domEventName) {
	    case "beforetoggle":
	    case "cancel":
	    case "click":
	    case "close":
	    case "contextmenu":
	    case "copy":
	    case "cut":
	    case "auxclick":
	    case "dblclick":
	    case "dragend":
	    case "dragstart":
	    case "drop":
	    case "focusin":
	    case "focusout":
	    case "input":
	    case "invalid":
	    case "keydown":
	    case "keypress":
	    case "keyup":
	    case "mousedown":
	    case "mouseup":
	    case "paste":
	    case "pause":
	    case "play":
	    case "pointercancel":
	    case "pointerdown":
	    case "pointerup":
	    case "ratechange":
	    case "reset":
	    case "resize":
	    case "seeked":
	    case "submit":
	    case "toggle":
	    case "touchcancel":
	    case "touchend":
	    case "touchstart":
	    case "volumechange":
	    case "change":
	    case "selectionchange":
	    case "textInput":
	    case "compositionstart":
	    case "compositionend":
	    case "compositionupdate":
	    case "beforeblur":
	    case "afterblur":
	    case "beforeinput":
	    case "blur":
	    case "fullscreenchange":
	    case "focus":
	    case "hashchange":
	    case "popstate":
	    case "select":
	    case "selectstart":
	      return 2;
	    case "drag":
	    case "dragenter":
	    case "dragexit":
	    case "dragleave":
	    case "dragover":
	    case "mousemove":
	    case "mouseout":
	    case "mouseover":
	    case "pointermove":
	    case "pointerout":
	    case "pointerover":
	    case "scroll":
	    case "touchmove":
	    case "wheel":
	    case "mouseenter":
	    case "mouseleave":
	    case "pointerenter":
	    case "pointerleave":
	      return 8;
	    case "message":
	      switch (getCurrentPriorityLevel()) {
	        case ImmediatePriority:
	          return 2;
	        case UserBlockingPriority:
	          return 8;
	        case NormalPriority$1:
	        case LowPriority:
	          return 32;
	        case IdlePriority:
	          return 268435456;
	        default:
	          return 32;
	      }
	    default:
	      return 32;
	  }
	}
	var hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
	  " "
	);
	function clearIfContinuousEvent(domEventName, nativeEvent) {
	  switch (domEventName) {
	    case "focusin":
	    case "focusout":
	      queuedFocus = null;
	      break;
	    case "dragenter":
	    case "dragleave":
	      queuedDrag = null;
	      break;
	    case "mouseover":
	    case "mouseout":
	      queuedMouse = null;
	      break;
	    case "pointerover":
	    case "pointerout":
	      queuedPointers.delete(nativeEvent.pointerId);
	      break;
	    case "gotpointercapture":
	    case "lostpointercapture":
	      queuedPointerCaptures.delete(nativeEvent.pointerId);
	  }
	}
	function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
	  if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
	    return existingQueuedEvent = {
	      blockedOn,
	      domEventName,
	      eventSystemFlags,
	      nativeEvent,
	      targetContainers: [targetContainer]
	    }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
	  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
	  blockedOn = existingQueuedEvent.targetContainers;
	  null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
	  return existingQueuedEvent;
	}
	function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
	  switch (domEventName) {
	    case "focusin":
	      return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
	        queuedFocus,
	        blockedOn,
	        domEventName,
	        eventSystemFlags,
	        targetContainer,
	        nativeEvent
	      ), true;
	    case "dragenter":
	      return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
	        queuedDrag,
	        blockedOn,
	        domEventName,
	        eventSystemFlags,
	        targetContainer,
	        nativeEvent
	      ), true;
	    case "mouseover":
	      return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
	        queuedMouse,
	        blockedOn,
	        domEventName,
	        eventSystemFlags,
	        targetContainer,
	        nativeEvent
	      ), true;
	    case "pointerover":
	      var pointerId = nativeEvent.pointerId;
	      queuedPointers.set(
	        pointerId,
	        accumulateOrCreateContinuousQueuedReplayableEvent(
	          queuedPointers.get(pointerId) || null,
	          blockedOn,
	          domEventName,
	          eventSystemFlags,
	          targetContainer,
	          nativeEvent
	        )
	      );
	      return true;
	    case "gotpointercapture":
	      return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
	        pointerId,
	        accumulateOrCreateContinuousQueuedReplayableEvent(
	          queuedPointerCaptures.get(pointerId) || null,
	          blockedOn,
	          domEventName,
	          eventSystemFlags,
	          targetContainer,
	          nativeEvent
	        )
	      ), true;
	  }
	  return false;
	}
	function attemptExplicitHydrationTarget(queuedTarget) {
	  var targetInst = getClosestInstanceFromNode(queuedTarget.target);
	  if (null !== targetInst) {
	    var nearestMounted = getNearestMountedFiber(targetInst);
	    if (null !== nearestMounted) {
	      if (targetInst = nearestMounted.tag, 13 === targetInst) {
	        if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
	          queuedTarget.blockedOn = targetInst;
	          runWithPriority(queuedTarget.priority, function() {
	            if (13 === nearestMounted.tag) {
	              var lane = requestUpdateLane();
	              lane = getBumpedLaneForHydrationByLane(lane);
	              var root2 = enqueueConcurrentRenderForLane(nearestMounted, lane);
	              null !== root2 && scheduleUpdateOnFiber(root2, nearestMounted, lane);
	              markRetryLaneIfNotHydrated(nearestMounted, lane);
	            }
	          });
	          return;
	        }
	      } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
	        queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
	        return;
	      }
	    }
	  }
	  queuedTarget.blockedOn = null;
	}
	function attemptReplayContinuousQueuedEvent(queuedEvent) {
	  if (null !== queuedEvent.blockedOn) return false;
	  for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
	    var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
	    if (null === nextBlockedOn) {
	      nextBlockedOn = queuedEvent.nativeEvent;
	      var nativeEventClone = new nextBlockedOn.constructor(
	        nextBlockedOn.type,
	        nextBlockedOn
	      );
	      currentReplayingEvent = nativeEventClone;
	      nextBlockedOn.target.dispatchEvent(nativeEventClone);
	      currentReplayingEvent = null;
	    } else
	      return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
	    targetContainers.shift();
	  }
	  return true;
	}
	function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
	  attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
	}
	function replayUnblockedEvents() {
	  hasScheduledReplayAttempt = false;
	  null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
	  null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
	  null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
	  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
	  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
	}
	function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
	  queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
	    Scheduler.unstable_NormalPriority,
	    replayUnblockedEvents
	  )));
	}
	var lastScheduledReplayQueue = null;
	function scheduleReplayQueueIfNeeded(formReplayingQueue) {
	  lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
	    Scheduler.unstable_NormalPriority,
	    function() {
	      lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
	      for (var i = 0; i < formReplayingQueue.length; i += 3) {
	        var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
	        if ("function" !== typeof submitterOrAction)
	          if (null === findInstanceBlockingTarget(submitterOrAction || form))
	            continue;
	          else break;
	        var formInst = getInstanceFromNode(form);
	        null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(
	          formInst,
	          {
	            pending: true,
	            data: formData,
	            method: form.method,
	            action: submitterOrAction
	          },
	          submitterOrAction,
	          formData
	        ));
	      }
	    }
	  ));
	}
	function retryIfBlockedOn(unblocked) {
	  function unblock(queuedEvent) {
	    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
	  }
	  null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
	  null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
	  null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
	  queuedPointers.forEach(unblock);
	  queuedPointerCaptures.forEach(unblock);
	  for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
	    var queuedTarget = queuedExplicitHydrationTargets[i];
	    queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
	  }
	  for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
	    attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
	  i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
	  if (null != i)
	    for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
	      var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
	      if ("function" === typeof submitterOrAction)
	        formProps || scheduleReplayQueueIfNeeded(i);
	      else if (formProps) {
	        var action = null;
	        if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
	          if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
	            action = formProps.formAction;
	          else {
	            if (null !== findInstanceBlockingTarget(form)) continue;
	          }
	        else action = formProps.action;
	        "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
	        scheduleReplayQueueIfNeeded(i);
	      }
	    }
	}
	function ReactDOMRoot(internalRoot) {
	  this._internalRoot = internalRoot;
	}
	ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
	  var root2 = this._internalRoot;
	  if (null === root2) throw Error(formatProdErrorMessage(409));
	  var current = root2.current, lane = requestUpdateLane();
	  updateContainerImpl(current, lane, children, root2, null, null);
	};
	ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
	  var root2 = this._internalRoot;
	  if (null !== root2) {
	    this._internalRoot = null;
	    var container = root2.containerInfo;
	    updateContainerImpl(root2.current, 2, null, root2, null, null);
	    flushSyncWork$1();
	    container[internalContainerInstanceKey] = null;
	  }
	};
	function ReactDOMHydrationRoot(internalRoot) {
	  this._internalRoot = internalRoot;
	}
	ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
	  if (target) {
	    var updatePriority = resolveUpdatePriority();
	    target = { blockedOn: null, target, priority: updatePriority };
	    for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
	    queuedExplicitHydrationTargets.splice(i, 0, target);
	    0 === i && attemptExplicitHydrationTarget(target);
	  }
	};
	var isomorphicReactPackageVersion$jscomp$inline_1785 = React.version;
	if ("19.1.1" !== isomorphicReactPackageVersion$jscomp$inline_1785)
	  throw Error(
	    formatProdErrorMessage(
	      527,
	      isomorphicReactPackageVersion$jscomp$inline_1785,
	      "19.1.1"
	    )
	  );
	ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
	  var fiber = componentOrElement._reactInternals;
	  if (void 0 === fiber) {
	    if ("function" === typeof componentOrElement.render)
	      throw Error(formatProdErrorMessage(188));
	    componentOrElement = Object.keys(componentOrElement).join(",");
	    throw Error(formatProdErrorMessage(268, componentOrElement));
	  }
	  componentOrElement = findCurrentFiberUsingSlowPath(fiber);
	  componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
	  componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
	  return componentOrElement;
	};
	var internals$jscomp$inline_2256 = {
	  bundleType: 0,
	  version: "19.1.1",
	  rendererPackageName: "react-dom",
	  currentDispatcherRef: ReactSharedInternals,
	  reconcilerVersion: "19.1.1"
	};
	if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
	  var hook$jscomp$inline_2257 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
	  if (!hook$jscomp$inline_2257.isDisabled && hook$jscomp$inline_2257.supportsFiber)
	    try {
	      rendererID = hook$jscomp$inline_2257.inject(
	        internals$jscomp$inline_2256
	      ), injectedHook = hook$jscomp$inline_2257;
	    } catch (err) {
	    }
	}
	reactDomClient_production.createRoot = function(container, options2) {
	  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
	  var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
	  null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks));
	  options2 = createFiberRoot(
	    container,
	    1,
	    false,
	    null,
	    null,
	    isStrictMode,
	    identifierPrefix,
	    onUncaughtError,
	    onCaughtError,
	    onRecoverableError,
	    transitionCallbacks,
	    null
	  );
	  container[internalContainerInstanceKey] = options2.current;
	  listenToAllSupportedEvents(container);
	  return new ReactDOMRoot(options2);
	};
	reactDomClient_production.hydrateRoot = function(container, initialChildren, options2) {
	  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
	  var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
	  null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks), void 0 !== options2.formState && (formState = options2.formState));
	  initialChildren = createFiberRoot(
	    container,
	    1,
	    true,
	    initialChildren,
	    null != options2 ? options2 : null,
	    isStrictMode,
	    identifierPrefix,
	    onUncaughtError,
	    onCaughtError,
	    onRecoverableError,
	    transitionCallbacks,
	    formState
	  );
	  initialChildren.context = getContextForSubtree(null);
	  options2 = initialChildren.current;
	  isStrictMode = requestUpdateLane();
	  isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
	  identifierPrefix = createUpdate(isStrictMode);
	  identifierPrefix.callback = null;
	  enqueueUpdate(options2, identifierPrefix, isStrictMode);
	  options2 = isStrictMode;
	  initialChildren.current.lanes = options2;
	  markRootUpdated$1(initialChildren, options2);
	  ensureRootIsScheduled(initialChildren);
	  container[internalContainerInstanceKey] = initialChildren.current;
	  listenToAllSupportedEvents(container);
	  return new ReactDOMHydrationRoot(initialChildren);
	};
	reactDomClient_production.version = "19.1.1";
	return reactDomClient_production;
}

var hasRequiredClient;

function requireClient () {
	if (hasRequiredClient) return client.exports;
	hasRequiredClient = 1;
	function checkDCE() {
	  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
	    return;
	  }
	  try {
	    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
	  } catch (err) {
	    console.error(err);
	  }
	}
	{
	  checkDCE();
	  client.exports = requireReactDomClient_production();
	}
	return client.exports;
}

var clientExports = requireClient();

/**
 * react-router v7.8.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
var PopStateEventType = "popstate";
function createBrowserHistory(options = {}) {
  function createBrowserLocation(window2, globalHistory) {
    let { pathname, search, hash } = window2.location;
    return createLocation(
      "",
      { pathname, search, hash },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(
    createBrowserLocation,
    createBrowserHref,
    null,
    options
  );
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message);
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substring(2, 10);
}
function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
function createLocation(current, to, state = null, key) {
  let location = {
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: "",
    ...typeof to === "string" ? parsePath(to) : to,
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  };
  return location;
}
function createPath({
  pathname = "/",
  search = "",
  hash = ""
}) {
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substring(hashIndex);
      path = path.substring(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substring(searchIndex);
      path = path.substring(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {
  let { window: window2 = document.defaultView, v5Compat = false } = options;
  let globalHistory = window2.history;
  let action = "POP";
  let listener = null;
  let index = getIndex();
  if (index == null) {
    index = 0;
    globalHistory.replaceState({ ...globalHistory.state, idx: index }, "");
  }
  function getIndex() {
    let state = globalHistory.state || { idx: null };
    return state.idx;
  }
  function handlePop() {
    action = "POP";
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({ action, location: history.location, delta });
    }
  }
  function push(to, state) {
    action = "PUSH";
    let location = createLocation(history.location, to, state);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({ action, location: history.location, delta: 1 });
    }
  }
  function replace2(to, state) {
    action = "REPLACE";
    let location = createLocation(history.location, to, state);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({ action, location: history.location, delta: 0 });
    }
  }
  function createURL(to) {
    return createBrowserURLImpl(to);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref2(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace: replace2,
    go(n) {
      return globalHistory.go(n);
    }
  };
  return history;
}
function createBrowserURLImpl(to, isAbsolute = false) {
  let base = "http://localhost";
  if (typeof window !== "undefined") {
    base = window.location.origin !== "null" ? window.location.origin : window.location.href;
  }
  invariant(base, "No window.location.(origin|href) available to create URL");
  let href = typeof to === "string" ? to : createPath(to);
  href = href.replace(/ $/, "%20");
  if (!isAbsolute && href.startsWith("//")) {
    href = base + href;
  }
  return new URL(href, base);
}
function matchRoutes(routes, locationArg, basename = "/") {
  return matchRoutesImpl(routes, locationArg, basename, false);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(
      branches[i],
      decoded,
      allowPartial
    );
  }
  return matches;
}
function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "", _hasParentOptionalSegments = false) {
  let flattenRoute = (route, index, hasParentOptionalSegments = _hasParentOptionalSegments, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      if (!meta.relativePath.startsWith(parentPath) && hasParentOptionalSegments) {
        return;
      }
      invariant(
        meta.relativePath.startsWith(parentPath),
        `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
      );
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        `Index routes must not have child routes. Please remove all child routes from route path "${path}".`
      );
      flattenRoutes(
        route.children,
        branches,
        routesMeta,
        path,
        hasParentOptionalSegments
      );
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    if (route.path === "" || !route.path?.includes("?")) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, true, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(
    ...restExploded.map(
      (subpath) => subpath === "" ? required : [required, subpath].join("/")
    )
  );
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map(
    (exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded
  );
}
function rankRouteBranches(branches) {
  branches.sort(
    (a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(
      a.routesMeta.map((meta) => meta.childrenIndex),
      b.routesMeta.map((meta) => meta.childrenIndex)
    )
  );
}
var paramRe = /^:[\w-]+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = (s) => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce(
    (score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue),
    initialScore
  );
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a[a.length - 1] - b[b.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname, allowPartial = false) {
  let { routesMeta } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath(
      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },
      remainingPathname
    );
    let route = meta.route;
    if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
      match = matchPath(
        {
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end: false
        },
        remainingPathname
      );
    }
    if (!match) {
      return null;
    }
    Object.assign(matchedParams, match.params);
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(
        joinPaths([matchedPathname, match.pathnameBase])
      ),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = { path: pattern, caseSensitive: false, end: true };
  }
  let [matcher, compiledParams] = compilePath(
    pattern.path,
    pattern.caseSensitive,
    pattern.end
  );
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = compiledParams.reduce(
    (memo2, { paramName, isOptional }, index) => {
      if (paramName === "*") {
        let splatValue = captureGroups[index] || "";
        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
      }
      const value = captureGroups[index];
      if (isOptional && !value) {
        memo2[paramName] = void 0;
      } else {
        memo2[paramName] = (value || "").replace(/%2F/g, "/");
      }
      return memo2;
    },
    {}
  );
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive = false, end = true) {
  warning(
    path === "*" || !path.endsWith("*") || path.endsWith("/*"),
    `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`
  );
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
    /\/:([\w-]+)(\?)?/g,
    (_, paramName, isOptional) => {
      params.push({ paramName, isOptional: isOptional != null });
      return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
    }
  ).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
  if (path.endsWith("*")) {
    params.push({ paramName: "*" });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map((v) => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(
      false,
      `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`
    );
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname = "/") {
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return `Cannot include a '${char}' character in a manually specified \`to.${field}\` field [${JSON.stringify(
    path
  )}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function getPathContributingMatches(matches) {
  return matches.filter(
    (match, index) => index === 0 || match.route.path && match.route.path.length > 0
  );
}
function getResolveToMatches(matches) {
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches.map(
    (match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase
  );
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = { ...toArg };
    invariant(
      !to.pathname || !to.pathname.includes("?"),
      getInvalidPathError("?", "pathname", "search", to)
    );
    invariant(
      !to.pathname || !to.pathname.includes("#"),
      getInvalidPathError("#", "pathname", "hash", to)
    );
    invariant(
      !to.search || !to.search.includes("#"),
      getInvalidPathError("#", "search", "hash", to)
    );
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
var validMutationMethodsArr = [
  "POST",
  "PUT",
  "PATCH",
  "DELETE"
];
new Set(
  validMutationMethodsArr
);
var validRequestMethodsArr = [
  "GET",
  ...validMutationMethodsArr
];
new Set(validRequestMethodsArr);
var DataRouterContext = reactExports.createContext(null);
DataRouterContext.displayName = "DataRouter";
var DataRouterStateContext = reactExports.createContext(null);
DataRouterStateContext.displayName = "DataRouterState";
reactExports.createContext(false);
var ViewTransitionContext = reactExports.createContext({
  isTransitioning: false
});
ViewTransitionContext.displayName = "ViewTransition";
var FetchersContext = reactExports.createContext(
  /* @__PURE__ */ new Map()
);
FetchersContext.displayName = "Fetchers";
var AwaitContext = reactExports.createContext(null);
AwaitContext.displayName = "Await";
var NavigationContext = reactExports.createContext(
  null
);
NavigationContext.displayName = "Navigation";
var LocationContext = reactExports.createContext(
  null
);
LocationContext.displayName = "Location";
var RouteContext = reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
RouteContext.displayName = "Route";
var RouteErrorContext = reactExports.createContext(null);
RouteErrorContext.displayName = "RouteError";
function useHref(to, { relative } = {}) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useHref() may be used only in the context of a <Router> component.`
  );
  let { basename, navigator } = reactExports.useContext(NavigationContext);
  let { hash, pathname, search } = useResolvedPath(to, { relative });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator.createHref({ pathname: joinedPathname, search, hash });
}
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useLocation() may be used only in the context of a <Router> component.`
  );
  return reactExports.useContext(LocationContext).location;
}
var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
function useIsomorphicLayoutEffect(cb) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb);
  }
}
function useNavigate() {
  let { isDataRoute } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useNavigate() may be used only in the context of a <Router> component.`
  );
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let { basename, navigator } = reactExports.useContext(NavigationContext);
  let { matches } = reactExports.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(
    (to, options = {}) => {
      warning(activeRef.current, navigateEffectWarning);
      if (!activeRef.current) return;
      if (typeof to === "number") {
        navigator.go(to);
        return;
      }
      let path = resolveTo(
        to,
        JSON.parse(routePathnamesJson),
        locationPathname,
        options.relative === "path"
      );
      if (dataRouterContext == null && basename !== "/") {
        path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
      }
      (!!options.replace ? navigator.replace : navigator.push)(
        path,
        options.state,
        options
      );
    },
    [
      basename,
      navigator,
      routePathnamesJson,
      locationPathname,
      dataRouterContext
    ]
  );
  return navigate;
}
reactExports.createContext(null);
function useResolvedPath(to, { relative } = {}) {
  let { matches } = reactExports.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  return reactExports.useMemo(
    () => resolveTo(
      to,
      JSON.parse(routePathnamesJson),
      locationPathname,
      relative === "path"
    ),
    [to, routePathnamesJson, locationPathname, relative]
  );
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useRoutes() may be used only in the context of a <Router> component.`
  );
  let { navigator } = reactExports.useContext(NavigationContext);
  let { matches: parentMatches } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(
      parentPathname,
      !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`
    );
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    invariant(
      parentPathnameBase === "/" || parsedLocationArg.pathname?.startsWith(parentPathnameBase),
      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`
    );
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches = matchRoutes(routes, { pathname: remainingPathname });
  {
    warning(
      parentRoute || matches != null,
      `No routes matched location "${location.pathname}${location.search}${location.hash}" `
    );
    warning(
      matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0,
      `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
    );
  }
  let renderedMatches = _renderMatches(
    matches && matches.map(
      (match) => Object.assign({}, match, {
        params: Object.assign({}, parentParams, match.params),
        pathname: joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname
        ]),
        pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
        ])
      })
    ),
    parentMatches,
    dataRouterState,
    future
  );
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(
      LocationContext.Provider,
      {
        value: {
          location: {
            pathname: "/",
            search: "",
            hash: "",
            state: null,
            key: "default",
            ...location
          },
          navigationType: "POP"
          /* Pop */
        }
      },
      renderedMatches
    );
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = { padding: "0.5rem", backgroundColor: lightgrey };
  let codeStyles = { padding: "2px 4px", backgroundColor: lightgrey };
  let devInfo = null;
  {
    console.error(
      "Error handled by React Router default ErrorBoundary:",
      error
    );
    devInfo = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("p", null, " Hey developer "), /* @__PURE__ */ reactExports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ reactExports.createElement("code", { style: codeStyles }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ reactExports.createElement("code", { style: codeStyles }, "errorElement"), " prop on your route."));
  }
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", { style: { fontStyle: "italic" } }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", { style: preStyles }, stack) : null, devInfo);
}
var defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
var RenderErrorBoundary = class extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error(
      "React Router caught the following error during render",
      error,
      errorInfo
    );
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, { value: this.props.routeContext }, /* @__PURE__ */ reactExports.createElement(
      RouteErrorContext.Provider,
      {
        value: this.state.error,
        children: this.props.component
      }
    )) : this.props.children;
  }
};
function RenderedRoute({ routeContext, match, children }) {
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, { value: routeContext }, children);
}
function _renderMatches(matches, parentMatches = [], dataRouterState = null, future = null) {
  if (matches == null) {
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = dataRouterState?.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex(
      (m) => m.route.id && errors?.[m.route.id] !== void 0
    );
    invariant(
      errorIndex >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        errors
      ).join(",")}`
    );
    renderedMatches = renderedMatches.slice(
      0,
      Math.min(renderedMatches.length, errorIndex + 1)
    );
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState) {
    for (let i = 0; i < renderedMatches.length; i++) {
      let match = renderedMatches[i];
      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
        fallbackIndex = i;
      }
      if (match.route.id) {
        let { loaderData, errors: errors2 } = dataRouterState;
        let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);
        if (match.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight(
    (outlet, match, index) => {
      let error;
      let shouldRenderHydrateFallback = false;
      let errorElement = null;
      let hydrateFallbackElement = null;
      if (dataRouterState) {
        error = errors && match.route.id ? errors[match.route.id] : void 0;
        errorElement = match.route.errorElement || defaultErrorElement;
        if (renderFallback) {
          if (fallbackIndex < 0 && index === 0) {
            warningOnce(
              "route-fallback",
              false,
              "No `HydrateFallback` element provided to render during initial hydration"
            );
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = null;
          } else if (fallbackIndex === index) {
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = match.route.hydrateFallbackElement || null;
          }
        }
      }
      let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
      let getChildren = () => {
        let children;
        if (error) {
          children = errorElement;
        } else if (shouldRenderHydrateFallback) {
          children = hydrateFallbackElement;
        } else if (match.route.Component) {
          children = /* @__PURE__ */ reactExports.createElement(match.route.Component, null);
        } else if (match.route.element) {
          children = match.route.element;
        } else {
          children = outlet;
        }
        return /* @__PURE__ */ reactExports.createElement(
          RenderedRoute,
          {
            match,
            routeContext: {
              outlet,
              matches: matches2,
              isDataRoute: dataRouterState != null
            },
            children
          }
        );
      };
      return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ reactExports.createElement(
        RenderErrorBoundary,
        {
          location: dataRouterState.location,
          revalidation: dataRouterState.revalidation,
          component: errorElement,
          error,
          children: getChildren(),
          routeContext: { outlet: null, matches: matches2, isDataRoute: true }
        }
      ) : getChildren();
    },
    null
  );
}
function getDataRouterConsoleError(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError(hookName));
  return ctx;
}
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  invariant(state, getDataRouterConsoleError(hookName));
  return state;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  invariant(route, getDataRouterConsoleError(hookName));
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  invariant(
    thisRoute.route.id,
    `${hookName} can only be used on routes that contain a unique "id"`
  );
  return thisRoute.route.id;
}
function useRouteId() {
  return useCurrentRouteId(
    "useRouteId"
    /* UseRouteId */
  );
}
function useRouteError() {
  let error = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState(
    "useRouteError"
    /* UseRouteError */
  );
  let routeId = useCurrentRouteId(
    "useRouteError"
    /* UseRouteError */
  );
  if (error !== void 0) {
    return error;
  }
  return state.errors?.[routeId];
}
function useNavigateStable() {
  let { router } = useDataRouterContext(
    "useNavigate"
    /* UseNavigateStable */
  );
  let id = useCurrentRouteId(
    "useNavigate"
    /* UseNavigateStable */
  );
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(
    async (to, options = {}) => {
      warning(activeRef.current, navigateEffectWarning);
      if (!activeRef.current) return;
      if (typeof to === "number") {
        router.navigate(to);
      } else {
        await router.navigate(to, { fromRouteId: id, ...options });
      }
    },
    [router, id]
  );
  return navigate;
}
var alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
    warning(false, message);
  }
}
reactExports.memo(DataRoutes);
function DataRoutes({
  routes,
  future,
  state
}) {
  return useRoutesImpl(routes, void 0, state, future);
}
function Navigate({
  to,
  replace: replace2,
  state,
  relative
}) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    `<Navigate> may be used only in the context of a <Router> component.`
  );
  let { static: isStatic } = reactExports.useContext(NavigationContext);
  warning(
    !isStatic,
    `<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.`
  );
  let { matches } = reactExports.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let navigate = useNavigate();
  let path = resolveTo(
    to,
    getResolveToMatches(matches),
    locationPathname,
    relative === "path"
  );
  let jsonPath = JSON.stringify(path);
  reactExports.useEffect(() => {
    navigate(JSON.parse(jsonPath), { replace: replace2, state, relative });
  }, [navigate, jsonPath, relative, replace2, state]);
  return null;
}
function Route(props) {
  invariant(
    false,
    `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`
  );
}
function Router({
  basename: basenameProp = "/",
  children = null,
  location: locationProp,
  navigationType = "POP",
  navigator,
  static: staticProp = false
}) {
  invariant(
    !useInRouterContext(),
    `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`
  );
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(
    () => ({
      basename,
      navigator,
      static: staticProp,
      future: {}
    }),
    [basename, navigator, staticProp]
  );
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
  warning(
    locationContext != null,
    `<Router basename="${basename}"> is not able to match the URL "${pathname}${search}${hash}" because it does not start with the basename, so the <Router> won't render anything.`
  );
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, { value: navigationContext }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, { children, value: locationContext }));
}
function Routes({
  children,
  location
}) {
  return useRoutes(createRoutesFromChildren(children), location);
}
function createRoutesFromChildren(children, parentPath = []) {
  let routes = [];
  reactExports.Children.forEach(children, (element, index) => {
    if (!reactExports.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index];
    if (element.type === reactExports.Fragment) {
      routes.push.apply(
        routes,
        createRoutesFromChildren(element.props.children, treePath)
      );
      return;
    }
    invariant(
      element.type === Route,
      `[${typeof element.type === "string" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`
    );
    invariant(
      !element.props.index || !element.props.children,
      "An index route cannot have child routes."
    );
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      hydrateFallbackElement: element.props.hydrateFallbackElement,
      HydrateFallback: element.props.HydrateFallback,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(
        element.props.children,
        treePath
      );
    }
    routes.push(route);
  });
  return routes;
}
var defaultMethod = "get";
var defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
var _formDataSupportsSubmitter = null;
function isFormDataSubmitterSupported() {
  if (_formDataSupportsSubmitter === null) {
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      );
      _formDataSupportsSubmitter = false;
    } catch (e) {
      _formDataSupportsSubmitter = true;
    }
  }
  return _formDataSupportsSubmitter;
}
var supportedFormEncTypes = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
]);
function getFormEncType(encType) {
  if (encType != null && !supportedFormEncTypes.has(encType)) {
    warning(
      false,
      `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`
    );
    return null;
  }
  return encType;
}
function getFormSubmissionInfo(target, basename) {
  let method;
  let action;
  let encType;
  let formData;
  let body;
  if (isFormElement(target)) {
    let attr = target.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(target);
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error(
        `Cannot submit a <button> or <input type="submit"> without a <form>`
      );
    }
    let attr = target.getAttribute("formaction") || form.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(form, target);
    if (!isFormDataSubmitterSupported()) {
      let { name, type, value } = target;
      if (type === "image") {
        let prefix = name ? `${name}.` : "";
        formData.append(`${prefix}x`, "0");
        formData.append(`${prefix}y`, "0");
      } else if (name) {
        formData.append(name, value);
      }
    }
  } else if (isHtmlElement(target)) {
    throw new Error(
      `Cannot submit element that is not <form>, <button>, or <input type="submit|image">`
    );
  } else {
    method = defaultMethod;
    action = null;
    encType = defaultEncType;
    body = target;
  }
  if (formData && encType === "text/plain") {
    body = formData;
    formData = void 0;
  }
  return { action, method: method.toLowerCase(), encType, formData, body };
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function invariant2(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function singleFetchUrl(reqUrl, basename, extension) {
  let url = typeof reqUrl === "string" ? new URL(
    reqUrl,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window === "undefined" ? "server://singlefetch/" : window.location.origin
  ) : reqUrl;
  if (url.pathname === "/") {
    url.pathname = `_root.${extension}`;
  } else if (basename && stripBasename(url.pathname, basename) === "/") {
    url.pathname = `${basename.replace(/\/$/, "")}/_root.${extension}`;
  } else {
    url.pathname = `${url.pathname.replace(/\/$/, "")}.${extension}`;
  }
  return url;
}
async function loadRouteModule(route, routeModulesCache) {
  if (route.id in routeModulesCache) {
    return routeModulesCache[route.id];
  }
  try {
    let routeModule = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      route.module
    );
    routeModulesCache[route.id] = routeModule;
    return routeModule;
  } catch (error) {
    console.error(
      `Error loading route module \`${route.module}\`, reloading page...`
    );
    console.error(error);
    if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error
    void 0) ;
    window.location.reload();
    return new Promise(() => {
    });
  }
}
function isHtmlLinkDescriptor(object) {
  if (object == null) {
    return false;
  }
  if (object.href == null) {
    return object.rel === "preload" && typeof object.imageSrcSet === "string" && typeof object.imageSizes === "string";
  }
  return typeof object.rel === "string" && typeof object.href === "string";
}
async function getKeyedPrefetchLinks(matches, manifest, routeModules) {
  let links = await Promise.all(
    matches.map(async (match) => {
      let route = manifest.routes[match.route.id];
      if (route) {
        let mod = await loadRouteModule(route, routeModules);
        return mod.links ? mod.links() : [];
      }
      return [];
    })
  );
  return dedupeLinkDescriptors(
    links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map(
      (link) => link.rel === "stylesheet" ? { ...link, rel: "prefetch", as: "style" } : { ...link, rel: "prefetch" }
    )
  );
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
  let isNew = (match, index) => {
    if (!currentMatches[index]) return true;
    return match.route.id !== currentMatches[index].route.id;
  };
  let matchPathChanged = (match, index) => {
    return (
      // param change, /users/123 -> /users/456
      currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      currentMatches[index].route.path?.endsWith("*") && currentMatches[index].params["*"] !== match.params["*"]
    );
  };
  if (mode === "assets") {
    return nextMatches.filter(
      (match, index) => isNew(match, index) || matchPathChanged(match, index)
    );
  }
  if (mode === "data") {
    return nextMatches.filter((match, index) => {
      let manifestRoute = manifest.routes[match.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return false;
      }
      if (isNew(match, index) || matchPathChanged(match, index)) {
        return true;
      }
      if (match.route.shouldRevalidate) {
        let routeChoice = match.route.shouldRevalidate({
          currentUrl: new URL(
            location.pathname + location.search + location.hash,
            window.origin
          ),
          currentParams: currentMatches[0]?.params || {},
          nextUrl: new URL(page, window.origin),
          nextParams: match.params,
          defaultShouldRevalidate: true
        });
        if (typeof routeChoice === "boolean") {
          return routeChoice;
        }
      }
      return true;
    });
  }
  return [];
}
function getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {
  return dedupeHrefs(
    matches.map((match) => {
      let route = manifest.routes[match.route.id];
      if (!route) return [];
      let hrefs = [route.module];
      if (route.clientActionModule) {
        hrefs = hrefs.concat(route.clientActionModule);
      }
      if (route.clientLoaderModule) {
        hrefs = hrefs.concat(route.clientLoaderModule);
      }
      if (includeHydrateFallback && route.hydrateFallbackModule) {
        hrefs = hrefs.concat(route.hydrateFallbackModule);
      }
      if (route.imports) {
        hrefs = hrefs.concat(route.imports);
      }
      return hrefs;
    }).flat(1)
  );
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function sortKeys(obj) {
  let sorted = {};
  let keys = Object.keys(obj).sort();
  for (let key of keys) {
    sorted[key] = obj[key];
  }
  return sorted;
}
function dedupeLinkDescriptors(descriptors, preloads) {
  let set = /* @__PURE__ */ new Set();
  new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    let key = JSON.stringify(sortKeys(descriptor));
    if (!set.has(key)) {
      set.add(key);
      deduped.push({ key, link: descriptor });
    }
    return deduped;
  }, []);
}
function useDataRouterContext2() {
  let context = reactExports.useContext(DataRouterContext);
  invariant2(
    context,
    "You must render this element inside a <DataRouterContext.Provider> element"
  );
  return context;
}
function useDataRouterStateContext() {
  let context = reactExports.useContext(DataRouterStateContext);
  invariant2(
    context,
    "You must render this element inside a <DataRouterStateContext.Provider> element"
  );
  return context;
}
var FrameworkContext = reactExports.createContext(void 0);
FrameworkContext.displayName = "FrameworkContext";
function useFrameworkContext() {
  let context = reactExports.useContext(FrameworkContext);
  invariant2(
    context,
    "You must render this element inside a <HydratedRouter> element"
  );
  return context;
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let frameworkContext = reactExports.useContext(FrameworkContext);
  let [maybePrefetch, setMaybePrefetch] = reactExports.useState(false);
  let [shouldPrefetch, setShouldPrefetch] = reactExports.useState(false);
  let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;
  let ref = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (prefetch === "render") {
      setShouldPrefetch(true);
    }
    if (prefetch === "viewport") {
      let callback = (entries) => {
        entries.forEach((entry) => {
          setShouldPrefetch(entry.isIntersecting);
        });
      };
      let observer = new IntersectionObserver(callback, { threshold: 0.5 });
      if (ref.current) observer.observe(ref.current);
      return () => {
        observer.disconnect();
      };
    }
  }, [prefetch]);
  reactExports.useEffect(() => {
    if (maybePrefetch) {
      let id = setTimeout(() => {
        setShouldPrefetch(true);
      }, 100);
      return () => {
        clearTimeout(id);
      };
    }
  }, [maybePrefetch]);
  let setIntent = () => {
    setMaybePrefetch(true);
  };
  let cancelIntent = () => {
    setMaybePrefetch(false);
    setShouldPrefetch(false);
  };
  if (!frameworkContext) {
    return [false, ref, {}];
  }
  if (prefetch !== "intent") {
    return [shouldPrefetch, ref, {}];
  }
  return [
    shouldPrefetch,
    ref,
    {
      onFocus: composeEventHandlers(onFocus, setIntent),
      onBlur: composeEventHandlers(onBlur, cancelIntent),
      onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
      onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
      onTouchStart: composeEventHandlers(onTouchStart, setIntent)
    }
  ];
}
function composeEventHandlers(theirHandler, ourHandler) {
  return (event) => {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      ourHandler(event);
    }
  };
}
function PrefetchPageLinks({ page, ...linkProps }) {
  let { router } = useDataRouterContext2();
  let matches = reactExports.useMemo(
    () => matchRoutes(router.routes, page, router.basename),
    [router.routes, page, router.basename]
  );
  if (!matches) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(PrefetchPageLinksImpl, { page, matches, ...linkProps });
}
function useKeyedPrefetchLinks(matches) {
  let { manifest, routeModules } = useFrameworkContext();
  let [keyedPrefetchLinks, setKeyedPrefetchLinks] = reactExports.useState([]);
  reactExports.useEffect(() => {
    let interrupted = false;
    void getKeyedPrefetchLinks(matches, manifest, routeModules).then(
      (links) => {
        if (!interrupted) {
          setKeyedPrefetchLinks(links);
        }
      }
    );
    return () => {
      interrupted = true;
    };
  }, [matches, manifest, routeModules]);
  return keyedPrefetchLinks;
}
function PrefetchPageLinksImpl({
  page,
  matches: nextMatches,
  ...linkProps
}) {
  let location = useLocation();
  let { manifest, routeModules } = useFrameworkContext();
  let { basename } = useDataRouterContext2();
  let { loaderData, matches } = useDataRouterStateContext();
  let newMatchesForData = reactExports.useMemo(
    () => getNewMatchesForLinks(
      page,
      nextMatches,
      matches,
      manifest,
      location,
      "data"
    ),
    [page, nextMatches, matches, manifest, location]
  );
  let newMatchesForAssets = reactExports.useMemo(
    () => getNewMatchesForLinks(
      page,
      nextMatches,
      matches,
      manifest,
      location,
      "assets"
    ),
    [page, nextMatches, matches, manifest, location]
  );
  let dataHrefs = reactExports.useMemo(() => {
    if (page === location.pathname + location.search + location.hash) {
      return [];
    }
    let routesParams = /* @__PURE__ */ new Set();
    let foundOptOutRoute = false;
    nextMatches.forEach((m) => {
      let manifestRoute = manifest.routes[m.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return;
      }
      if (!newMatchesForData.some((m2) => m2.route.id === m.route.id) && m.route.id in loaderData && routeModules[m.route.id]?.shouldRevalidate) {
        foundOptOutRoute = true;
      } else if (manifestRoute.hasClientLoader) {
        foundOptOutRoute = true;
      } else {
        routesParams.add(m.route.id);
      }
    });
    if (routesParams.size === 0) {
      return [];
    }
    let url = singleFetchUrl(page, basename, "data");
    if (foundOptOutRoute && routesParams.size > 0) {
      url.searchParams.set(
        "_routes",
        nextMatches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(",")
      );
    }
    return [url.pathname + url.search];
  }, [
    basename,
    loaderData,
    location,
    manifest,
    newMatchesForData,
    nextMatches,
    page,
    routeModules
  ]);
  let moduleHrefs = reactExports.useMemo(
    () => getModuleLinkHrefs(newMatchesForAssets, manifest),
    [newMatchesForAssets, manifest]
  );
  let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ reactExports.createElement("link", { key: href, rel: "prefetch", as: "fetch", href, ...linkProps })), moduleHrefs.map((href) => /* @__PURE__ */ reactExports.createElement("link", { key: href, rel: "modulepreload", href, ...linkProps })), keyedPrefetchLinks.map(({ key, link }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    /* @__PURE__ */ reactExports.createElement("link", { key, nonce: linkProps.nonce, ...link })
  )));
}
function mergeRefs(...refs) {
  return (value) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
try {
  if (isBrowser) {
    window.__reactRouterVersion = // @ts-expect-error
    "7.8.1";
  }
} catch (e) {
}
function BrowserRouter({
  basename,
  children,
  window: window2
}) {
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({ window: window2, v5Compat: true });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  let setState = reactExports.useCallback(
    (newState) => {
      reactExports.startTransition(() => setStateImpl(newState));
    },
    [setStateImpl]
  );
  reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ reactExports.createElement(
    Router,
    {
      basename,
      children,
      location: state.location,
      navigationType: state.action,
      navigator: history
    }
  );
}
var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var Link = reactExports.forwardRef(
  function LinkWithRef({
    onClick,
    discover = "render",
    prefetch = "none",
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to,
    preventScrollReset,
    viewTransition,
    ...rest
  }, forwardedRef) {
    let { basename } = reactExports.useContext(NavigationContext);
    let isAbsolute = typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to);
    let absoluteHref;
    let isExternal = false;
    if (typeof to === "string" && isAbsolute) {
      absoluteHref = to;
      if (isBrowser) {
        try {
          let currentUrl = new URL(window.location.href);
          let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
          let path = stripBasename(targetUrl.pathname, basename);
          if (targetUrl.origin === currentUrl.origin && path != null) {
            to = path + targetUrl.search + targetUrl.hash;
          } else {
            isExternal = true;
          }
        } catch (e) {
          warning(
            false,
            `<Link to="${to}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
          );
        }
      }
    }
    let href = useHref(to, { relative });
    let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(
      prefetch,
      rest
    );
    let internalOnClick = useLinkClickHandler(to, {
      replace: replace2,
      state,
      target,
      preventScrollReset,
      relative,
      viewTransition
    });
    function handleClick(event) {
      if (onClick) onClick(event);
      if (!event.defaultPrevented) {
        internalOnClick(event);
      }
    }
    let link = (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      /* @__PURE__ */ reactExports.createElement(
        "a",
        {
          ...rest,
          ...prefetchHandlers,
          href: absoluteHref || href,
          onClick: isExternal || reloadDocument ? onClick : handleClick,
          ref: mergeRefs(forwardedRef, prefetchRef),
          target,
          "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
        }
      )
    );
    return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, link, /* @__PURE__ */ reactExports.createElement(PrefetchPageLinks, { page: href })) : link;
  }
);
Link.displayName = "Link";
var NavLink = reactExports.forwardRef(
  function NavLinkWithRef({
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    viewTransition,
    children,
    ...rest
  }, ref) {
    let path = useResolvedPath(to, { relative: rest.relative });
    let location = useLocation();
    let routerState = reactExports.useContext(DataRouterStateContext);
    let { navigator, basename } = reactExports.useContext(NavigationContext);
    let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useViewTransitionState(path) && viewTransition === true;
    let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
    let locationPathname = location.pathname;
    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
    if (!caseSensitive) {
      locationPathname = locationPathname.toLowerCase();
      nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
      toPathname = toPathname.toLowerCase();
    }
    if (nextLocationPathname && basename) {
      nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
    }
    const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
    let renderProps = {
      isActive,
      isPending,
      isTransitioning
    };
    let ariaCurrent = isActive ? ariaCurrentProp : void 0;
    let className;
    if (typeof classNameProp === "function") {
      className = classNameProp(renderProps);
    } else {
      className = [
        classNameProp,
        isActive ? "active" : null,
        isPending ? "pending" : null,
        isTransitioning ? "transitioning" : null
      ].filter(Boolean).join(" ");
    }
    let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
    return /* @__PURE__ */ reactExports.createElement(
      Link,
      {
        ...rest,
        "aria-current": ariaCurrent,
        className,
        ref,
        style,
        to,
        viewTransition
      },
      typeof children === "function" ? children(renderProps) : children
    );
  }
);
NavLink.displayName = "NavLink";
var Form = reactExports.forwardRef(
  ({
    discover = "render",
    fetcherKey,
    navigate,
    reloadDocument,
    replace: replace2,
    state,
    method = defaultMethod,
    action,
    onSubmit,
    relative,
    preventScrollReset,
    viewTransition,
    ...props
  }, forwardedRef) => {
    let submit = useSubmit();
    let formAction = useFormAction(action, { relative });
    let formMethod = method.toLowerCase() === "get" ? "get" : "post";
    let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
    let submitHandler = (event) => {
      onSubmit && onSubmit(event);
      if (event.defaultPrevented) return;
      event.preventDefault();
      let submitter = event.nativeEvent.submitter;
      let submitMethod = submitter?.getAttribute("formmethod") || method;
      submit(submitter || event.currentTarget, {
        fetcherKey,
        method: submitMethod,
        navigate,
        replace: replace2,
        state,
        relative,
        preventScrollReset,
        viewTransition
      });
    };
    return /* @__PURE__ */ reactExports.createElement(
      "form",
      {
        ref: forwardedRef,
        method: formMethod,
        action: formAction,
        onSubmit: reloadDocument ? onSubmit : submitHandler,
        ...props,
        "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
      }
    );
  }
);
Form.displayName = "Form";
function getDataRouterConsoleError2(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext3(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError2(hookName));
  return ctx;
}
function useLinkClickHandler(to, {
  target,
  replace: replaceProp,
  state,
  preventScrollReset,
  relative,
  viewTransition
} = {}) {
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, { relative });
  return reactExports.useCallback(
    (event) => {
      if (shouldProcessLinkClick(event, target)) {
        event.preventDefault();
        let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
        navigate(to, {
          replace: replace2,
          state,
          preventScrollReset,
          relative,
          viewTransition
        });
      }
    },
    [
      location,
      navigate,
      path,
      replaceProp,
      state,
      target,
      to,
      preventScrollReset,
      relative,
      viewTransition
    ]
  );
}
var fetcherId = 0;
var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
function useSubmit() {
  let { router } = useDataRouterContext3(
    "useSubmit"
    /* UseSubmit */
  );
  let { basename } = reactExports.useContext(NavigationContext);
  let currentRouteId = useRouteId();
  return reactExports.useCallback(
    async (target, options = {}) => {
      let { action, method, encType, formData, body } = getFormSubmissionInfo(
        target,
        basename
      );
      if (options.navigate === false) {
        let key = options.fetcherKey || getUniqueFetcherId();
        await router.fetch(key, currentRouteId, options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          flushSync: options.flushSync
        });
      } else {
        await router.navigate(options.action || action, {
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          replace: options.replace,
          state: options.state,
          fromRouteId: currentRouteId,
          flushSync: options.flushSync,
          viewTransition: options.viewTransition
        });
      }
    },
    [router, basename, currentRouteId]
  );
}
function useFormAction(action, { relative } = {}) {
  let { basename } = reactExports.useContext(NavigationContext);
  let routeContext = reactExports.useContext(RouteContext);
  invariant(routeContext, "useFormAction must be used inside a RouteContext");
  let [match] = routeContext.matches.slice(-1);
  let path = { ...useResolvedPath(action ? action : ".", { relative }) };
  let location = useLocation();
  if (action == null) {
    path.search = location.search;
    let params = new URLSearchParams(path.search);
    let indexValues = params.getAll("index");
    let hasNakedIndexParam = indexValues.some((v) => v === "");
    if (hasNakedIndexParam) {
      params.delete("index");
      indexValues.filter((v) => v).forEach((v) => params.append("index", v));
      let qs = params.toString();
      path.search = qs ? `?${qs}` : "";
    }
  }
  if ((!action || action === ".") && match.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
function useViewTransitionState(to, { relative } = {}) {
  let vtContext = reactExports.useContext(ViewTransitionContext);
  invariant(
    vtContext != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename } = useDataRouterContext3(
    "useViewTransitionState"
    /* useViewTransitionState */
  );
  let path = useResolvedPath(to, { relative });
  if (!vtContext.isTransitioning) {
    return false;
  }
  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
}

const createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const api = { setState, getState, getInitialState, subscribe };
  const initialState = state = createState(setState, getState, api);
  return api;
};
const createStore = ((createState) => createState ? createStoreImpl(createState) : createStoreImpl);

const identity = (arg) => arg;
function useStore$1(api, selector = identity) {
  const slice = React.useSyncExternalStore(
    api.subscribe,
    React.useCallback(() => selector(api.getState()), [api, selector]),
    React.useCallback(() => selector(api.getInitialState()), [api, selector])
  );
  React.useDebugValue(slice);
  return slice;
}
const createImpl = (createState) => {
  const api = createStore(createState);
  const useBoundStore = (selector) => useStore$1(api, selector);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
const create = ((createState) => createImpl);

const __vite_import_meta_env__ = {"BASE_URL": "/", "DEV": false, "MODE": "production", "PROD": true, "SSR": false};
const trackedConnections = /* @__PURE__ */ new Map();
const getTrackedConnectionState = (name) => {
  const api = trackedConnections.get(name);
  if (!api) return {};
  return Object.fromEntries(
    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])
  );
};
const extractConnectionInformation = (store, extensionConnector, options) => {
  if (store === void 0) {
    return {
      type: "untracked",
      connection: extensionConnector.connect(options)
    };
  }
  const existingConnection = trackedConnections.get(options.name);
  if (existingConnection) {
    return { type: "tracked", store, ...existingConnection };
  }
  const newConnection = {
    connection: extensionConnector.connect(options),
    stores: {}
  };
  trackedConnections.set(options.name, newConnection);
  return { type: "tracked", store, ...newConnection };
};
const removeStoreFromTrackedConnections = (name, store) => {
  if (store === void 0) return;
  const connectionInfo = trackedConnections.get(name);
  if (!connectionInfo) return;
  delete connectionInfo.stores[store];
  if (Object.keys(connectionInfo.stores).length === 0) {
    trackedConnections.delete(name);
  }
};
const findCallerName = (stack) => {
  var _a, _b;
  if (!stack) return void 0;
  const traceLines = stack.split("\n");
  const apiSetStateLineIndex = traceLines.findIndex(
    (traceLine) => traceLine.includes("api.setState")
  );
  if (apiSetStateLineIndex < 0) return void 0;
  const callerLine = ((_a = traceLines[apiSetStateLineIndex + 1]) == null ? void 0 : _a.trim()) || "";
  return (_b = /.+ (.+) .+/.exec(callerLine)) == null ? void 0 : _b[1];
};
const devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {
  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;
  let extensionConnector;
  try {
    extensionConnector = (enabled != null ? enabled : (__vite_import_meta_env__ ? "production" : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch (e) {
  }
  if (!extensionConnector) {
    return fn(set, get, api);
  }
  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);
  let isRecording = true;
  api.setState = ((state, replace, nameOrAction) => {
    const r = set(state, replace);
    if (!isRecording) return r;
    const action = nameOrAction === void 0 ? {
      type: anonymousActionType || findCallerName(new Error().stack) || "anonymous"
    } : typeof nameOrAction === "string" ? { type: nameOrAction } : nameOrAction;
    if (store === void 0) {
      connection == null ? void 0 : connection.send(action, get());
      return r;
    }
    connection == null ? void 0 : connection.send(
      {
        ...action,
        type: `${store}/${action.type}`
      },
      {
        ...getTrackedConnectionState(options.name),
        [store]: api.getState()
      }
    );
    return r;
  });
  api.devtools = {
    cleanup: () => {
      if (connection && typeof connection.unsubscribe === "function") {
        connection.unsubscribe();
      }
      removeStoreFromTrackedConnections(options.name, store);
    }
  };
  const setStateFromDevtools = (...a) => {
    const originalIsRecording = isRecording;
    isRecording = false;
    set(...a);
    isRecording = originalIsRecording;
  };
  const initialState = fn(api.setState, get, api);
  if (connectionInformation.type === "untracked") {
    connection == null ? void 0 : connection.init(initialState);
  } else {
    connectionInformation.stores[connectionInformation.store] = api;
    connection == null ? void 0 : connection.init(
      Object.fromEntries(
        Object.entries(connectionInformation.stores).map(([key, store2]) => [
          key,
          key === connectionInformation.store ? initialState : store2.getState()
        ])
      )
    );
  }
  if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
    let didWarnAboutReservedActionType = false;
    const originalDispatch = api.dispatch;
    api.dispatch = (...args) => {
      if ((__vite_import_meta_env__ ? "production" : void 0) !== "production" && args[0].type === "__setState" && !didWarnAboutReservedActionType) {
        console.warn(
          '[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'
        );
        didWarnAboutReservedActionType = true;
      }
      originalDispatch(...args);
    };
  }
  connection.subscribe((message) => {
    var _a;
    switch (message.type) {
      case "ACTION":
        if (typeof message.payload !== "string") {
          console.error(
            "[zustand devtools middleware] Unsupported action format"
          );
          return;
        }
        return parseJsonThen(
          message.payload,
          (action) => {
            if (action.type === "__setState") {
              if (store === void 0) {
                setStateFromDevtools(action.state);
                return;
              }
              if (Object.keys(action.state).length !== 1) {
                console.error(
                  `
                    [zustand devtools middleware] Unsupported __setState action format.
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
                );
              }
              const stateFromDevtools = action.state[store];
              if (stateFromDevtools === void 0 || stateFromDevtools === null) {
                return;
              }
              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {
                setStateFromDevtools(stateFromDevtools);
              }
              return;
            }
            if (!api.dispatchFromDevtools) return;
            if (typeof api.dispatch !== "function") return;
            api.dispatch(action);
          }
        );
      case "DISPATCH":
        switch (message.payload.type) {
          case "RESET":
            setStateFromDevtools(initialState);
            if (store === void 0) {
              return connection == null ? void 0 : connection.init(api.getState());
            }
            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
          case "COMMIT":
            if (store === void 0) {
              connection == null ? void 0 : connection.init(api.getState());
              return;
            }
            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
          case "ROLLBACK":
            return parseJsonThen(message.state, (state) => {
              if (store === void 0) {
                setStateFromDevtools(state);
                connection == null ? void 0 : connection.init(api.getState());
                return;
              }
              setStateFromDevtools(state[store]);
              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
            });
          case "JUMP_TO_STATE":
          case "JUMP_TO_ACTION":
            return parseJsonThen(message.state, (state) => {
              if (store === void 0) {
                setStateFromDevtools(state);
                return;
              }
              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {
                setStateFromDevtools(state[store]);
              }
            });
          case "IMPORT_STATE": {
            const { nextLiftedState } = message.payload;
            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;
            if (!lastComputedState) return;
            if (store === void 0) {
              setStateFromDevtools(lastComputedState);
            } else {
              setStateFromDevtools(lastComputedState[store]);
            }
            connection == null ? void 0 : connection.send(
              null,
              // FIXME no-any
              nextLiftedState
            );
            return;
          }
          case "PAUSE_RECORDING":
            return isRecording = !isRecording;
        }
        return;
    }
  });
  return initialState;
};
const devtools = devtoolsImpl;
const parseJsonThen = (stringified, fn) => {
  let parsed;
  try {
    parsed = JSON.parse(stringified);
  } catch (e) {
    console.error(
      "[zustand devtools middleware] Could not parse the received json",
      e
    );
  }
  if (parsed !== void 0) fn(parsed);
};
const subscribeWithSelectorImpl = (fn) => (set, get, api) => {
  const origSubscribe = api.subscribe;
  api.subscribe = ((selector, optListener, options) => {
    let listener = selector;
    if (optListener) {
      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
      let currentSlice = selector(api.getState());
      listener = (state) => {
        const nextSlice = selector(state);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      };
      if (options == null ? void 0 : options.fireImmediately) {
        optListener(currentSlice, currentSlice);
      }
    }
    return origSubscribe(listener);
  });
  const initialState = fn(set, get, api);
  return initialState;
};
const subscribeWithSelector = subscribeWithSelectorImpl;
function createJSONStorage(getStorage, options) {
  let storage;
  try {
    storage = getStorage();
  } catch (e) {
    return;
  }
  const persistStorage = {
    getItem: (name) => {
      var _a;
      const parse = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2, void 0 );
      };
      const str = (_a = storage.getItem(name)) != null ? _a : null;
      if (str instanceof Promise) {
        return str.then(parse);
      }
      return parse(str);
    },
    setItem: (name, newValue) => storage.setItem(name, JSON.stringify(newValue, void 0 )),
    removeItem: (name) => storage.removeItem(name)
  };
  return persistStorage;
}
const toThenable = (fn) => (input) => {
  try {
    const result = fn(input);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e);
      }
    };
  }
};
const persistImpl = (config, baseOptions) => (set, get, api) => {
  let options = {
    storage: createJSONStorage(() => localStorage),
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage = options.storage;
  if (!storage) {
    return config(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get,
      api
    );
  }
  const setItem = () => {
    const state = options.partialize({ ...get() });
    return storage.setItem(options.name, {
      state,
      version: options.version
    });
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    return setItem();
  };
  const configResult = config(
    (...args) => {
      set(...args);
      return setItem();
    },
    get,
    api
  );
  api.getInitialState = () => configResult;
  let stateFromStorage;
  const hydrate = () => {
    var _a, _b;
    if (!storage) return;
    hasHydrated = false;
    hydrationListeners.forEach((cb) => {
      var _a2;
      return cb((_a2 = get()) != null ? _a2 : configResult);
    });
    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            const migration = options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
            if (migration instanceof Promise) {
              return migration.then((result) => [true, result]);
            }
            return [true, migration];
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return [false, deserializedStorageValue.state];
        }
      }
      return [false, void 0];
    }).then((migrationResult) => {
      var _a2;
      const [migrated, migratedState] = migrationResult;
      stateFromStorage = options.merge(
        migratedState,
        (_a2 = get()) != null ? _a2 : configResult
      );
      set(stateFromStorage, true);
      if (migrated) {
        return setItem();
      }
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      stateFromStorage = get();
      hasHydrated = true;
      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
    }).catch((e) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.storage) {
        storage = newOptions.storage;
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb) => {
      hydrationListeners.add(cb);
      return () => {
        hydrationListeners.delete(cb);
      };
    },
    onFinishHydration: (cb) => {
      finishHydrationListeners.add(cb);
      return () => {
        finishHydrationListeners.delete(cb);
      };
    }
  };
  if (!options.skipHydration) {
    hydrate();
  }
  return stateFromStorage || configResult;
};
const persist = persistImpl;

const isIterable = (obj) => Symbol.iterator in obj;
const hasIterableEntries = (value) => (
  // HACK: avoid checking entries type
  "entries" in value
);
const compareEntries = (valueA, valueB) => {
  const mapA = valueA instanceof Map ? valueA : new Map(valueA.entries());
  const mapB = valueB instanceof Map ? valueB : new Map(valueB.entries());
  if (mapA.size !== mapB.size) {
    return false;
  }
  for (const [key, value] of mapA) {
    if (!mapB.has(key) || !Object.is(value, mapB.get(key))) {
      return false;
    }
  }
  return true;
};
const compareIterables = (valueA, valueB) => {
  const iteratorA = valueA[Symbol.iterator]();
  const iteratorB = valueB[Symbol.iterator]();
  let nextA = iteratorA.next();
  let nextB = iteratorB.next();
  while (!nextA.done && !nextB.done) {
    if (!Object.is(nextA.value, nextB.value)) {
      return false;
    }
    nextA = iteratorA.next();
    nextB = iteratorB.next();
  }
  return !!nextA.done && !!nextB.done;
};
function shallow(valueA, valueB) {
  if (Object.is(valueA, valueB)) {
    return true;
  }
  if (typeof valueA !== "object" || valueA === null || typeof valueB !== "object" || valueB === null) {
    return false;
  }
  if (Object.getPrototypeOf(valueA) !== Object.getPrototypeOf(valueB)) {
    return false;
  }
  if (isIterable(valueA) && isIterable(valueB)) {
    if (hasIterableEntries(valueA) && hasIterableEntries(valueB)) {
      return compareEntries(valueA, valueB);
    }
    return compareIterables(valueA, valueB);
  }
  return compareEntries(
    { entries: () => Object.entries(valueA) },
    { entries: () => Object.entries(valueB) }
  );
}

function useShallow(selector) {
  const prev = React.useRef(void 0);
  return (state) => {
    const next = selector(state);
    return shallow(prev.current, next) ? prev.current : prev.current = next;
  };
}

var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
function die(error, ...args) {
  throw new Error(
    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  if (!value)
    return false;
  return isPlainObject$2(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject$2(value) {
  if (!value || typeof value !== "object")
    return false;
  const proto = getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object)
    return true;
  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function each(obj, iter) {
  if (getArchtype(obj) === 0) {
    Reflect.ownKeys(obj).forEach((key) => {
      iter(key, obj[key], obj);
    });
  } else {
    obj.forEach((entry, index) => iter(index, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
}
function has(thing, prop) {
  return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function set(thing, propOrOldValue, value) {
  const t = getArchtype(thing);
  if (t === 2)
    thing.set(propOrOldValue, value);
  else if (t === 3) {
    thing.add(value);
  } else
    thing[propOrOldValue] = value;
}
function is(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function isMap(target) {
  return target instanceof Map;
}
function isSet(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
  if (isMap(base)) {
    return new Map(base);
  }
  if (isSet(base)) {
    return new Set(base);
  }
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  const isPlain = isPlainObject$2(base);
  if (strict === true || strict === "class_only" && !isPlain) {
    const descriptors = Object.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys = Reflect.ownKeys(descriptors);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const desc = descriptors[key];
      if (desc.writable === false) {
        desc.writable = true;
        desc.configurable = true;
      }
      if (desc.get || desc.set)
        descriptors[key] = {
          configurable: true,
          writable: true,
          // could live with !!desc.set as well here...
          enumerable: desc.enumerable,
          value: base[key]
        };
    }
    return Object.create(getPrototypeOf(base), descriptors);
  } else {
    const proto = getPrototypeOf(base);
    if (proto !== null && isPlain) {
      return { ...base };
    }
    const obj = Object.create(proto);
    return Object.assign(obj, base);
  }
}
function freeze(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
  }
  Object.freeze(obj);
  if (deep)
    Object.entries(obj).forEach(([key, value]) => freeze(value, true));
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
function isFrozen(obj) {
  return Object.isFrozen(obj);
}
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 || state.type_ === 1)
    state.revoke_();
  else
    state.revoked_ = true;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize(scope, result);
      if (!scope.parent_)
        maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(
        baseDraft[DRAFT_STATE].base_,
        result,
        scope.patches_,
        scope.inversePatches_
      );
    }
  } else {
    result = finalize(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path) {
  if (isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  if (!state) {
    each(
      value,
      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)
    );
    return value;
  }
  if (state.scope_ !== rootScope)
    return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result;
    let isSet2 = false;
    if (state.type_ === 3) {
      resultEach = new Set(result);
      result.clear();
      isSet2 = true;
    }
    each(
      resultEach,
      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)
    );
    maybeFreeze(rootScope, result, false);
    if (path && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(
        state,
        path,
        rootScope.patches_,
        rootScope.inversePatches_
      );
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (isDraft(childValue)) {
    const path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    const res = finalize(rootScope, childValue, path);
    set(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else
      return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !isFrozen(childValue)) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    finalize(rootScope, childValue);
    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))
      maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}
function createProxyProxy(base, parent) {
  const isArray = Array.isArray(base);
  const state = {
    type_: isArray ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy } = Proxy.revocable(target, traps);
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    const source = latest(state);
    if (!has(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value, state);
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc?.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      const current2 = peek(latest(state), prop);
      const currentState = current2?.[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
        return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
      return true;
    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty(state, prop) {
    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc)
      return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, (key, fn) => {
  arrayTraps[key] = function() {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  const desc = getDescriptorFromProto(source, prop);
  return desc ? `value` in desc ? desc.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    desc.get?.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return void 0;
  let proto = getPrototypeOf(source);
  while (proto) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc)
      return desc;
    proto = getPrototypeOf(proto);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy(
      state.base_,
      state.scope_.immer_.useStrictShallowCopy_
    );
  }
}
var Immer2 = class {
  constructor(config) {
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    this.produce = (base, recipe, patchListener) => {
      if (typeof base === "function" && typeof recipe !== "function") {
        const defaultBase = recipe;
        recipe = base;
        const self = this;
        return function curriedProduce(base2 = defaultBase, ...args) {
          return self.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      if (typeof recipe !== "function")
        die(6);
      if (patchListener !== void 0 && typeof patchListener !== "function")
        die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        let hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          if (hasError)
            revokeScope(scope);
          else
            leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === void 0)
          result = base;
        if (result === NOTHING)
          result = void 0;
        if (this.autoFreeze_)
          freeze(result, true);
        if (patchListener) {
          const p = [];
          const ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
          patchListener(p, ip);
        }
        return result;
      } else
        die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (typeof base === "function") {
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      }
      let patches, inversePatches;
      const result = this.produce(base, recipe, (p, ip) => {
        patches = p;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (typeof config?.autoFreeze === "boolean")
      this.setAutoFreeze(config.autoFreeze);
    if (typeof config?.useStrictShallowCopy === "boolean")
      this.setUseStrictShallowCopy(config.useStrictShallowCopy);
  }
  createDraft(base) {
    if (!isDraftable(base))
      die(8);
    if (isDraft(base))
      base = current(base);
    const scope = enterScope(this);
    const proxy = createProxy(base, void 0);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_)
      die(9);
    const { scope_: scope } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  applyPatches(base, patches) {
    let i;
    for (i = patches.length - 1; i >= 0; i--) {
      const patch = patches[i];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    if (i > -1) {
      patches = patches.slice(i + 1);
    }
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(value, parent) {
  const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
  const scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}
function current(value) {
  if (!isDraft(value))
    die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
  } else {
    copy = shallowCopy(value, true);
  }
  each(copy, (key, childValue) => {
    set(copy, key, currentImpl(childValue));
  });
  if (state) {
    state.finalized_ = false;
  }
  return copy;
}
var immer$1 = new Immer2();
var produce = immer$1.produce;
immer$1.produceWithPatches.bind(
  immer$1
);
immer$1.setAutoFreeze.bind(immer$1);
immer$1.setUseStrictShallowCopy.bind(immer$1);
immer$1.applyPatches.bind(immer$1);
immer$1.createDraft.bind(immer$1);
immer$1.finishDraft.bind(immer$1);

const immerImpl = (initializer) => (set, get, store) => {
  store.setState = (updater, replace, ...args) => {
    const nextState = typeof updater === "function" ? produce(updater) : updater;
    return set(nextState, replace, ...args);
  };
  return initializer(store.setState, get, store);
};
const immer = immerImpl;

const LogLevels = {
  fatal: 0,
  error: 0,
  warn: 1,
  log: 2,
  info: 3,
  success: 3,
  fail: 3,
  debug: 4,
  trace: 5,
  verbose: Number.POSITIVE_INFINITY
};
const LogTypes = {
  // Silent
  silent: {
    level: -1
  },
  // Level 0
  fatal: {
    level: LogLevels.fatal
  },
  error: {
    level: LogLevels.error
  },
  // Level 1
  warn: {
    level: LogLevels.warn
  },
  // Level 2
  log: {
    level: LogLevels.log
  },
  // Level 3
  info: {
    level: LogLevels.info
  },
  success: {
    level: LogLevels.success
  },
  fail: {
    level: LogLevels.fail
  },
  ready: {
    level: LogLevels.info
  },
  start: {
    level: LogLevels.info
  },
  box: {
    level: LogLevels.info
  },
  // Level 4
  debug: {
    level: LogLevels.debug
  },
  // Level 5
  trace: {
    level: LogLevels.trace
  },
  // Verbose
  verbose: {
    level: LogLevels.verbose
  }
};

function isPlainObject$1(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}

function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isPlainObject$1(defaults)) {
    return _defu(baseObject, {}, namespace);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject$1(value) && isPlainObject$1(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString());
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, ""), {})
  );
}
const defu = createDefu();

function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
function isLogObj(arg) {
  if (!isPlainObject(arg)) {
    return false;
  }
  if (!arg.message && !arg.args) {
    return false;
  }
  if (arg.stack) {
    return false;
  }
  return true;
}

let paused = false;
const queue = [];
class Consola {
  options;
  _lastLog;
  _mockFn;
  /**
   * Creates an instance of Consola with specified options or defaults.
   *
   * @param {Partial<ConsolaOptions>} [options={}] - Configuration options for the Consola instance.
   */
  constructor(options = {}) {
    const types = options.types || LogTypes;
    this.options = defu(
      {
        ...options,
        defaults: { ...options.defaults },
        level: _normalizeLogLevel(options.level, types),
        reporters: [...options.reporters || []]
      },
      {
        types: LogTypes,
        throttle: 1e3,
        throttleMin: 5,
        formatOptions: {
          date: true,
          colors: false,
          compact: true
        }
      }
    );
    for (const type in types) {
      const defaults = {
        type,
        ...this.options.defaults,
        ...types[type]
      };
      this[type] = this._wrapLogFn(defaults);
      this[type].raw = this._wrapLogFn(
        defaults,
        true
      );
    }
    if (this.options.mockFn) {
      this.mockTypes();
    }
    this._lastLog = {};
  }
  /**
   * Gets the current log level of the Consola instance.
   *
   * @returns {number} The current log level.
   */
  get level() {
    return this.options.level;
  }
  /**
   * Sets the minimum log level that will be output by the instance.
   *
   * @param {number} level - The new log level to set.
   */
  set level(level) {
    this.options.level = _normalizeLogLevel(
      level,
      this.options.types,
      this.options.level
    );
  }
  /**
   * Displays a prompt to the user and returns the response.
   * Throw an error if `prompt` is not supported by the current configuration.
   *
   * @template T
   * @param {string} message - The message to display in the prompt.
   * @param {T} [opts] - Optional options for the prompt. See {@link PromptOptions}.
   * @returns {promise<T>} A promise that infer with the prompt options. See {@link PromptOptions}.
   */
  prompt(message, opts) {
    if (!this.options.prompt) {
      throw new Error("prompt is not supported!");
    }
    return this.options.prompt(message, opts);
  }
  /**
   * Creates a new instance of Consola, inheriting options from the current instance, with possible overrides.
   *
   * @param {Partial<ConsolaOptions>} options - Optional overrides for the new instance. See {@link ConsolaOptions}.
   * @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.
   */
  create(options) {
    const instance = new Consola({
      ...this.options,
      ...options
    });
    if (this._mockFn) {
      instance.mockTypes(this._mockFn);
    }
    return instance;
  }
  /**
   * Creates a new Consola instance with the specified default log object properties.
   *
   * @param {InputLogObject} defaults - Default properties to include in any log from the new instance. See {@link InputLogObject}.
   * @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.
   */
  withDefaults(defaults) {
    return this.create({
      ...this.options,
      defaults: {
        ...this.options.defaults,
        ...defaults
      }
    });
  }
  /**
   * Creates a new Consola instance with a specified tag, which will be included in every log.
   *
   * @param {string} tag - The tag to include in each log of the new instance.
   * @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.
   */
  withTag(tag) {
    return this.withDefaults({
      tag: this.options.defaults.tag ? this.options.defaults.tag + ":" + tag : tag
    });
  }
  /**
   * Adds a custom reporter to the Consola instance.
   * Reporters will be called for each log message, depending on their implementation and log level.
   *
   * @param {ConsolaReporter} reporter - The reporter to add. See {@link ConsolaReporter}.
   * @returns {Consola} The current Consola instance.
   */
  addReporter(reporter) {
    this.options.reporters.push(reporter);
    return this;
  }
  /**
   * Removes a custom reporter from the Consola instance.
   * If no reporter is specified, all reporters will be removed.
   *
   * @param {ConsolaReporter} reporter - The reporter to remove. See {@link ConsolaReporter}.
   * @returns {Consola} The current Consola instance.
   */
  removeReporter(reporter) {
    if (reporter) {
      const i = this.options.reporters.indexOf(reporter);
      if (i !== -1) {
        return this.options.reporters.splice(i, 1);
      }
    } else {
      this.options.reporters.splice(0);
    }
    return this;
  }
  /**
   * Replaces all reporters of the Consola instance with the specified array of reporters.
   *
   * @param {ConsolaReporter[]} reporters - The new reporters to set. See {@link ConsolaReporter}.
   * @returns {Consola} The current Consola instance.
   */
  setReporters(reporters) {
    this.options.reporters = Array.isArray(reporters) ? reporters : [reporters];
    return this;
  }
  wrapAll() {
    this.wrapConsole();
    this.wrapStd();
  }
  restoreAll() {
    this.restoreConsole();
    this.restoreStd();
  }
  /**
   * Overrides console methods with Consola logging methods for consistent logging.
   */
  wrapConsole() {
    for (const type in this.options.types) {
      if (!console["__" + type]) {
        console["__" + type] = console[type];
      }
      console[type] = this[type].raw;
    }
  }
  /**
   * Restores the original console methods, removing Consola overrides.
   */
  restoreConsole() {
    for (const type in this.options.types) {
      if (console["__" + type]) {
        console[type] = console["__" + type];
        delete console["__" + type];
      }
    }
  }
  /**
   * Overrides standard output and error streams to redirect them through Consola.
   */
  wrapStd() {
    this._wrapStream(this.options.stdout, "log");
    this._wrapStream(this.options.stderr, "log");
  }
  _wrapStream(stream, type) {
    if (!stream) {
      return;
    }
    if (!stream.__write) {
      stream.__write = stream.write;
    }
    stream.write = (data) => {
      this[type].raw(String(data).trim());
    };
  }
  /**
   * Restores the original standard output and error streams, removing the Consola redirection.
   */
  restoreStd() {
    this._restoreStream(this.options.stdout);
    this._restoreStream(this.options.stderr);
  }
  _restoreStream(stream) {
    if (!stream) {
      return;
    }
    if (stream.__write) {
      stream.write = stream.__write;
      delete stream.__write;
    }
  }
  /**
   * Pauses logging, queues incoming logs until resumed.
   */
  pauseLogs() {
    paused = true;
  }
  /**
   * Resumes logging, processing any queued logs.
   */
  resumeLogs() {
    paused = false;
    const _queue = queue.splice(0);
    for (const item of _queue) {
      item[0]._logFn(item[1], item[2]);
    }
  }
  /**
   * Replaces logging methods with mocks if a mock function is provided.
   *
   * @param {ConsolaOptions["mockFn"]} mockFn - The function to use for mocking logging methods. See {@link ConsolaOptions["mockFn"]}.
   */
  mockTypes(mockFn) {
    const _mockFn = mockFn || this.options.mockFn;
    this._mockFn = _mockFn;
    if (typeof _mockFn !== "function") {
      return;
    }
    for (const type in this.options.types) {
      this[type] = _mockFn(type, this.options.types[type]) || this[type];
      this[type].raw = this[type];
    }
  }
  _wrapLogFn(defaults, isRaw) {
    return (...args) => {
      if (paused) {
        queue.push([this, defaults, args, isRaw]);
        return;
      }
      return this._logFn(defaults, args, isRaw);
    };
  }
  _logFn(defaults, args, isRaw) {
    if ((defaults.level || 0) > this.level) {
      return false;
    }
    const logObj = {
      date: /* @__PURE__ */ new Date(),
      args: [],
      ...defaults,
      level: _normalizeLogLevel(defaults.level, this.options.types)
    };
    if (!isRaw && args.length === 1 && isLogObj(args[0])) {
      Object.assign(logObj, args[0]);
    } else {
      logObj.args = [...args];
    }
    if (logObj.message) {
      logObj.args.unshift(logObj.message);
      delete logObj.message;
    }
    if (logObj.additional) {
      if (!Array.isArray(logObj.additional)) {
        logObj.additional = logObj.additional.split("\n");
      }
      logObj.args.push("\n" + logObj.additional.join("\n"));
      delete logObj.additional;
    }
    logObj.type = typeof logObj.type === "string" ? logObj.type.toLowerCase() : "log";
    logObj.tag = typeof logObj.tag === "string" ? logObj.tag : "";
    const resolveLog = (newLog = false) => {
      const repeated = (this._lastLog.count || 0) - this.options.throttleMin;
      if (this._lastLog.object && repeated > 0) {
        const args2 = [...this._lastLog.object.args];
        if (repeated > 1) {
          args2.push(`(repeated ${repeated} times)`);
        }
        this._log({ ...this._lastLog.object, args: args2 });
        this._lastLog.count = 1;
      }
      if (newLog) {
        this._lastLog.object = logObj;
        this._log(logObj);
      }
    };
    clearTimeout(this._lastLog.timeout);
    const diffTime = this._lastLog.time && logObj.date ? logObj.date.getTime() - this._lastLog.time.getTime() : 0;
    this._lastLog.time = logObj.date;
    if (diffTime < this.options.throttle) {
      try {
        const serializedLog = JSON.stringify([
          logObj.type,
          logObj.tag,
          logObj.args
        ]);
        const isSameLog = this._lastLog.serialized === serializedLog;
        this._lastLog.serialized = serializedLog;
        if (isSameLog) {
          this._lastLog.count = (this._lastLog.count || 0) + 1;
          if (this._lastLog.count > this.options.throttleMin) {
            this._lastLog.timeout = setTimeout(
              resolveLog,
              this.options.throttle
            );
            return;
          }
        }
      } catch {
      }
    }
    resolveLog(true);
  }
  _log(logObj) {
    for (const reporter of this.options.reporters) {
      reporter.log(logObj, {
        options: this.options
      });
    }
  }
}
function _normalizeLogLevel(input, types = {}, defaultLevel = 3) {
  if (input === void 0) {
    return defaultLevel;
  }
  if (typeof input === "number") {
    return input;
  }
  if (types[input] && types[input].level !== void 0) {
    return types[input].level;
  }
  return defaultLevel;
}
Consola.prototype.add = Consola.prototype.addReporter;
Consola.prototype.remove = Consola.prototype.removeReporter;
Consola.prototype.clear = Consola.prototype.removeReporter;
Consola.prototype.withScope = Consola.prototype.withTag;
Consola.prototype.mock = Consola.prototype.mockTypes;
Consola.prototype.pause = Consola.prototype.pauseLogs;
Consola.prototype.resume = Consola.prototype.resumeLogs;
function createConsola$1(options = {}) {
  return new Consola(options);
}

class BrowserReporter {
  options;
  defaultColor;
  levelColorMap;
  typeColorMap;
  constructor(options) {
    this.options = { ...options };
    this.defaultColor = "#7f8c8d";
    this.levelColorMap = {
      0: "#c0392b",
      // Red
      1: "#f39c12",
      // Yellow
      3: "#00BCD4"
      // Cyan
    };
    this.typeColorMap = {
      success: "#2ecc71"
      // Green
    };
  }
  _getLogFn(level) {
    if (level < 1) {
      return console.__error || console.error;
    }
    if (level === 1) {
      return console.__warn || console.warn;
    }
    return console.__log || console.log;
  }
  log(logObj) {
    const consoleLogFn = this._getLogFn(logObj.level);
    const type = logObj.type === "log" ? "" : logObj.type;
    const tag = logObj.tag || "";
    const color = this.typeColorMap[logObj.type] || this.levelColorMap[logObj.level] || this.defaultColor;
    const style = `
      background: ${color};
      border-radius: 0.5em;
      color: white;
      font-weight: bold;
      padding: 2px 0.5em;
    `;
    const badge = `%c${[tag, type].filter(Boolean).join(":")}`;
    if (typeof logObj.args[0] === "string") {
      consoleLogFn(
        `${badge}%c ${logObj.args[0]}`,
        style,
        // Empty string as style resets to default console style
        "",
        ...logObj.args.slice(1)
      );
    } else {
      consoleLogFn(badge, style, ...logObj.args);
    }
  }
}

function createConsola(options = {}) {
  const consola2 = createConsola$1({
    reporters: options.reporters || [new BrowserReporter({})],
    prompt(message, options2 = {}) {
      if (options2.type === "confirm") {
        return Promise.resolve(confirm(message));
      }
      return Promise.resolve(prompt(message));
    },
    ...options
  });
  return consola2;
}
createConsola();

const getInitialLogLevel = () => {
  try {
    const storedLevel = localStorage.getItem("wallet-log-level");
    if (storedLevel !== null) {
      const level = parseInt(storedLevel, 10);
      if (level >= 0 && level <= 5) {
        return level;
      }
    }
  } catch (error) {
    console.warn("Failed to read log level from localStorage:", error);
  }
  return 2;
};
const logger = createConsola({
  level: getInitialLogLevel(),
  formatOptions: {
    colors: true,
    compact: false,
    date: true
  }
});
const walletLogger = logger.withTag("wallet");
const createComponentLogger = (component) => {
  const componentLogger = walletLogger.withTag(component);
  return {
    debug: (message, ...args) => componentLogger.debug(message, ...args),
    info: (message, ...args) => componentLogger.info(message, ...args),
    success: (message, ...args) => componentLogger.success(message, ...args),
    warn: (message, ...args) => componentLogger.warn(message, ...args),
    error: (message, error, ...args) => {
      if (error instanceof Error) {
        componentLogger.error(message, error.message, error.stack, ...args);
      } else if (error) {
        componentLogger.error(message, error, ...args);
      } else {
        componentLogger.error(message, ...args);
      }
    },
    fatal: (message, error, ...args) => {
      if (error instanceof Error) {
        componentLogger.fatal(message, error.message, error.stack, ...args);
      } else if (error) {
        componentLogger.fatal(message, error, ...args);
      } else {
        componentLogger.fatal(message, ...args);
      }
    }
  };
};

const log$s = createComponentLogger("AuthSlice");
const createAuthSlice = (set, get) => ({
  // Initial state
  auth: {
    isPasswordSet: false,
    isUnlocked: false,
    currentPassword: void 0,
    passwordHash: void 0
  },
  // Actions
  setPassword: async (password) => {
    try {
      const passwordHashBuffer = await crypto.subtle.digest(
        "SHA-256",
        new TextEncoder().encode(password + "wallet_salt")
      );
      const passwordHash = Array.from(new Uint8Array(passwordHashBuffer));
      set((state) => {
        state.auth.isPasswordSet = true;
        state.auth.isUnlocked = true;
        state.auth.currentPassword = password;
        state.auth.passwordHash = passwordHash;
      });
    } catch (error) {
      log$s.error("Error setting password:", error);
      throw new Error("Failed to set password");
    }
  },
  unlock: async (password) => {
    try {
      const state = get();
      if (!state.auth.passwordHash) return false;
      const passwordHashBuffer = await crypto.subtle.digest(
        "SHA-256",
        new TextEncoder().encode(password + "wallet_salt")
      );
      const currentHash = Array.from(new Uint8Array(passwordHashBuffer));
      const isValid = state.auth.passwordHash.every((byte, index) => byte === currentHash[index]);
      if (isValid) {
        set((state2) => {
          state2.auth.isUnlocked = true;
          state2.auth.currentPassword = password;
        });
        return true;
      }
      return false;
    } catch (error) {
      log$s.error("Error unlocking wallet:", error);
      return false;
    }
  },
  lock: () => {
    set((state) => {
      state.auth.isUnlocked = false;
      state.auth.currentPassword = void 0;
    });
  },
  reset: () => {
    set((state) => {
      state.auth.isPasswordSet = false;
      state.auth.isUnlocked = false;
      state.auth.currentPassword = void 0;
      state.auth.passwordHash = void 0;
    });
  }
});

var dist$3 = {};

var dist$2 = {};

var Address = {};

var symbol_inspect;
var hasRequiredSymbol_inspect;

function requireSymbol_inspect () {
	if (hasRequiredSymbol_inspect) return symbol_inspect;
	hasRequiredSymbol_inspect = 1;
	/**
	 * <symbol> that can be used to declare custom inspect functions.
	 *
	 * same as Symbol.for('nodejs.util.inspect.custom')
	 * same as util.inspect.custom
	 */
	const SymbolInspect = Symbol.for('nodejs.util.inspect.custom');
	symbol_inspect = SymbolInspect;
	
	return symbol_inspect;
}

var crc16 = {};

var hasRequiredCrc16;

function requireCrc16 () {
	if (hasRequiredCrc16) return crc16;
	hasRequiredCrc16 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(crc16, "__esModule", { value: true });
	crc16.crc16 = void 0;
	function crc16$1(data) {
	    const poly = 0x1021;
	    let reg = 0;
	    const message = Buffer.alloc(data.length + 2);
	    message.set(data);
	    for (let byte of message) {
	        let mask = 0x80;
	        while (mask > 0) {
	            reg <<= 1;
	            if (byte & mask) {
	                reg += 1;
	            }
	            mask >>= 1;
	            if (reg > 0xffff) {
	                reg &= 0xffff;
	                reg ^= poly;
	            }
	        }
	    }
	    return Buffer.from([Math.floor(reg / 256), reg % 256]);
	}
	crc16.crc16 = crc16$1;
	return crc16;
}

var hasRequiredAddress;

function requireAddress () {
	if (hasRequiredAddress) return Address;
	hasRequiredAddress = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var __importDefault = (Address && Address.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	var _a;
	Object.defineProperty(Address, "__esModule", { value: true });
	Address.address = Address.Address = void 0;
	const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
	const crc16_1 = requireCrc16();
	const bounceable_tag = 0x11;
	const non_bounceable_tag = 0x51;
	const test_flag = 0x80;
	function parseFriendlyAddress(src) {
	    if (typeof src === 'string' && !Address$1.isFriendly(src)) {
	        throw new Error('Unknown address type');
	    }
	    const data = Buffer.isBuffer(src) ? src : Buffer.from(src, 'base64');
	    // 1byte tag + 1byte workchain + 32 bytes hash + 2 byte crc
	    if (data.length !== 36) {
	        throw new Error('Unknown address type: byte length is not equal to 36');
	    }
	    // Prepare data
	    const addr = data.subarray(0, 34);
	    const crc = data.subarray(34, 36);
	    const calcedCrc = (0, crc16_1.crc16)(addr);
	    if (!(calcedCrc[0] === crc[0] && calcedCrc[1] === crc[1])) {
	        throw new Error('Invalid checksum: ' + src);
	    }
	    // Parse tag
	    let tag = addr[0];
	    let isTestOnly = false;
	    let isBounceable = false;
	    if (tag & test_flag) {
	        isTestOnly = true;
	        tag = tag ^ test_flag;
	    }
	    if ((tag !== bounceable_tag) && (tag !== non_bounceable_tag))
	        throw "Unknown address tag";
	    isBounceable = tag === bounceable_tag;
	    let workchain = null;
	    if (addr[1] === 0xff) { // TODO we should read signed integer here
	        workchain = -1;
	    }
	    else {
	        workchain = addr[1];
	    }
	    const hashPart = addr.subarray(2, 34);
	    return { isTestOnly, isBounceable, workchain, hashPart };
	}
	let Address$1 = class Address {
	    static isAddress(src) {
	        return src instanceof Address;
	    }
	    static isFriendly(source) {
	        // Check length
	        if (source.length !== 48) {
	            return false;
	        }
	        // Check if address is valid base64
	        if (!/^[A-Za-z0-9+/_-]+$/.test(source)) {
	            return false;
	        }
	        return true;
	    }
	    static isRaw(source) {
	        // Check if has delimiter
	        if (source.indexOf(':') === -1) {
	            return false;
	        }
	        let [wc, hash] = source.split(':');
	        // wc is not valid
	        if (!Number.isInteger(parseFloat(wc))) {
	            return false;
	        }
	        // hash is not valid
	        if (!/[a-f0-9]+/.test(hash.toLowerCase())) {
	            return false;
	        }
	        // has is not correct
	        if (hash.length !== 64) {
	            return false;
	        }
	        return true;
	    }
	    static normalize(source) {
	        if (typeof source === 'string') {
	            return Address.parse(source).toString();
	        }
	        else {
	            return source.toString();
	        }
	    }
	    static parse(source) {
	        if (Address.isFriendly(source)) {
	            return this.parseFriendly(source).address;
	        }
	        else if (Address.isRaw(source)) {
	            return this.parseRaw(source);
	        }
	        else {
	            throw new Error('Unknown address type: ' + source);
	        }
	    }
	    static parseRaw(source) {
	        let workChain = parseInt(source.split(":")[0]);
	        let hash = Buffer.from(source.split(":")[1], 'hex');
	        return new Address(workChain, hash);
	    }
	    static parseFriendly(source) {
	        if (Buffer.isBuffer(source)) {
	            let r = parseFriendlyAddress(source);
	            return {
	                isBounceable: r.isBounceable,
	                isTestOnly: r.isTestOnly,
	                address: new Address(r.workchain, r.hashPart)
	            };
	        }
	        else {
	            let addr = source.replace(/\-/g, '+').replace(/_/g, '\/'); // Convert from url-friendly to true base64
	            let r = parseFriendlyAddress(addr);
	            return {
	                isBounceable: r.isBounceable,
	                isTestOnly: r.isTestOnly,
	                address: new Address(r.workchain, r.hashPart)
	            };
	        }
	    }
	    constructor(workChain, hash) {
	        this.toRawString = () => {
	            return this.workChain + ':' + this.hash.toString('hex');
	        };
	        this.toRaw = () => {
	            const addressWithChecksum = Buffer.alloc(36);
	            addressWithChecksum.set(this.hash);
	            addressWithChecksum.set([this.workChain, this.workChain, this.workChain, this.workChain], 32);
	            return addressWithChecksum;
	        };
	        this.toStringBuffer = (args) => {
	            let testOnly = (args && args.testOnly !== undefined) ? args.testOnly : false;
	            let bounceable = (args && args.bounceable !== undefined) ? args.bounceable : true;
	            let tag = bounceable ? bounceable_tag : non_bounceable_tag;
	            if (testOnly) {
	                tag |= test_flag;
	            }
	            const addr = Buffer.alloc(34);
	            addr[0] = tag;
	            addr[1] = this.workChain;
	            addr.set(this.hash, 2);
	            const addressWithChecksum = Buffer.alloc(36);
	            addressWithChecksum.set(addr);
	            addressWithChecksum.set((0, crc16_1.crc16)(addr), 34);
	            return addressWithChecksum;
	        };
	        this.toString = (args) => {
	            let urlSafe = (args && args.urlSafe !== undefined) ? args.urlSafe : true;
	            let buffer = this.toStringBuffer(args);
	            if (urlSafe) {
	                return buffer.toString('base64').replace(/\+/g, '-').replace(/\//g, '_');
	            }
	            else {
	                return buffer.toString('base64');
	            }
	        };
	        this[_a] = () => this.toString();
	        if (hash.length !== 32) {
	            throw new Error('Invalid address hash length: ' + hash.length);
	        }
	        this.workChain = workChain;
	        this.hash = hash;
	        Object.freeze(this);
	    }
	    equals(src) {
	        if (src.workChain !== this.workChain) {
	            return false;
	        }
	        return src.hash.equals(this.hash);
	    }
	};
	Address.Address = Address$1;
	_a = symbol_inspect_1.default;
	function address(src) {
	    return Address$1.parse(src);
	}
	Address.address = address;
	return Address;
}

var ExternalAddress = {};

var hasRequiredExternalAddress;

function requireExternalAddress () {
	if (hasRequiredExternalAddress) return ExternalAddress;
	hasRequiredExternalAddress = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var __importDefault = (ExternalAddress && ExternalAddress.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	var _a;
	Object.defineProperty(ExternalAddress, "__esModule", { value: true });
	ExternalAddress.ExternalAddress = void 0;
	const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
	let ExternalAddress$1 = class ExternalAddress {
	    static isAddress(src) {
	        return src instanceof ExternalAddress;
	    }
	    constructor(value, bits) {
	        this[_a] = () => this.toString();
	        this.value = value;
	        this.bits = bits;
	    }
	    toString() {
	        return `External<${this.bits}:${this.value}>`;
	    }
	};
	ExternalAddress.ExternalAddress = ExternalAddress$1;
	_a = symbol_inspect_1.default;
	return ExternalAddress;
}

var ADNLAddress = {};

var base32 = {};

var hasRequiredBase32;

function requireBase32 () {
	if (hasRequiredBase32) return base32;
	hasRequiredBase32 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(base32, "__esModule", { value: true });
	base32.base32Decode = base32.base32Encode = void 0;
	const alphabet = 'abcdefghijklmnopqrstuvwxyz234567';
	function base32Encode(buffer) {
	    const length = buffer.byteLength;
	    let bits = 0;
	    let value = 0;
	    let output = '';
	    for (let i = 0; i < length; i++) {
	        value = (value << 8) | buffer[i];
	        bits += 8;
	        while (bits >= 5) {
	            output += alphabet[(value >>> (bits - 5)) & 31];
	            bits -= 5;
	        }
	    }
	    if (bits > 0) {
	        output += alphabet[(value << (5 - bits)) & 31];
	    }
	    return output;
	}
	base32.base32Encode = base32Encode;
	function readChar(alphabet, char) {
	    const idx = alphabet.indexOf(char);
	    if (idx === -1) {
	        throw new Error('Invalid character found: ' + char);
	    }
	    return idx;
	}
	function base32Decode(input) {
	    let cleanedInput;
	    cleanedInput = input.toLowerCase();
	    const { length } = cleanedInput;
	    let bits = 0;
	    let value = 0;
	    let index = 0;
	    const output = Buffer.alloc(((length * 5) / 8) | 0);
	    for (let i = 0; i < length; i++) {
	        value = (value << 5) | readChar(alphabet, cleanedInput[i]);
	        bits += 5;
	        if (bits >= 8) {
	            output[index++] = (value >>> (bits - 8)) & 255;
	            bits -= 8;
	        }
	    }
	    return output;
	}
	base32.base32Decode = base32Decode;
	return base32;
}

var hasRequiredADNLAddress;

function requireADNLAddress () {
	if (hasRequiredADNLAddress) return ADNLAddress;
	hasRequiredADNLAddress = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var __importDefault = (ADNLAddress && ADNLAddress.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	var _a;
	Object.defineProperty(ADNLAddress, "__esModule", { value: true });
	ADNLAddress.ADNLAddress = void 0;
	const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
	const base32_1 = requireBase32();
	const crc16_1 = requireCrc16();
	let ADNLAddress$1 = class ADNLAddress {
	    static parseFriendly(src) {
	        if (src.length !== 55) {
	            throw Error('Invalid address');
	        }
	        // Decoding
	        src = 'f' + src;
	        let decoded = (0, base32_1.base32Decode)(src);
	        if (decoded[0] !== 0x2d) {
	            throw Error('Invalid address');
	        }
	        let gotHash = decoded.slice(33);
	        let hash = (0, crc16_1.crc16)(decoded.slice(0, 33));
	        if (!hash.equals(gotHash)) {
	            throw Error('Invalid address');
	        }
	        return new ADNLAddress(decoded.slice(1, 33));
	    }
	    static parseRaw(src) {
	        const data = Buffer.from(src, 'base64');
	        return new ADNLAddress(data);
	    }
	    constructor(address) {
	        this.toRaw = () => {
	            return this.address.toString('hex').toUpperCase();
	        };
	        this.toString = () => {
	            let data = Buffer.concat([Buffer.from([0x2D]), this.address]);
	            let hash = (0, crc16_1.crc16)(data);
	            data = Buffer.concat([data, hash]);
	            return (0, base32_1.base32Encode)(data).slice(1);
	        };
	        this[_a] = () => this.toString();
	        if (address.length !== 32) {
	            throw Error('Invalid address');
	        }
	        this.address = address;
	    }
	    equals(b) {
	        return this.address.equals(b.address);
	    }
	};
	ADNLAddress.ADNLAddress = ADNLAddress$1;
	_a = symbol_inspect_1.default;
	return ADNLAddress;
}

var contractAddress = {};

var Builder$3 = {};

var BitBuilder = {};

var BitString = {};

var paddedBits = {};

var hasRequiredPaddedBits;

function requirePaddedBits () {
	if (hasRequiredPaddedBits) return paddedBits;
	hasRequiredPaddedBits = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(paddedBits, "__esModule", { value: true });
	paddedBits.paddedBufferToBits = paddedBits.bitsToPaddedBuffer = void 0;
	const BitBuilder_1 = requireBitBuilder();
	const BitString_1 = requireBitString();
	function bitsToPaddedBuffer(bits) {
	    // Create builder
	    let builder = new BitBuilder_1.BitBuilder(Math.ceil(bits.length / 8) * 8);
	    builder.writeBits(bits);
	    // Apply padding
	    let padding = Math.ceil(bits.length / 8) * 8 - bits.length;
	    for (let i = 0; i < padding; i++) {
	        if (i === 0) {
	            builder.writeBit(1);
	        }
	        else {
	            builder.writeBit(0);
	        }
	    }
	    return builder.buffer();
	}
	paddedBits.bitsToPaddedBuffer = bitsToPaddedBuffer;
	function paddedBufferToBits(buff) {
	    let bitLen = 0;
	    // Finding rightmost non-zero byte in the buffer
	    for (let i = buff.length - 1; i >= 0; i--) {
	        if (buff[i] !== 0) {
	            const testByte = buff[i];
	            // Looking for a rightmost set padding bit
	            let bitPos = testByte & -testByte;
	            if ((bitPos & 1) == 0) {
	                // It's power of 2 (only one bit set)
	                bitPos = Math.log2(bitPos) + 1;
	            }
	            if (i > 0) {
	                // If we are dealing with more than 1 byte buffer
	                bitLen = i << 3; //Number of full bytes * 8
	            }
	            bitLen += 8 - bitPos;
	            break;
	        }
	    }
	    return new BitString_1.BitString(buff, 0, bitLen);
	}
	paddedBits.paddedBufferToBits = paddedBufferToBits;
	return paddedBits;
}

var hasRequiredBitString;

function requireBitString () {
	if (hasRequiredBitString) return BitString;
	hasRequiredBitString = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var __importDefault = (BitString && BitString.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	var _a;
	Object.defineProperty(BitString, "__esModule", { value: true });
	BitString.BitString = void 0;
	const paddedBits_1 = requirePaddedBits();
	const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
	/**
	 * BitString is a class that represents a bitstring in a buffer with a specified offset and length
	 */
	let BitString$1 = class BitString {
	    /**
	     * Checks if supplied object is BitString
	     * @param src is unknow object
	     * @returns true if object is BitString and false otherwise
	     **/
	    static isBitString(src) {
	        return src instanceof BitString;
	    }
	    /**
	     * Constructing BitString from a buffer
	     * @param data data that contains the bitstring data. NOTE: We are expecting this buffer to be NOT modified
	     * @param offset offset in bits from the start of the buffer
	     * @param length length of the bitstring in bits
	     */
	    constructor(data, offset, length) {
	        this[_a] = () => this.toString();
	        // Check bounds
	        if (length < 0) {
	            throw new Error(`Length ${length} is out of bounds`);
	        }
	        this._length = length;
	        this._data = data;
	        this._offset = offset;
	    }
	    /**
	     * Returns the length of the bitstring
	     */
	    get length() {
	        return this._length;
	    }
	    /**
	     * Returns the bit at the specified index
	     * @param index index of the bit
	     * @throws Error if index is out of bounds
	     * @returns true if the bit is set, false otherwise
	     */
	    at(index) {
	        // Check bounds
	        if (index >= this._length) {
	            throw new Error(`Index ${index} > ${this._length} is out of bounds`);
	        }
	        if (index < 0) {
	            throw new Error(`Index ${index} < 0 is out of bounds`);
	        }
	        // Calculcate offsets
	        let byteIndex = (this._offset + index) >> 3;
	        let bitIndex = 7 - ((this._offset + index) % 8); // NOTE: We are using big endian
	        // Return the bit
	        return (this._data[byteIndex] & (1 << bitIndex)) !== 0;
	    }
	    /**
	     * Get a subscring of the bitstring
	     * @param offset
	     * @param length
	     * @returns
	     */
	    substring(offset, length) {
	        // Check offset
	        if (offset > this._length) {
	            throw new Error(`Offset(${offset}) > ${this._length} is out of bounds`);
	        }
	        if (offset < 0) {
	            throw new Error(`Offset(${offset}) < 0 is out of bounds`);
	        }
	        // Corner case of empty string
	        if (length === 0) {
	            return BitString.EMPTY;
	        }
	        if (offset + length > this._length) {
	            throw new Error(`Offset ${offset} + Length ${length} > ${this._length} is out of bounds`);
	        }
	        // Create substring
	        return new BitString(this._data, this._offset + offset, length);
	    }
	    /**
	     * Try to get a buffer from the bitstring without allocations
	     * @param offset offset in bits
	     * @param length length in bits
	     * @returns buffer if the bitstring is aligned to bytes, null otherwise
	     */
	    subbuffer(offset, length) {
	        // Check offset
	        if (offset > this._length) {
	            throw new Error(`Offset ${offset} is out of bounds`);
	        }
	        if (offset < 0) {
	            throw new Error(`Offset ${offset} is out of bounds`);
	        }
	        if (offset + length > this._length) {
	            throw new Error(`Offset + Lenght = ${offset + length} is out of bounds`);
	        }
	        // Check alignment
	        if (length % 8 !== 0) {
	            return null;
	        }
	        if ((this._offset + offset) % 8 !== 0) {
	            return null;
	        }
	        // Create substring
	        let start = ((this._offset + offset) >> 3);
	        let end = start + (length >> 3);
	        return this._data.subarray(start, end);
	    }
	    /**
	     * Checks for equality
	     * @param b other bitstring
	     * @returns true if the bitstrings are equal, false otherwise
	     */
	    equals(b) {
	        if (this._length !== b._length) {
	            return false;
	        }
	        for (let i = 0; i < this._length; i++) {
	            if (this.at(i) !== b.at(i)) {
	                return false;
	            }
	        }
	        return true;
	    }
	    /**
	     * Format to canonical string
	     * @returns formatted bits as a string
	     */
	    toString() {
	        const padded = (0, paddedBits_1.bitsToPaddedBuffer)(this);
	        if (this._length % 4 === 0) {
	            const s = padded.subarray(0, Math.ceil(this._length / 8)).toString('hex').toUpperCase();
	            if (this._length % 8 === 0) {
	                return s;
	            }
	            else {
	                return s.substring(0, s.length - 1);
	            }
	        }
	        else {
	            const hex = padded.toString('hex').toUpperCase();
	            if (this._length % 8 <= 4) {
	                return hex.substring(0, hex.length - 1) + '_';
	            }
	            else {
	                return hex + '_';
	            }
	        }
	    }
	};
	BitString.BitString = BitString$1;
	_a = symbol_inspect_1.default;
	BitString$1.EMPTY = new BitString$1(Buffer.alloc(0), 0, 0);
	return BitString;
}

var hasRequiredBitBuilder;

function requireBitBuilder () {
	if (hasRequiredBitBuilder) return BitBuilder;
	hasRequiredBitBuilder = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(BitBuilder, "__esModule", { value: true });
	BitBuilder.BitBuilder = void 0;
	const Address_1 = requireAddress();
	const ExternalAddress_1 = requireExternalAddress();
	const BitString_1 = requireBitString();
	/**
	 * Class for building bit strings
	 */
	let BitBuilder$1 = class BitBuilder {
	    constructor(size = 1023) {
	        this._buffer = Buffer.alloc(Math.ceil(size / 8));
	        this._length = 0;
	    }
	    /**
	     * Current number of bits written
	     */
	    get length() {
	        return this._length;
	    }
	    /**
	     * Write a single bit
	     * @param value bit to write, true or positive number for 1, false or zero or negative for 0
	     */
	    writeBit(value) {
	        // Check overflow
	        let n = this._length;
	        if (n > this._buffer.length * 8) {
	            throw new Error("BitBuilder overflow");
	        }
	        // Set bit
	        if ((typeof value === 'boolean' && value === true) || (typeof value === 'number' && value > 0)) {
	            this._buffer[(n / 8) | 0] |= 1 << (7 - (n % 8));
	        }
	        // Advance
	        this._length++;
	    }
	    /**
	     * Copy bits from BitString
	     * @param src source bits
	     */
	    writeBits(src) {
	        for (let i = 0; i < src.length; i++) {
	            this.writeBit(src.at(i));
	        }
	    }
	    /**
	     * Write bits from buffer
	     * @param src source buffer
	     */
	    writeBuffer(src) {
	        // Special case for aligned offsets
	        if (this._length % 8 === 0) {
	            if (this._length + src.length * 8 > this._buffer.length * 8) {
	                throw new Error("BitBuilder overflow");
	            }
	            src.copy(this._buffer, this._length / 8);
	            this._length += src.length * 8;
	        }
	        else {
	            for (let i = 0; i < src.length; i++) {
	                this.writeUint(src[i], 8);
	            }
	        }
	    }
	    /**
	     * Write uint value
	     * @param value value as bigint or number
	     * @param bits number of bits to write
	     */
	    writeUint(value, bits) {
	        if (bits < 0 || !Number.isSafeInteger(bits)) {
	            throw Error(`invalid bit length. Got ${bits}`);
	        }
	        const v = BigInt(value);
	        if (bits === 0) {
	            if (v !== 0n) {
	                throw Error(`value is not zero for ${bits} bits. Got ${value}`);
	            }
	            else {
	                return;
	            }
	        }
	        const vBits = (1n << BigInt(bits));
	        if (v < 0 || v >= vBits) {
	            throw Error(`bitLength is too small for a value ${value}. Got ${bits}`);
	        }
	        if (this._length + bits > this._buffer.length * 8) {
	            throw new Error("BitBuilder overflow");
	        }
	        const tillByte = 8 - (this._length % 8);
	        if (tillByte > 0) {
	            const bidx = Math.floor(this._length / 8);
	            if (bits < tillByte) {
	                const wb = Number(v);
	                this._buffer[bidx] |= wb << (tillByte - bits);
	                this._length += bits;
	            }
	            else {
	                const wb = Number(v >> BigInt(bits - tillByte));
	                this._buffer[bidx] |= wb;
	                this._length += tillByte;
	            }
	        }
	        bits -= tillByte;
	        while (bits > 0) {
	            if (bits >= 8) {
	                this._buffer[this._length / 8] = Number((v >> BigInt(bits - 8)) & 0xffn);
	                this._length += 8;
	                bits -= 8;
	            }
	            else {
	                this._buffer[this._length / 8] = Number((v << BigInt(8 - bits)) & 0xffn);
	                this._length += bits;
	                bits = 0;
	            }
	        }
	    }
	    /**
	     * Write int value
	     * @param value value as bigint or number
	     * @param bits number of bits to write
	     */
	    writeInt(value, bits) {
	        let v = BigInt(value);
	        if (bits < 0 || !Number.isSafeInteger(bits)) {
	            throw Error(`invalid bit length. Got ${bits}`);
	        }
	        // Corner case for zero bits
	        if (bits === 0) {
	            if (v !== 0n) {
	                throw Error(`value is not zero for ${bits} bits. Got ${value}`);
	            }
	            else {
	                return;
	            }
	        }
	        // Corner case for one bit
	        if (bits === 1) {
	            if (v !== -1n && v !== 0n) {
	                throw Error(`value is not zero or -1 for ${bits} bits. Got ${value}`);
	            }
	            else {
	                this.writeBit(value === -1n);
	                return;
	            }
	        }
	        // Check input
	        let vBits = 1n << (BigInt(bits) - 1n);
	        if (v < -vBits || v >= vBits) {
	            throw Error(`value is out of range for ${bits} bits. Got ${value}`);
	        }
	        // Write sign
	        if (v < 0) {
	            this.writeBit(true);
	            v = vBits + v;
	        }
	        else {
	            this.writeBit(false);
	        }
	        // Write value
	        this.writeUint(v, bits - 1);
	    }
	    /**
	     * Wrtie var uint value, used for serializing coins
	     * @param value value to write as bigint or number
	     * @param bits header bits to write size
	     */
	    writeVarUint(value, bits) {
	        let v = BigInt(value);
	        if (bits < 0 || !Number.isSafeInteger(bits)) {
	            throw Error(`invalid bit length. Got ${bits}`);
	        }
	        if (v < 0) {
	            throw Error(`value is negative. Got ${value}`);
	        }
	        // Corner case for zero
	        if (v === 0n) {
	            // Write zero size
	            this.writeUint(0, bits);
	            return;
	        }
	        // Calculate size
	        const sizeBytes = Math.ceil((v.toString(2).length) / 8); // Fastest way in most environments
	        const sizeBits = sizeBytes * 8;
	        // Write size
	        this.writeUint(sizeBytes, bits);
	        // Write number
	        this.writeUint(v, sizeBits);
	    }
	    /**
	     * Wrtie var int value, used for serializing coins
	     * @param value value to write as bigint or number
	     * @param bits header bits to write size
	     */
	    writeVarInt(value, bits) {
	        let v = BigInt(value);
	        if (bits < 0 || !Number.isSafeInteger(bits)) {
	            throw Error(`invalid bit length. Got ${bits}`);
	        }
	        // Corner case for zero
	        if (v === 0n) {
	            // Write zero size
	            this.writeUint(0, bits);
	            return;
	        }
	        // Calculate size
	        let v2 = v > 0 ? v : -v;
	        const sizeBytes = Math.ceil((v2.toString(2).length + 1) / 8); // Fastest way in most environments
	        const sizeBits = sizeBytes * 8;
	        // Write size
	        this.writeUint(sizeBytes, bits);
	        // Write number
	        this.writeInt(v, sizeBits);
	    }
	    /**
	     * Write coins in var uint format
	     * @param amount amount to write
	     */
	    writeCoins(amount) {
	        this.writeVarUint(amount, 4);
	    }
	    /**
	     * Write address
	     * @param address write address or address external
	     */
	    writeAddress(address) {
	        // Is empty address
	        if (address === null || address === undefined) {
	            this.writeUint(0, 2); // Empty address
	            return;
	        }
	        // Is Internal Address
	        if (Address_1.Address.isAddress(address)) {
	            this.writeUint(2, 2); // Internal address
	            this.writeUint(0, 1); // No anycast
	            this.writeInt(address.workChain, 8);
	            this.writeBuffer(address.hash);
	            return;
	        }
	        // Is External Address
	        if (ExternalAddress_1.ExternalAddress.isAddress(address)) {
	            this.writeUint(1, 2); // External address
	            this.writeUint(address.bits, 9);
	            this.writeUint(address.value, address.bits);
	            return;
	        }
	        // Invalid address
	        throw Error(`Invalid address. Got ${address}`);
	    }
	    /**
	     * Build BitString
	     * @returns result bit string
	     */
	    build() {
	        return new BitString_1.BitString(this._buffer, 0, this._length);
	    }
	    /**
	     * Build into Buffer
	     * @returns result buffer
	     */
	    buffer() {
	        if (this._length % 8 !== 0) {
	            throw new Error("BitBuilder buffer is not byte aligned");
	        }
	        return this._buffer.subarray(0, this._length / 8);
	    }
	};
	BitBuilder.BitBuilder = BitBuilder$1;
	return BitBuilder;
}

var Cell = {};

var CellType = {};

var hasRequiredCellType;

function requireCellType () {
	if (hasRequiredCellType) return CellType;
	hasRequiredCellType = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(CellType, "__esModule", { value: true });
	CellType.CellType = void 0;
	var CellType$1;
	(function (CellType) {
	    CellType[CellType["Ordinary"] = -1] = "Ordinary";
	    CellType[CellType["PrunedBranch"] = 1] = "PrunedBranch";
	    CellType[CellType["Library"] = 2] = "Library";
	    CellType[CellType["MerkleProof"] = 3] = "MerkleProof";
	    CellType[CellType["MerkleUpdate"] = 4] = "MerkleUpdate";
	})(CellType$1 || (CellType.CellType = CellType$1 = {}));
	return CellType;
}

var Slice = {};

var Dictionary = {};

var generateMerkleProof = {};

var readUnaryLength = {};

var hasRequiredReadUnaryLength;

function requireReadUnaryLength () {
	if (hasRequiredReadUnaryLength) return readUnaryLength;
	hasRequiredReadUnaryLength = 1;
	Object.defineProperty(readUnaryLength, "__esModule", { value: true });
	readUnaryLength.readUnaryLength = void 0;
	function readUnaryLength$1(slice) {
	    let res = 0;
	    while (slice.loadBit()) {
	        res++;
	    }
	    return res;
	}
	readUnaryLength.readUnaryLength = readUnaryLength$1;
	return readUnaryLength;
}

var exoticMerkleProof = {};

var BitReader = {};

var hasRequiredBitReader;

function requireBitReader () {
	if (hasRequiredBitReader) return BitReader;
	hasRequiredBitReader = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(BitReader, "__esModule", { value: true });
	BitReader.BitReader = void 0;
	const Address_1 = requireAddress();
	const ExternalAddress_1 = requireExternalAddress();
	/**
	 * Class for reading bit strings
	 */
	let BitReader$1 = class BitReader {
	    constructor(bits, offset = 0) {
	        this._checkpoints = [];
	        this._bits = bits;
	        this._offset = offset;
	    }
	    /**
	     * Offset in source bit string
	     */
	    get offset() {
	        return this._offset;
	    }
	    /**
	     * Number of bits remaining
	     */
	    get remaining() {
	        return this._bits.length - this._offset;
	    }
	    /**
	     * Skip bits
	     * @param bits number of bits to skip
	     */
	    skip(bits) {
	        if (bits < 0 || this._offset + bits > this._bits.length) {
	            throw new Error(`Index ${this._offset + bits} is out of bounds`);
	        }
	        this._offset += bits;
	    }
	    /**
	     * Reset to the beginning or latest checkpoint
	     */
	    reset() {
	        if (this._checkpoints.length > 0) {
	            this._offset = this._checkpoints.pop();
	        }
	        else {
	            this._offset = 0;
	        }
	    }
	    /**
	     * Save checkpoint
	     */
	    save() {
	        this._checkpoints.push(this._offset);
	    }
	    /**
	     * Load a single bit
	     * @returns true if the bit is set, false otherwise
	     */
	    loadBit() {
	        let r = this._bits.at(this._offset);
	        this._offset++;
	        return r;
	    }
	    /**
	     * Preload bit
	     * @returns true if the bit is set, false otherwise
	     */
	    preloadBit() {
	        return this._bits.at(this._offset);
	    }
	    /**
	     * Load bit string
	     * @param bits number of bits to read
	     * @returns new bitstring
	     */
	    loadBits(bits) {
	        let r = this._bits.substring(this._offset, bits);
	        this._offset += bits;
	        return r;
	    }
	    /**
	     * Preload bit string
	     * @param bits number of bits to read
	     * @returns new bitstring
	     */
	    preloadBits(bits) {
	        return this._bits.substring(this._offset, bits);
	    }
	    /**
	     * Load buffer
	     * @param bytes number of bytes
	     * @returns new buffer
	     */
	    loadBuffer(bytes) {
	        let buf = this._preloadBuffer(bytes, this._offset);
	        this._offset += bytes * 8;
	        return buf;
	    }
	    /**
	     * Preload buffer
	     * @param bytes number of bytes
	     * @returns new buffer
	     */
	    preloadBuffer(bytes) {
	        return this._preloadBuffer(bytes, this._offset);
	    }
	    /**
	     * Load uint value
	     * @param bits uint bits
	     * @returns read value as number
	     */
	    loadUint(bits) {
	        return this._toSafeInteger(this.loadUintBig(bits), 'loadUintBig');
	    }
	    /**
	     * Load uint value as bigint
	     * @param bits uint bits
	     * @returns read value as bigint
	     */
	    loadUintBig(bits) {
	        let loaded = this.preloadUintBig(bits);
	        this._offset += bits;
	        return loaded;
	    }
	    /**
	     * Preload uint value
	     * @param bits uint bits
	     * @returns read value as number
	     */
	    preloadUint(bits) {
	        return this._toSafeInteger(this._preloadUint(bits, this._offset), 'preloadUintBig');
	    }
	    /**
	     * Preload uint value as bigint
	     * @param bits uint bits
	     * @returns read value as bigint
	     */
	    preloadUintBig(bits) {
	        return this._preloadUint(bits, this._offset);
	    }
	    /**
	     * Load int value
	     * @param bits int bits
	     * @returns read value as bigint
	     */
	    loadInt(bits) {
	        let res = this._preloadInt(bits, this._offset);
	        this._offset += bits;
	        return this._toSafeInteger(res, 'loadUintBig');
	    }
	    /**
	     * Load int value as bigint
	     * @param bits int bits
	     * @returns read value as bigint
	     */
	    loadIntBig(bits) {
	        let res = this._preloadInt(bits, this._offset);
	        this._offset += bits;
	        return res;
	    }
	    /**
	     * Preload int value
	     * @param bits int bits
	     * @returns read value as bigint
	     */
	    preloadInt(bits) {
	        return this._toSafeInteger(this._preloadInt(bits, this._offset), 'preloadIntBig');
	    }
	    /**
	     * Preload int value
	     * @param bits int bits
	     * @returns read value as bigint
	     */
	    preloadIntBig(bits) {
	        return this._preloadInt(bits, this._offset);
	    }
	    /**
	     * Load varuint value
	     * @param bits number of bits to read the size
	     * @returns read value as bigint
	     */
	    loadVarUint(bits) {
	        let size = Number(this.loadUint(bits));
	        return this._toSafeInteger(this.loadUintBig(size * 8), 'loadVarUintBig');
	    }
	    /**
	     * Load varuint value
	     * @param bits number of bits to read the size
	     * @returns read value as bigint
	     */
	    loadVarUintBig(bits) {
	        let size = Number(this.loadUint(bits));
	        return this.loadUintBig(size * 8);
	    }
	    /**
	     * Preload varuint value
	     * @param bits number of bits to read the size
	     * @returns read value as bigint
	     */
	    preloadVarUint(bits) {
	        let size = Number(this._preloadUint(bits, this._offset));
	        return this._toSafeInteger(this._preloadUint(size * 8, this._offset + bits), 'preloadVarUintBig');
	    }
	    /**
	     * Preload varuint value
	     * @param bits number of bits to read the size
	     * @returns read value as bigint
	     */
	    preloadVarUintBig(bits) {
	        let size = Number(this._preloadUint(bits, this._offset));
	        return this._preloadUint(size * 8, this._offset + bits);
	    }
	    /**
	     * Load varint value
	     * @param bits number of bits to read the size
	     * @returns read value as bigint
	     */
	    loadVarInt(bits) {
	        let size = Number(this.loadUint(bits));
	        return this._toSafeInteger(this.loadIntBig(size * 8), 'loadVarIntBig');
	    }
	    /**
	     * Load varint value
	     * @param bits number of bits to read the size
	     * @returns read value as bigint
	     */
	    loadVarIntBig(bits) {
	        let size = Number(this.loadUint(bits));
	        return this.loadIntBig(size * 8);
	    }
	    /**
	     * Preload varint value
	     * @param bits number of bits to read the size
	     * @returns read value as bigint
	     */
	    preloadVarInt(bits) {
	        let size = Number(this._preloadUint(bits, this._offset));
	        return this._toSafeInteger(this._preloadInt(size * 8, this._offset + bits), 'preloadVarIntBig');
	    }
	    /**
	     * Preload varint value
	     * @param bits number of bits to read the size
	     * @returns read value as bigint
	     */
	    preloadVarIntBig(bits) {
	        let size = Number(this._preloadUint(bits, this._offset));
	        return this._preloadInt(size * 8, this._offset + bits);
	    }
	    /**
	     * Load coins value
	     * @returns read value as bigint
	     */
	    loadCoins() {
	        return this.loadVarUintBig(4);
	    }
	    /**
	     * Preload coins value
	     * @returns read value as bigint
	     */
	    preloadCoins() {
	        return this.preloadVarUintBig(4);
	    }
	    /**
	     * Load Address
	     * @returns Address
	     */
	    loadAddress() {
	        let type = Number(this._preloadUint(2, this._offset));
	        if (type === 2) {
	            return this._loadInternalAddress();
	        }
	        else {
	            throw new Error("Invalid address: " + type);
	        }
	    }
	    /**
	     * Load internal address
	     * @returns Address or null
	     */
	    loadMaybeAddress() {
	        let type = Number(this._preloadUint(2, this._offset));
	        if (type === 0) {
	            this._offset += 2;
	            return null;
	        }
	        else if (type === 2) {
	            return this._loadInternalAddress();
	        }
	        else {
	            throw new Error("Invalid address");
	        }
	    }
	    /**
	     * Load external address
	     * @returns ExternalAddress
	     */
	    loadExternalAddress() {
	        let type = Number(this._preloadUint(2, this._offset));
	        if (type === 1) {
	            return this._loadExternalAddress();
	        }
	        else {
	            throw new Error("Invalid address");
	        }
	    }
	    /**
	     * Load external address
	     * @returns ExternalAddress or null
	     */
	    loadMaybeExternalAddress() {
	        let type = Number(this._preloadUint(2, this._offset));
	        if (type === 0) {
	            this._offset += 2;
	            return null;
	        }
	        else if (type === 1) {
	            return this._loadExternalAddress();
	        }
	        else {
	            throw new Error("Invalid address");
	        }
	    }
	    /**
	     * Read address of any type
	     * @returns Address or ExternalAddress or null
	     */
	    loadAddressAny() {
	        let type = Number(this._preloadUint(2, this._offset));
	        if (type === 0) {
	            this._offset += 2;
	            return null;
	        }
	        else if (type === 2) {
	            return this._loadInternalAddress();
	        }
	        else if (type === 1) {
	            return this._loadExternalAddress();
	        }
	        else if (type === 3) {
	            throw Error('Unsupported');
	        }
	        else {
	            throw Error('Unreachable');
	        }
	    }
	    /**
	     * Load bit string that was padded to make it byte alligned. Used in BOC serialization
	     * @param bytes number of bytes to read
	     */
	    loadPaddedBits(bits) {
	        // Check that number of bits is byte alligned
	        if (bits % 8 !== 0) {
	            throw new Error("Invalid number of bits");
	        }
	        // Skip padding
	        let length = bits;
	        while (true) {
	            if (this._bits.at(this._offset + length - 1)) {
	                length--;
	                break;
	            }
	            else {
	                length--;
	            }
	        }
	        // Read substring
	        let r = this._bits.substring(this._offset, length);
	        this._offset += bits;
	        return r;
	    }
	    /**
	     * Clone BitReader
	     */
	    clone() {
	        return new BitReader(this._bits, this._offset);
	    }
	    /**
	     * Preload int from specific offset
	     * @param bits bits to preload
	     * @param offset offset to start from
	     * @returns read value as bigint
	     */
	    _preloadInt(bits, offset) {
	        if (bits == 0) {
	            return 0n;
	        }
	        let sign = this._bits.at(offset);
	        let res = 0n;
	        for (let i = 0; i < bits - 1; i++) {
	            if (this._bits.at(offset + 1 + i)) {
	                res += 1n << BigInt(bits - i - 1 - 1);
	            }
	        }
	        if (sign) {
	            res = res - (1n << BigInt(bits - 1));
	        }
	        return res;
	    }
	    /**
	     * Preload uint from specific offset
	     * @param bits bits to preload
	     * @param offset offset to start from
	     * @returns read value as bigint
	     */
	    _preloadUint(bits, offset) {
	        if (bits == 0) {
	            return 0n;
	        }
	        let res = 0n;
	        for (let i = 0; i < bits; i++) {
	            if (this._bits.at(offset + i)) {
	                res += 1n << BigInt(bits - i - 1);
	            }
	        }
	        return res;
	    }
	    _preloadBuffer(bytes, offset) {
	        // Try to load fast
	        let fastBuffer = this._bits.subbuffer(offset, bytes * 8);
	        if (fastBuffer) {
	            return fastBuffer;
	        }
	        // Load slow
	        let buf = Buffer.alloc(bytes);
	        for (let i = 0; i < bytes; i++) {
	            buf[i] = Number(this._preloadUint(8, offset + i * 8));
	        }
	        return buf;
	    }
	    _loadInternalAddress() {
	        let type = Number(this._preloadUint(2, this._offset));
	        if (type !== 2) {
	            throw Error('Invalid address');
	        }
	        // Handle Anycast
	        let rewrite_pfx = undefined;
	        let rewrite_depth = undefined;
	        if (this._preloadUint(1, this._offset + 2) !== 0n) {
	            rewrite_depth = Number(this._preloadUint(5, this._offset + 3));
	            rewrite_pfx = this._preloadUint(rewrite_depth, this._offset + 8);
	            this._offset += 5 + rewrite_depth;
	        }
	        // Read address
	        let wc = Number(this._preloadInt(8, this._offset + 3));
	        let hash = this._preloadBuffer(32, this._offset + 11);
	        // Apply rewrite prefix if present
	        if (rewrite_depth !== undefined && rewrite_pfx !== undefined) {
	            let pfx = Number(rewrite_pfx);
	            let byteIndex = 0;
	            let bitIndex = 0;
	            let bitsRemaining = rewrite_depth;
	            while (bitsRemaining > 0) {
	                let bitsInThisByte = Math.min(8 - bitIndex, bitsRemaining);
	                let mask = ((1 << bitsInThisByte) - 1) << (8 - bitIndex - bitsInThisByte);
	                let bits = ((pfx >> (bitsRemaining - bitsInThisByte)) & ((1 << bitsInThisByte) - 1)) << (8 - bitIndex - bitsInThisByte);
	                hash[byteIndex] = (hash[byteIndex] & ~mask) | bits;
	                bitsRemaining -= bitsInThisByte;
	                bitIndex += bitsInThisByte;
	                if (bitIndex === 8) {
	                    byteIndex++;
	                    bitIndex = 0;
	                }
	            }
	        }
	        // Update offset
	        this._offset += 267;
	        return new Address_1.Address(wc, hash);
	    }
	    _loadExternalAddress() {
	        let type = Number(this._preloadUint(2, this._offset));
	        if (type !== 1) {
	            throw Error('Invalid address');
	        }
	        // Load length
	        let bits = Number(this._preloadUint(9, this._offset + 2));
	        // Load address
	        let value = this._preloadUint(bits, this._offset + 11);
	        // Update offset
	        this._offset += 11 + bits;
	        return new ExternalAddress_1.ExternalAddress(value, bits);
	    }
	    _toSafeInteger(src, alt) {
	        if (BigInt(Number.MAX_SAFE_INTEGER) < src || src < BigInt(Number.MIN_SAFE_INTEGER)) {
	            throw new TypeError(`${src} is out of safe integer range. Use ${alt} instead`);
	        }
	        return Number(src);
	    }
	};
	BitReader.BitReader = BitReader$1;
	return BitReader;
}

var hasRequiredExoticMerkleProof;

function requireExoticMerkleProof () {
	if (hasRequiredExoticMerkleProof) return exoticMerkleProof;
	hasRequiredExoticMerkleProof = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(exoticMerkleProof, "__esModule", { value: true });
	exoticMerkleProof.convertToMerkleProof = exoticMerkleProof.exoticMerkleProof = void 0;
	const BitReader_1 = requireBitReader();
	const Builder_1 = requireBuilder$1();
	function exoticMerkleProof$1(bits, refs) {
	    const reader = new BitReader_1.BitReader(bits);
	    // type + hash + depth
	    const size = 8 + 256 + 16;
	    if (bits.length !== size) {
	        throw new Error(`Merkle Proof cell must have exactly (8 + 256 + 16) bits, got "${bits.length}"`);
	    }
	    if (refs.length !== 1) {
	        throw new Error(`Merkle Proof cell must have exactly 1 ref, got "${refs.length}"`);
	    }
	    // Check type
	    let type = reader.loadUint(8);
	    if (type !== 3) {
	        throw new Error(`Merkle Proof cell must have type 3, got "${type}"`);
	    }
	    // Check data
	    const proofHash = reader.loadBuffer(32);
	    const proofDepth = reader.loadUint(16);
	    const refHash = refs[0].hash(0);
	    const refDepth = refs[0].depth(0);
	    if (proofDepth !== refDepth) {
	        throw new Error(`Merkle Proof cell ref depth must be exactly "${proofDepth}", got "${refDepth}"`);
	    }
	    if (!proofHash.equals(refHash)) {
	        throw new Error(`Merkle Proof cell ref hash must be exactly "${proofHash.toString('hex')}", got "${refHash.toString('hex')}"`);
	    }
	    return {
	        proofDepth,
	        proofHash
	    };
	}
	exoticMerkleProof.exoticMerkleProof = exoticMerkleProof$1;
	function convertToMerkleProof(c) {
	    return (0, Builder_1.beginCell)()
	        .storeUint(3, 8)
	        .storeBuffer(c.hash(0))
	        .storeUint(c.depth(0), 16)
	        .storeRef(c)
	        .endCell({ exotic: true });
	}
	exoticMerkleProof.convertToMerkleProof = convertToMerkleProof;
	return exoticMerkleProof;
}

var hasRequiredGenerateMerkleProof;

function requireGenerateMerkleProof () {
	if (hasRequiredGenerateMerkleProof) return generateMerkleProof;
	hasRequiredGenerateMerkleProof = 1;
	Object.defineProperty(generateMerkleProof, "__esModule", { value: true });
	generateMerkleProof.generateMerkleProof = generateMerkleProof.generateMerkleProofDirect = void 0;
	const Builder_1 = requireBuilder$1();
	const readUnaryLength_1 = requireReadUnaryLength();
	const exoticMerkleProof_1 = requireExoticMerkleProof();
	function convertToPrunedBranch(c) {
	    return (0, Builder_1.beginCell)()
	        .storeUint(1, 8)
	        .storeUint(1, 8)
	        .storeBuffer(c.hash(0))
	        .storeUint(c.depth(0), 16)
	        .endCell({ exotic: true });
	}
	function doGenerateMerkleProof(prefix, slice, n, keys) {
	    // Reading label
	    const originalCell = slice.asCell();
	    if (keys.length == 0) {
	        // no keys to prove, prune the whole subdict
	        return convertToPrunedBranch(originalCell);
	    }
	    let lb0 = slice.loadBit() ? 1 : 0;
	    let prefixLength = 0;
	    let pp = prefix;
	    if (lb0 === 0) {
	        // Short label detected
	        // Read
	        prefixLength = (0, readUnaryLength_1.readUnaryLength)(slice);
	        // Read prefix
	        for (let i = 0; i < prefixLength; i++) {
	            pp += slice.loadBit() ? '1' : '0';
	        }
	    }
	    else {
	        let lb1 = slice.loadBit() ? 1 : 0;
	        if (lb1 === 0) {
	            // Long label detected
	            prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
	            for (let i = 0; i < prefixLength; i++) {
	                pp += slice.loadBit() ? '1' : '0';
	            }
	        }
	        else {
	            // Same label detected
	            let bit = slice.loadBit() ? '1' : '0';
	            prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
	            for (let i = 0; i < prefixLength; i++) {
	                pp += bit;
	            }
	        }
	    }
	    if (n - prefixLength === 0) {
	        return originalCell;
	    }
	    else {
	        let sl = originalCell.beginParse();
	        let left = sl.loadRef();
	        let right = sl.loadRef();
	        // NOTE: Left and right branches are implicitly contain prefixes '0' and '1'
	        if (!left.isExotic) {
	            const leftKeys = keys.filter((key) => {
	                return pp + '0' === key.slice(0, pp.length + 1);
	            });
	            left = doGenerateMerkleProof(pp + '0', left.beginParse(), n - prefixLength - 1, leftKeys);
	        }
	        if (!right.isExotic) {
	            const rightKeys = keys.filter((key) => {
	                return pp + '1' === key.slice(0, pp.length + 1);
	            });
	            right = doGenerateMerkleProof(pp + '1', right.beginParse(), n - prefixLength - 1, rightKeys);
	        }
	        return (0, Builder_1.beginCell)()
	            .storeSlice(sl)
	            .storeRef(left)
	            .storeRef(right)
	            .endCell();
	    }
	}
	function generateMerkleProofDirect(dict, keys, keyObject) {
	    keys.forEach((key) => {
	        if (!dict.has(key)) {
	            throw new Error(`Trying to generate merkle proof for a missing key "${key}"`);
	        }
	    });
	    const s = (0, Builder_1.beginCell)().storeDictDirect(dict).asSlice();
	    return doGenerateMerkleProof('', s, keyObject.bits, keys.map((key) => keyObject.serialize(key).toString(2).padStart(keyObject.bits, '0')));
	}
	generateMerkleProof.generateMerkleProofDirect = generateMerkleProofDirect;
	function generateMerkleProof$1(dict, keys, keyObject) {
	    return (0, exoticMerkleProof_1.convertToMerkleProof)(generateMerkleProofDirect(dict, keys, keyObject));
	}
	generateMerkleProof.generateMerkleProof = generateMerkleProof$1;
	return generateMerkleProof;
}

var generateMerkleUpdate = {};

var hasRequiredGenerateMerkleUpdate;

function requireGenerateMerkleUpdate () {
	if (hasRequiredGenerateMerkleUpdate) return generateMerkleUpdate;
	hasRequiredGenerateMerkleUpdate = 1;
	Object.defineProperty(generateMerkleUpdate, "__esModule", { value: true });
	generateMerkleUpdate.generateMerkleUpdate = void 0;
	const Builder_1 = requireBuilder$1();
	const generateMerkleProof_1 = requireGenerateMerkleProof();
	function convertToMerkleUpdate(c1, c2) {
	    return (0, Builder_1.beginCell)()
	        .storeUint(4, 8)
	        .storeBuffer(c1.hash(0))
	        .storeBuffer(c2.hash(0))
	        .storeUint(c1.depth(0), 16)
	        .storeUint(c2.depth(0), 16)
	        .storeRef(c1)
	        .storeRef(c2)
	        .endCell({ exotic: true });
	}
	function generateMerkleUpdate$1(dict, key, keyObject, newValue) {
	    const oldProof = (0, generateMerkleProof_1.generateMerkleProof)(dict, [key], keyObject).refs[0];
	    dict.set(key, newValue);
	    const newProof = (0, generateMerkleProof_1.generateMerkleProof)(dict, [key], keyObject).refs[0];
	    return convertToMerkleUpdate(oldProof, newProof);
	}
	generateMerkleUpdate.generateMerkleUpdate = generateMerkleUpdate$1;
	return generateMerkleUpdate;
}

var parseDict = {};

var hasRequiredParseDict;

function requireParseDict () {
	if (hasRequiredParseDict) return parseDict;
	hasRequiredParseDict = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(parseDict, "__esModule", { value: true });
	parseDict.parseDict = void 0;
	function readUnaryLength(slice) {
	    let res = 0;
	    while (slice.loadBit()) {
	        res++;
	    }
	    return res;
	}
	function doParse(prefix, slice, n, res, extractor) {
	    // Reading label
	    let lb0 = slice.loadBit() ? 1 : 0;
	    let prefixLength = 0;
	    let pp = prefix;
	    if (lb0 === 0) {
	        // Short label detected
	        // Read 
	        prefixLength = readUnaryLength(slice);
	        // Read prefix
	        for (let i = 0; i < prefixLength; i++) {
	            pp += slice.loadBit() ? '1' : '0';
	        }
	    }
	    else {
	        let lb1 = slice.loadBit() ? 1 : 0;
	        if (lb1 === 0) {
	            // Long label detected
	            prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
	            for (let i = 0; i < prefixLength; i++) {
	                pp += slice.loadBit() ? '1' : '0';
	            }
	        }
	        else {
	            // Same label detected
	            let bit = slice.loadBit() ? '1' : '0';
	            prefixLength = slice.loadUint(Math.ceil(Math.log2(n + 1)));
	            for (let i = 0; i < prefixLength; i++) {
	                pp += bit;
	            }
	        }
	    }
	    if (n - prefixLength === 0) {
	        res.set(BigInt('0b' + pp), extractor(slice));
	    }
	    else {
	        let left = slice.loadRef();
	        let right = slice.loadRef();
	        // NOTE: Left and right branches are implicitly contain prefixes '0' and '1'
	        if (!left.isExotic) {
	            doParse(pp + '0', left.beginParse(), n - prefixLength - 1, res, extractor);
	        }
	        if (!right.isExotic) {
	            doParse(pp + '1', right.beginParse(), n - prefixLength - 1, res, extractor);
	        }
	    }
	}
	function parseDict$1(sc, keySize, extractor) {
	    let res = new Map();
	    if (sc) {
	        doParse('', sc, keySize, res, extractor);
	    }
	    return res;
	}
	parseDict.parseDict = parseDict$1;
	return parseDict;
}

var serializeDict = {};

var findCommonPrefix = {};

var hasRequiredFindCommonPrefix;

function requireFindCommonPrefix () {
	if (hasRequiredFindCommonPrefix) return findCommonPrefix;
	hasRequiredFindCommonPrefix = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(findCommonPrefix, "__esModule", { value: true });
	findCommonPrefix.findCommonPrefix = void 0;
	function findCommonPrefix$1(src, startPos = 0) {
	    // Corner cases
	    if (src.length === 0) {
	        return '';
	    }
	    let r = src[0].slice(startPos);
	    for (let i = 1; i < src.length; i++) {
	        const s = src[i];
	        while (s.indexOf(r, startPos) !== startPos) {
	            r = r.substring(0, r.length - 1);
	            if (r === '') {
	                return r;
	            }
	        }
	    }
	    return r;
	}
	findCommonPrefix.findCommonPrefix = findCommonPrefix$1;
	return findCommonPrefix;
}

var hasRequiredSerializeDict;

function requireSerializeDict () {
	if (hasRequiredSerializeDict) return serializeDict;
	hasRequiredSerializeDict = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(serializeDict, "__esModule", { value: true });
	serializeDict.serializeDict = serializeDict.detectLabelType = serializeDict.writeLabelSame = serializeDict.writeLabelLong = serializeDict.writeLabelShort = serializeDict.buildTree = void 0;
	const Builder_1 = requireBuilder$1();
	const findCommonPrefix_1 = requireFindCommonPrefix();
	//
	// Tree Build
	//
	function pad(src, size) {
	    while (src.length < size) {
	        src = '0' + src;
	    }
	    return src;
	}
	function forkMap(src, prefixLen) {
	    if (src.size === 0) {
	        throw Error('Internal inconsistency');
	    }
	    let left = new Map();
	    let right = new Map();
	    for (let [k, d] of src.entries()) {
	        if (k[prefixLen] === '0') {
	            left.set(k, d);
	        }
	        else {
	            right.set(k, d);
	        }
	    }
	    if (left.size === 0) {
	        throw Error('Internal inconsistency. Left emtpy.');
	    }
	    if (right.size === 0) {
	        throw Error('Internal inconsistency. Right emtpy.');
	    }
	    return { left, right };
	}
	function buildNode(src, prefixLen) {
	    if (src.size === 0) {
	        throw Error('Internal inconsistency');
	    }
	    if (src.size === 1) {
	        return { type: 'leaf', value: Array.from(src.values())[0] };
	    }
	    let { left, right } = forkMap(src, prefixLen);
	    return {
	        type: 'fork',
	        left: buildEdge(left, prefixLen + 1),
	        right: buildEdge(right, prefixLen + 1)
	    };
	}
	function buildEdge(src, prefixLen = 0) {
	    if (src.size === 0) {
	        throw Error('Internal inconsistency');
	    }
	    const label = (0, findCommonPrefix_1.findCommonPrefix)(Array.from(src.keys()), prefixLen);
	    return { label, node: buildNode(src, label.length + prefixLen) };
	}
	function buildTree(src, keyLength) {
	    // Convert map keys
	    let converted = new Map();
	    for (let k of Array.from(src.keys())) {
	        const padded = pad(k.toString(2), keyLength);
	        converted.set(padded, src.get(k));
	    }
	    // Calculate root label
	    return buildEdge(converted);
	}
	serializeDict.buildTree = buildTree;
	//
	// Serialization
	//
	function writeLabelShort(src, to) {
	    // Header
	    to.storeBit(0);
	    // Unary length
	    for (let i = 0; i < src.length; i++) {
	        to.storeBit(1);
	    }
	    to.storeBit(0);
	    // Value
	    if (src.length > 0) {
	        to.storeUint(BigInt('0b' + src), src.length);
	    }
	    return to;
	}
	serializeDict.writeLabelShort = writeLabelShort;
	function labelShortLength(src) {
	    return 1 + src.length + 1 + src.length;
	}
	function writeLabelLong(src, keyLength, to) {
	    // Header
	    to.storeBit(1);
	    to.storeBit(0);
	    // Length
	    let length = Math.ceil(Math.log2(keyLength + 1));
	    to.storeUint(src.length, length);
	    // Value
	    if (src.length > 0) {
	        to.storeUint(BigInt('0b' + src), src.length);
	    }
	    return to;
	}
	serializeDict.writeLabelLong = writeLabelLong;
	function labelLongLength(src, keyLength) {
	    return 1 + 1 + Math.ceil(Math.log2(keyLength + 1)) + src.length;
	}
	function writeLabelSame(value, length, keyLength, to) {
	    // Header
	    to.storeBit(1);
	    to.storeBit(1);
	    // Value
	    to.storeBit(value);
	    // Length
	    let lenLen = Math.ceil(Math.log2(keyLength + 1));
	    to.storeUint(length, lenLen);
	}
	serializeDict.writeLabelSame = writeLabelSame;
	function labelSameLength(keyLength) {
	    return 1 + 1 + 1 + Math.ceil(Math.log2(keyLength + 1));
	}
	function isSame(src) {
	    if (src.length === 0 || src.length === 1) {
	        return true;
	    }
	    for (let i = 1; i < src.length; i++) {
	        if (src[i] !== src[0]) {
	            return false;
	        }
	    }
	    return true;
	}
	function detectLabelType(src, keyLength) {
	    let kind = 'short';
	    let kindLength = labelShortLength(src);
	    let longLength = labelLongLength(src, keyLength);
	    if (longLength < kindLength) {
	        kindLength = longLength;
	        kind = 'long';
	    }
	    if (isSame(src)) {
	        let sameLength = labelSameLength(keyLength);
	        if (sameLength < kindLength) {
	            kindLength = sameLength;
	            kind = 'same';
	        }
	    }
	    return kind;
	}
	serializeDict.detectLabelType = detectLabelType;
	function writeLabel(src, keyLength, to) {
	    let type = detectLabelType(src, keyLength);
	    if (type === 'short') {
	        writeLabelShort(src, to);
	    }
	    else if (type === 'long') {
	        writeLabelLong(src, keyLength, to);
	    }
	    else if (type === 'same') {
	        writeLabelSame(src[0] === '1', src.length, keyLength, to);
	    }
	}
	function writeNode(src, keyLength, serializer, to) {
	    if (src.type === 'leaf') {
	        serializer(src.value, to);
	    }
	    if (src.type === 'fork') {
	        const leftCell = (0, Builder_1.beginCell)();
	        const rightCell = (0, Builder_1.beginCell)();
	        writeEdge(src.left, keyLength - 1, serializer, leftCell);
	        writeEdge(src.right, keyLength - 1, serializer, rightCell);
	        to.storeRef(leftCell);
	        to.storeRef(rightCell);
	    }
	}
	function writeEdge(src, keyLength, serializer, to) {
	    writeLabel(src.label, keyLength, to);
	    writeNode(src.node, keyLength - src.label.length, serializer, to);
	}
	function serializeDict$1(src, keyLength, serializer, to) {
	    const tree = buildTree(src, keyLength);
	    writeEdge(tree, keyLength, serializer, to);
	}
	serializeDict.serializeDict = serializeDict$1;
	return serializeDict;
}

var internalKeySerializer = {};

var hasRequiredInternalKeySerializer;

function requireInternalKeySerializer () {
	if (hasRequiredInternalKeySerializer) return internalKeySerializer;
	hasRequiredInternalKeySerializer = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(internalKeySerializer, "__esModule", { value: true });
	internalKeySerializer.deserializeInternalKey = internalKeySerializer.serializeInternalKey = void 0;
	const Address_1 = requireAddress();
	const BitString_1 = requireBitString();
	const paddedBits_1 = requirePaddedBits();
	function serializeInternalKey(value) {
	    if (typeof value === 'number') {
	        if (!Number.isSafeInteger(value)) {
	            throw Error('Invalid key type: not a safe integer: ' + value);
	        }
	        return 'n:' + value.toString(10);
	    }
	    else if (typeof value === 'bigint') {
	        return 'b:' + value.toString(10);
	    }
	    else if (Address_1.Address.isAddress(value)) {
	        return 'a:' + value.toString();
	    }
	    else if (Buffer.isBuffer(value)) {
	        return 'f:' + value.toString('hex');
	    }
	    else if (BitString_1.BitString.isBitString(value)) {
	        return 'B:' + value.toString();
	    }
	    else {
	        throw Error('Invalid key type');
	    }
	}
	internalKeySerializer.serializeInternalKey = serializeInternalKey;
	function deserializeInternalKey(value) {
	    let k = value.slice(0, 2);
	    let v = value.slice(2);
	    if (k === 'n:') {
	        return parseInt(v, 10);
	    }
	    else if (k === 'b:') {
	        return BigInt(v);
	    }
	    else if (k === 'a:') {
	        return Address_1.Address.parse(v);
	    }
	    else if (k === 'f:') {
	        return Buffer.from(v, 'hex');
	    }
	    else if (k === 'B:') {
	        const lastDash = v.slice(-1) == "_";
	        const isPadded = lastDash || v.length % 2 != 0;
	        if (isPadded) {
	            let charLen = lastDash ? v.length - 1 : v.length;
	            const padded = v.substr(0, charLen) + "0"; //Padding
	            if ((!lastDash) && ((charLen & 1) !== 0)) {
	                // Four bit nibmle without padding
	                return new BitString_1.BitString(Buffer.from(padded, 'hex'), 0, charLen << 2);
	            }
	            else {
	                return (0, paddedBits_1.paddedBufferToBits)(Buffer.from(padded, 'hex'));
	            }
	        }
	        else {
	            return new BitString_1.BitString(Buffer.from(v, 'hex'), 0, v.length << 2);
	        }
	    }
	    throw Error('Invalid key type: ' + k);
	}
	internalKeySerializer.deserializeInternalKey = deserializeInternalKey;
	return internalKeySerializer;
}

var hasRequiredDictionary;

function requireDictionary () {
	if (hasRequiredDictionary) return Dictionary;
	hasRequiredDictionary = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(Dictionary, "__esModule", { value: true });
	Dictionary.Dictionary = void 0;
	const Address_1 = requireAddress();
	const Builder_1 = requireBuilder$1();
	const Cell_1 = requireCell();
	const BitString_1 = requireBitString();
	const generateMerkleProof_1 = requireGenerateMerkleProof();
	const generateMerkleUpdate_1 = requireGenerateMerkleUpdate();
	const parseDict_1 = requireParseDict();
	const serializeDict_1 = requireSerializeDict();
	const internalKeySerializer_1 = requireInternalKeySerializer();
	let Dictionary$1 = class Dictionary {
	    /**
	     * Create an empty map
	     * @param key key type
	     * @param value value type
	     * @returns Dictionary<K, V>
	     */
	    static empty(key, value) {
	        if (key && value) {
	            return new Dictionary(new Map(), key, value);
	        }
	        else {
	            return new Dictionary(new Map(), null, null);
	        }
	    }
	    /**
	     * Load dictionary from slice
	     * @param key key description
	     * @param value value description
	     * @param src slice
	     * @returns Dictionary<K, V>
	     */
	    static load(key, value, sc) {
	        let slice;
	        if (sc instanceof Cell_1.Cell) {
	            if (sc.isExotic) {
	                return Dictionary.empty(key, value);
	            }
	            slice = sc.beginParse();
	        }
	        else {
	            slice = sc;
	        }
	        let cell = slice.loadMaybeRef();
	        if (cell && !cell.isExotic) {
	            return Dictionary.loadDirect(key, value, cell.beginParse());
	        }
	        else {
	            return Dictionary.empty(key, value);
	        }
	    }
	    /**
	     * Low level method for rare dictionaries from system contracts.
	     * Loads dictionary from slice directly without going to the ref.
	     *
	     * @param key key description
	     * @param value value description
	     * @param sc slice
	     * @returns Dictionary<K, V>
	     */
	    static loadDirect(key, value, sc) {
	        if (!sc) {
	            return Dictionary.empty(key, value);
	        }
	        let slice;
	        if (sc instanceof Cell_1.Cell) {
	            slice = sc.beginParse();
	        }
	        else {
	            slice = sc;
	        }
	        let values = (0, parseDict_1.parseDict)(slice, key.bits, value.parse);
	        let prepare = new Map();
	        for (let [k, v] of values) {
	            prepare.set((0, internalKeySerializer_1.serializeInternalKey)(key.parse(k)), v);
	        }
	        return new Dictionary(prepare, key, value);
	    }
	    constructor(values, key, value) {
	        this._key = key;
	        this._value = value;
	        this._map = values;
	    }
	    get size() {
	        return this._map.size;
	    }
	    get(key) {
	        return this._map.get((0, internalKeySerializer_1.serializeInternalKey)(key));
	    }
	    has(key) {
	        return this._map.has((0, internalKeySerializer_1.serializeInternalKey)(key));
	    }
	    set(key, value) {
	        this._map.set((0, internalKeySerializer_1.serializeInternalKey)(key), value);
	        return this;
	    }
	    delete(key) {
	        const k = (0, internalKeySerializer_1.serializeInternalKey)(key);
	        return this._map.delete(k);
	    }
	    clear() {
	        this._map.clear();
	    }
	    *[Symbol.iterator]() {
	        for (const [k, v] of this._map) {
	            const key = (0, internalKeySerializer_1.deserializeInternalKey)(k);
	            yield [key, v];
	        }
	    }
	    keys() {
	        return Array.from(this._map.keys()).map((v) => (0, internalKeySerializer_1.deserializeInternalKey)(v));
	    }
	    values() {
	        return Array.from(this._map.values());
	    }
	    store(builder, key, value) {
	        if (this._map.size === 0) {
	            builder.storeBit(0);
	        }
	        else {
	            // Resolve serializer
	            let resolvedKey = this._key;
	            if (key !== null && key !== undefined) {
	                resolvedKey = key;
	            }
	            let resolvedValue = this._value;
	            if (value !== null && value !== undefined) {
	                resolvedValue = value;
	            }
	            if (!resolvedKey) {
	                throw Error('Key serializer is not defined');
	            }
	            if (!resolvedValue) {
	                throw Error('Value serializer is not defined');
	            }
	            // Prepare map
	            let prepared = new Map();
	            for (const [k, v] of this._map) {
	                prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v);
	            }
	            // Store
	            builder.storeBit(1);
	            let dd = (0, Builder_1.beginCell)();
	            (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, dd);
	            builder.storeRef(dd.endCell());
	        }
	    }
	    storeDirect(builder, key, value) {
	        if (this._map.size === 0) {
	            throw Error('Cannot store empty dictionary directly');
	        }
	        // Resolve serializer
	        let resolvedKey = this._key;
	        if (key !== null && key !== undefined) {
	            resolvedKey = key;
	        }
	        let resolvedValue = this._value;
	        if (value !== null && value !== undefined) {
	            resolvedValue = value;
	        }
	        if (!resolvedKey) {
	            throw Error('Key serializer is not defined');
	        }
	        if (!resolvedValue) {
	            throw Error('Value serializer is not defined');
	        }
	        // Prepare map
	        let prepared = new Map();
	        for (const [k, v] of this._map) {
	            prepared.set(resolvedKey.serialize((0, internalKeySerializer_1.deserializeInternalKey)(k)), v);
	        }
	        // Store
	        (0, serializeDict_1.serializeDict)(prepared, resolvedKey.bits, resolvedValue.serialize, builder);
	    }
	    /**
	     * Generate merkle proof for multiple keys in the dictionary
	     * @param keys an array of the keys
	     * @returns generated merkle proof cell
	     */
	    generateMerkleProof(keys) {
	        return (0, generateMerkleProof_1.generateMerkleProof)(this, keys, this._key);
	    }
	    /**
	     * Low level method for generating pruned dictionary directly.
	     * The result can be used as a part of a bigger merkle proof
	     * @param keys an array of the keys
	     * @returns cell that contains the pruned dictionary
	     */
	    generateMerkleProofDirect(keys) {
	        return (0, generateMerkleProof_1.generateMerkleProofDirect)(this, keys, this._key);
	    }
	    generateMerkleUpdate(key, newValue) {
	        return (0, generateMerkleUpdate_1.generateMerkleUpdate)(this, key, this._key, newValue);
	    }
	};
	Dictionary.Dictionary = Dictionary$1;
	Dictionary$1.Keys = {
	    /**
	     * Standard address key
	     * @returns DictionaryKey<Address>
	     */
	    Address: () => {
	        return createAddressKey();
	    },
	    /**
	     * Create standard big integer key
	     * @param bits number of bits
	     * @returns DictionaryKey<bigint>
	     */
	    BigInt: (bits) => {
	        return createBigIntKey(bits);
	    },
	    /**
	     * Create integer key
	     * @param bits bits of integer
	     * @returns DictionaryKey<number>
	     */
	    Int: (bits) => {
	        return createIntKey(bits);
	    },
	    /**
	     * Create standard unsigned big integer key
	     * @param bits number of bits
	     * @returns DictionaryKey<bigint>
	     */
	    BigUint: (bits) => {
	        return createBigUintKey(bits);
	    },
	    /**
	     * Create standard unsigned integer key
	     * @param bits number of bits
	     * @returns DictionaryKey<number>
	     */
	    Uint: (bits) => {
	        return createUintKey(bits);
	    },
	    /**
	     * Create standard buffer key
	     * @param bytes number of bytes of a buffer
	     * @returns DictionaryKey<Buffer>
	     */
	    Buffer: (bytes) => {
	        return createBufferKey(bytes);
	    },
	    /**
	     * Create BitString key
	     * @param bits key length
	     * @returns DictionaryKey<BitString>
	     * Point is that Buffer has to be 8 bit aligned,
	     * while key is TVM dictionary doesn't have to be
	     * aligned at all.
	     */
	    BitString: (bits) => {
	        return createBitStringKey(bits);
	    }
	};
	Dictionary$1.Values = {
	    /**
	     * Create standard integer value
	     * @returns DictionaryValue<bigint>
	     */
	    BigInt: (bits) => {
	        return createBigIntValue(bits);
	    },
	    /**
	     * Create standard integer value
	     * @returns DictionaryValue<number>
	     */
	    Int: (bits) => {
	        return createIntValue(bits);
	    },
	    /**
	     * Create big var int
	     * @param bits nubmer of header bits
	     * @returns DictionaryValue<bigint>
	     */
	    BigVarInt: (bits) => {
	        return createBigVarIntValue(bits);
	    },
	    /**
	     * Create standard unsigned integer value
	     * @param bits number of bits
	     * @returns DictionaryValue<bigint>
	     */
	    BigUint: (bits) => {
	        return createBigUintValue(bits);
	    },
	    /**
	     * Create standard unsigned integer value
	     * @param bits number of bits
	     * @returns DictionaryValue<bigint>
	     */
	    Uint: (bits) => {
	        return createUintValue(bits);
	    },
	    /**
	     * Create big var int
	     * @param bits nubmer of header bits
	     * @returns DictionaryValue<bigint>
	     */
	    BigVarUint: (bits) => {
	        return createBigVarUintValue(bits);
	    },
	    /**
	     * Create standard boolean value
	     * @returns DictionaryValue<boolean>
	     */
	    Bool: () => {
	        return createBooleanValue();
	    },
	    /**
	     * Create standard address value
	     * @returns DictionaryValue<Address>
	     */
	    Address: () => {
	        return createAddressValue();
	    },
	    /**
	     * Create standard cell value
	     * @returns DictionaryValue<Cell>
	     */
	    Cell: () => {
	        return createCellValue();
	    },
	    /**
	     * Create Builder value
	     * @param bytes number of bytes of a buffer
	     * @returns DictionaryValue<Builder>
	     */
	    Buffer: (bytes) => {
	        return createBufferValue(bytes);
	    },
	    /**
	     * Create BitString value
	     * @param requested bit length
	     * @returns DictionaryValue<BitString>
	     * Point is that Buffer is not applicable
	     * when length is not 8 bit alligned.
	     */
	    BitString: (bits) => {
	        return createBitStringValue(bits);
	    },
	    /**
	     * Create dictionary value
	     * @param key
	     * @param value
	     */
	    Dictionary: (key, value) => {
	        return createDictionaryValue(key, value);
	    }
	};
	//
	// Keys and Values
	//
	function createAddressKey() {
	    return {
	        bits: 267,
	        serialize: (src) => {
	            if (!Address_1.Address.isAddress(src)) {
	                throw Error('Key is not an address');
	            }
	            return (0, Builder_1.beginCell)().storeAddress(src).endCell().beginParse().preloadUintBig(267);
	        },
	        parse: (src) => {
	            return (0, Builder_1.beginCell)().storeUint(src, 267).endCell().beginParse().loadAddress();
	        }
	    };
	}
	function createBigIntKey(bits) {
	    return {
	        bits,
	        serialize: (src) => {
	            if (typeof src !== 'bigint') {
	                throw Error('Key is not a bigint');
	            }
	            return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
	        },
	        parse: (src) => {
	            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadIntBig(bits);
	        }
	    };
	}
	function createIntKey(bits) {
	    return {
	        bits: bits,
	        serialize: (src) => {
	            if (typeof src !== 'number') {
	                throw Error('Key is not a number');
	            }
	            if (!Number.isSafeInteger(src)) {
	                throw Error('Key is not a safe integer: ' + src);
	            }
	            return (0, Builder_1.beginCell)().storeInt(src, bits).endCell().beginParse().loadUintBig(bits);
	        },
	        parse: (src) => {
	            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadInt(bits);
	        }
	    };
	}
	function createBigUintKey(bits) {
	    return {
	        bits,
	        serialize: (src) => {
	            if (typeof src !== 'bigint') {
	                throw Error('Key is not a bigint');
	            }
	            if (src < 0) {
	                throw Error('Key is negative: ' + src);
	            }
	            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
	        },
	        parse: (src) => {
	            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
	        }
	    };
	}
	function createUintKey(bits) {
	    return {
	        bits,
	        serialize: (src) => {
	            if (typeof src !== 'number') {
	                throw Error('Key is not a number');
	            }
	            if (!Number.isSafeInteger(src)) {
	                throw Error('Key is not a safe integer: ' + src);
	            }
	            if (src < 0) {
	                throw Error('Key is negative: ' + src);
	            }
	            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUintBig(bits);
	        },
	        parse: (src) => {
	            return Number((0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadUint(bits));
	        }
	    };
	}
	function createBufferKey(bytes) {
	    return {
	        bits: bytes * 8,
	        serialize: (src) => {
	            if (!Buffer.isBuffer(src)) {
	                throw Error('Key is not a buffer');
	            }
	            return (0, Builder_1.beginCell)().storeBuffer(src).endCell().beginParse().loadUintBig(bytes * 8);
	        },
	        parse: (src) => {
	            return (0, Builder_1.beginCell)().storeUint(src, bytes * 8).endCell().beginParse().loadBuffer(bytes);
	        }
	    };
	}
	function createBitStringKey(bits) {
	    return {
	        bits,
	        serialize: (src) => {
	            if (!BitString_1.BitString.isBitString(src))
	                throw Error('Key is not a BitString');
	            return (0, Builder_1.beginCell)().storeBits(src).endCell().beginParse().loadUintBig(bits);
	        },
	        parse: (src) => {
	            return (0, Builder_1.beginCell)().storeUint(src, bits).endCell().beginParse().loadBits(bits);
	        }
	    };
	}
	function createIntValue(bits) {
	    return {
	        serialize: (src, buidler) => {
	            buidler.storeInt(src, bits);
	        },
	        parse: (src) => {
	            let value = src.loadInt(bits);
	            src.endParse();
	            return value;
	        }
	    };
	}
	function createBigIntValue(bits) {
	    return {
	        serialize: (src, buidler) => {
	            buidler.storeInt(src, bits);
	        },
	        parse: (src) => {
	            let value = src.loadIntBig(bits);
	            src.endParse();
	            return value;
	        }
	    };
	}
	function createBigVarIntValue(bits) {
	    return {
	        serialize: (src, buidler) => {
	            buidler.storeVarInt(src, bits);
	        },
	        parse: (src) => {
	            let value = src.loadVarIntBig(bits);
	            src.endParse();
	            return value;
	        }
	    };
	}
	function createBigVarUintValue(bits) {
	    return {
	        serialize: (src, buidler) => {
	            buidler.storeVarUint(src, bits);
	        },
	        parse: (src) => {
	            let value = src.loadVarUintBig(bits);
	            src.endParse();
	            return value;
	        }
	    };
	}
	function createUintValue(bits) {
	    return {
	        serialize: (src, buidler) => {
	            buidler.storeUint(src, bits);
	        },
	        parse: (src) => {
	            let value = src.loadUint(bits);
	            src.endParse();
	            return value;
	        }
	    };
	}
	function createBigUintValue(bits) {
	    return {
	        serialize: (src, buidler) => {
	            buidler.storeUint(src, bits);
	        },
	        parse: (src) => {
	            let value = src.loadUintBig(bits);
	            src.endParse();
	            return value;
	        }
	    };
	}
	function createBooleanValue() {
	    return {
	        serialize: (src, buidler) => {
	            buidler.storeBit(src);
	        },
	        parse: (src) => {
	            let value = src.loadBit();
	            src.endParse();
	            return value;
	        }
	    };
	}
	function createAddressValue() {
	    return {
	        serialize: (src, buidler) => {
	            buidler.storeAddress(src);
	        },
	        parse: (src) => {
	            let addr = src.loadAddress();
	            src.endParse();
	            return addr;
	        }
	    };
	}
	function createCellValue() {
	    return {
	        serialize: (src, buidler) => {
	            buidler.storeRef(src);
	        },
	        parse: (src) => {
	            let value = src.loadRef();
	            src.endParse();
	            return value;
	        }
	    };
	}
	function createDictionaryValue(key, value) {
	    return {
	        serialize: (src, buidler) => {
	            src.store(buidler);
	        },
	        parse: (src) => {
	            let dict = Dictionary$1.load(key, value, src);
	            src.endParse();
	            return dict;
	        }
	    };
	}
	function createBufferValue(size) {
	    return {
	        serialize: (src, buidler) => {
	            if (src.length !== size) {
	                throw Error('Invalid buffer size');
	            }
	            buidler.storeBuffer(src);
	        },
	        parse: (src) => {
	            let value = src.loadBuffer(size);
	            src.endParse();
	            return value;
	        }
	    };
	}
	function createBitStringValue(bits) {
	    return {
	        serialize: (src, builder) => {
	            if (src.length !== bits) {
	                throw Error('Invalid BitString size');
	            }
	            builder.storeBits(src);
	        },
	        parse: (src) => {
	            let value = src.loadBits(bits);
	            src.endParse();
	            return value;
	        }
	    };
	}
	return Dictionary;
}

var strings = {};

var hasRequiredStrings;

function requireStrings () {
	if (hasRequiredStrings) return strings;
	hasRequiredStrings = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(strings, "__esModule", { value: true });
	strings.writeString = strings.stringToCell = strings.readString = void 0;
	const Builder_1 = requireBuilder$1();
	function readBuffer(slice) {
	    // Check consistency
	    if (slice.remainingBits % 8 !== 0) {
	        throw new Error(`Invalid string length: ${slice.remainingBits}`);
	    }
	    if (slice.remainingRefs !== 0 && slice.remainingRefs !== 1) {
	        throw new Error(`invalid number of refs: ${slice.remainingRefs}`);
	    }
	    // Read string
	    let res;
	    if (slice.remainingBits === 0) {
	        res = Buffer.alloc(0);
	    }
	    else {
	        res = slice.loadBuffer(slice.remainingBits / 8);
	    }
	    // Read tail
	    if (slice.remainingRefs === 1) {
	        res = Buffer.concat([res, readBuffer(slice.loadRef().beginParse())]);
	    }
	    return res;
	}
	function readString(slice) {
	    return readBuffer(slice).toString();
	}
	strings.readString = readString;
	function writeBuffer(src, builder) {
	    if (src.length > 0) {
	        let bytes = Math.floor(builder.availableBits / 8);
	        if (src.length > bytes) {
	            let a = src.subarray(0, bytes);
	            let t = src.subarray(bytes);
	            builder = builder.storeBuffer(a);
	            let bb = (0, Builder_1.beginCell)();
	            writeBuffer(t, bb);
	            builder = builder.storeRef(bb.endCell());
	        }
	        else {
	            builder = builder.storeBuffer(src);
	        }
	    }
	}
	function stringToCell(src) {
	    let builder = (0, Builder_1.beginCell)();
	    writeBuffer(Buffer.from(src), builder);
	    return builder.endCell();
	}
	strings.stringToCell = stringToCell;
	function writeString(src, builder) {
	    writeBuffer(Buffer.from(src), builder);
	}
	strings.writeString = writeString;
	return strings;
}

var hasRequiredSlice;

function requireSlice () {
	if (hasRequiredSlice) return Slice;
	hasRequiredSlice = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var __importDefault = (Slice && Slice.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	var _a;
	Object.defineProperty(Slice, "__esModule", { value: true });
	Slice.Slice = void 0;
	const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
	const Dictionary_1 = requireDictionary();
	const Builder_1 = requireBuilder$1();
	const strings_1 = requireStrings();
	/**
	 * Slice is a class that allows to read cell data
	 */
	let Slice$1 = class Slice {
	    constructor(reader, refs) {
	        this[_a] = () => this.toString();
	        this._reader = reader.clone();
	        this._refs = [...refs];
	        this._refsOffset = 0;
	    }
	    /**
	     * Get remaining bits
	     */
	    get remainingBits() {
	        return this._reader.remaining;
	    }
	    /**
	     * Get offset bits
	     */
	    get offsetBits() {
	        return this._reader.offset;
	    }
	    /**
	     * Get remaining refs
	     */
	    get remainingRefs() {
	        return this._refs.length - this._refsOffset;
	    }
	    /**
	     * Get offset refs
	     */
	    get offsetRefs() {
	        return this._refsOffset;
	    }
	    /**
	     * Skip bits
	     * @param bits
	     */
	    skip(bits) {
	        this._reader.skip(bits);
	        return this;
	    }
	    /**
	     * Load a single bit
	     * @returns true or false depending on the bit value
	     */
	    loadBit() {
	        return this._reader.loadBit();
	    }
	    /**
	     * Preload a signle bit
	     * @returns true or false depending on the bit value
	     */
	    preloadBit() {
	        return this._reader.preloadBit();
	    }
	    /**
	     * Load a boolean
	     * @returns true or false depending on the bit value
	     */
	    loadBoolean() {
	        return this.loadBit();
	    }
	    /**
	     * Load maybe boolean
	     * @returns true or false depending on the bit value or null
	     */
	    loadMaybeBoolean() {
	        if (this.loadBit()) {
	            return this.loadBoolean();
	        }
	        else {
	            return null;
	        }
	    }
	    /**
	     * Load bits as a new BitString
	     * @param bits number of bits to read
	     * @returns new BitString
	     */
	    loadBits(bits) {
	        return this._reader.loadBits(bits);
	    }
	    /**
	     * Preload bits as a new BitString
	     * @param bits number of bits to read
	     * @returns new BitString
	     */
	    preloadBits(bits) {
	        return this._reader.preloadBits(bits);
	    }
	    /**
	     * Load uint
	     * @param bits number of bits to read
	     * @returns uint value
	     */
	    loadUint(bits) {
	        return this._reader.loadUint(bits);
	    }
	    /**
	     * Load uint
	     * @param bits number of bits to read
	     * @returns uint value
	     */
	    loadUintBig(bits) {
	        return this._reader.loadUintBig(bits);
	    }
	    /**
	     * Preload uint
	     * @param bits number of bits to read
	     * @returns uint value
	     */
	    preloadUint(bits) {
	        return this._reader.preloadUint(bits);
	    }
	    /**
	     * Preload uint
	     * @param bits number of bits to read
	     * @returns uint value
	     */
	    preloadUintBig(bits) {
	        return this._reader.preloadUintBig(bits);
	    }
	    /**
	     * Load maybe uint
	     * @param bits number of bits to read
	     * @returns uint value or null
	     */
	    loadMaybeUint(bits) {
	        if (this.loadBit()) {
	            return this.loadUint(bits);
	        }
	        else {
	            return null;
	        }
	    }
	    /**
	     * Load maybe uint
	     * @param bits number of bits to read
	     * @returns uint value or null
	     */
	    loadMaybeUintBig(bits) {
	        if (this.loadBit()) {
	            return this.loadUintBig(bits);
	        }
	        else {
	            return null;
	        }
	    }
	    /**
	     * Load int
	     * @param bits number of bits to read
	     * @returns int value
	     */
	    loadInt(bits) {
	        return this._reader.loadInt(bits);
	    }
	    /**
	     * Load int
	     * @param bits number of bits to read
	     * @returns int value
	     */
	    loadIntBig(bits) {
	        return this._reader.loadIntBig(bits);
	    }
	    /**
	     * Preload int
	     * @param bits number of bits to read
	     * @returns int value
	     */
	    preloadInt(bits) {
	        return this._reader.preloadInt(bits);
	    }
	    /**
	     * Preload int
	     * @param bits number of bits to read
	     * @returns int value
	     */
	    preloadIntBig(bits) {
	        return this._reader.preloadIntBig(bits);
	    }
	    /**
	     * Load maybe uint
	     * @param bits number of bits to read
	     * @returns uint value or null
	     */
	    loadMaybeInt(bits) {
	        if (this.loadBit()) {
	            return this.loadInt(bits);
	        }
	        else {
	            return null;
	        }
	    }
	    /**
	     * Load maybe uint
	     * @param bits number of bits to read
	     * @returns uint value or null
	     */
	    loadMaybeIntBig(bits) {
	        if (this.loadBit()) {
	            return this.loadIntBig(bits);
	        }
	        else {
	            return null;
	        }
	    }
	    /**
	     * Load varuint
	     * @param bits number of bits to read in header
	     * @returns varuint value
	     */
	    loadVarUint(bits) {
	        return this._reader.loadVarUint(bits);
	    }
	    /**
	     * Load varuint
	     * @param bits number of bits to read in header
	     * @returns varuint value
	     */
	    loadVarUintBig(bits) {
	        return this._reader.loadVarUintBig(bits);
	    }
	    /**
	     * Preload varuint
	     * @param bits number of bits to read in header
	     * @returns varuint value
	     */
	    preloadVarUint(bits) {
	        return this._reader.preloadVarUint(bits);
	    }
	    /**
	     * Preload varuint
	     * @param bits number of bits to read in header
	     * @returns varuint value
	     */
	    preloadVarUintBig(bits) {
	        return this._reader.preloadVarUintBig(bits);
	    }
	    /**
	     * Load varint
	     * @param bits number of bits to read in header
	     * @returns varint value
	     */
	    loadVarInt(bits) {
	        return this._reader.loadVarInt(bits);
	    }
	    /**
	     * Load varint
	     * @param bits number of bits to read in header
	     * @returns varint value
	     */
	    loadVarIntBig(bits) {
	        return this._reader.loadVarIntBig(bits);
	    }
	    /**
	     * Preload varint
	     * @param bits number of bits to read in header
	     * @returns varint value
	     */
	    preloadVarInt(bits) {
	        return this._reader.preloadVarInt(bits);
	    }
	    /**
	     * Preload varint
	     * @param bits number of bits to read in header
	     * @returns varint value
	     */
	    preloadVarIntBig(bits) {
	        return this._reader.preloadVarIntBig(bits);
	    }
	    /**
	     * Load coins
	     * @returns coins value
	     */
	    loadCoins() {
	        return this._reader.loadCoins();
	    }
	    /**
	     * Preload coins
	     * @returns coins value
	     */
	    preloadCoins() {
	        return this._reader.preloadCoins();
	    }
	    /**
	     * Load maybe coins
	     * @returns coins value or null
	     */
	    loadMaybeCoins() {
	        if (this._reader.loadBit()) {
	            return this._reader.loadCoins();
	        }
	        else {
	            return null;
	        }
	    }
	    /**
	     * Load internal Address
	     * @returns Address
	     */
	    loadAddress() {
	        return this._reader.loadAddress();
	    }
	    /**
	     * Load optional internal Address
	     * @returns Address or null
	     */
	    loadMaybeAddress() {
	        return this._reader.loadMaybeAddress();
	    }
	    /**
	     * Load external address
	     * @returns ExternalAddress
	     */
	    loadExternalAddress() {
	        return this._reader.loadExternalAddress();
	    }
	    /**
	     * Load optional external address
	     * @returns ExternalAddress or null
	     */
	    loadMaybeExternalAddress() {
	        return this._reader.loadMaybeExternalAddress();
	    }
	    /**
	     * Load address
	     * @returns Address, ExternalAddress or null
	     */
	    loadAddressAny() {
	        return this._reader.loadAddressAny();
	    }
	    /**
	     * Load reference
	     * @returns Cell
	     */
	    loadRef() {
	        if (this._refsOffset >= this._refs.length) {
	            throw new Error("No more references");
	        }
	        return this._refs[this._refsOffset++];
	    }
	    /**
	     * Preload reference
	     * @returns Cell
	     */
	    preloadRef() {
	        if (this._refsOffset >= this._refs.length) {
	            throw new Error("No more references");
	        }
	        return this._refs[this._refsOffset];
	    }
	    /**
	     * Load optional reference
	     * @returns Cell or null
	     */
	    loadMaybeRef() {
	        if (this.loadBit()) {
	            return this.loadRef();
	        }
	        else {
	            return null;
	        }
	    }
	    /**
	     * Preload optional reference
	     * @returns Cell or null
	     */
	    preloadMaybeRef() {
	        if (this.preloadBit()) {
	            return this.preloadRef();
	        }
	        else {
	            return null;
	        }
	    }
	    /**
	     * Load byte buffer
	     * @param bytes number of bytes to load
	     * @returns Buffer
	     */
	    loadBuffer(bytes) {
	        return this._reader.loadBuffer(bytes);
	    }
	    /**
	     * Load byte buffer
	     * @param bytes number of bytes to load
	     * @returns Buffer
	     */
	    preloadBuffer(bytes) {
	        return this._reader.preloadBuffer(bytes);
	    }
	    /**
	     * Load string tail
	     */
	    loadStringTail() {
	        return (0, strings_1.readString)(this);
	    }
	    /**
	     * Load maybe string tail
	     * @returns string or null
	     */
	    loadMaybeStringTail() {
	        if (this.loadBit()) {
	            return (0, strings_1.readString)(this);
	        }
	        else {
	            return null;
	        }
	    }
	    /**
	     * Load string tail from ref
	     * @returns string
	     */
	    loadStringRefTail() {
	        return (0, strings_1.readString)(this.loadRef().beginParse());
	    }
	    /**
	     * Load maybe string tail from ref
	     * @returns string or null
	     */
	    loadMaybeStringRefTail() {
	        const ref = this.loadMaybeRef();
	        if (ref) {
	            return (0, strings_1.readString)(ref.beginParse());
	        }
	        else {
	            return null;
	        }
	    }
	    /**
	     * Loads dictionary
	     * @param key key description
	     * @param value value description
	     * @returns Dictionary<K, V>
	     */
	    loadDict(key, value) {
	        return Dictionary_1.Dictionary.load(key, value, this);
	    }
	    /**
	     * Loads dictionary directly from current slice
	     * @param key key description
	     * @param value value description
	     * @returns Dictionary<K, V>
	     */
	    loadDictDirect(key, value) {
	        return Dictionary_1.Dictionary.loadDirect(key, value, this);
	    }
	    /**
	     * Checks if slice is empty
	     */
	    endParse() {
	        if (this.remainingBits > 0 || this.remainingRefs > 0) {
	            throw new Error("Slice is not empty");
	        }
	    }
	    /**
	     * Convert slice to cell
	     */
	    asCell() {
	        return (0, Builder_1.beginCell)().storeSlice(this).endCell();
	    }
	    /**
	     *
	     * @returns
	     */
	    asBuilder() {
	        return (0, Builder_1.beginCell)().storeSlice(this);
	    }
	    /**
	     * Clone slice
	     * @returns cloned slice
	     */
	    clone(fromStart = false) {
	        if (fromStart) {
	            let reader = this._reader.clone();
	            reader.reset();
	            return new Slice(reader, this._refs);
	        }
	        else {
	            let res = new Slice(this._reader, this._refs);
	            res._refsOffset = this._refsOffset;
	            return res;
	        }
	    }
	    /**
	     * Print slice as string by converting it to cell
	     * @returns string
	     */
	    toString() {
	        return this.asCell().toString();
	    }
	};
	Slice.Slice = Slice$1;
	_a = symbol_inspect_1.default;
	return Slice;
}

var resolveExotic = {};

var exoticLibrary = {};

var hasRequiredExoticLibrary;

function requireExoticLibrary () {
	if (hasRequiredExoticLibrary) return exoticLibrary;
	hasRequiredExoticLibrary = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(exoticLibrary, "__esModule", { value: true });
	exoticLibrary.exoticLibrary = void 0;
	const BitReader_1 = requireBitReader();
	function exoticLibrary$1(bits, refs) {
	    const reader = new BitReader_1.BitReader(bits);
	    // type + hash
	    const size = 8 + 256;
	    if (bits.length !== size) {
	        throw new Error(`Library cell must have exactly (8 + 256) bits, got "${bits.length}"`);
	    }
	    // Check type
	    let type = reader.loadUint(8);
	    if (type !== 2) {
	        throw new Error(`Library cell must have type 2, got "${type}"`);
	    }
	    return {};
	}
	exoticLibrary.exoticLibrary = exoticLibrary$1;
	return exoticLibrary;
}

var exoticMerkleUpdate = {};

var hasRequiredExoticMerkleUpdate;

function requireExoticMerkleUpdate () {
	if (hasRequiredExoticMerkleUpdate) return exoticMerkleUpdate;
	hasRequiredExoticMerkleUpdate = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(exoticMerkleUpdate, "__esModule", { value: true });
	exoticMerkleUpdate.exoticMerkleUpdate = void 0;
	const BitReader_1 = requireBitReader();
	function exoticMerkleUpdate$1(bits, refs) {
	    const reader = new BitReader_1.BitReader(bits);
	    // type + hash + hash + depth + depth
	    const size = 8 + (2 * (256 + 16));
	    if (bits.length !== size) {
	        throw new Error(`Merkle Update cell must have exactly (8 + (2 * (256 + 16))) bits, got "${bits.length}"`);
	    }
	    if (refs.length !== 2) {
	        throw new Error(`Merkle Update cell must have exactly 2 refs, got "${refs.length}"`);
	    }
	    let type = reader.loadUint(8);
	    if (type !== 4) {
	        throw new Error(`Merkle Update cell type must be exactly 4, got "${type}"`);
	    }
	    const proofHash1 = reader.loadBuffer(32);
	    const proofHash2 = reader.loadBuffer(32);
	    const proofDepth1 = reader.loadUint(16);
	    const proofDepth2 = reader.loadUint(16);
	    if (proofDepth1 !== refs[0].depth(0)) {
	        throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth1}", got "${refs[0].depth(0)}"`);
	    }
	    if (!proofHash1.equals(refs[0].hash(0))) {
	        throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash1.toString('hex')}", got "${refs[0].hash(0).toString('hex')}"`);
	    }
	    if (proofDepth2 !== refs[1].depth(0)) {
	        throw new Error(`Merkle Update cell ref depth must be exactly "${proofDepth2}", got "${refs[1].depth(0)}"`);
	    }
	    if (!proofHash2.equals(refs[1].hash(0))) {
	        throw new Error(`Merkle Update cell ref hash must be exactly "${proofHash2.toString('hex')}", got "${refs[1].hash(0).toString('hex')}"`);
	    }
	    return {
	        proofDepth1,
	        proofDepth2,
	        proofHash1,
	        proofHash2
	    };
	}
	exoticMerkleUpdate.exoticMerkleUpdate = exoticMerkleUpdate$1;
	return exoticMerkleUpdate;
}

var exoticPruned = {};

var LevelMask = {};

var hasRequiredLevelMask;

function requireLevelMask () {
	if (hasRequiredLevelMask) return LevelMask;
	hasRequiredLevelMask = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(LevelMask, "__esModule", { value: true });
	LevelMask.LevelMask = void 0;
	let LevelMask$1 = class LevelMask {
	    constructor(mask = 0) {
	        this._mask = 0;
	        this._mask = mask;
	        this._hashIndex = countSetBits(this._mask);
	        this._hashCount = this._hashIndex + 1;
	    }
	    get value() {
	        return this._mask;
	    }
	    get level() {
	        return 32 - Math.clz32(this._mask);
	    }
	    get hashIndex() {
	        return this._hashIndex;
	    }
	    get hashCount() {
	        return this._hashCount;
	    }
	    apply(level) {
	        return new LevelMask(this._mask & ((1 << level) - 1));
	    }
	    isSignificant(level) {
	        let res = level === 0 || (this._mask >> (level - 1)) % 2 !== 0;
	        return res;
	        // bool res = level == 0 | | ( (mask_ >> (level -1)) % 2 != 0);
	    }
	};
	LevelMask.LevelMask = LevelMask$1;
	function countSetBits(n) {
	    n = n - ((n >> 1) & 0x55555555);
	    n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
	    return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;
	}
	return LevelMask;
}

var hasRequiredExoticPruned;

function requireExoticPruned () {
	if (hasRequiredExoticPruned) return exoticPruned;
	hasRequiredExoticPruned = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(exoticPruned, "__esModule", { value: true });
	exoticPruned.exoticPruned = void 0;
	const BitReader_1 = requireBitReader();
	const LevelMask_1 = requireLevelMask();
	function exoticPruned$1(bits, refs) {
	    let reader = new BitReader_1.BitReader(bits);
	    // Check type
	    let type = reader.loadUint(8);
	    if (type !== 1) {
	        throw new Error(`Pruned branch cell must have type 1, got "${type}"`);
	    }
	    // Check refs
	    if (refs.length !== 0) {
	        throw new Error(`Pruned Branch cell can't has refs, got "${refs.length}"`);
	    }
	    // Resolve cell
	    let mask;
	    if (bits.length === 280) {
	        // Special case for config proof
	        // This test proof is generated in the moment of voting for a slashing
	        // it seems that tools generate it incorrectly and therefore doesn't have mask in it
	        // so we need to hardcode it equal to 1
	        mask = new LevelMask_1.LevelMask(1);
	    }
	    else {
	        // Check level
	        mask = new LevelMask_1.LevelMask(reader.loadUint(8));
	        if (mask.level < 1 || mask.level > 3) {
	            throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got "${mask.level}/${mask.value}"`);
	        }
	        // Read pruned
	        const size = 8 + 8 + (mask.apply(mask.level - 1).hashCount * (256 /* Hash */ + 16 /* Depth */));
	        if (bits.length !== size) {
	            throw new Error(`Pruned branch cell must have exactly ${size} bits, got "${bits.length}"`);
	        }
	    }
	    // Read pruned
	    let pruned = [];
	    let hashes = [];
	    let depths = [];
	    for (let i = 0; i < mask.level; i++) {
	        hashes.push(reader.loadBuffer(32));
	    }
	    for (let i = 0; i < mask.level; i++) {
	        depths.push(reader.loadUint(16));
	    }
	    for (let i = 0; i < mask.level; i++) {
	        pruned.push({
	            depth: depths[i],
	            hash: hashes[i]
	        });
	    }
	    return {
	        mask: mask.value,
	        pruned
	    };
	}
	exoticPruned.exoticPruned = exoticPruned$1;
	return exoticPruned;
}

var hasRequiredResolveExotic;

function requireResolveExotic () {
	if (hasRequiredResolveExotic) return resolveExotic;
	hasRequiredResolveExotic = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(resolveExotic, "__esModule", { value: true });
	resolveExotic.resolveExotic = void 0;
	const BitReader_1 = requireBitReader();
	const CellType_1 = requireCellType();
	const exoticLibrary_1 = requireExoticLibrary();
	const exoticMerkleProof_1 = requireExoticMerkleProof();
	const exoticMerkleUpdate_1 = requireExoticMerkleUpdate();
	const exoticPruned_1 = requireExoticPruned();
	const LevelMask_1 = requireLevelMask();
	function resolvePruned(bits, refs) {
	    // Parse pruned cell
	    let pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
	    // Calculate parameters
	    let depths = [];
	    let hashes = [];
	    let mask = new LevelMask_1.LevelMask(pruned.mask);
	    for (let i = 0; i < pruned.pruned.length; i++) {
	        depths.push(pruned.pruned[i].depth);
	        hashes.push(pruned.pruned[i].hash);
	    }
	    return {
	        type: CellType_1.CellType.PrunedBranch,
	        depths,
	        hashes,
	        mask
	    };
	}
	function resolveLibrary(bits, refs) {
	    // Parse library cell
	    (0, exoticLibrary_1.exoticLibrary)(bits, refs);
	    // Calculate parameters
	    let depths = [];
	    let hashes = [];
	    let mask = new LevelMask_1.LevelMask();
	    return {
	        type: CellType_1.CellType.Library,
	        depths,
	        hashes,
	        mask
	    };
	}
	function resolveMerkleProof(bits, refs) {
	    // Parse merkle proof cell
	    (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
	    // Calculate parameters
	    let depths = [];
	    let hashes = [];
	    let mask = new LevelMask_1.LevelMask(refs[0].level() >> 1);
	    return {
	        type: CellType_1.CellType.MerkleProof,
	        depths,
	        hashes,
	        mask
	    };
	}
	function resolveMerkleUpdate(bits, refs) {
	    // Parse merkle proof cell
	    (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
	    // Calculate parameters
	    let depths = [];
	    let hashes = [];
	    let mask = new LevelMask_1.LevelMask((refs[0].level() | refs[1].level()) >> 1);
	    return {
	        type: CellType_1.CellType.MerkleUpdate,
	        depths,
	        hashes,
	        mask
	    };
	}
	function resolveExotic$1(bits, refs) {
	    let reader = new BitReader_1.BitReader(bits);
	    let type = reader.preloadUint(8);
	    if (type === 1) {
	        return resolvePruned(bits, refs);
	    }
	    if (type === 2) {
	        return resolveLibrary(bits, refs);
	    }
	    if (type === 3) {
	        return resolveMerkleProof(bits, refs);
	    }
	    if (type === 4) {
	        return resolveMerkleUpdate(bits, refs);
	    }
	    throw Error('Invalid exotic cell type: ' + type);
	}
	resolveExotic.resolveExotic = resolveExotic$1;
	return resolveExotic;
}

var wonderCalculator = {};

var descriptor = {};

var hasRequiredDescriptor;

function requireDescriptor () {
	if (hasRequiredDescriptor) return descriptor;
	hasRequiredDescriptor = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(descriptor, "__esModule", { value: true });
	descriptor.getRepr = descriptor.getBitsDescriptor = descriptor.getRefsDescriptor = void 0;
	const CellType_1 = requireCellType();
	const paddedBits_1 = requirePaddedBits();
	function getRefsDescriptor(refs, levelMask, type) {
	    return refs.length + (type !== CellType_1.CellType.Ordinary ? 1 : 0) * 8 + levelMask * 32;
	}
	descriptor.getRefsDescriptor = getRefsDescriptor;
	function getBitsDescriptor(bits) {
	    let len = bits.length;
	    return Math.ceil(len / 8) + Math.floor(len / 8);
	}
	descriptor.getBitsDescriptor = getBitsDescriptor;
	function getRepr(originalBits, bits, refs, level, levelMask, type) {
	    // Allocate
	    const bitsLen = Math.ceil(bits.length / 8);
	    const repr = Buffer.alloc(2 + bitsLen + (2 + 32) * refs.length);
	    // Write descriptors
	    let reprCursor = 0;
	    repr[reprCursor++] = getRefsDescriptor(refs, levelMask, type);
	    repr[reprCursor++] = getBitsDescriptor(originalBits);
	    // Write bits
	    (0, paddedBits_1.bitsToPaddedBuffer)(bits).copy(repr, reprCursor);
	    reprCursor += bitsLen;
	    // Write refs
	    for (const c of refs) {
	        let childDepth;
	        if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
	            childDepth = c.depth(level + 1);
	        }
	        else {
	            childDepth = c.depth(level);
	        }
	        repr[reprCursor++] = Math.floor(childDepth / 256);
	        repr[reprCursor++] = childDepth % 256;
	    }
	    for (const c of refs) {
	        let childHash;
	        if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
	            childHash = c.hash(level + 1);
	        }
	        else {
	            childHash = c.hash(level);
	        }
	        childHash.copy(repr, reprCursor);
	        reprCursor += 32;
	    }
	    // Result
	    return repr;
	}
	descriptor.getRepr = getRepr;
	return descriptor;
}

var dist$1 = {};

var sha256$1 = {};

var sha$1 = {exports: {}};

var sha = sha$1.exports;

var hasRequiredSha;

function requireSha () {
	if (hasRequiredSha) return sha$1.exports;
	hasRequiredSha = 1;
	(function (module, exports) {
		!(function(n, r) {
		  module.exports = r() ;
		})(sha, (function() {
		  var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		  function r(n2, r2, t2, e2) {
		    var i2, o2, u2, f2 = r2 || [0], w2 = (t2 = t2 || 0) >>> 3, s2 = -1 === e2 ? 3 : 0;
		    for (i2 = 0; i2 < n2.length; i2 += 1) o2 = (u2 = i2 + w2) >>> 2, f2.length <= o2 && f2.push(0), f2[o2] |= n2[i2] << 8 * (s2 + e2 * (u2 % 4));
		    return { value: f2, binLen: 8 * n2.length + t2 };
		  }
		  function t(t2, e2, i2) {
		    switch (e2) {
		      case "UTF8":
		      case "UTF16BE":
		      case "UTF16LE":
		        break;
		      default:
		        throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE");
		    }
		    switch (t2) {
		      case "HEX":
		        return function(n2, r2, t3) {
		          return (function(n3, r3, t4, e3) {
		            var i3, o2, u2, f2;
		            if (0 != n3.length % 2) throw new Error("String of HEX type must be in byte increments");
		            var w2 = r3 || [0], s2 = (t4 = t4 || 0) >>> 3, a2 = -1 === e3 ? 3 : 0;
		            for (i3 = 0; i3 < n3.length; i3 += 2) {
		              if (o2 = parseInt(n3.substr(i3, 2), 16), isNaN(o2)) throw new Error("String of HEX type contains invalid characters");
		              for (u2 = (f2 = (i3 >>> 1) + s2) >>> 2; w2.length <= u2; ) w2.push(0);
		              w2[u2] |= o2 << 8 * (a2 + e3 * (f2 % 4));
		            }
		            return { value: w2, binLen: 4 * n3.length + t4 };
		          })(n2, r2, t3, i2);
		        };
		      case "TEXT":
		        return function(n2, r2, t3) {
		          return (function(n3, r3, t4, e3, i3) {
		            var o2, u2, f2, w2, s2, a2, h2, c2, v2 = 0, A2 = t4 || [0], E2 = (e3 = e3 || 0) >>> 3;
		            if ("UTF8" === r3) for (h2 = -1 === i3 ? 3 : 0, f2 = 0; f2 < n3.length; f2 += 1) for (u2 = [], 128 > (o2 = n3.charCodeAt(f2)) ? u2.push(o2) : 2048 > o2 ? (u2.push(192 | o2 >>> 6), u2.push(128 | 63 & o2)) : 55296 > o2 || 57344 <= o2 ? u2.push(224 | o2 >>> 12, 128 | o2 >>> 6 & 63, 128 | 63 & o2) : (f2 += 1, o2 = 65536 + ((1023 & o2) << 10 | 1023 & n3.charCodeAt(f2)), u2.push(240 | o2 >>> 18, 128 | o2 >>> 12 & 63, 128 | o2 >>> 6 & 63, 128 | 63 & o2)), w2 = 0; w2 < u2.length; w2 += 1) {
		              for (s2 = (a2 = v2 + E2) >>> 2; A2.length <= s2; ) A2.push(0);
		              A2[s2] |= u2[w2] << 8 * (h2 + i3 * (a2 % 4)), v2 += 1;
		            }
		            else for (h2 = -1 === i3 ? 2 : 0, c2 = "UTF16LE" === r3 && 1 !== i3 || "UTF16LE" !== r3 && 1 === i3, f2 = 0; f2 < n3.length; f2 += 1) {
		              for (o2 = n3.charCodeAt(f2), true === c2 && (o2 = (w2 = 255 & o2) << 8 | o2 >>> 8), s2 = (a2 = v2 + E2) >>> 2; A2.length <= s2; ) A2.push(0);
		              A2[s2] |= o2 << 8 * (h2 + i3 * (a2 % 4)), v2 += 2;
		            }
		            return { value: A2, binLen: 8 * v2 + e3 };
		          })(n2, e2, r2, t3, i2);
		        };
		      case "B64":
		        return function(r2, t3, e3) {
		          return (function(r3, t4, e4, i3) {
		            var o2, u2, f2, w2, s2, a2, h2 = 0, c2 = t4 || [0], v2 = (e4 = e4 || 0) >>> 3, A2 = -1 === i3 ? 3 : 0, E2 = r3.indexOf("=");
		            if (-1 === r3.search(/^[a-zA-Z0-9=+/]+$/)) throw new Error("Invalid character in base-64 string");
		            if (r3 = r3.replace(/=/g, ""), -1 !== E2 && E2 < r3.length) throw new Error("Invalid '=' found in base-64 string");
		            for (o2 = 0; o2 < r3.length; o2 += 4) {
		              for (w2 = r3.substr(o2, 4), f2 = 0, u2 = 0; u2 < w2.length; u2 += 1) f2 |= n.indexOf(w2.charAt(u2)) << 18 - 6 * u2;
		              for (u2 = 0; u2 < w2.length - 1; u2 += 1) {
		                for (s2 = (a2 = h2 + v2) >>> 2; c2.length <= s2; ) c2.push(0);
		                c2[s2] |= (f2 >>> 16 - 8 * u2 & 255) << 8 * (A2 + i3 * (a2 % 4)), h2 += 1;
		              }
		            }
		            return { value: c2, binLen: 8 * h2 + e4 };
		          })(r2, t3, e3, i2);
		        };
		      case "BYTES":
		        return function(n2, r2, t3) {
		          return (function(n3, r3, t4, e3) {
		            var i3, o2, u2, f2, w2 = r3 || [0], s2 = (t4 = t4 || 0) >>> 3, a2 = -1 === e3 ? 3 : 0;
		            for (o2 = 0; o2 < n3.length; o2 += 1) i3 = n3.charCodeAt(o2), u2 = (f2 = o2 + s2) >>> 2, w2.length <= u2 && w2.push(0), w2[u2] |= i3 << 8 * (a2 + e3 * (f2 % 4));
		            return { value: w2, binLen: 8 * n3.length + t4 };
		          })(n2, r2, t3, i2);
		        };
		      case "ARRAYBUFFER":
		        try {
		          new ArrayBuffer(0);
		        } catch (n2) {
		          throw new Error("ARRAYBUFFER not supported by this environment");
		        }
		        return function(n2, t3, e3) {
		          return (function(n3, t4, e4, i3) {
		            return r(new Uint8Array(n3), t4, e4, i3);
		          })(n2, t3, e3, i2);
		        };
		      case "UINT8ARRAY":
		        try {
		          new Uint8Array(0);
		        } catch (n2) {
		          throw new Error("UINT8ARRAY not supported by this environment");
		        }
		        return function(n2, t3, e3) {
		          return r(n2, t3, e3, i2);
		        };
		      default:
		        throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
		    }
		  }
		  function e(r2, t2, e2, i2) {
		    switch (r2) {
		      case "HEX":
		        return function(n2) {
		          return (function(n3, r3, t3, e3) {
		            var i3, o2, u2 = "", f2 = r3 / 8, w2 = -1 === t3 ? 3 : 0;
		            for (i3 = 0; i3 < f2; i3 += 1) o2 = n3[i3 >>> 2] >>> 8 * (w2 + t3 * (i3 % 4)), u2 += "0123456789abcdef".charAt(o2 >>> 4 & 15) + "0123456789abcdef".charAt(15 & o2);
		            return e3.outputUpper ? u2.toUpperCase() : u2;
		          })(n2, t2, e2, i2);
		        };
		      case "B64":
		        return function(r3) {
		          return (function(r4, t3, e3, i3) {
		            var o2, u2, f2, w2, s2, a2 = "", h2 = t3 / 8, c2 = -1 === e3 ? 3 : 0;
		            for (o2 = 0; o2 < h2; o2 += 3) for (w2 = o2 + 1 < h2 ? r4[o2 + 1 >>> 2] : 0, s2 = o2 + 2 < h2 ? r4[o2 + 2 >>> 2] : 0, f2 = (r4[o2 >>> 2] >>> 8 * (c2 + e3 * (o2 % 4)) & 255) << 16 | (w2 >>> 8 * (c2 + e3 * ((o2 + 1) % 4)) & 255) << 8 | s2 >>> 8 * (c2 + e3 * ((o2 + 2) % 4)) & 255, u2 = 0; u2 < 4; u2 += 1) a2 += 8 * o2 + 6 * u2 <= t3 ? n.charAt(f2 >>> 6 * (3 - u2) & 63) : i3.b64Pad;
		            return a2;
		          })(r3, t2, e2, i2);
		        };
		      case "BYTES":
		        return function(n2) {
		          return (function(n3, r3, t3) {
		            var e3, i3, o2 = "", u2 = r3 / 8, f2 = -1 === t3 ? 3 : 0;
		            for (e3 = 0; e3 < u2; e3 += 1) i3 = n3[e3 >>> 2] >>> 8 * (f2 + t3 * (e3 % 4)) & 255, o2 += String.fromCharCode(i3);
		            return o2;
		          })(n2, t2, e2);
		        };
		      case "ARRAYBUFFER":
		        try {
		          new ArrayBuffer(0);
		        } catch (n2) {
		          throw new Error("ARRAYBUFFER not supported by this environment");
		        }
		        return function(n2) {
		          return (function(n3, r3, t3) {
		            var e3, i3 = r3 / 8, o2 = new ArrayBuffer(i3), u2 = new Uint8Array(o2), f2 = -1 === t3 ? 3 : 0;
		            for (e3 = 0; e3 < i3; e3 += 1) u2[e3] = n3[e3 >>> 2] >>> 8 * (f2 + t3 * (e3 % 4)) & 255;
		            return o2;
		          })(n2, t2, e2);
		        };
		      case "UINT8ARRAY":
		        try {
		          new Uint8Array(0);
		        } catch (n2) {
		          throw new Error("UINT8ARRAY not supported by this environment");
		        }
		        return function(n2) {
		          return (function(n3, r3, t3) {
		            var e3, i3 = r3 / 8, o2 = -1 === t3 ? 3 : 0, u2 = new Uint8Array(i3);
		            for (e3 = 0; e3 < i3; e3 += 1) u2[e3] = n3[e3 >>> 2] >>> 8 * (o2 + t3 * (e3 % 4)) & 255;
		            return u2;
		          })(n2, t2, e2);
		        };
		      default:
		        throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY");
		    }
		  }
		  var i = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], o = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428], u = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], f = "Chosen SHA variant is not supported";
		  function w(n2, r2) {
		    var t2, e2, i2 = n2.binLen >>> 3, o2 = r2.binLen >>> 3, u2 = i2 << 3, f2 = 4 - i2 << 3;
		    if (i2 % 4 != 0) {
		      for (t2 = 0; t2 < o2; t2 += 4) e2 = i2 + t2 >>> 2, n2.value[e2] |= r2.value[t2 >>> 2] << u2, n2.value.push(0), n2.value[e2 + 1] |= r2.value[t2 >>> 2] >>> f2;
		      return (n2.value.length << 2) - 4 >= o2 + i2 && n2.value.pop(), { value: n2.value, binLen: n2.binLen + r2.binLen };
		    }
		    return { value: n2.value.concat(r2.value), binLen: n2.binLen + r2.binLen };
		  }
		  function s(n2) {
		    var r2 = { outputUpper: false, b64Pad: "=", outputLen: -1 }, t2 = n2 || {}, e2 = "Output length must be a multiple of 8";
		    if (r2.outputUpper = t2.outputUpper || false, t2.b64Pad && (r2.b64Pad = t2.b64Pad), t2.outputLen) {
		      if (t2.outputLen % 8 != 0) throw new Error(e2);
		      r2.outputLen = t2.outputLen;
		    } else if (t2.shakeLen) {
		      if (t2.shakeLen % 8 != 0) throw new Error(e2);
		      r2.outputLen = t2.shakeLen;
		    }
		    if ("boolean" != typeof r2.outputUpper) throw new Error("Invalid outputUpper formatting option");
		    if ("string" != typeof r2.b64Pad) throw new Error("Invalid b64Pad formatting option");
		    return r2;
		  }
		  function a(n2, r2, e2, i2) {
		    var o2 = n2 + " must include a value and format";
		    if (!r2) {
		      if (!i2) throw new Error(o2);
		      return i2;
		    }
		    if (void 0 === r2.value || !r2.format) throw new Error(o2);
		    return t(r2.format, r2.encoding || "UTF8", e2)(r2.value);
		  }
		  var h = (function() {
		    function n2(n3, r2, t2) {
		      var e2 = t2 || {};
		      if (this.t = r2, this.i = e2.encoding || "UTF8", this.numRounds = e2.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds) throw new Error("numRounds must a integer >= 1");
		      this.o = n3, this.u = [], this.s = 0, this.h = false, this.v = 0, this.A = false, this.l = [], this.H = [];
		    }
		    return n2.prototype.update = function(n3) {
		      var r2, t2 = 0, e2 = this.S >>> 5, i2 = this.p(n3, this.u, this.s), o2 = i2.binLen, u2 = i2.value, f2 = o2 >>> 5;
		      for (r2 = 0; r2 < f2; r2 += e2) t2 + this.S <= o2 && (this.m = this.R(u2.slice(r2, r2 + e2), this.m), t2 += this.S);
		      this.v += t2, this.u = u2.slice(t2 >>> 5), this.s = o2 % this.S, this.h = true;
		    }, n2.prototype.getHash = function(n3, r2) {
		      var t2, i2, o2 = this.U, u2 = s(r2);
		      if (this.T) {
		        if (-1 === u2.outputLen) throw new Error("Output length must be specified in options");
		        o2 = u2.outputLen;
		      }
		      var f2 = e(n3, o2, this.C, u2);
		      if (this.A && this.F) return f2(this.F(u2));
		      for (i2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), o2), t2 = 1; t2 < this.numRounds; t2 += 1) this.T && o2 % 32 != 0 && (i2[i2.length - 1] &= 16777215 >>> 24 - o2 % 32), i2 = this.K(i2, o2, 0, this.L(this.o), o2);
		      return f2(i2);
		    }, n2.prototype.setHMACKey = function(n3, r2, e2) {
		      if (!this.g) throw new Error("Variant does not support HMAC");
		      if (this.h) throw new Error("Cannot set MAC key after calling update");
		      var i2 = t(r2, (e2 || {}).encoding || "UTF8", this.C);
		      this.k(i2(n3));
		    }, n2.prototype.k = function(n3) {
		      var r2, t2 = this.S >>> 3, e2 = t2 / 4 - 1;
		      if (1 !== this.numRounds) throw new Error("Cannot set numRounds with MAC");
		      if (this.A) throw new Error("MAC key already set");
		      for (t2 < n3.binLen / 8 && (n3.value = this.K(n3.value, n3.binLen, 0, this.L(this.o), this.U)); n3.value.length <= e2; ) n3.value.push(0);
		      for (r2 = 0; r2 <= e2; r2 += 1) this.l[r2] = 909522486 ^ n3.value[r2], this.H[r2] = 1549556828 ^ n3.value[r2];
		      this.m = this.R(this.l, this.m), this.v = this.S, this.A = true;
		    }, n2.prototype.getHMAC = function(n3, r2) {
		      var t2 = s(r2);
		      return e(n3, this.U, this.C, t2)(this.Y());
		    }, n2.prototype.Y = function() {
		      var n3;
		      if (!this.A) throw new Error("Cannot call getHMAC without first setting MAC key");
		      var r2 = this.K(this.u.slice(), this.s, this.v, this.B(this.m), this.U);
		      return n3 = this.R(this.H, this.L(this.o)), n3 = this.K(r2, this.U, this.S, n3, this.U);
		    }, n2;
		  })(), c = function(n2, r2) {
		    return (c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n3, r3) {
		      n3.__proto__ = r3;
		    } || function(n3, r3) {
		      for (var t2 in r3) Object.prototype.hasOwnProperty.call(r3, t2) && (n3[t2] = r3[t2]);
		    })(n2, r2);
		  };
		  function v(n2, r2) {
		    function t2() {
		      this.constructor = n2;
		    }
		    c(n2, r2), n2.prototype = null === r2 ? Object.create(r2) : (t2.prototype = r2.prototype, new t2());
		  }
		  function A(n2, r2) {
		    return n2 << r2 | n2 >>> 32 - r2;
		  }
		  function E(n2, r2) {
		    return n2 >>> r2 | n2 << 32 - r2;
		  }
		  function l(n2, r2) {
		    return n2 >>> r2;
		  }
		  function b(n2, r2, t2) {
		    return n2 ^ r2 ^ t2;
		  }
		  function H(n2, r2, t2) {
		    return n2 & r2 ^ ~n2 & t2;
		  }
		  function d(n2, r2, t2) {
		    return n2 & r2 ^ n2 & t2 ^ r2 & t2;
		  }
		  function S(n2) {
		    return E(n2, 2) ^ E(n2, 13) ^ E(n2, 22);
		  }
		  function p(n2, r2) {
		    var t2 = (65535 & n2) + (65535 & r2);
		    return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16)) << 16 | 65535 & t2;
		  }
		  function m(n2, r2, t2, e2) {
		    var i2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2);
		    return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16)) << 16 | 65535 & i2;
		  }
		  function y(n2, r2, t2, e2, i2) {
		    var o2 = (65535 & n2) + (65535 & r2) + (65535 & t2) + (65535 & e2) + (65535 & i2);
		    return (65535 & (n2 >>> 16) + (r2 >>> 16) + (t2 >>> 16) + (e2 >>> 16) + (i2 >>> 16) + (o2 >>> 16)) << 16 | 65535 & o2;
		  }
		  function R(n2) {
		    return E(n2, 7) ^ E(n2, 18) ^ l(n2, 3);
		  }
		  function U(n2) {
		    return E(n2, 6) ^ E(n2, 11) ^ E(n2, 25);
		  }
		  function T(n2) {
		    return [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
		  }
		  function C(n2, r2) {
		    var t2, e2, i2, o2, u2, f2, w2, s2 = [];
		    for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], w2 = 0; w2 < 80; w2 += 1) s2[w2] = w2 < 16 ? n2[w2] : A(s2[w2 - 3] ^ s2[w2 - 8] ^ s2[w2 - 14] ^ s2[w2 - 16], 1), f2 = w2 < 20 ? y(A(t2, 5), H(e2, i2, o2), u2, 1518500249, s2[w2]) : w2 < 40 ? y(A(t2, 5), b(e2, i2, o2), u2, 1859775393, s2[w2]) : w2 < 60 ? y(A(t2, 5), d(e2, i2, o2), u2, 2400959708, s2[w2]) : y(A(t2, 5), b(e2, i2, o2), u2, 3395469782, s2[w2]), u2 = o2, o2 = i2, i2 = A(e2, 30), e2 = t2, t2 = f2;
		    return r2[0] = p(t2, r2[0]), r2[1] = p(e2, r2[1]), r2[2] = p(i2, r2[2]), r2[3] = p(o2, r2[3]), r2[4] = p(u2, r2[4]), r2;
		  }
		  function F(n2, r2, t2, e2) {
		    for (var i2, o2 = 15 + (r2 + 65 >>> 9 << 4), u2 = r2 + t2; n2.length <= o2; ) n2.push(0);
		    for (n2[r2 >>> 5] |= 128 << 24 - r2 % 32, n2[o2] = 4294967295 & u2, n2[o2 - 1] = u2 / 4294967296 | 0, i2 = 0; i2 < n2.length; i2 += 16) e2 = C(n2.slice(i2, i2 + 16), e2);
		    return e2;
		  }
		  var K = (function(n2) {
		    function r2(r3, e2, i2) {
		      var o2 = this;
		      if ("SHA-1" !== r3) throw new Error(f);
		      var u2 = i2 || {};
		      return (o2 = n2.call(this, r3, e2, i2) || this).g = true, o2.F = o2.Y, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = C, o2.B = function(n3) {
		        return n3.slice();
		      }, o2.L = T, o2.K = F, o2.m = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], o2.S = 512, o2.U = 160, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
		    }
		    return v(r2, n2), r2;
		  })(h);
		  function B(n2) {
		    return "SHA-224" == n2 ? o.slice() : u.slice();
		  }
		  function L(n2, r2) {
		    var t2, e2, o2, u2, f2, w2, s2, a2, h2, c2, v2, A2, b2 = [];
		    for (t2 = r2[0], e2 = r2[1], o2 = r2[2], u2 = r2[3], f2 = r2[4], w2 = r2[5], s2 = r2[6], a2 = r2[7], v2 = 0; v2 < 64; v2 += 1) b2[v2] = v2 < 16 ? n2[v2] : m(E(A2 = b2[v2 - 2], 17) ^ E(A2, 19) ^ l(A2, 10), b2[v2 - 7], R(b2[v2 - 15]), b2[v2 - 16]), h2 = y(a2, U(f2), H(f2, w2, s2), i[v2], b2[v2]), c2 = p(S(t2), d(t2, e2, o2)), a2 = s2, s2 = w2, w2 = f2, f2 = p(u2, h2), u2 = o2, o2 = e2, e2 = t2, t2 = p(h2, c2);
		    return r2[0] = p(t2, r2[0]), r2[1] = p(e2, r2[1]), r2[2] = p(o2, r2[2]), r2[3] = p(u2, r2[3]), r2[4] = p(f2, r2[4]), r2[5] = p(w2, r2[5]), r2[6] = p(s2, r2[6]), r2[7] = p(a2, r2[7]), r2;
		  }
		  var g = (function(n2) {
		    function r2(r3, e2, i2) {
		      var o2 = this;
		      if ("SHA-224" !== r3 && "SHA-256" !== r3) throw new Error(f);
		      var u2 = i2 || {};
		      return (o2 = n2.call(this, r3, e2, i2) || this).F = o2.Y, o2.g = true, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = L, o2.B = function(n3) {
		        return n3.slice();
		      }, o2.L = B, o2.K = function(n3, t2, e3, i3) {
		        return (function(n4, r4, t3, e4, i4) {
		          for (var o3, u3 = 15 + (r4 + 65 >>> 9 << 4), f2 = r4 + t3; n4.length <= u3; ) n4.push(0);
		          for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f2, n4[u3 - 1] = f2 / 4294967296 | 0, o3 = 0; o3 < n4.length; o3 += 16) e4 = L(n4.slice(o3, o3 + 16), e4);
		          return "SHA-224" === i4 ? [e4[0], e4[1], e4[2], e4[3], e4[4], e4[5], e4[6]] : e4;
		        })(n3, t2, e3, i3, r3);
		      }, o2.m = B(r3), o2.S = 512, o2.U = "SHA-224" === r3 ? 224 : 256, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
		    }
		    return v(r2, n2), r2;
		  })(h), k = function(n2, r2) {
		    this.N = n2, this.I = r2;
		  };
		  function Y(n2, r2) {
		    var t2;
		    return r2 > 32 ? (t2 = 64 - r2, new k(n2.I << r2 | n2.N >>> t2, n2.N << r2 | n2.I >>> t2)) : 0 !== r2 ? (t2 = 32 - r2, new k(n2.N << r2 | n2.I >>> t2, n2.I << r2 | n2.N >>> t2)) : n2;
		  }
		  function N(n2, r2) {
		    var t2;
		    return r2 < 32 ? (t2 = 32 - r2, new k(n2.N >>> r2 | n2.I << t2, n2.I >>> r2 | n2.N << t2)) : (t2 = 64 - r2, new k(n2.I >>> r2 | n2.N << t2, n2.N >>> r2 | n2.I << t2));
		  }
		  function I(n2, r2) {
		    return new k(n2.N >>> r2, n2.I >>> r2 | n2.N << 32 - r2);
		  }
		  function M(n2, r2, t2) {
		    return new k(n2.N & r2.N ^ ~n2.N & t2.N, n2.I & r2.I ^ ~n2.I & t2.I);
		  }
		  function X(n2, r2, t2) {
		    return new k(n2.N & r2.N ^ n2.N & t2.N ^ r2.N & t2.N, n2.I & r2.I ^ n2.I & t2.I ^ r2.I & t2.I);
		  }
		  function z(n2) {
		    var r2 = N(n2, 28), t2 = N(n2, 34), e2 = N(n2, 39);
		    return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
		  }
		  function O(n2, r2) {
		    var t2, e2;
		    t2 = (65535 & n2.I) + (65535 & r2.I);
		    var i2 = (65535 & (e2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2 >>> 16))) << 16 | 65535 & t2;
		    return t2 = (65535 & n2.N) + (65535 & r2.N) + (e2 >>> 16), e2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2 >>> 16), new k((65535 & e2) << 16 | 65535 & t2, i2);
		  }
		  function j(n2, r2, t2, e2) {
		    var i2, o2;
		    i2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I);
		    var u2 = (65535 & (o2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2 >>> 16))) << 16 | 65535 & i2;
		    return i2 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (o2 >>> 16), o2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2 >>> 16), new k((65535 & o2) << 16 | 65535 & i2, u2);
		  }
		  function _(n2, r2, t2, e2, i2) {
		    var o2, u2;
		    o2 = (65535 & n2.I) + (65535 & r2.I) + (65535 & t2.I) + (65535 & e2.I) + (65535 & i2.I);
		    var f2 = (65535 & (u2 = (n2.I >>> 16) + (r2.I >>> 16) + (t2.I >>> 16) + (e2.I >>> 16) + (i2.I >>> 16) + (o2 >>> 16))) << 16 | 65535 & o2;
		    return o2 = (65535 & n2.N) + (65535 & r2.N) + (65535 & t2.N) + (65535 & e2.N) + (65535 & i2.N) + (u2 >>> 16), u2 = (n2.N >>> 16) + (r2.N >>> 16) + (t2.N >>> 16) + (e2.N >>> 16) + (i2.N >>> 16) + (o2 >>> 16), new k((65535 & u2) << 16 | 65535 & o2, f2);
		  }
		  function P(n2, r2) {
		    return new k(n2.N ^ r2.N, n2.I ^ r2.I);
		  }
		  function x(n2) {
		    var r2 = N(n2, 1), t2 = N(n2, 8), e2 = I(n2, 7);
		    return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
		  }
		  function V(n2) {
		    var r2 = N(n2, 14), t2 = N(n2, 18), e2 = N(n2, 41);
		    return new k(r2.N ^ t2.N ^ e2.N, r2.I ^ t2.I ^ e2.I);
		  }
		  var Z = [new k(i[0], 3609767458), new k(i[1], 602891725), new k(i[2], 3964484399), new k(i[3], 2173295548), new k(i[4], 4081628472), new k(i[5], 3053834265), new k(i[6], 2937671579), new k(i[7], 3664609560), new k(i[8], 2734883394), new k(i[9], 1164996542), new k(i[10], 1323610764), new k(i[11], 3590304994), new k(i[12], 4068182383), new k(i[13], 991336113), new k(i[14], 633803317), new k(i[15], 3479774868), new k(i[16], 2666613458), new k(i[17], 944711139), new k(i[18], 2341262773), new k(i[19], 2007800933), new k(i[20], 1495990901), new k(i[21], 1856431235), new k(i[22], 3175218132), new k(i[23], 2198950837), new k(i[24], 3999719339), new k(i[25], 766784016), new k(i[26], 2566594879), new k(i[27], 3203337956), new k(i[28], 1034457026), new k(i[29], 2466948901), new k(i[30], 3758326383), new k(i[31], 168717936), new k(i[32], 1188179964), new k(i[33], 1546045734), new k(i[34], 1522805485), new k(i[35], 2643833823), new k(i[36], 2343527390), new k(i[37], 1014477480), new k(i[38], 1206759142), new k(i[39], 344077627), new k(i[40], 1290863460), new k(i[41], 3158454273), new k(i[42], 3505952657), new k(i[43], 106217008), new k(i[44], 3606008344), new k(i[45], 1432725776), new k(i[46], 1467031594), new k(i[47], 851169720), new k(i[48], 3100823752), new k(i[49], 1363258195), new k(i[50], 3750685593), new k(i[51], 3785050280), new k(i[52], 3318307427), new k(i[53], 3812723403), new k(i[54], 2003034995), new k(i[55], 3602036899), new k(i[56], 1575990012), new k(i[57], 1125592928), new k(i[58], 2716904306), new k(i[59], 442776044), new k(i[60], 593698344), new k(i[61], 3733110249), new k(i[62], 2999351573), new k(i[63], 3815920427), new k(3391569614, 3928383900), new k(3515267271, 566280711), new k(3940187606, 3454069534), new k(4118630271, 4000239992), new k(116418474, 1914138554), new k(174292421, 2731055270), new k(289380356, 3203993006), new k(460393269, 320620315), new k(685471733, 587496836), new k(852142971, 1086792851), new k(1017036298, 365543100), new k(1126000580, 2618297676), new k(1288033470, 3409855158), new k(1501505948, 4234509866), new k(1607167915, 987167468), new k(1816402316, 1246189591)];
		  function q(n2) {
		    return "SHA-384" === n2 ? [new k(3418070365, o[0]), new k(1654270250, o[1]), new k(2438529370, o[2]), new k(355462360, o[3]), new k(1731405415, o[4]), new k(41048885895, o[5]), new k(3675008525, o[6]), new k(1203062813, o[7])] : [new k(u[0], 4089235720), new k(u[1], 2227873595), new k(u[2], 4271175723), new k(u[3], 1595750129), new k(u[4], 2917565137), new k(u[5], 725511199), new k(u[6], 4215389547), new k(u[7], 327033209)];
		  }
		  function D(n2, r2) {
		    var t2, e2, i2, o2, u2, f2, w2, s2, a2, h2, c2, v2, A2, E2, l2, b2, H2 = [];
		    for (t2 = r2[0], e2 = r2[1], i2 = r2[2], o2 = r2[3], u2 = r2[4], f2 = r2[5], w2 = r2[6], s2 = r2[7], c2 = 0; c2 < 80; c2 += 1) c2 < 16 ? (v2 = 2 * c2, H2[c2] = new k(n2[v2], n2[v2 + 1])) : H2[c2] = j((A2 = H2[c2 - 2], E2 = void 0, l2 = void 0, b2 = void 0, E2 = N(A2, 19), l2 = N(A2, 61), b2 = I(A2, 6), new k(E2.N ^ l2.N ^ b2.N, E2.I ^ l2.I ^ b2.I)), H2[c2 - 7], x(H2[c2 - 15]), H2[c2 - 16]), a2 = _(s2, V(u2), M(u2, f2, w2), Z[c2], H2[c2]), h2 = O(z(t2), X(t2, e2, i2)), s2 = w2, w2 = f2, f2 = u2, u2 = O(o2, a2), o2 = i2, i2 = e2, e2 = t2, t2 = O(a2, h2);
		    return r2[0] = O(t2, r2[0]), r2[1] = O(e2, r2[1]), r2[2] = O(i2, r2[2]), r2[3] = O(o2, r2[3]), r2[4] = O(u2, r2[4]), r2[5] = O(f2, r2[5]), r2[6] = O(w2, r2[6]), r2[7] = O(s2, r2[7]), r2;
		  }
		  var G = (function(n2) {
		    function r2(r3, e2, i2) {
		      var o2 = this;
		      if ("SHA-384" !== r3 && "SHA-512" !== r3) throw new Error(f);
		      var u2 = i2 || {};
		      return (o2 = n2.call(this, r3, e2, i2) || this).F = o2.Y, o2.g = true, o2.C = -1, o2.p = t(o2.t, o2.i, o2.C), o2.R = D, o2.B = function(n3) {
		        return n3.slice();
		      }, o2.L = q, o2.K = function(n3, t2, e3, i3) {
		        return (function(n4, r4, t3, e4, i4) {
		          for (var o3, u3 = 31 + (r4 + 129 >>> 10 << 5), f2 = r4 + t3; n4.length <= u3; ) n4.push(0);
		          for (n4[r4 >>> 5] |= 128 << 24 - r4 % 32, n4[u3] = 4294967295 & f2, n4[u3 - 1] = f2 / 4294967296 | 0, o3 = 0; o3 < n4.length; o3 += 32) e4 = D(n4.slice(o3, o3 + 32), e4);
		          return "SHA-384" === i4 ? [(e4 = e4)[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I] : [e4[0].N, e4[0].I, e4[1].N, e4[1].I, e4[2].N, e4[2].I, e4[3].N, e4[3].I, e4[4].N, e4[4].I, e4[5].N, e4[5].I, e4[6].N, e4[6].I, e4[7].N, e4[7].I];
		        })(n3, t2, e3, i3, r3);
		      }, o2.m = q(r3), o2.S = 1024, o2.U = "SHA-384" === r3 ? 384 : 512, o2.T = false, u2.hmacKey && o2.k(a("hmacKey", u2.hmacKey, o2.C)), o2;
		    }
		    return v(r2, n2), r2;
		  })(h), J = [new k(0, 1), new k(0, 32898), new k(2147483648, 32906), new k(2147483648, 2147516416), new k(0, 32907), new k(0, 2147483649), new k(2147483648, 2147516545), new k(2147483648, 32777), new k(0, 138), new k(0, 136), new k(0, 2147516425), new k(0, 2147483658), new k(0, 2147516555), new k(2147483648, 139), new k(2147483648, 32905), new k(2147483648, 32771), new k(2147483648, 32770), new k(2147483648, 128), new k(0, 32778), new k(2147483648, 2147483658), new k(2147483648, 2147516545), new k(2147483648, 32896), new k(0, 2147483649), new k(2147483648, 2147516424)], Q = [[0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61], [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]];
		  function W(n2) {
		    var r2, t2 = [];
		    for (r2 = 0; r2 < 5; r2 += 1) t2[r2] = [new k(0, 0), new k(0, 0), new k(0, 0), new k(0, 0), new k(0, 0)];
		    return t2;
		  }
		  function $(n2) {
		    var r2, t2 = [];
		    for (r2 = 0; r2 < 5; r2 += 1) t2[r2] = n2[r2].slice();
		    return t2;
		  }
		  function nn(n2, r2) {
		    var t2, e2, i2, o2, u2, f2, w2, s2, a2, h2 = [], c2 = [];
		    if (null !== n2) for (e2 = 0; e2 < n2.length; e2 += 2) r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0] = P(r2[(e2 >>> 1) % 5][(e2 >>> 1) / 5 | 0], new k(n2[e2 + 1], n2[e2]));
		    for (t2 = 0; t2 < 24; t2 += 1) {
		      for (o2 = W(), e2 = 0; e2 < 5; e2 += 1) h2[e2] = (u2 = r2[e2][0], f2 = r2[e2][1], w2 = r2[e2][2], s2 = r2[e2][3], a2 = r2[e2][4], new k(u2.N ^ f2.N ^ w2.N ^ s2.N ^ a2.N, u2.I ^ f2.I ^ w2.I ^ s2.I ^ a2.I));
		      for (e2 = 0; e2 < 5; e2 += 1) c2[e2] = P(h2[(e2 + 4) % 5], Y(h2[(e2 + 1) % 5], 1));
		      for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) r2[e2][i2] = P(r2[e2][i2], c2[e2]);
		      for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) o2[i2][(2 * e2 + 3 * i2) % 5] = Y(r2[e2][i2], Q[e2][i2]);
		      for (e2 = 0; e2 < 5; e2 += 1) for (i2 = 0; i2 < 5; i2 += 1) r2[e2][i2] = P(o2[e2][i2], new k(~o2[(e2 + 1) % 5][i2].N & o2[(e2 + 2) % 5][i2].N, ~o2[(e2 + 1) % 5][i2].I & o2[(e2 + 2) % 5][i2].I));
		      r2[0][0] = P(r2[0][0], J[t2]);
		    }
		    return r2;
		  }
		  function rn(n2) {
		    var r2, t2, e2 = 0, i2 = [0, 0], o2 = [4294967295 & n2, n2 / 4294967296 & 2097151];
		    for (r2 = 6; r2 >= 0; r2--) 0 === (t2 = o2[r2 >> 2] >>> 8 * r2 & 255) && 0 === e2 || (i2[e2 + 1 >> 2] |= t2 << 8 * (e2 + 1), e2 += 1);
		    return e2 = 0 !== e2 ? e2 : 1, i2[0] |= e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
		  }
		  function tn(n2) {
		    return w(rn(n2.binLen), n2);
		  }
		  function en(n2, r2) {
		    var t2, e2 = rn(r2), i2 = r2 >>> 2, o2 = (i2 - (e2 = w(e2, n2)).value.length % i2) % i2;
		    for (t2 = 0; t2 < o2; t2++) e2.value.push(0);
		    return e2.value;
		  }
		  var on = (function(n2) {
		    function r2(r3, e2, i2) {
		      var o2 = this, u2 = 6, w2 = 0, s2 = i2 || {};
		      if (1 !== (o2 = n2.call(this, r3, e2, i2) || this).numRounds) {
		        if (s2.kmacKey || s2.hmacKey) throw new Error("Cannot set numRounds with MAC");
		        if ("CSHAKE128" === o2.o || "CSHAKE256" === o2.o) throw new Error("Cannot set numRounds for CSHAKE variants");
		      }
		      switch (o2.C = 1, o2.p = t(o2.t, o2.i, o2.C), o2.R = nn, o2.B = $, o2.L = W, o2.m = W(), o2.T = false, r3) {
		        case "SHA3-224":
		          o2.S = w2 = 1152, o2.U = 224, o2.g = true, o2.F = o2.Y;
		          break;
		        case "SHA3-256":
		          o2.S = w2 = 1088, o2.U = 256, o2.g = true, o2.F = o2.Y;
		          break;
		        case "SHA3-384":
		          o2.S = w2 = 832, o2.U = 384, o2.g = true, o2.F = o2.Y;
		          break;
		        case "SHA3-512":
		          o2.S = w2 = 576, o2.U = 512, o2.g = true, o2.F = o2.Y;
		          break;
		        case "SHAKE128":
		          u2 = 31, o2.S = w2 = 1344, o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
		          break;
		        case "SHAKE256":
		          u2 = 31, o2.S = w2 = 1088, o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
		          break;
		        case "KMAC128":
		          u2 = 4, o2.S = w2 = 1344, o2.M(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = o2.X;
		          break;
		        case "KMAC256":
		          u2 = 4, o2.S = w2 = 1088, o2.M(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = o2.X;
		          break;
		        case "CSHAKE128":
		          o2.S = w2 = 1344, u2 = o2.O(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
		          break;
		        case "CSHAKE256":
		          o2.S = w2 = 1088, u2 = o2.O(i2), o2.U = -1, o2.T = true, o2.g = false, o2.F = null;
		          break;
		        default:
		          throw new Error(f);
		      }
		      return o2.K = function(n3, r4, t2, e3, i3) {
		        return (function(n4, r5, t3, e4, i4, o3, u3) {
		          var f2, w3, s3 = 0, a2 = [], h2 = i4 >>> 5, c2 = r5 >>> 5;
		          for (f2 = 0; f2 < c2 && r5 >= i4; f2 += h2) e4 = nn(n4.slice(f2, f2 + h2), e4), r5 -= i4;
		          for (n4 = n4.slice(f2), r5 %= i4; n4.length < h2; ) n4.push(0);
		          for (n4[(f2 = r5 >>> 3) >> 2] ^= o3 << f2 % 4 * 8, n4[h2 - 1] ^= 2147483648, e4 = nn(n4, e4); 32 * a2.length < u3 && (w3 = e4[s3 % 5][s3 / 5 | 0], a2.push(w3.I), !(32 * a2.length >= u3)); ) a2.push(w3.N), 0 == 64 * (s3 += 1) % i4 && (nn(null, e4), s3 = 0);
		          return a2;
		        })(n3, r4, 0, e3, w2, u2, i3);
		      }, s2.hmacKey && o2.k(a("hmacKey", s2.hmacKey, o2.C)), o2;
		    }
		    return v(r2, n2), r2.prototype.O = function(n3, r3) {
		      var t2 = (function(n4) {
		        var r4 = n4 || {};
		        return { funcName: a("funcName", r4.funcName, 1, { value: [], binLen: 0 }), customization: a("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
		      })(n3 || {});
		      r3 && (t2.funcName = r3);
		      var e2 = w(tn(t2.funcName), tn(t2.customization));
		      if (0 !== t2.customization.binLen || 0 !== t2.funcName.binLen) {
		        for (var i2 = en(e2, this.S >>> 3), o2 = 0; o2 < i2.length; o2 += this.S >>> 5) this.m = this.R(i2.slice(o2, o2 + (this.S >>> 5)), this.m), this.v += this.S;
		        return 4;
		      }
		      return 31;
		    }, r2.prototype.M = function(n3) {
		      var r3 = (function(n4) {
		        var r4 = n4 || {};
		        return { kmacKey: a("kmacKey", r4.kmacKey, 1), funcName: { value: [1128353099], binLen: 32 }, customization: a("Customization", r4.customization, 1, { value: [], binLen: 0 }) };
		      })(n3 || {});
		      this.O(n3, r3.funcName);
		      for (var t2 = en(tn(r3.kmacKey), this.S >>> 3), e2 = 0; e2 < t2.length; e2 += this.S >>> 5) this.m = this.R(t2.slice(e2, e2 + (this.S >>> 5)), this.m), this.v += this.S;
		      this.A = true;
		    }, r2.prototype.X = function(n3) {
		      var r3 = w({ value: this.u.slice(), binLen: this.s }, (function(n4) {
		        var r4, t2, e2 = 0, i2 = [0, 0], o2 = [4294967295 & n4, n4 / 4294967296 & 2097151];
		        for (r4 = 6; r4 >= 0; r4--) 0 == (t2 = o2[r4 >> 2] >>> 8 * r4 & 255) && 0 === e2 || (i2[e2 >> 2] |= t2 << 8 * e2, e2 += 1);
		        return i2[(e2 = 0 !== e2 ? e2 : 1) >> 2] |= e2 << 8 * e2, { value: e2 + 1 > 4 ? i2 : [i2[0]], binLen: 8 + 8 * e2 };
		      })(n3.outputLen));
		      return this.K(r3.value, r3.binLen, this.v, this.B(this.m), n3.outputLen);
		    }, r2;
		  })(h);
		  return (function() {
		    function n2(n3, r2, t2) {
		      if ("SHA-1" == n3) this.j = new K(n3, r2, t2);
		      else if ("SHA-224" == n3 || "SHA-256" == n3) this.j = new g(n3, r2, t2);
		      else if ("SHA-384" == n3 || "SHA-512" == n3) this.j = new G(n3, r2, t2);
		      else {
		        if ("SHA3-224" != n3 && "SHA3-256" != n3 && "SHA3-384" != n3 && "SHA3-512" != n3 && "SHAKE128" != n3 && "SHAKE256" != n3 && "CSHAKE128" != n3 && "CSHAKE256" != n3 && "KMAC128" != n3 && "KMAC256" != n3) throw new Error(f);
		        this.j = new on(n3, r2, t2);
		      }
		    }
		    return n2.prototype.update = function(n3) {
		      this.j.update(n3);
		    }, n2.prototype.getHash = function(n3, r2) {
		      return this.j.getHash(n3, r2);
		    }, n2.prototype.setHMACKey = function(n3, r2, t2) {
		      this.j.setHMACKey(n3, r2, t2);
		    }, n2.prototype.getHMAC = function(n3, r2) {
		      return this.j.getHMAC(n3, r2);
		    }, n2;
		  })();
		})); 
	} (sha$1));
	return sha$1.exports;
}

var browser = {};

var getSecureRandom$1 = {};

var hasRequiredGetSecureRandom$1;

function requireGetSecureRandom$1 () {
	if (hasRequiredGetSecureRandom$1) return getSecureRandom$1;
	hasRequiredGetSecureRandom$1 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(getSecureRandom$1, "__esModule", { value: true });
	getSecureRandom$1.getSecureRandomWords = getSecureRandom$1.getSecureRandomBytes = void 0;
	function getSecureRandomBytes(size) {
	    return Buffer.from(window.crypto.getRandomValues(new Uint8Array(size)));
	}
	getSecureRandom$1.getSecureRandomBytes = getSecureRandomBytes;
	function getSecureRandomWords(size) {
	    return window.crypto.getRandomValues(new Uint16Array(size));
	}
	getSecureRandom$1.getSecureRandomWords = getSecureRandomWords;
	return getSecureRandom$1;
}

var hmac_sha512$1 = {};

var hasRequiredHmac_sha512$1;

function requireHmac_sha512$1 () {
	if (hasRequiredHmac_sha512$1) return hmac_sha512$1;
	hasRequiredHmac_sha512$1 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(hmac_sha512$1, "__esModule", { value: true });
	hmac_sha512$1.hmac_sha512 = void 0;
	async function hmac_sha512(key, data) {
	    let keyBuffer = typeof key === 'string' ? Buffer.from(key, 'utf-8') : key;
	    let dataBuffer = typeof data === 'string' ? Buffer.from(data, 'utf-8') : data;
	    const hmacAlgo = { name: "HMAC", hash: "SHA-512" };
	    const hmacKey = await window.crypto.subtle.importKey("raw", keyBuffer, hmacAlgo, false, ["sign"]);
	    return Buffer.from(await crypto.subtle.sign(hmacAlgo, hmacKey, dataBuffer));
	}
	hmac_sha512$1.hmac_sha512 = hmac_sha512;
	return hmac_sha512$1;
}

var pbkdf2_sha512$1 = {};

var hasRequiredPbkdf2_sha512$1;

function requirePbkdf2_sha512$1 () {
	if (hasRequiredPbkdf2_sha512$1) return pbkdf2_sha512$1;
	hasRequiredPbkdf2_sha512$1 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(pbkdf2_sha512$1, "__esModule", { value: true });
	pbkdf2_sha512$1.pbkdf2_sha512 = void 0;
	async function pbkdf2_sha512(key, salt, iterations, keyLen) {
	    const keyBuffer = typeof key === 'string' ? Buffer.from(key, 'utf-8') : key;
	    const saltBuffer = typeof salt === 'string' ? Buffer.from(salt, 'utf-8') : salt;
	    const pbkdf2_key = await window.crypto.subtle.importKey("raw", keyBuffer, { name: "PBKDF2" }, false, ["deriveBits"]);
	    const derivedBits = await window.crypto.subtle.deriveBits({ name: "PBKDF2", hash: "SHA-512", salt: saltBuffer, iterations: iterations }, pbkdf2_key, keyLen * 8);
	    return Buffer.from(derivedBits);
	}
	pbkdf2_sha512$1.pbkdf2_sha512 = pbkdf2_sha512;
	return pbkdf2_sha512$1;
}

var sha256 = {};

var hasRequiredSha256$1;

function requireSha256$1 () {
	if (hasRequiredSha256$1) return sha256;
	hasRequiredSha256$1 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(sha256, "__esModule", { value: true });
	sha256.sha256 = void 0;
	async function sha256$1(source) {
	    if (typeof source === 'string') {
	        return Buffer.from(await crypto.subtle.digest("SHA-256", Buffer.from(source, 'utf-8')));
	    }
	    return Buffer.from(await crypto.subtle.digest("SHA-256", source));
	}
	sha256.sha256 = sha256$1;
	return sha256;
}

var sha512$1 = {};

var hasRequiredSha512$1;

function requireSha512$1 () {
	if (hasRequiredSha512$1) return sha512$1;
	hasRequiredSha512$1 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(sha512$1, "__esModule", { value: true });
	sha512$1.sha512 = void 0;
	async function sha512(source) {
	    if (typeof source === 'string') {
	        return Buffer.from(await crypto.subtle.digest("SHA-512", Buffer.from(source, 'utf-8')));
	    }
	    return Buffer.from(await crypto.subtle.digest("SHA-512", source));
	}
	sha512$1.sha512 = sha512;
	return sha512$1;
}

var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return browser;
	hasRequiredBrowser = 1;
	(function (exports) {
		/**
		 * Copyright (c) Whales Corp.
		 * All Rights Reserved.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.sha512 = exports.sha256 = exports.pbkdf2_sha512 = exports.hmac_sha512 = exports.getSecureRandomWords = exports.getSecureRandomBytes = void 0;
		var getSecureRandom_1 = requireGetSecureRandom$1();
		Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function () { return getSecureRandom_1.getSecureRandomBytes; } });
		Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function () { return getSecureRandom_1.getSecureRandomWords; } });
		var hmac_sha512_1 = requireHmac_sha512$1();
		Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function () { return hmac_sha512_1.hmac_sha512; } });
		var pbkdf2_sha512_1 = requirePbkdf2_sha512$1();
		Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function () { return pbkdf2_sha512_1.pbkdf2_sha512; } });
		var sha256_1 = requireSha256$1();
		Object.defineProperty(exports, "sha256", { enumerable: true, get: function () { return sha256_1.sha256; } });
		var sha512_1 = requireSha512$1();
		Object.defineProperty(exports, "sha512", { enumerable: true, get: function () { return sha512_1.sha512; } }); 
	} (browser));
	return browser;
}

var hasRequiredSha256;

function requireSha256 () {
	if (hasRequiredSha256) return sha256$1;
	hasRequiredSha256 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var __importDefault = (sha256$1 && sha256$1.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(sha256$1, "__esModule", { value: true });
	sha256$1.sha256 = sha256$1.sha256_fallback = sha256$1.sha256_sync = void 0;
	const jssha_1 = __importDefault(requireSha());
	const crypto_primitives_1 = requireBrowser();
	function sha256_sync(source) {
	    let src;
	    if (typeof source === 'string') {
	        src = Buffer.from(source, 'utf-8').toString('hex');
	    }
	    else {
	        src = source.toString('hex');
	    }
	    let hasher = new jssha_1.default('SHA-256', 'HEX');
	    hasher.update(src);
	    let res = hasher.getHash('HEX');
	    return Buffer.from(res, 'hex');
	}
	sha256$1.sha256_sync = sha256_sync;
	async function sha256_fallback(source) {
	    return sha256_sync(source);
	}
	sha256$1.sha256_fallback = sha256_fallback;
	function sha256(source) {
	    return (0, crypto_primitives_1.sha256)(source);
	}
	sha256$1.sha256 = sha256;
	return sha256$1;
}

var sha512 = {};

var hasRequiredSha512;

function requireSha512 () {
	if (hasRequiredSha512) return sha512;
	hasRequiredSha512 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var __importDefault = (sha512 && sha512.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(sha512, "__esModule", { value: true });
	sha512.sha512 = sha512.sha512_fallback = sha512.sha512_sync = void 0;
	const jssha_1 = __importDefault(requireSha());
	const crypto_primitives_1 = requireBrowser();
	function sha512_sync(source) {
	    let src;
	    if (typeof source === 'string') {
	        src = Buffer.from(source, 'utf-8').toString('hex');
	    }
	    else {
	        src = source.toString('hex');
	    }
	    let hasher = new jssha_1.default('SHA-512', 'HEX');
	    hasher.update(src);
	    let res = hasher.getHash('HEX');
	    return Buffer.from(res, 'hex');
	}
	sha512.sha512_sync = sha512_sync;
	async function sha512_fallback(source) {
	    return sha512_sync(source);
	}
	sha512.sha512_fallback = sha512_fallback;
	async function sha512$1(source) {
	    return (0, crypto_primitives_1.sha512)(source);
	}
	sha512.sha512 = sha512$1;
	return sha512;
}

var pbkdf2_sha512 = {};

var hasRequiredPbkdf2_sha512;

function requirePbkdf2_sha512 () {
	if (hasRequiredPbkdf2_sha512) return pbkdf2_sha512;
	hasRequiredPbkdf2_sha512 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(pbkdf2_sha512, "__esModule", { value: true });
	pbkdf2_sha512.pbkdf2_sha512 = void 0;
	const crypto_primitives_1 = requireBrowser();
	function pbkdf2_sha512$1(key, salt, iterations, keyLen) {
	    return (0, crypto_primitives_1.pbkdf2_sha512)(key, salt, iterations, keyLen);
	}
	pbkdf2_sha512.pbkdf2_sha512 = pbkdf2_sha512$1;
	return pbkdf2_sha512;
}

var hmac_sha512 = {};

var hasRequiredHmac_sha512;

function requireHmac_sha512 () {
	if (hasRequiredHmac_sha512) return hmac_sha512;
	hasRequiredHmac_sha512 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var __importDefault = (hmac_sha512 && hmac_sha512.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(hmac_sha512, "__esModule", { value: true });
	hmac_sha512.hmac_sha512 = hmac_sha512.hmac_sha512_fallback = void 0;
	const jssha_1 = __importDefault(requireSha());
	const crypto_primitives_1 = requireBrowser();
	async function hmac_sha512_fallback(key, data) {
	    let keyBuffer = typeof key === 'string' ? Buffer.from(key, 'utf-8') : key;
	    let dataBuffer = typeof data === 'string' ? Buffer.from(data, 'utf-8') : data;
	    const shaObj = new jssha_1.default("SHA-512", "HEX", {
	        hmacKey: { value: keyBuffer.toString('hex'), format: "HEX" },
	    });
	    shaObj.update(dataBuffer.toString('hex'));
	    const hmac = shaObj.getHash("HEX");
	    return Buffer.from(hmac, 'hex');
	}
	hmac_sha512.hmac_sha512_fallback = hmac_sha512_fallback;
	function hmac_sha512$1(key, data) {
	    return (0, crypto_primitives_1.hmac_sha512)(key, data);
	}
	hmac_sha512.hmac_sha512 = hmac_sha512$1;
	return hmac_sha512;
}

var getSecureRandom = {};

var hasRequiredGetSecureRandom;

function requireGetSecureRandom () {
	if (hasRequiredGetSecureRandom) return getSecureRandom;
	hasRequiredGetSecureRandom = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(getSecureRandom, "__esModule", { value: true });
	getSecureRandom.getSecureRandomNumber = getSecureRandom.getSecureRandomWords = getSecureRandom.getSecureRandomBytes = void 0;
	const crypto_primitives_1 = requireBrowser();
	async function getSecureRandomBytes(size) {
	    return (0, crypto_primitives_1.getSecureRandomBytes)(size);
	}
	getSecureRandom.getSecureRandomBytes = getSecureRandomBytes;
	async function getSecureRandomWords(size) {
	    return getSecureRandomWords();
	}
	getSecureRandom.getSecureRandomWords = getSecureRandomWords;
	async function getSecureRandomNumber(min, max) {
	    let range = max - min;
	    var bitsNeeded = Math.ceil(Math.log2(range));
	    if (bitsNeeded > 53) {
	        throw new Error('Range is too large');
	    }
	    var bytesNeeded = Math.ceil(bitsNeeded / 8);
	    var mask = Math.pow(2, bitsNeeded) - 1;
	    while (true) {
	        let res = await getSecureRandomBytes(bitsNeeded);
	        let power = (bytesNeeded - 1) * 8;
	        let numberValue = 0;
	        for (var i = 0; i < bytesNeeded; i++) {
	            numberValue += res[i] * Math.pow(2, power);
	            power -= 8;
	        }
	        numberValue = numberValue & mask; // Truncate
	        if (numberValue >= range) {
	            continue;
	        }
	        return min + numberValue;
	    }
	}
	getSecureRandom.getSecureRandomNumber = getSecureRandomNumber;
	return getSecureRandom;
}

var newSecureWords = {};

var wordlist$1 = {};

var hasRequiredWordlist$1;

function requireWordlist$1 () {
	if (hasRequiredWordlist$1) return wordlist$1;
	hasRequiredWordlist$1 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(wordlist$1, "__esModule", { value: true });
	wordlist$1.wordlist = void 0;
	// Source https://www.eff.org/dice
	wordlist$1.wordlist = [
	    'abacus',
	    'abdomen',
	    'abdominal',
	    'abide',
	    'abiding',
	    'ability',
	    'ablaze',
	    'able',
	    'abnormal',
	    'abrasion',
	    'abrasive',
	    'abreast',
	    'abridge',
	    'abroad',
	    'abruptly',
	    'absence',
	    'absentee',
	    'absently',
	    'absinthe',
	    'absolute',
	    'absolve',
	    'abstain',
	    'abstract',
	    'absurd',
	    'accent',
	    'acclaim',
	    'acclimate',
	    'accompany',
	    'account',
	    'accuracy',
	    'accurate',
	    'accustom',
	    'acetone',
	    'achiness',
	    'aching',
	    'acid',
	    'acorn',
	    'acquaint',
	    'acquire',
	    'acre',
	    'acrobat',
	    'acronym',
	    'acting',
	    'action',
	    'activate',
	    'activator',
	    'active',
	    'activism',
	    'activist',
	    'activity',
	    'actress',
	    'acts',
	    'acutely',
	    'acuteness',
	    'aeration',
	    'aerobics',
	    'aerosol',
	    'aerospace',
	    'afar',
	    'affair',
	    'affected',
	    'affecting',
	    'affection',
	    'affidavit',
	    'affiliate',
	    'affirm',
	    'affix',
	    'afflicted',
	    'affluent',
	    'afford',
	    'affront',
	    'aflame',
	    'afloat',
	    'aflutter',
	    'afoot',
	    'afraid',
	    'afterglow',
	    'afterlife',
	    'aftermath',
	    'aftermost',
	    'afternoon',
	    'aged',
	    'ageless',
	    'agency',
	    'agenda',
	    'agent',
	    'aggregate',
	    'aghast',
	    'agile',
	    'agility',
	    'aging',
	    'agnostic',
	    'agonize',
	    'agonizing',
	    'agony',
	    'agreeable',
	    'agreeably',
	    'agreed',
	    'agreeing',
	    'agreement',
	    'aground',
	    'ahead',
	    'ahoy',
	    'aide',
	    'aids',
	    'aim',
	    'ajar',
	    'alabaster',
	    'alarm',
	    'albatross',
	    'album',
	    'alfalfa',
	    'algebra',
	    'algorithm',
	    'alias',
	    'alibi',
	    'alienable',
	    'alienate',
	    'aliens',
	    'alike',
	    'alive',
	    'alkaline',
	    'alkalize',
	    'almanac',
	    'almighty',
	    'almost',
	    'aloe',
	    'aloft',
	    'aloha',
	    'alone',
	    'alongside',
	    'aloof',
	    'alphabet',
	    'alright',
	    'although',
	    'altitude',
	    'alto',
	    'aluminum',
	    'alumni',
	    'always',
	    'amaretto',
	    'amaze',
	    'amazingly',
	    'amber',
	    'ambiance',
	    'ambiguity',
	    'ambiguous',
	    'ambition',
	    'ambitious',
	    'ambulance',
	    'ambush',
	    'amendable',
	    'amendment',
	    'amends',
	    'amenity',
	    'amiable',
	    'amicably',
	    'amid',
	    'amigo',
	    'amino',
	    'amiss',
	    'ammonia',
	    'ammonium',
	    'amnesty',
	    'amniotic',
	    'among',
	    'amount',
	    'amperage',
	    'ample',
	    'amplifier',
	    'amplify',
	    'amply',
	    'amuck',
	    'amulet',
	    'amusable',
	    'amused',
	    'amusement',
	    'amuser',
	    'amusing',
	    'anaconda',
	    'anaerobic',
	    'anagram',
	    'anatomist',
	    'anatomy',
	    'anchor',
	    'anchovy',
	    'ancient',
	    'android',
	    'anemia',
	    'anemic',
	    'aneurism',
	    'anew',
	    'angelfish',
	    'angelic',
	    'anger',
	    'angled',
	    'angler',
	    'angles',
	    'angling',
	    'angrily',
	    'angriness',
	    'anguished',
	    'angular',
	    'animal',
	    'animate',
	    'animating',
	    'animation',
	    'animator',
	    'anime',
	    'animosity',
	    'ankle',
	    'annex',
	    'annotate',
	    'announcer',
	    'annoying',
	    'annually',
	    'annuity',
	    'anointer',
	    'another',
	    'answering',
	    'antacid',
	    'antarctic',
	    'anteater',
	    'antelope',
	    'antennae',
	    'anthem',
	    'anthill',
	    'anthology',
	    'antibody',
	    'antics',
	    'antidote',
	    'antihero',
	    'antiquely',
	    'antiques',
	    'antiquity',
	    'antirust',
	    'antitoxic',
	    'antitrust',
	    'antiviral',
	    'antivirus',
	    'antler',
	    'antonym',
	    'antsy',
	    'anvil',
	    'anybody',
	    'anyhow',
	    'anymore',
	    'anyone',
	    'anyplace',
	    'anything',
	    'anytime',
	    'anyway',
	    'anywhere',
	    'aorta',
	    'apache',
	    'apostle',
	    'appealing',
	    'appear',
	    'appease',
	    'appeasing',
	    'appendage',
	    'appendix',
	    'appetite',
	    'appetizer',
	    'applaud',
	    'applause',
	    'apple',
	    'appliance',
	    'applicant',
	    'applied',
	    'apply',
	    'appointee',
	    'appraisal',
	    'appraiser',
	    'apprehend',
	    'approach',
	    'approval',
	    'approve',
	    'apricot',
	    'april',
	    'apron',
	    'aptitude',
	    'aptly',
	    'aqua',
	    'aqueduct',
	    'arbitrary',
	    'arbitrate',
	    'ardently',
	    'area',
	    'arena',
	    'arguable',
	    'arguably',
	    'argue',
	    'arise',
	    'armadillo',
	    'armband',
	    'armchair',
	    'armed',
	    'armful',
	    'armhole',
	    'arming',
	    'armless',
	    'armoire',
	    'armored',
	    'armory',
	    'armrest',
	    'army',
	    'aroma',
	    'arose',
	    'around',
	    'arousal',
	    'arrange',
	    'array',
	    'arrest',
	    'arrival',
	    'arrive',
	    'arrogance',
	    'arrogant',
	    'arson',
	    'art',
	    'ascend',
	    'ascension',
	    'ascent',
	    'ascertain',
	    'ashamed',
	    'ashen',
	    'ashes',
	    'ashy',
	    'aside',
	    'askew',
	    'asleep',
	    'asparagus',
	    'aspect',
	    'aspirate',
	    'aspire',
	    'aspirin',
	    'astonish',
	    'astound',
	    'astride',
	    'astrology',
	    'astronaut',
	    'astronomy',
	    'astute',
	    'atlantic',
	    'atlas',
	    'atom',
	    'atonable',
	    'atop',
	    'atrium',
	    'atrocious',
	    'atrophy',
	    'attach',
	    'attain',
	    'attempt',
	    'attendant',
	    'attendee',
	    'attention',
	    'attentive',
	    'attest',
	    'attic',
	    'attire',
	    'attitude',
	    'attractor',
	    'attribute',
	    'atypical',
	    'auction',
	    'audacious',
	    'audacity',
	    'audible',
	    'audibly',
	    'audience',
	    'audio',
	    'audition',
	    'augmented',
	    'august',
	    'authentic',
	    'author',
	    'autism',
	    'autistic',
	    'autograph',
	    'automaker',
	    'automated',
	    'automatic',
	    'autopilot',
	    'available',
	    'avalanche',
	    'avatar',
	    'avenge',
	    'avenging',
	    'avenue',
	    'average',
	    'aversion',
	    'avert',
	    'aviation',
	    'aviator',
	    'avid',
	    'avoid',
	    'await',
	    'awaken',
	    'award',
	    'aware',
	    'awhile',
	    'awkward',
	    'awning',
	    'awoke',
	    'awry',
	    'axis',
	    'babble',
	    'babbling',
	    'babied',
	    'baboon',
	    'backache',
	    'backboard',
	    'backboned',
	    'backdrop',
	    'backed',
	    'backer',
	    'backfield',
	    'backfire',
	    'backhand',
	    'backing',
	    'backlands',
	    'backlash',
	    'backless',
	    'backlight',
	    'backlit',
	    'backlog',
	    'backpack',
	    'backpedal',
	    'backrest',
	    'backroom',
	    'backshift',
	    'backside',
	    'backslid',
	    'backspace',
	    'backspin',
	    'backstab',
	    'backstage',
	    'backtalk',
	    'backtrack',
	    'backup',
	    'backward',
	    'backwash',
	    'backwater',
	    'backyard',
	    'bacon',
	    'bacteria',
	    'bacterium',
	    'badass',
	    'badge',
	    'badland',
	    'badly',
	    'badness',
	    'baffle',
	    'baffling',
	    'bagel',
	    'bagful',
	    'baggage',
	    'bagged',
	    'baggie',
	    'bagginess',
	    'bagging',
	    'baggy',
	    'bagpipe',
	    'baguette',
	    'baked',
	    'bakery',
	    'bakeshop',
	    'baking',
	    'balance',
	    'balancing',
	    'balcony',
	    'balmy',
	    'balsamic',
	    'bamboo',
	    'banana',
	    'banish',
	    'banister',
	    'banjo',
	    'bankable',
	    'bankbook',
	    'banked',
	    'banker',
	    'banking',
	    'banknote',
	    'bankroll',
	    'banner',
	    'bannister',
	    'banshee',
	    'banter',
	    'barbecue',
	    'barbed',
	    'barbell',
	    'barber',
	    'barcode',
	    'barge',
	    'bargraph',
	    'barista',
	    'baritone',
	    'barley',
	    'barmaid',
	    'barman',
	    'barn',
	    'barometer',
	    'barrack',
	    'barracuda',
	    'barrel',
	    'barrette',
	    'barricade',
	    'barrier',
	    'barstool',
	    'bartender',
	    'barterer',
	    'bash',
	    'basically',
	    'basics',
	    'basil',
	    'basin',
	    'basis',
	    'basket',
	    'batboy',
	    'batch',
	    'bath',
	    'baton',
	    'bats',
	    'battalion',
	    'battered',
	    'battering',
	    'battery',
	    'batting',
	    'battle',
	    'bauble',
	    'bazooka',
	    'blabber',
	    'bladder',
	    'blade',
	    'blah',
	    'blame',
	    'blaming',
	    'blanching',
	    'blandness',
	    'blank',
	    'blaspheme',
	    'blasphemy',
	    'blast',
	    'blatancy',
	    'blatantly',
	    'blazer',
	    'blazing',
	    'bleach',
	    'bleak',
	    'bleep',
	    'blemish',
	    'blend',
	    'bless',
	    'blighted',
	    'blimp',
	    'bling',
	    'blinked',
	    'blinker',
	    'blinking',
	    'blinks',
	    'blip',
	    'blissful',
	    'blitz',
	    'blizzard',
	    'bloated',
	    'bloating',
	    'blob',
	    'blog',
	    'bloomers',
	    'blooming',
	    'blooper',
	    'blot',
	    'blouse',
	    'blubber',
	    'bluff',
	    'bluish',
	    'blunderer',
	    'blunt',
	    'blurb',
	    'blurred',
	    'blurry',
	    'blurt',
	    'blush',
	    'blustery',
	    'boaster',
	    'boastful',
	    'boasting',
	    'boat',
	    'bobbed',
	    'bobbing',
	    'bobble',
	    'bobcat',
	    'bobsled',
	    'bobtail',
	    'bodacious',
	    'body',
	    'bogged',
	    'boggle',
	    'bogus',
	    'boil',
	    'bok',
	    'bolster',
	    'bolt',
	    'bonanza',
	    'bonded',
	    'bonding',
	    'bondless',
	    'boned',
	    'bonehead',
	    'boneless',
	    'bonelike',
	    'boney',
	    'bonfire',
	    'bonnet',
	    'bonsai',
	    'bonus',
	    'bony',
	    'boogeyman',
	    'boogieman',
	    'book',
	    'boondocks',
	    'booted',
	    'booth',
	    'bootie',
	    'booting',
	    'bootlace',
	    'bootleg',
	    'boots',
	    'boozy',
	    'borax',
	    'boring',
	    'borough',
	    'borrower',
	    'borrowing',
	    'boss',
	    'botanical',
	    'botanist',
	    'botany',
	    'botch',
	    'both',
	    'bottle',
	    'bottling',
	    'bottom',
	    'bounce',
	    'bouncing',
	    'bouncy',
	    'bounding',
	    'boundless',
	    'bountiful',
	    'bovine',
	    'boxcar',
	    'boxer',
	    'boxing',
	    'boxlike',
	    'boxy',
	    'breach',
	    'breath',
	    'breeches',
	    'breeching',
	    'breeder',
	    'breeding',
	    'breeze',
	    'breezy',
	    'brethren',
	    'brewery',
	    'brewing',
	    'briar',
	    'bribe',
	    'brick',
	    'bride',
	    'bridged',
	    'brigade',
	    'bright',
	    'brilliant',
	    'brim',
	    'bring',
	    'brink',
	    'brisket',
	    'briskly',
	    'briskness',
	    'bristle',
	    'brittle',
	    'broadband',
	    'broadcast',
	    'broaden',
	    'broadly',
	    'broadness',
	    'broadside',
	    'broadways',
	    'broiler',
	    'broiling',
	    'broken',
	    'broker',
	    'bronchial',
	    'bronco',
	    'bronze',
	    'bronzing',
	    'brook',
	    'broom',
	    'brought',
	    'browbeat',
	    'brownnose',
	    'browse',
	    'browsing',
	    'bruising',
	    'brunch',
	    'brunette',
	    'brunt',
	    'brush',
	    'brussels',
	    'brute',
	    'brutishly',
	    'bubble',
	    'bubbling',
	    'bubbly',
	    'buccaneer',
	    'bucked',
	    'bucket',
	    'buckle',
	    'buckshot',
	    'buckskin',
	    'bucktooth',
	    'buckwheat',
	    'buddhism',
	    'buddhist',
	    'budding',
	    'buddy',
	    'budget',
	    'buffalo',
	    'buffed',
	    'buffer',
	    'buffing',
	    'buffoon',
	    'buggy',
	    'bulb',
	    'bulge',
	    'bulginess',
	    'bulgur',
	    'bulk',
	    'bulldog',
	    'bulldozer',
	    'bullfight',
	    'bullfrog',
	    'bullhorn',
	    'bullion',
	    'bullish',
	    'bullpen',
	    'bullring',
	    'bullseye',
	    'bullwhip',
	    'bully',
	    'bunch',
	    'bundle',
	    'bungee',
	    'bunion',
	    'bunkbed',
	    'bunkhouse',
	    'bunkmate',
	    'bunny',
	    'bunt',
	    'busboy',
	    'bush',
	    'busily',
	    'busload',
	    'bust',
	    'busybody',
	    'buzz',
	    'cabana',
	    'cabbage',
	    'cabbie',
	    'cabdriver',
	    'cable',
	    'caboose',
	    'cache',
	    'cackle',
	    'cacti',
	    'cactus',
	    'caddie',
	    'caddy',
	    'cadet',
	    'cadillac',
	    'cadmium',
	    'cage',
	    'cahoots',
	    'cake',
	    'calamari',
	    'calamity',
	    'calcium',
	    'calculate',
	    'calculus',
	    'caliber',
	    'calibrate',
	    'calm',
	    'caloric',
	    'calorie',
	    'calzone',
	    'camcorder',
	    'cameo',
	    'camera',
	    'camisole',
	    'camper',
	    'campfire',
	    'camping',
	    'campsite',
	    'campus',
	    'canal',
	    'canary',
	    'cancel',
	    'candied',
	    'candle',
	    'candy',
	    'cane',
	    'canine',
	    'canister',
	    'cannabis',
	    'canned',
	    'canning',
	    'cannon',
	    'cannot',
	    'canola',
	    'canon',
	    'canopener',
	    'canopy',
	    'canteen',
	    'canyon',
	    'capable',
	    'capably',
	    'capacity',
	    'cape',
	    'capillary',
	    'capital',
	    'capitol',
	    'capped',
	    'capricorn',
	    'capsize',
	    'capsule',
	    'caption',
	    'captivate',
	    'captive',
	    'captivity',
	    'capture',
	    'caramel',
	    'carat',
	    'caravan',
	    'carbon',
	    'cardboard',
	    'carded',
	    'cardiac',
	    'cardigan',
	    'cardinal',
	    'cardstock',
	    'carefully',
	    'caregiver',
	    'careless',
	    'caress',
	    'caretaker',
	    'cargo',
	    'caring',
	    'carless',
	    'carload',
	    'carmaker',
	    'carnage',
	    'carnation',
	    'carnival',
	    'carnivore',
	    'carol',
	    'carpenter',
	    'carpentry',
	    'carpool',
	    'carport',
	    'carried',
	    'carrot',
	    'carrousel',
	    'carry',
	    'cartel',
	    'cartload',
	    'carton',
	    'cartoon',
	    'cartridge',
	    'cartwheel',
	    'carve',
	    'carving',
	    'carwash',
	    'cascade',
	    'case',
	    'cash',
	    'casing',
	    'casino',
	    'casket',
	    'cassette',
	    'casually',
	    'casualty',
	    'catacomb',
	    'catalog',
	    'catalyst',
	    'catalyze',
	    'catapult',
	    'cataract',
	    'catatonic',
	    'catcall',
	    'catchable',
	    'catcher',
	    'catching',
	    'catchy',
	    'caterer',
	    'catering',
	    'catfight',
	    'catfish',
	    'cathedral',
	    'cathouse',
	    'catlike',
	    'catnap',
	    'catnip',
	    'catsup',
	    'cattail',
	    'cattishly',
	    'cattle',
	    'catty',
	    'catwalk',
	    'caucasian',
	    'caucus',
	    'causal',
	    'causation',
	    'cause',
	    'causing',
	    'cauterize',
	    'caution',
	    'cautious',
	    'cavalier',
	    'cavalry',
	    'caviar',
	    'cavity',
	    'cedar',
	    'celery',
	    'celestial',
	    'celibacy',
	    'celibate',
	    'celtic',
	    'cement',
	    'census',
	    'ceramics',
	    'ceremony',
	    'certainly',
	    'certainty',
	    'certified',
	    'certify',
	    'cesarean',
	    'cesspool',
	    'chafe',
	    'chaffing',
	    'chain',
	    'chair',
	    'chalice',
	    'challenge',
	    'chamber',
	    'chamomile',
	    'champion',
	    'chance',
	    'change',
	    'channel',
	    'chant',
	    'chaos',
	    'chaperone',
	    'chaplain',
	    'chapped',
	    'chaps',
	    'chapter',
	    'character',
	    'charbroil',
	    'charcoal',
	    'charger',
	    'charging',
	    'chariot',
	    'charity',
	    'charm',
	    'charred',
	    'charter',
	    'charting',
	    'chase',
	    'chasing',
	    'chaste',
	    'chastise',
	    'chastity',
	    'chatroom',
	    'chatter',
	    'chatting',
	    'chatty',
	    'cheating',
	    'cheddar',
	    'cheek',
	    'cheer',
	    'cheese',
	    'cheesy',
	    'chef',
	    'chemicals',
	    'chemist',
	    'chemo',
	    'cherisher',
	    'cherub',
	    'chess',
	    'chest',
	    'chevron',
	    'chevy',
	    'chewable',
	    'chewer',
	    'chewing',
	    'chewy',
	    'chief',
	    'chihuahua',
	    'childcare',
	    'childhood',
	    'childish',
	    'childless',
	    'childlike',
	    'chili',
	    'chill',
	    'chimp',
	    'chip',
	    'chirping',
	    'chirpy',
	    'chitchat',
	    'chivalry',
	    'chive',
	    'chloride',
	    'chlorine',
	    'choice',
	    'chokehold',
	    'choking',
	    'chomp',
	    'chooser',
	    'choosing',
	    'choosy',
	    'chop',
	    'chosen',
	    'chowder',
	    'chowtime',
	    'chrome',
	    'chubby',
	    'chuck',
	    'chug',
	    'chummy',
	    'chump',
	    'chunk',
	    'churn',
	    'chute',
	    'cider',
	    'cilantro',
	    'cinch',
	    'cinema',
	    'cinnamon',
	    'circle',
	    'circling',
	    'circular',
	    'circulate',
	    'circus',
	    'citable',
	    'citadel',
	    'citation',
	    'citizen',
	    'citric',
	    'citrus',
	    'city',
	    'civic',
	    'civil',
	    'clad',
	    'claim',
	    'clambake',
	    'clammy',
	    'clamor',
	    'clamp',
	    'clamshell',
	    'clang',
	    'clanking',
	    'clapped',
	    'clapper',
	    'clapping',
	    'clarify',
	    'clarinet',
	    'clarity',
	    'clash',
	    'clasp',
	    'class',
	    'clatter',
	    'clause',
	    'clavicle',
	    'claw',
	    'clay',
	    'clean',
	    'clear',
	    'cleat',
	    'cleaver',
	    'cleft',
	    'clench',
	    'clergyman',
	    'clerical',
	    'clerk',
	    'clever',
	    'clicker',
	    'client',
	    'climate',
	    'climatic',
	    'cling',
	    'clinic',
	    'clinking',
	    'clip',
	    'clique',
	    'cloak',
	    'clobber',
	    'clock',
	    'clone',
	    'cloning',
	    'closable',
	    'closure',
	    'clothes',
	    'clothing',
	    'cloud',
	    'clover',
	    'clubbed',
	    'clubbing',
	    'clubhouse',
	    'clump',
	    'clumsily',
	    'clumsy',
	    'clunky',
	    'clustered',
	    'clutch',
	    'clutter',
	    'coach',
	    'coagulant',
	    'coastal',
	    'coaster',
	    'coasting',
	    'coastland',
	    'coastline',
	    'coat',
	    'coauthor',
	    'cobalt',
	    'cobbler',
	    'cobweb',
	    'cocoa',
	    'coconut',
	    'cod',
	    'coeditor',
	    'coerce',
	    'coexist',
	    'coffee',
	    'cofounder',
	    'cognition',
	    'cognitive',
	    'cogwheel',
	    'coherence',
	    'coherent',
	    'cohesive',
	    'coil',
	    'coke',
	    'cola',
	    'cold',
	    'coleslaw',
	    'coliseum',
	    'collage',
	    'collapse',
	    'collar',
	    'collected',
	    'collector',
	    'collide',
	    'collie',
	    'collision',
	    'colonial',
	    'colonist',
	    'colonize',
	    'colony',
	    'colossal',
	    'colt',
	    'coma',
	    'come',
	    'comfort',
	    'comfy',
	    'comic',
	    'coming',
	    'comma',
	    'commence',
	    'commend',
	    'comment',
	    'commerce',
	    'commode',
	    'commodity',
	    'commodore',
	    'common',
	    'commotion',
	    'commute',
	    'commuting',
	    'compacted',
	    'compacter',
	    'compactly',
	    'compactor',
	    'companion',
	    'company',
	    'compare',
	    'compel',
	    'compile',
	    'comply',
	    'component',
	    'composed',
	    'composer',
	    'composite',
	    'compost',
	    'composure',
	    'compound',
	    'compress',
	    'comprised',
	    'computer',
	    'computing',
	    'comrade',
	    'concave',
	    'conceal',
	    'conceded',
	    'concept',
	    'concerned',
	    'concert',
	    'conch',
	    'concierge',
	    'concise',
	    'conclude',
	    'concrete',
	    'concur',
	    'condense',
	    'condiment',
	    'condition',
	    'condone',
	    'conducive',
	    'conductor',
	    'conduit',
	    'cone',
	    'confess',
	    'confetti',
	    'confidant',
	    'confident',
	    'confider',
	    'confiding',
	    'configure',
	    'confined',
	    'confining',
	    'confirm',
	    'conflict',
	    'conform',
	    'confound',
	    'confront',
	    'confused',
	    'confusing',
	    'confusion',
	    'congenial',
	    'congested',
	    'congrats',
	    'congress',
	    'conical',
	    'conjoined',
	    'conjure',
	    'conjuror',
	    'connected',
	    'connector',
	    'consensus',
	    'consent',
	    'console',
	    'consoling',
	    'consonant',
	    'constable',
	    'constant',
	    'constrain',
	    'constrict',
	    'construct',
	    'consult',
	    'consumer',
	    'consuming',
	    'contact',
	    'container',
	    'contempt',
	    'contend',
	    'contented',
	    'contently',
	    'contents',
	    'contest',
	    'context',
	    'contort',
	    'contour',
	    'contrite',
	    'control',
	    'contusion',
	    'convene',
	    'convent',
	    'copartner',
	    'cope',
	    'copied',
	    'copier',
	    'copilot',
	    'coping',
	    'copious',
	    'copper',
	    'copy',
	    'coral',
	    'cork',
	    'cornball',
	    'cornbread',
	    'corncob',
	    'cornea',
	    'corned',
	    'corner',
	    'cornfield',
	    'cornflake',
	    'cornhusk',
	    'cornmeal',
	    'cornstalk',
	    'corny',
	    'coronary',
	    'coroner',
	    'corporal',
	    'corporate',
	    'corral',
	    'correct',
	    'corridor',
	    'corrode',
	    'corroding',
	    'corrosive',
	    'corsage',
	    'corset',
	    'cortex',
	    'cosigner',
	    'cosmetics',
	    'cosmic',
	    'cosmos',
	    'cosponsor',
	    'cost',
	    'cottage',
	    'cotton',
	    'couch',
	    'cough',
	    'could',
	    'countable',
	    'countdown',
	    'counting',
	    'countless',
	    'country',
	    'county',
	    'courier',
	    'covenant',
	    'cover',
	    'coveted',
	    'coveting',
	    'coyness',
	    'cozily',
	    'coziness',
	    'cozy',
	    'crabbing',
	    'crabgrass',
	    'crablike',
	    'crabmeat',
	    'cradle',
	    'cradling',
	    'crafter',
	    'craftily',
	    'craftsman',
	    'craftwork',
	    'crafty',
	    'cramp',
	    'cranberry',
	    'crane',
	    'cranial',
	    'cranium',
	    'crank',
	    'crate',
	    'crave',
	    'craving',
	    'crawfish',
	    'crawlers',
	    'crawling',
	    'crayfish',
	    'crayon',
	    'crazed',
	    'crazily',
	    'craziness',
	    'crazy',
	    'creamed',
	    'creamer',
	    'creamlike',
	    'crease',
	    'creasing',
	    'creatable',
	    'create',
	    'creation',
	    'creative',
	    'creature',
	    'credible',
	    'credibly',
	    'credit',
	    'creed',
	    'creme',
	    'creole',
	    'crepe',
	    'crept',
	    'crescent',
	    'crested',
	    'cresting',
	    'crestless',
	    'crevice',
	    'crewless',
	    'crewman',
	    'crewmate',
	    'crib',
	    'cricket',
	    'cried',
	    'crier',
	    'crimp',
	    'crimson',
	    'cringe',
	    'cringing',
	    'crinkle',
	    'crinkly',
	    'crisped',
	    'crisping',
	    'crisply',
	    'crispness',
	    'crispy',
	    'criteria',
	    'critter',
	    'croak',
	    'crock',
	    'crook',
	    'croon',
	    'crop',
	    'cross',
	    'crouch',
	    'crouton',
	    'crowbar',
	    'crowd',
	    'crown',
	    'crucial',
	    'crudely',
	    'crudeness',
	    'cruelly',
	    'cruelness',
	    'cruelty',
	    'crumb',
	    'crummiest',
	    'crummy',
	    'crumpet',
	    'crumpled',
	    'cruncher',
	    'crunching',
	    'crunchy',
	    'crusader',
	    'crushable',
	    'crushed',
	    'crusher',
	    'crushing',
	    'crust',
	    'crux',
	    'crying',
	    'cryptic',
	    'crystal',
	    'cubbyhole',
	    'cube',
	    'cubical',
	    'cubicle',
	    'cucumber',
	    'cuddle',
	    'cuddly',
	    'cufflink',
	    'culinary',
	    'culminate',
	    'culpable',
	    'culprit',
	    'cultivate',
	    'cultural',
	    'culture',
	    'cupbearer',
	    'cupcake',
	    'cupid',
	    'cupped',
	    'cupping',
	    'curable',
	    'curator',
	    'curdle',
	    'cure',
	    'curfew',
	    'curing',
	    'curled',
	    'curler',
	    'curliness',
	    'curling',
	    'curly',
	    'curry',
	    'curse',
	    'cursive',
	    'cursor',
	    'curtain',
	    'curtly',
	    'curtsy',
	    'curvature',
	    'curve',
	    'curvy',
	    'cushy',
	    'cusp',
	    'cussed',
	    'custard',
	    'custodian',
	    'custody',
	    'customary',
	    'customer',
	    'customize',
	    'customs',
	    'cut',
	    'cycle',
	    'cyclic',
	    'cycling',
	    'cyclist',
	    'cylinder',
	    'cymbal',
	    'cytoplasm',
	    'cytoplast',
	    'dab',
	    'dad',
	    'daffodil',
	    'dagger',
	    'daily',
	    'daintily',
	    'dainty',
	    'dairy',
	    'daisy',
	    'dallying',
	    'dance',
	    'dancing',
	    'dandelion',
	    'dander',
	    'dandruff',
	    'dandy',
	    'danger',
	    'dangle',
	    'dangling',
	    'daredevil',
	    'dares',
	    'daringly',
	    'darkened',
	    'darkening',
	    'darkish',
	    'darkness',
	    'darkroom',
	    'darling',
	    'darn',
	    'dart',
	    'darwinism',
	    'dash',
	    'dastardly',
	    'data',
	    'datebook',
	    'dating',
	    'daughter',
	    'daunting',
	    'dawdler',
	    'dawn',
	    'daybed',
	    'daybreak',
	    'daycare',
	    'daydream',
	    'daylight',
	    'daylong',
	    'dayroom',
	    'daytime',
	    'dazzler',
	    'dazzling',
	    'deacon',
	    'deafening',
	    'deafness',
	    'dealer',
	    'dealing',
	    'dealmaker',
	    'dealt',
	    'dean',
	    'debatable',
	    'debate',
	    'debating',
	    'debit',
	    'debrief',
	    'debtless',
	    'debtor',
	    'debug',
	    'debunk',
	    'decade',
	    'decaf',
	    'decal',
	    'decathlon',
	    'decay',
	    'deceased',
	    'deceit',
	    'deceiver',
	    'deceiving',
	    'december',
	    'decency',
	    'decent',
	    'deception',
	    'deceptive',
	    'decibel',
	    'decidable',
	    'decimal',
	    'decimeter',
	    'decipher',
	    'deck',
	    'declared',
	    'decline',
	    'decode',
	    'decompose',
	    'decorated',
	    'decorator',
	    'decoy',
	    'decrease',
	    'decree',
	    'dedicate',
	    'dedicator',
	    'deduce',
	    'deduct',
	    'deed',
	    'deem',
	    'deepen',
	    'deeply',
	    'deepness',
	    'deface',
	    'defacing',
	    'defame',
	    'default',
	    'defeat',
	    'defection',
	    'defective',
	    'defendant',
	    'defender',
	    'defense',
	    'defensive',
	    'deferral',
	    'deferred',
	    'defiance',
	    'defiant',
	    'defile',
	    'defiling',
	    'define',
	    'definite',
	    'deflate',
	    'deflation',
	    'deflator',
	    'deflected',
	    'deflector',
	    'defog',
	    'deforest',
	    'defraud',
	    'defrost',
	    'deftly',
	    'defuse',
	    'defy',
	    'degraded',
	    'degrading',
	    'degrease',
	    'degree',
	    'dehydrate',
	    'deity',
	    'dejected',
	    'delay',
	    'delegate',
	    'delegator',
	    'delete',
	    'deletion',
	    'delicacy',
	    'delicate',
	    'delicious',
	    'delighted',
	    'delirious',
	    'delirium',
	    'deliverer',
	    'delivery',
	    'delouse',
	    'delta',
	    'deluge',
	    'delusion',
	    'deluxe',
	    'demanding',
	    'demeaning',
	    'demeanor',
	    'demise',
	    'democracy',
	    'democrat',
	    'demote',
	    'demotion',
	    'demystify',
	    'denatured',
	    'deniable',
	    'denial',
	    'denim',
	    'denote',
	    'dense',
	    'density',
	    'dental',
	    'dentist',
	    'denture',
	    'deny',
	    'deodorant',
	    'deodorize',
	    'departed',
	    'departure',
	    'depict',
	    'deplete',
	    'depletion',
	    'deplored',
	    'deploy',
	    'deport',
	    'depose',
	    'depraved',
	    'depravity',
	    'deprecate',
	    'depress',
	    'deprive',
	    'depth',
	    'deputize',
	    'deputy',
	    'derail',
	    'deranged',
	    'derby',
	    'derived',
	    'desecrate',
	    'deserve',
	    'deserving',
	    'designate',
	    'designed',
	    'designer',
	    'designing',
	    'deskbound',
	    'desktop',
	    'deskwork',
	    'desolate',
	    'despair',
	    'despise',
	    'despite',
	    'destiny',
	    'destitute',
	    'destruct',
	    'detached',
	    'detail',
	    'detection',
	    'detective',
	    'detector',
	    'detention',
	    'detergent',
	    'detest',
	    'detonate',
	    'detonator',
	    'detoxify',
	    'detract',
	    'deuce',
	    'devalue',
	    'deviancy',
	    'deviant',
	    'deviate',
	    'deviation',
	    'deviator',
	    'device',
	    'devious',
	    'devotedly',
	    'devotee',
	    'devotion',
	    'devourer',
	    'devouring',
	    'devoutly',
	    'dexterity',
	    'dexterous',
	    'diabetes',
	    'diabetic',
	    'diabolic',
	    'diagnoses',
	    'diagnosis',
	    'diagram',
	    'dial',
	    'diameter',
	    'diaper',
	    'diaphragm',
	    'diary',
	    'dice',
	    'dicing',
	    'dictate',
	    'dictation',
	    'dictator',
	    'difficult',
	    'diffused',
	    'diffuser',
	    'diffusion',
	    'diffusive',
	    'dig',
	    'dilation',
	    'diligence',
	    'diligent',
	    'dill',
	    'dilute',
	    'dime',
	    'diminish',
	    'dimly',
	    'dimmed',
	    'dimmer',
	    'dimness',
	    'dimple',
	    'diner',
	    'dingbat',
	    'dinghy',
	    'dinginess',
	    'dingo',
	    'dingy',
	    'dining',
	    'dinner',
	    'diocese',
	    'dioxide',
	    'diploma',
	    'dipped',
	    'dipper',
	    'dipping',
	    'directed',
	    'direction',
	    'directive',
	    'directly',
	    'directory',
	    'direness',
	    'dirtiness',
	    'disabled',
	    'disagree',
	    'disallow',
	    'disarm',
	    'disarray',
	    'disaster',
	    'disband',
	    'disbelief',
	    'disburse',
	    'discard',
	    'discern',
	    'discharge',
	    'disclose',
	    'discolor',
	    'discount',
	    'discourse',
	    'discover',
	    'discuss',
	    'disdain',
	    'disengage',
	    'disfigure',
	    'disgrace',
	    'dish',
	    'disinfect',
	    'disjoin',
	    'disk',
	    'dislike',
	    'disliking',
	    'dislocate',
	    'dislodge',
	    'disloyal',
	    'dismantle',
	    'dismay',
	    'dismiss',
	    'dismount',
	    'disobey',
	    'disorder',
	    'disown',
	    'disparate',
	    'disparity',
	    'dispatch',
	    'dispense',
	    'dispersal',
	    'dispersed',
	    'disperser',
	    'displace',
	    'display',
	    'displease',
	    'disposal',
	    'dispose',
	    'disprove',
	    'dispute',
	    'disregard',
	    'disrupt',
	    'dissuade',
	    'distance',
	    'distant',
	    'distaste',
	    'distill',
	    'distinct',
	    'distort',
	    'distract',
	    'distress',
	    'district',
	    'distrust',
	    'ditch',
	    'ditto',
	    'ditzy',
	    'dividable',
	    'divided',
	    'dividend',
	    'dividers',
	    'dividing',
	    'divinely',
	    'diving',
	    'divinity',
	    'divisible',
	    'divisibly',
	    'division',
	    'divisive',
	    'divorcee',
	    'dizziness',
	    'dizzy',
	    'doable',
	    'docile',
	    'dock',
	    'doctrine',
	    'document',
	    'dodge',
	    'dodgy',
	    'doily',
	    'doing',
	    'dole',
	    'dollar',
	    'dollhouse',
	    'dollop',
	    'dolly',
	    'dolphin',
	    'domain',
	    'domelike',
	    'domestic',
	    'dominion',
	    'dominoes',
	    'donated',
	    'donation',
	    'donator',
	    'donor',
	    'donut',
	    'doodle',
	    'doorbell',
	    'doorframe',
	    'doorknob',
	    'doorman',
	    'doormat',
	    'doornail',
	    'doorpost',
	    'doorstep',
	    'doorstop',
	    'doorway',
	    'doozy',
	    'dork',
	    'dormitory',
	    'dorsal',
	    'dosage',
	    'dose',
	    'dotted',
	    'doubling',
	    'douche',
	    'dove',
	    'down',
	    'dowry',
	    'doze',
	    'drab',
	    'dragging',
	    'dragonfly',
	    'dragonish',
	    'dragster',
	    'drainable',
	    'drainage',
	    'drained',
	    'drainer',
	    'drainpipe',
	    'dramatic',
	    'dramatize',
	    'drank',
	    'drapery',
	    'drastic',
	    'draw',
	    'dreaded',
	    'dreadful',
	    'dreadlock',
	    'dreamboat',
	    'dreamily',
	    'dreamland',
	    'dreamless',
	    'dreamlike',
	    'dreamt',
	    'dreamy',
	    'drearily',
	    'dreary',
	    'drench',
	    'dress',
	    'drew',
	    'dribble',
	    'dried',
	    'drier',
	    'drift',
	    'driller',
	    'drilling',
	    'drinkable',
	    'drinking',
	    'dripping',
	    'drippy',
	    'drivable',
	    'driven',
	    'driver',
	    'driveway',
	    'driving',
	    'drizzle',
	    'drizzly',
	    'drone',
	    'drool',
	    'droop',
	    'drop-down',
	    'dropbox',
	    'dropkick',
	    'droplet',
	    'dropout',
	    'dropper',
	    'drove',
	    'drown',
	    'drowsily',
	    'drudge',
	    'drum',
	    'dry',
	    'dubbed',
	    'dubiously',
	    'duchess',
	    'duckbill',
	    'ducking',
	    'duckling',
	    'ducktail',
	    'ducky',
	    'duct',
	    'dude',
	    'duffel',
	    'dugout',
	    'duh',
	    'duke',
	    'duller',
	    'dullness',
	    'duly',
	    'dumping',
	    'dumpling',
	    'dumpster',
	    'duo',
	    'dupe',
	    'duplex',
	    'duplicate',
	    'duplicity',
	    'durable',
	    'durably',
	    'duration',
	    'duress',
	    'during',
	    'dusk',
	    'dust',
	    'dutiful',
	    'duty',
	    'duvet',
	    'dwarf',
	    'dweeb',
	    'dwelled',
	    'dweller',
	    'dwelling',
	    'dwindle',
	    'dwindling',
	    'dynamic',
	    'dynamite',
	    'dynasty',
	    'dyslexia',
	    'dyslexic',
	    'each',
	    'eagle',
	    'earache',
	    'eardrum',
	    'earflap',
	    'earful',
	    'earlobe',
	    'early',
	    'earmark',
	    'earmuff',
	    'earphone',
	    'earpiece',
	    'earplugs',
	    'earring',
	    'earshot',
	    'earthen',
	    'earthlike',
	    'earthling',
	    'earthly',
	    'earthworm',
	    'earthy',
	    'earwig',
	    'easeful',
	    'easel',
	    'easiest',
	    'easily',
	    'easiness',
	    'easing',
	    'eastbound',
	    'eastcoast',
	    'easter',
	    'eastward',
	    'eatable',
	    'eaten',
	    'eatery',
	    'eating',
	    'eats',
	    'ebay',
	    'ebony',
	    'ebook',
	    'ecard',
	    'eccentric',
	    'echo',
	    'eclair',
	    'eclipse',
	    'ecologist',
	    'ecology',
	    'economic',
	    'economist',
	    'economy',
	    'ecosphere',
	    'ecosystem',
	    'edge',
	    'edginess',
	    'edging',
	    'edgy',
	    'edition',
	    'editor',
	    'educated',
	    'education',
	    'educator',
	    'eel',
	    'effective',
	    'effects',
	    'efficient',
	    'effort',
	    'eggbeater',
	    'egging',
	    'eggnog',
	    'eggplant',
	    'eggshell',
	    'egomaniac',
	    'egotism',
	    'egotistic',
	    'either',
	    'eject',
	    'elaborate',
	    'elastic',
	    'elated',
	    'elbow',
	    'eldercare',
	    'elderly',
	    'eldest',
	    'electable',
	    'election',
	    'elective',
	    'elephant',
	    'elevate',
	    'elevating',
	    'elevation',
	    'elevator',
	    'eleven',
	    'elf',
	    'eligible',
	    'eligibly',
	    'eliminate',
	    'elite',
	    'elitism',
	    'elixir',
	    'elk',
	    'ellipse',
	    'elliptic',
	    'elm',
	    'elongated',
	    'elope',
	    'eloquence',
	    'eloquent',
	    'elsewhere',
	    'elude',
	    'elusive',
	    'elves',
	    'email',
	    'embargo',
	    'embark',
	    'embassy',
	    'embattled',
	    'embellish',
	    'ember',
	    'embezzle',
	    'emblaze',
	    'emblem',
	    'embody',
	    'embolism',
	    'emboss',
	    'embroider',
	    'emcee',
	    'emerald',
	    'emergency',
	    'emission',
	    'emit',
	    'emote',
	    'emoticon',
	    'emotion',
	    'empathic',
	    'empathy',
	    'emperor',
	    'emphases',
	    'emphasis',
	    'emphasize',
	    'emphatic',
	    'empirical',
	    'employed',
	    'employee',
	    'employer',
	    'emporium',
	    'empower',
	    'emptier',
	    'emptiness',
	    'empty',
	    'emu',
	    'enable',
	    'enactment',
	    'enamel',
	    'enchanted',
	    'enchilada',
	    'encircle',
	    'enclose',
	    'enclosure',
	    'encode',
	    'encore',
	    'encounter',
	    'encourage',
	    'encroach',
	    'encrust',
	    'encrypt',
	    'endanger',
	    'endeared',
	    'endearing',
	    'ended',
	    'ending',
	    'endless',
	    'endnote',
	    'endocrine',
	    'endorphin',
	    'endorse',
	    'endowment',
	    'endpoint',
	    'endurable',
	    'endurance',
	    'enduring',
	    'energetic',
	    'energize',
	    'energy',
	    'enforced',
	    'enforcer',
	    'engaged',
	    'engaging',
	    'engine',
	    'engorge',
	    'engraved',
	    'engraver',
	    'engraving',
	    'engross',
	    'engulf',
	    'enhance',
	    'enigmatic',
	    'enjoyable',
	    'enjoyably',
	    'enjoyer',
	    'enjoying',
	    'enjoyment',
	    'enlarged',
	    'enlarging',
	    'enlighten',
	    'enlisted',
	    'enquirer',
	    'enrage',
	    'enrich',
	    'enroll',
	    'enslave',
	    'ensnare',
	    'ensure',
	    'entail',
	    'entangled',
	    'entering',
	    'entertain',
	    'enticing',
	    'entire',
	    'entitle',
	    'entity',
	    'entomb',
	    'entourage',
	    'entrap',
	    'entree',
	    'entrench',
	    'entrust',
	    'entryway',
	    'entwine',
	    'enunciate',
	    'envelope',
	    'enviable',
	    'enviably',
	    'envious',
	    'envision',
	    'envoy',
	    'envy',
	    'enzyme',
	    'epic',
	    'epidemic',
	    'epidermal',
	    'epidermis',
	    'epidural',
	    'epilepsy',
	    'epileptic',
	    'epilogue',
	    'epiphany',
	    'episode',
	    'equal',
	    'equate',
	    'equation',
	    'equator',
	    'equinox',
	    'equipment',
	    'equity',
	    'equivocal',
	    'eradicate',
	    'erasable',
	    'erased',
	    'eraser',
	    'erasure',
	    'ergonomic',
	    'errand',
	    'errant',
	    'erratic',
	    'error',
	    'erupt',
	    'escalate',
	    'escalator',
	    'escapable',
	    'escapade',
	    'escapist',
	    'escargot',
	    'eskimo',
	    'esophagus',
	    'espionage',
	    'espresso',
	    'esquire',
	    'essay',
	    'essence',
	    'essential',
	    'establish',
	    'estate',
	    'esteemed',
	    'estimate',
	    'estimator',
	    'estranged',
	    'estrogen',
	    'etching',
	    'eternal',
	    'eternity',
	    'ethanol',
	    'ether',
	    'ethically',
	    'ethics',
	    'euphemism',
	    'evacuate',
	    'evacuee',
	    'evade',
	    'evaluate',
	    'evaluator',
	    'evaporate',
	    'evasion',
	    'evasive',
	    'even',
	    'everglade',
	    'evergreen',
	    'everybody',
	    'everyday',
	    'everyone',
	    'evict',
	    'evidence',
	    'evident',
	    'evil',
	    'evoke',
	    'evolution',
	    'evolve',
	    'exact',
	    'exalted',
	    'example',
	    'excavate',
	    'excavator',
	    'exceeding',
	    'exception',
	    'excess',
	    'exchange',
	    'excitable',
	    'exciting',
	    'exclaim',
	    'exclude',
	    'excluding',
	    'exclusion',
	    'exclusive',
	    'excretion',
	    'excretory',
	    'excursion',
	    'excusable',
	    'excusably',
	    'excuse',
	    'exemplary',
	    'exemplify',
	    'exemption',
	    'exerciser',
	    'exert',
	    'exes',
	    'exfoliate',
	    'exhale',
	    'exhaust',
	    'exhume',
	    'exile',
	    'existing',
	    'exit',
	    'exodus',
	    'exonerate',
	    'exorcism',
	    'exorcist',
	    'expand',
	    'expanse',
	    'expansion',
	    'expansive',
	    'expectant',
	    'expedited',
	    'expediter',
	    'expel',
	    'expend',
	    'expenses',
	    'expensive',
	    'expert',
	    'expire',
	    'expiring',
	    'explain',
	    'expletive',
	    'explicit',
	    'explode',
	    'exploit',
	    'explore',
	    'exploring',
	    'exponent',
	    'exporter',
	    'exposable',
	    'expose',
	    'exposure',
	    'express',
	    'expulsion',
	    'exquisite',
	    'extended',
	    'extending',
	    'extent',
	    'extenuate',
	    'exterior',
	    'external',
	    'extinct',
	    'extortion',
	    'extradite',
	    'extras',
	    'extrovert',
	    'extrude',
	    'extruding',
	    'exuberant',
	    'fable',
	    'fabric',
	    'fabulous',
	    'facebook',
	    'facecloth',
	    'facedown',
	    'faceless',
	    'facelift',
	    'faceplate',
	    'faceted',
	    'facial',
	    'facility',
	    'facing',
	    'facsimile',
	    'faction',
	    'factoid',
	    'factor',
	    'factsheet',
	    'factual',
	    'faculty',
	    'fade',
	    'fading',
	    'failing',
	    'falcon',
	    'fall',
	    'false',
	    'falsify',
	    'fame',
	    'familiar',
	    'family',
	    'famine',
	    'famished',
	    'fanatic',
	    'fancied',
	    'fanciness',
	    'fancy',
	    'fanfare',
	    'fang',
	    'fanning',
	    'fantasize',
	    'fantastic',
	    'fantasy',
	    'fascism',
	    'fastball',
	    'faster',
	    'fasting',
	    'fastness',
	    'faucet',
	    'favorable',
	    'favorably',
	    'favored',
	    'favoring',
	    'favorite',
	    'fax',
	    'feast',
	    'federal',
	    'fedora',
	    'feeble',
	    'feed',
	    'feel',
	    'feisty',
	    'feline',
	    'felt-tip',
	    'feminine',
	    'feminism',
	    'feminist',
	    'feminize',
	    'femur',
	    'fence',
	    'fencing',
	    'fender',
	    'ferment',
	    'fernlike',
	    'ferocious',
	    'ferocity',
	    'ferret',
	    'ferris',
	    'ferry',
	    'fervor',
	    'fester',
	    'festival',
	    'festive',
	    'festivity',
	    'fetal',
	    'fetch',
	    'fever',
	    'fiber',
	    'fiction',
	    'fiddle',
	    'fiddling',
	    'fidelity',
	    'fidgeting',
	    'fidgety',
	    'fifteen',
	    'fifth',
	    'fiftieth',
	    'fifty',
	    'figment',
	    'figure',
	    'figurine',
	    'filing',
	    'filled',
	    'filler',
	    'filling',
	    'film',
	    'filter',
	    'filth',
	    'filtrate',
	    'finale',
	    'finalist',
	    'finalize',
	    'finally',
	    'finance',
	    'financial',
	    'finch',
	    'fineness',
	    'finer',
	    'finicky',
	    'finished',
	    'finisher',
	    'finishing',
	    'finite',
	    'finless',
	    'finlike',
	    'fiscally',
	    'fit',
	    'five',
	    'flaccid',
	    'flagman',
	    'flagpole',
	    'flagship',
	    'flagstick',
	    'flagstone',
	    'flail',
	    'flakily',
	    'flaky',
	    'flame',
	    'flammable',
	    'flanked',
	    'flanking',
	    'flannels',
	    'flap',
	    'flaring',
	    'flashback',
	    'flashbulb',
	    'flashcard',
	    'flashily',
	    'flashing',
	    'flashy',
	    'flask',
	    'flatbed',
	    'flatfoot',
	    'flatly',
	    'flatness',
	    'flatten',
	    'flattered',
	    'flatterer',
	    'flattery',
	    'flattop',
	    'flatware',
	    'flatworm',
	    'flavored',
	    'flavorful',
	    'flavoring',
	    'flaxseed',
	    'fled',
	    'fleshed',
	    'fleshy',
	    'flick',
	    'flier',
	    'flight',
	    'flinch',
	    'fling',
	    'flint',
	    'flip',
	    'flirt',
	    'float',
	    'flock',
	    'flogging',
	    'flop',
	    'floral',
	    'florist',
	    'floss',
	    'flounder',
	    'flyable',
	    'flyaway',
	    'flyer',
	    'flying',
	    'flyover',
	    'flypaper',
	    'foam',
	    'foe',
	    'fog',
	    'foil',
	    'folic',
	    'folk',
	    'follicle',
	    'follow',
	    'fondling',
	    'fondly',
	    'fondness',
	    'fondue',
	    'font',
	    'food',
	    'fool',
	    'footage',
	    'football',
	    'footbath',
	    'footboard',
	    'footer',
	    'footgear',
	    'foothill',
	    'foothold',
	    'footing',
	    'footless',
	    'footman',
	    'footnote',
	    'footpad',
	    'footpath',
	    'footprint',
	    'footrest',
	    'footsie',
	    'footsore',
	    'footwear',
	    'footwork',
	    'fossil',
	    'foster',
	    'founder',
	    'founding',
	    'fountain',
	    'fox',
	    'foyer',
	    'fraction',
	    'fracture',
	    'fragile',
	    'fragility',
	    'fragment',
	    'fragrance',
	    'fragrant',
	    'frail',
	    'frame',
	    'framing',
	    'frantic',
	    'fraternal',
	    'frayed',
	    'fraying',
	    'frays',
	    'freckled',
	    'freckles',
	    'freebase',
	    'freebee',
	    'freebie',
	    'freedom',
	    'freefall',
	    'freehand',
	    'freeing',
	    'freeload',
	    'freely',
	    'freemason',
	    'freeness',
	    'freestyle',
	    'freeware',
	    'freeway',
	    'freewill',
	    'freezable',
	    'freezing',
	    'freight',
	    'french',
	    'frenzied',
	    'frenzy',
	    'frequency',
	    'frequent',
	    'fresh',
	    'fretful',
	    'fretted',
	    'friction',
	    'friday',
	    'fridge',
	    'fried',
	    'friend',
	    'frighten',
	    'frightful',
	    'frigidity',
	    'frigidly',
	    'frill',
	    'fringe',
	    'frisbee',
	    'frisk',
	    'fritter',
	    'frivolous',
	    'frolic',
	    'from',
	    'front',
	    'frostbite',
	    'frosted',
	    'frostily',
	    'frosting',
	    'frostlike',
	    'frosty',
	    'froth',
	    'frown',
	    'frozen',
	    'fructose',
	    'frugality',
	    'frugally',
	    'fruit',
	    'frustrate',
	    'frying',
	    'gab',
	    'gaffe',
	    'gag',
	    'gainfully',
	    'gaining',
	    'gains',
	    'gala',
	    'gallantly',
	    'galleria',
	    'gallery',
	    'galley',
	    'gallon',
	    'gallows',
	    'gallstone',
	    'galore',
	    'galvanize',
	    'gambling',
	    'game',
	    'gaming',
	    'gamma',
	    'gander',
	    'gangly',
	    'gangrene',
	    'gangway',
	    'gap',
	    'garage',
	    'garbage',
	    'garden',
	    'gargle',
	    'garland',
	    'garlic',
	    'garment',
	    'garnet',
	    'garnish',
	    'garter',
	    'gas',
	    'gatherer',
	    'gathering',
	    'gating',
	    'gauging',
	    'gauntlet',
	    'gauze',
	    'gave',
	    'gawk',
	    'gazing',
	    'gear',
	    'gecko',
	    'geek',
	    'geiger',
	    'gem',
	    'gender',
	    'generic',
	    'generous',
	    'genetics',
	    'genre',
	    'gentile',
	    'gentleman',
	    'gently',
	    'gents',
	    'geography',
	    'geologic',
	    'geologist',
	    'geology',
	    'geometric',
	    'geometry',
	    'geranium',
	    'gerbil',
	    'geriatric',
	    'germicide',
	    'germinate',
	    'germless',
	    'germproof',
	    'gestate',
	    'gestation',
	    'gesture',
	    'getaway',
	    'getting',
	    'getup',
	    'giant',
	    'gibberish',
	    'giblet',
	    'giddily',
	    'giddiness',
	    'giddy',
	    'gift',
	    'gigabyte',
	    'gigahertz',
	    'gigantic',
	    'giggle',
	    'giggling',
	    'giggly',
	    'gigolo',
	    'gilled',
	    'gills',
	    'gimmick',
	    'girdle',
	    'giveaway',
	    'given',
	    'giver',
	    'giving',
	    'gizmo',
	    'gizzard',
	    'glacial',
	    'glacier',
	    'glade',
	    'gladiator',
	    'gladly',
	    'glamorous',
	    'glamour',
	    'glance',
	    'glancing',
	    'glandular',
	    'glare',
	    'glaring',
	    'glass',
	    'glaucoma',
	    'glazing',
	    'gleaming',
	    'gleeful',
	    'glider',
	    'gliding',
	    'glimmer',
	    'glimpse',
	    'glisten',
	    'glitch',
	    'glitter',
	    'glitzy',
	    'gloater',
	    'gloating',
	    'gloomily',
	    'gloomy',
	    'glorified',
	    'glorifier',
	    'glorify',
	    'glorious',
	    'glory',
	    'gloss',
	    'glove',
	    'glowing',
	    'glowworm',
	    'glucose',
	    'glue',
	    'gluten',
	    'glutinous',
	    'glutton',
	    'gnarly',
	    'gnat',
	    'goal',
	    'goatskin',
	    'goes',
	    'goggles',
	    'going',
	    'goldfish',
	    'goldmine',
	    'goldsmith',
	    'golf',
	    'goliath',
	    'gonad',
	    'gondola',
	    'gone',
	    'gong',
	    'good',
	    'gooey',
	    'goofball',
	    'goofiness',
	    'goofy',
	    'google',
	    'goon',
	    'gopher',
	    'gore',
	    'gorged',
	    'gorgeous',
	    'gory',
	    'gosling',
	    'gossip',
	    'gothic',
	    'gotten',
	    'gout',
	    'gown',
	    'grab',
	    'graceful',
	    'graceless',
	    'gracious',
	    'gradation',
	    'graded',
	    'grader',
	    'gradient',
	    'grading',
	    'gradually',
	    'graduate',
	    'graffiti',
	    'grafted',
	    'grafting',
	    'grain',
	    'granddad',
	    'grandkid',
	    'grandly',
	    'grandma',
	    'grandpa',
	    'grandson',
	    'granite',
	    'granny',
	    'granola',
	    'grant',
	    'granular',
	    'grape',
	    'graph',
	    'grapple',
	    'grappling',
	    'grasp',
	    'grass',
	    'gratified',
	    'gratify',
	    'grating',
	    'gratitude',
	    'gratuity',
	    'gravel',
	    'graveness',
	    'graves',
	    'graveyard',
	    'gravitate',
	    'gravity',
	    'gravy',
	    'gray',
	    'grazing',
	    'greasily',
	    'greedily',
	    'greedless',
	    'greedy',
	    'green',
	    'greeter',
	    'greeting',
	    'grew',
	    'greyhound',
	    'grid',
	    'grief',
	    'grievance',
	    'grieving',
	    'grievous',
	    'grill',
	    'grimace',
	    'grimacing',
	    'grime',
	    'griminess',
	    'grimy',
	    'grinch',
	    'grinning',
	    'grip',
	    'gristle',
	    'grit',
	    'groggily',
	    'groggy',
	    'groin',
	    'groom',
	    'groove',
	    'grooving',
	    'groovy',
	    'grope',
	    'ground',
	    'grouped',
	    'grout',
	    'grove',
	    'grower',
	    'growing',
	    'growl',
	    'grub',
	    'grudge',
	    'grudging',
	    'grueling',
	    'gruffly',
	    'grumble',
	    'grumbling',
	    'grumbly',
	    'grumpily',
	    'grunge',
	    'grunt',
	    'guacamole',
	    'guidable',
	    'guidance',
	    'guide',
	    'guiding',
	    'guileless',
	    'guise',
	    'gulf',
	    'gullible',
	    'gully',
	    'gulp',
	    'gumball',
	    'gumdrop',
	    'gumminess',
	    'gumming',
	    'gummy',
	    'gurgle',
	    'gurgling',
	    'guru',
	    'gush',
	    'gusto',
	    'gusty',
	    'gutless',
	    'guts',
	    'gutter',
	    'guy',
	    'guzzler',
	    'gyration',
	    'habitable',
	    'habitant',
	    'habitat',
	    'habitual',
	    'hacked',
	    'hacker',
	    'hacking',
	    'hacksaw',
	    'had',
	    'haggler',
	    'haiku',
	    'half',
	    'halogen',
	    'halt',
	    'halved',
	    'halves',
	    'hamburger',
	    'hamlet',
	    'hammock',
	    'hamper',
	    'hamster',
	    'hamstring',
	    'handbag',
	    'handball',
	    'handbook',
	    'handbrake',
	    'handcart',
	    'handclap',
	    'handclasp',
	    'handcraft',
	    'handcuff',
	    'handed',
	    'handful',
	    'handgrip',
	    'handgun',
	    'handheld',
	    'handiness',
	    'handiwork',
	    'handlebar',
	    'handled',
	    'handler',
	    'handling',
	    'handmade',
	    'handoff',
	    'handpick',
	    'handprint',
	    'handrail',
	    'handsaw',
	    'handset',
	    'handsfree',
	    'handshake',
	    'handstand',
	    'handwash',
	    'handwork',
	    'handwoven',
	    'handwrite',
	    'handyman',
	    'hangnail',
	    'hangout',
	    'hangover',
	    'hangup',
	    'hankering',
	    'hankie',
	    'hanky',
	    'haphazard',
	    'happening',
	    'happier',
	    'happiest',
	    'happily',
	    'happiness',
	    'happy',
	    'harbor',
	    'hardcopy',
	    'hardcore',
	    'hardcover',
	    'harddisk',
	    'hardened',
	    'hardener',
	    'hardening',
	    'hardhat',
	    'hardhead',
	    'hardiness',
	    'hardly',
	    'hardness',
	    'hardship',
	    'hardware',
	    'hardwired',
	    'hardwood',
	    'hardy',
	    'harmful',
	    'harmless',
	    'harmonica',
	    'harmonics',
	    'harmonize',
	    'harmony',
	    'harness',
	    'harpist',
	    'harsh',
	    'harvest',
	    'hash',
	    'hassle',
	    'haste',
	    'hastily',
	    'hastiness',
	    'hasty',
	    'hatbox',
	    'hatchback',
	    'hatchery',
	    'hatchet',
	    'hatching',
	    'hatchling',
	    'hate',
	    'hatless',
	    'hatred',
	    'haunt',
	    'haven',
	    'hazard',
	    'hazelnut',
	    'hazily',
	    'haziness',
	    'hazing',
	    'hazy',
	    'headache',
	    'headband',
	    'headboard',
	    'headcount',
	    'headdress',
	    'headed',
	    'header',
	    'headfirst',
	    'headgear',
	    'heading',
	    'headlamp',
	    'headless',
	    'headlock',
	    'headphone',
	    'headpiece',
	    'headrest',
	    'headroom',
	    'headscarf',
	    'headset',
	    'headsman',
	    'headstand',
	    'headstone',
	    'headway',
	    'headwear',
	    'heap',
	    'heat',
	    'heave',
	    'heavily',
	    'heaviness',
	    'heaving',
	    'hedge',
	    'hedging',
	    'heftiness',
	    'hefty',
	    'helium',
	    'helmet',
	    'helper',
	    'helpful',
	    'helping',
	    'helpless',
	    'helpline',
	    'hemlock',
	    'hemstitch',
	    'hence',
	    'henchman',
	    'henna',
	    'herald',
	    'herbal',
	    'herbicide',
	    'herbs',
	    'heritage',
	    'hermit',
	    'heroics',
	    'heroism',
	    'herring',
	    'herself',
	    'hertz',
	    'hesitancy',
	    'hesitant',
	    'hesitate',
	    'hexagon',
	    'hexagram',
	    'hubcap',
	    'huddle',
	    'huddling',
	    'huff',
	    'hug',
	    'hula',
	    'hulk',
	    'hull',
	    'human',
	    'humble',
	    'humbling',
	    'humbly',
	    'humid',
	    'humiliate',
	    'humility',
	    'humming',
	    'hummus',
	    'humongous',
	    'humorist',
	    'humorless',
	    'humorous',
	    'humpback',
	    'humped',
	    'humvee',
	    'hunchback',
	    'hundredth',
	    'hunger',
	    'hungrily',
	    'hungry',
	    'hunk',
	    'hunter',
	    'hunting',
	    'huntress',
	    'huntsman',
	    'hurdle',
	    'hurled',
	    'hurler',
	    'hurling',
	    'hurray',
	    'hurricane',
	    'hurried',
	    'hurry',
	    'hurt',
	    'husband',
	    'hush',
	    'husked',
	    'huskiness',
	    'hut',
	    'hybrid',
	    'hydrant',
	    'hydrated',
	    'hydration',
	    'hydrogen',
	    'hydroxide',
	    'hyperlink',
	    'hypertext',
	    'hyphen',
	    'hypnoses',
	    'hypnosis',
	    'hypnotic',
	    'hypnotism',
	    'hypnotist',
	    'hypnotize',
	    'hypocrisy',
	    'hypocrite',
	    'ibuprofen',
	    'ice',
	    'iciness',
	    'icing',
	    'icky',
	    'icon',
	    'icy',
	    'idealism',
	    'idealist',
	    'idealize',
	    'ideally',
	    'idealness',
	    'identical',
	    'identify',
	    'identity',
	    'ideology',
	    'idiocy',
	    'idiom',
	    'idly',
	    'igloo',
	    'ignition',
	    'ignore',
	    'iguana',
	    'illicitly',
	    'illusion',
	    'illusive',
	    'image',
	    'imaginary',
	    'imagines',
	    'imaging',
	    'imbecile',
	    'imitate',
	    'imitation',
	    'immature',
	    'immerse',
	    'immersion',
	    'imminent',
	    'immobile',
	    'immodest',
	    'immorally',
	    'immortal',
	    'immovable',
	    'immovably',
	    'immunity',
	    'immunize',
	    'impaired',
	    'impale',
	    'impart',
	    'impatient',
	    'impeach',
	    'impeding',
	    'impending',
	    'imperfect',
	    'imperial',
	    'impish',
	    'implant',
	    'implement',
	    'implicate',
	    'implicit',
	    'implode',
	    'implosion',
	    'implosive',
	    'imply',
	    'impolite',
	    'important',
	    'importer',
	    'impose',
	    'imposing',
	    'impotence',
	    'impotency',
	    'impotent',
	    'impound',
	    'imprecise',
	    'imprint',
	    'imprison',
	    'impromptu',
	    'improper',
	    'improve',
	    'improving',
	    'improvise',
	    'imprudent',
	    'impulse',
	    'impulsive',
	    'impure',
	    'impurity',
	    'iodine',
	    'iodize',
	    'ion',
	    'ipad',
	    'iphone',
	    'ipod',
	    'irate',
	    'irk',
	    'iron',
	    'irregular',
	    'irrigate',
	    'irritable',
	    'irritably',
	    'irritant',
	    'irritate',
	    'islamic',
	    'islamist',
	    'isolated',
	    'isolating',
	    'isolation',
	    'isotope',
	    'issue',
	    'issuing',
	    'italicize',
	    'italics',
	    'item',
	    'itinerary',
	    'itunes',
	    'ivory',
	    'ivy',
	    'jab',
	    'jackal',
	    'jacket',
	    'jackknife',
	    'jackpot',
	    'jailbird',
	    'jailbreak',
	    'jailer',
	    'jailhouse',
	    'jalapeno',
	    'jam',
	    'janitor',
	    'january',
	    'jargon',
	    'jarring',
	    'jasmine',
	    'jaundice',
	    'jaunt',
	    'java',
	    'jawed',
	    'jawless',
	    'jawline',
	    'jaws',
	    'jaybird',
	    'jaywalker',
	    'jazz',
	    'jeep',
	    'jeeringly',
	    'jellied',
	    'jelly',
	    'jersey',
	    'jester',
	    'jet',
	    'jiffy',
	    'jigsaw',
	    'jimmy',
	    'jingle',
	    'jingling',
	    'jinx',
	    'jitters',
	    'jittery',
	    'job',
	    'jockey',
	    'jockstrap',
	    'jogger',
	    'jogging',
	    'john',
	    'joining',
	    'jokester',
	    'jokingly',
	    'jolliness',
	    'jolly',
	    'jolt',
	    'jot',
	    'jovial',
	    'joyfully',
	    'joylessly',
	    'joyous',
	    'joyride',
	    'joystick',
	    'jubilance',
	    'jubilant',
	    'judge',
	    'judgingly',
	    'judicial',
	    'judiciary',
	    'judo',
	    'juggle',
	    'juggling',
	    'jugular',
	    'juice',
	    'juiciness',
	    'juicy',
	    'jujitsu',
	    'jukebox',
	    'july',
	    'jumble',
	    'jumbo',
	    'jump',
	    'junction',
	    'juncture',
	    'june',
	    'junior',
	    'juniper',
	    'junkie',
	    'junkman',
	    'junkyard',
	    'jurist',
	    'juror',
	    'jury',
	    'justice',
	    'justifier',
	    'justify',
	    'justly',
	    'justness',
	    'juvenile',
	    'kabob',
	    'kangaroo',
	    'karaoke',
	    'karate',
	    'karma',
	    'kebab',
	    'keenly',
	    'keenness',
	    'keep',
	    'keg',
	    'kelp',
	    'kennel',
	    'kept',
	    'kerchief',
	    'kerosene',
	    'kettle',
	    'kick',
	    'kiln',
	    'kilobyte',
	    'kilogram',
	    'kilometer',
	    'kilowatt',
	    'kilt',
	    'kimono',
	    'kindle',
	    'kindling',
	    'kindly',
	    'kindness',
	    'kindred',
	    'kinetic',
	    'kinfolk',
	    'king',
	    'kinship',
	    'kinsman',
	    'kinswoman',
	    'kissable',
	    'kisser',
	    'kissing',
	    'kitchen',
	    'kite',
	    'kitten',
	    'kitty',
	    'kiwi',
	    'kleenex',
	    'knapsack',
	    'knee',
	    'knelt',
	    'knickers',
	    'knoll',
	    'koala',
	    'kooky',
	    'kosher',
	    'krypton',
	    'kudos',
	    'kung',
	    'labored',
	    'laborer',
	    'laboring',
	    'laborious',
	    'labrador',
	    'ladder',
	    'ladies',
	    'ladle',
	    'ladybug',
	    'ladylike',
	    'lagged',
	    'lagging',
	    'lagoon',
	    'lair',
	    'lake',
	    'lance',
	    'landed',
	    'landfall',
	    'landfill',
	    'landing',
	    'landlady',
	    'landless',
	    'landline',
	    'landlord',
	    'landmark',
	    'landmass',
	    'landmine',
	    'landowner',
	    'landscape',
	    'landside',
	    'landslide',
	    'language',
	    'lankiness',
	    'lanky',
	    'lantern',
	    'lapdog',
	    'lapel',
	    'lapped',
	    'lapping',
	    'laptop',
	    'lard',
	    'large',
	    'lark',
	    'lash',
	    'lasso',
	    'last',
	    'latch',
	    'late',
	    'lather',
	    'latitude',
	    'latrine',
	    'latter',
	    'latticed',
	    'launch',
	    'launder',
	    'laundry',
	    'laurel',
	    'lavender',
	    'lavish',
	    'laxative',
	    'lazily',
	    'laziness',
	    'lazy',
	    'lecturer',
	    'left',
	    'legacy',
	    'legal',
	    'legend',
	    'legged',
	    'leggings',
	    'legible',
	    'legibly',
	    'legislate',
	    'lego',
	    'legroom',
	    'legume',
	    'legwarmer',
	    'legwork',
	    'lemon',
	    'lend',
	    'length',
	    'lens',
	    'lent',
	    'leotard',
	    'lesser',
	    'letdown',
	    'lethargic',
	    'lethargy',
	    'letter',
	    'lettuce',
	    'level',
	    'leverage',
	    'levers',
	    'levitate',
	    'levitator',
	    'liability',
	    'liable',
	    'liberty',
	    'librarian',
	    'library',
	    'licking',
	    'licorice',
	    'lid',
	    'life',
	    'lifter',
	    'lifting',
	    'liftoff',
	    'ligament',
	    'likely',
	    'likeness',
	    'likewise',
	    'liking',
	    'lilac',
	    'lilly',
	    'lily',
	    'limb',
	    'limeade',
	    'limelight',
	    'limes',
	    'limit',
	    'limping',
	    'limpness',
	    'line',
	    'lingo',
	    'linguini',
	    'linguist',
	    'lining',
	    'linked',
	    'linoleum',
	    'linseed',
	    'lint',
	    'lion',
	    'lip',
	    'liquefy',
	    'liqueur',
	    'liquid',
	    'lisp',
	    'list',
	    'litigate',
	    'litigator',
	    'litmus',
	    'litter',
	    'little',
	    'livable',
	    'lived',
	    'lively',
	    'liver',
	    'livestock',
	    'lividly',
	    'living',
	    'lizard',
	    'lubricant',
	    'lubricate',
	    'lucid',
	    'luckily',
	    'luckiness',
	    'luckless',
	    'lucrative',
	    'ludicrous',
	    'lugged',
	    'lukewarm',
	    'lullaby',
	    'lumber',
	    'luminance',
	    'luminous',
	    'lumpiness',
	    'lumping',
	    'lumpish',
	    'lunacy',
	    'lunar',
	    'lunchbox',
	    'luncheon',
	    'lunchroom',
	    'lunchtime',
	    'lung',
	    'lurch',
	    'lure',
	    'luridness',
	    'lurk',
	    'lushly',
	    'lushness',
	    'luster',
	    'lustfully',
	    'lustily',
	    'lustiness',
	    'lustrous',
	    'lusty',
	    'luxurious',
	    'luxury',
	    'lying',
	    'lyrically',
	    'lyricism',
	    'lyricist',
	    'lyrics',
	    'macarena',
	    'macaroni',
	    'macaw',
	    'mace',
	    'machine',
	    'machinist',
	    'magazine',
	    'magenta',
	    'maggot',
	    'magical',
	    'magician',
	    'magma',
	    'magnesium',
	    'magnetic',
	    'magnetism',
	    'magnetize',
	    'magnifier',
	    'magnify',
	    'magnitude',
	    'magnolia',
	    'mahogany',
	    'maimed',
	    'majestic',
	    'majesty',
	    'majorette',
	    'majority',
	    'makeover',
	    'maker',
	    'makeshift',
	    'making',
	    'malformed',
	    'malt',
	    'mama',
	    'mammal',
	    'mammary',
	    'mammogram',
	    'manager',
	    'managing',
	    'manatee',
	    'mandarin',
	    'mandate',
	    'mandatory',
	    'mandolin',
	    'manger',
	    'mangle',
	    'mango',
	    'mangy',
	    'manhandle',
	    'manhole',
	    'manhood',
	    'manhunt',
	    'manicotti',
	    'manicure',
	    'manifesto',
	    'manila',
	    'mankind',
	    'manlike',
	    'manliness',
	    'manly',
	    'manmade',
	    'manned',
	    'mannish',
	    'manor',
	    'manpower',
	    'mantis',
	    'mantra',
	    'manual',
	    'many',
	    'map',
	    'marathon',
	    'marauding',
	    'marbled',
	    'marbles',
	    'marbling',
	    'march',
	    'mardi',
	    'margarine',
	    'margarita',
	    'margin',
	    'marigold',
	    'marina',
	    'marine',
	    'marital',
	    'maritime',
	    'marlin',
	    'marmalade',
	    'maroon',
	    'married',
	    'marrow',
	    'marry',
	    'marshland',
	    'marshy',
	    'marsupial',
	    'marvelous',
	    'marxism',
	    'mascot',
	    'masculine',
	    'mashed',
	    'mashing',
	    'massager',
	    'masses',
	    'massive',
	    'mastiff',
	    'matador',
	    'matchbook',
	    'matchbox',
	    'matcher',
	    'matching',
	    'matchless',
	    'material',
	    'maternal',
	    'maternity',
	    'math',
	    'mating',
	    'matriarch',
	    'matrimony',
	    'matrix',
	    'matron',
	    'matted',
	    'matter',
	    'maturely',
	    'maturing',
	    'maturity',
	    'mauve',
	    'maverick',
	    'maximize',
	    'maximum',
	    'maybe',
	    'mayday',
	    'mayflower',
	    'moaner',
	    'moaning',
	    'mobile',
	    'mobility',
	    'mobilize',
	    'mobster',
	    'mocha',
	    'mocker',
	    'mockup',
	    'modified',
	    'modify',
	    'modular',
	    'modulator',
	    'module',
	    'moisten',
	    'moistness',
	    'moisture',
	    'molar',
	    'molasses',
	    'mold',
	    'molecular',
	    'molecule',
	    'molehill',
	    'mollusk',
	    'mom',
	    'monastery',
	    'monday',
	    'monetary',
	    'monetize',
	    'moneybags',
	    'moneyless',
	    'moneywise',
	    'mongoose',
	    'mongrel',
	    'monitor',
	    'monkhood',
	    'monogamy',
	    'monogram',
	    'monologue',
	    'monopoly',
	    'monorail',
	    'monotone',
	    'monotype',
	    'monoxide',
	    'monsieur',
	    'monsoon',
	    'monstrous',
	    'monthly',
	    'monument',
	    'moocher',
	    'moodiness',
	    'moody',
	    'mooing',
	    'moonbeam',
	    'mooned',
	    'moonlight',
	    'moonlike',
	    'moonlit',
	    'moonrise',
	    'moonscape',
	    'moonshine',
	    'moonstone',
	    'moonwalk',
	    'mop',
	    'morale',
	    'morality',
	    'morally',
	    'morbidity',
	    'morbidly',
	    'morphine',
	    'morphing',
	    'morse',
	    'mortality',
	    'mortally',
	    'mortician',
	    'mortified',
	    'mortify',
	    'mortuary',
	    'mosaic',
	    'mossy',
	    'most',
	    'mothball',
	    'mothproof',
	    'motion',
	    'motivate',
	    'motivator',
	    'motive',
	    'motocross',
	    'motor',
	    'motto',
	    'mountable',
	    'mountain',
	    'mounted',
	    'mounting',
	    'mourner',
	    'mournful',
	    'mouse',
	    'mousiness',
	    'moustache',
	    'mousy',
	    'mouth',
	    'movable',
	    'move',
	    'movie',
	    'moving',
	    'mower',
	    'mowing',
	    'much',
	    'muck',
	    'mud',
	    'mug',
	    'mulberry',
	    'mulch',
	    'mule',
	    'mulled',
	    'mullets',
	    'multiple',
	    'multiply',
	    'multitask',
	    'multitude',
	    'mumble',
	    'mumbling',
	    'mumbo',
	    'mummified',
	    'mummify',
	    'mummy',
	    'mumps',
	    'munchkin',
	    'mundane',
	    'municipal',
	    'muppet',
	    'mural',
	    'murkiness',
	    'murky',
	    'murmuring',
	    'muscular',
	    'museum',
	    'mushily',
	    'mushiness',
	    'mushroom',
	    'mushy',
	    'music',
	    'musket',
	    'muskiness',
	    'musky',
	    'mustang',
	    'mustard',
	    'muster',
	    'mustiness',
	    'musty',
	    'mutable',
	    'mutate',
	    'mutation',
	    'mute',
	    'mutilated',
	    'mutilator',
	    'mutiny',
	    'mutt',
	    'mutual',
	    'muzzle',
	    'myself',
	    'myspace',
	    'mystified',
	    'mystify',
	    'myth',
	    'nacho',
	    'nag',
	    'nail',
	    'name',
	    'naming',
	    'nanny',
	    'nanometer',
	    'nape',
	    'napkin',
	    'napped',
	    'napping',
	    'nappy',
	    'narrow',
	    'nastily',
	    'nastiness',
	    'national',
	    'native',
	    'nativity',
	    'natural',
	    'nature',
	    'naturist',
	    'nautical',
	    'navigate',
	    'navigator',
	    'navy',
	    'nearby',
	    'nearest',
	    'nearly',
	    'nearness',
	    'neatly',
	    'neatness',
	    'nebula',
	    'nebulizer',
	    'nectar',
	    'negate',
	    'negation',
	    'negative',
	    'neglector',
	    'negligee',
	    'negligent',
	    'negotiate',
	    'nemeses',
	    'nemesis',
	    'neon',
	    'nephew',
	    'nerd',
	    'nervous',
	    'nervy',
	    'nest',
	    'net',
	    'neurology',
	    'neuron',
	    'neurosis',
	    'neurotic',
	    'neuter',
	    'neutron',
	    'never',
	    'next',
	    'nibble',
	    'nickname',
	    'nicotine',
	    'niece',
	    'nifty',
	    'nimble',
	    'nimbly',
	    'nineteen',
	    'ninetieth',
	    'ninja',
	    'nintendo',
	    'ninth',
	    'nuclear',
	    'nuclei',
	    'nucleus',
	    'nugget',
	    'nullify',
	    'number',
	    'numbing',
	    'numbly',
	    'numbness',
	    'numeral',
	    'numerate',
	    'numerator',
	    'numeric',
	    'numerous',
	    'nuptials',
	    'nursery',
	    'nursing',
	    'nurture',
	    'nutcase',
	    'nutlike',
	    'nutmeg',
	    'nutrient',
	    'nutshell',
	    'nuttiness',
	    'nutty',
	    'nuzzle',
	    'nylon',
	    'oaf',
	    'oak',
	    'oasis',
	    'oat',
	    'obedience',
	    'obedient',
	    'obituary',
	    'object',
	    'obligate',
	    'obliged',
	    'oblivion',
	    'oblivious',
	    'oblong',
	    'obnoxious',
	    'oboe',
	    'obscure',
	    'obscurity',
	    'observant',
	    'observer',
	    'observing',
	    'obsessed',
	    'obsession',
	    'obsessive',
	    'obsolete',
	    'obstacle',
	    'obstinate',
	    'obstruct',
	    'obtain',
	    'obtrusive',
	    'obtuse',
	    'obvious',
	    'occultist',
	    'occupancy',
	    'occupant',
	    'occupier',
	    'occupy',
	    'ocean',
	    'ocelot',
	    'octagon',
	    'octane',
	    'october',
	    'octopus',
	    'ogle',
	    'oil',
	    'oink',
	    'ointment',
	    'okay',
	    'old',
	    'olive',
	    'olympics',
	    'omega',
	    'omen',
	    'ominous',
	    'omission',
	    'omit',
	    'omnivore',
	    'onboard',
	    'oncoming',
	    'ongoing',
	    'onion',
	    'online',
	    'onlooker',
	    'only',
	    'onscreen',
	    'onset',
	    'onshore',
	    'onslaught',
	    'onstage',
	    'onto',
	    'onward',
	    'onyx',
	    'oops',
	    'ooze',
	    'oozy',
	    'opacity',
	    'opal',
	    'open',
	    'operable',
	    'operate',
	    'operating',
	    'operation',
	    'operative',
	    'operator',
	    'opium',
	    'opossum',
	    'opponent',
	    'oppose',
	    'opposing',
	    'opposite',
	    'oppressed',
	    'oppressor',
	    'opt',
	    'opulently',
	    'osmosis',
	    'other',
	    'otter',
	    'ouch',
	    'ought',
	    'ounce',
	    'outage',
	    'outback',
	    'outbid',
	    'outboard',
	    'outbound',
	    'outbreak',
	    'outburst',
	    'outcast',
	    'outclass',
	    'outcome',
	    'outdated',
	    'outdoors',
	    'outer',
	    'outfield',
	    'outfit',
	    'outflank',
	    'outgoing',
	    'outgrow',
	    'outhouse',
	    'outing',
	    'outlast',
	    'outlet',
	    'outline',
	    'outlook',
	    'outlying',
	    'outmatch',
	    'outmost',
	    'outnumber',
	    'outplayed',
	    'outpost',
	    'outpour',
	    'output',
	    'outrage',
	    'outrank',
	    'outreach',
	    'outright',
	    'outscore',
	    'outsell',
	    'outshine',
	    'outshoot',
	    'outsider',
	    'outskirts',
	    'outsmart',
	    'outsource',
	    'outspoken',
	    'outtakes',
	    'outthink',
	    'outward',
	    'outweigh',
	    'outwit',
	    'oval',
	    'ovary',
	    'oven',
	    'overact',
	    'overall',
	    'overarch',
	    'overbid',
	    'overbill',
	    'overbite',
	    'overblown',
	    'overboard',
	    'overbook',
	    'overbuilt',
	    'overcast',
	    'overcoat',
	    'overcome',
	    'overcook',
	    'overcrowd',
	    'overdraft',
	    'overdrawn',
	    'overdress',
	    'overdrive',
	    'overdue',
	    'overeager',
	    'overeater',
	    'overexert',
	    'overfed',
	    'overfeed',
	    'overfill',
	    'overflow',
	    'overfull',
	    'overgrown',
	    'overhand',
	    'overhang',
	    'overhaul',
	    'overhead',
	    'overhear',
	    'overheat',
	    'overhung',
	    'overjoyed',
	    'overkill',
	    'overlabor',
	    'overlaid',
	    'overlap',
	    'overlay',
	    'overload',
	    'overlook',
	    'overlord',
	    'overlying',
	    'overnight',
	    'overpass',
	    'overpay',
	    'overplant',
	    'overplay',
	    'overpower',
	    'overprice',
	    'overrate',
	    'overreach',
	    'overreact',
	    'override',
	    'overripe',
	    'overrule',
	    'overrun',
	    'overshoot',
	    'overshot',
	    'oversight',
	    'oversized',
	    'oversleep',
	    'oversold',
	    'overspend',
	    'overstate',
	    'overstay',
	    'overstep',
	    'overstock',
	    'overstuff',
	    'oversweet',
	    'overtake',
	    'overthrow',
	    'overtime',
	    'overtly',
	    'overtone',
	    'overture',
	    'overturn',
	    'overuse',
	    'overvalue',
	    'overview',
	    'overwrite',
	    'owl',
	    'oxford',
	    'oxidant',
	    'oxidation',
	    'oxidize',
	    'oxidizing',
	    'oxygen',
	    'oxymoron',
	    'oyster',
	    'ozone',
	    'paced',
	    'pacemaker',
	    'pacific',
	    'pacifier',
	    'pacifism',
	    'pacifist',
	    'pacify',
	    'padded',
	    'padding',
	    'paddle',
	    'paddling',
	    'padlock',
	    'pagan',
	    'pager',
	    'paging',
	    'pajamas',
	    'palace',
	    'palatable',
	    'palm',
	    'palpable',
	    'palpitate',
	    'paltry',
	    'pampered',
	    'pamperer',
	    'pampers',
	    'pamphlet',
	    'panama',
	    'pancake',
	    'pancreas',
	    'panda',
	    'pandemic',
	    'pang',
	    'panhandle',
	    'panic',
	    'panning',
	    'panorama',
	    'panoramic',
	    'panther',
	    'pantomime',
	    'pantry',
	    'pants',
	    'pantyhose',
	    'paparazzi',
	    'papaya',
	    'paper',
	    'paprika',
	    'papyrus',
	    'parabola',
	    'parachute',
	    'parade',
	    'paradox',
	    'paragraph',
	    'parakeet',
	    'paralegal',
	    'paralyses',
	    'paralysis',
	    'paralyze',
	    'paramedic',
	    'parameter',
	    'paramount',
	    'parasail',
	    'parasite',
	    'parasitic',
	    'parcel',
	    'parched',
	    'parchment',
	    'pardon',
	    'parish',
	    'parka',
	    'parking',
	    'parkway',
	    'parlor',
	    'parmesan',
	    'parole',
	    'parrot',
	    'parsley',
	    'parsnip',
	    'partake',
	    'parted',
	    'parting',
	    'partition',
	    'partly',
	    'partner',
	    'partridge',
	    'party',
	    'passable',
	    'passably',
	    'passage',
	    'passcode',
	    'passenger',
	    'passerby',
	    'passing',
	    'passion',
	    'passive',
	    'passivism',
	    'passover',
	    'passport',
	    'password',
	    'pasta',
	    'pasted',
	    'pastel',
	    'pastime',
	    'pastor',
	    'pastrami',
	    'pasture',
	    'pasty',
	    'patchwork',
	    'patchy',
	    'paternal',
	    'paternity',
	    'path',
	    'patience',
	    'patient',
	    'patio',
	    'patriarch',
	    'patriot',
	    'patrol',
	    'patronage',
	    'patronize',
	    'pauper',
	    'pavement',
	    'paver',
	    'pavestone',
	    'pavilion',
	    'paving',
	    'pawing',
	    'payable',
	    'payback',
	    'paycheck',
	    'payday',
	    'payee',
	    'payer',
	    'paying',
	    'payment',
	    'payphone',
	    'payroll',
	    'pebble',
	    'pebbly',
	    'pecan',
	    'pectin',
	    'peculiar',
	    'peddling',
	    'pediatric',
	    'pedicure',
	    'pedigree',
	    'pedometer',
	    'pegboard',
	    'pelican',
	    'pellet',
	    'pelt',
	    'pelvis',
	    'penalize',
	    'penalty',
	    'pencil',
	    'pendant',
	    'pending',
	    'penholder',
	    'penknife',
	    'pennant',
	    'penniless',
	    'penny',
	    'penpal',
	    'pension',
	    'pentagon',
	    'pentagram',
	    'pep',
	    'perceive',
	    'percent',
	    'perch',
	    'percolate',
	    'perennial',
	    'perfected',
	    'perfectly',
	    'perfume',
	    'periscope',
	    'perish',
	    'perjurer',
	    'perjury',
	    'perkiness',
	    'perky',
	    'perm',
	    'peroxide',
	    'perpetual',
	    'perplexed',
	    'persecute',
	    'persevere',
	    'persuaded',
	    'persuader',
	    'pesky',
	    'peso',
	    'pessimism',
	    'pessimist',
	    'pester',
	    'pesticide',
	    'petal',
	    'petite',
	    'petition',
	    'petri',
	    'petroleum',
	    'petted',
	    'petticoat',
	    'pettiness',
	    'petty',
	    'petunia',
	    'phantom',
	    'phobia',
	    'phoenix',
	    'phonebook',
	    'phoney',
	    'phonics',
	    'phoniness',
	    'phony',
	    'phosphate',
	    'photo',
	    'phrase',
	    'phrasing',
	    'placard',
	    'placate',
	    'placidly',
	    'plank',
	    'planner',
	    'plant',
	    'plasma',
	    'plaster',
	    'plastic',
	    'plated',
	    'platform',
	    'plating',
	    'platinum',
	    'platonic',
	    'platter',
	    'platypus',
	    'plausible',
	    'plausibly',
	    'playable',
	    'playback',
	    'player',
	    'playful',
	    'playgroup',
	    'playhouse',
	    'playing',
	    'playlist',
	    'playmaker',
	    'playmate',
	    'playoff',
	    'playpen',
	    'playroom',
	    'playset',
	    'plaything',
	    'playtime',
	    'plaza',
	    'pleading',
	    'pleat',
	    'pledge',
	    'plentiful',
	    'plenty',
	    'plethora',
	    'plexiglas',
	    'pliable',
	    'plod',
	    'plop',
	    'plot',
	    'plow',
	    'ploy',
	    'pluck',
	    'plug',
	    'plunder',
	    'plunging',
	    'plural',
	    'plus',
	    'plutonium',
	    'plywood',
	    'poach',
	    'pod',
	    'poem',
	    'poet',
	    'pogo',
	    'pointed',
	    'pointer',
	    'pointing',
	    'pointless',
	    'pointy',
	    'poise',
	    'poison',
	    'poker',
	    'poking',
	    'polar',
	    'police',
	    'policy',
	    'polio',
	    'polish',
	    'politely',
	    'polka',
	    'polo',
	    'polyester',
	    'polygon',
	    'polygraph',
	    'polymer',
	    'poncho',
	    'pond',
	    'pony',
	    'popcorn',
	    'pope',
	    'poplar',
	    'popper',
	    'poppy',
	    'popsicle',
	    'populace',
	    'popular',
	    'populate',
	    'porcupine',
	    'pork',
	    'porous',
	    'porridge',
	    'portable',
	    'portal',
	    'portfolio',
	    'porthole',
	    'portion',
	    'portly',
	    'portside',
	    'poser',
	    'posh',
	    'posing',
	    'possible',
	    'possibly',
	    'possum',
	    'postage',
	    'postal',
	    'postbox',
	    'postcard',
	    'posted',
	    'poster',
	    'posting',
	    'postnasal',
	    'posture',
	    'postwar',
	    'pouch',
	    'pounce',
	    'pouncing',
	    'pound',
	    'pouring',
	    'pout',
	    'powdered',
	    'powdering',
	    'powdery',
	    'power',
	    'powwow',
	    'pox',
	    'praising',
	    'prance',
	    'prancing',
	    'pranker',
	    'prankish',
	    'prankster',
	    'prayer',
	    'praying',
	    'preacher',
	    'preaching',
	    'preachy',
	    'preamble',
	    'precinct',
	    'precise',
	    'precision',
	    'precook',
	    'precut',
	    'predator',
	    'predefine',
	    'predict',
	    'preface',
	    'prefix',
	    'preflight',
	    'preformed',
	    'pregame',
	    'pregnancy',
	    'pregnant',
	    'preheated',
	    'prelaunch',
	    'prelaw',
	    'prelude',
	    'premiere',
	    'premises',
	    'premium',
	    'prenatal',
	    'preoccupy',
	    'preorder',
	    'prepaid',
	    'prepay',
	    'preplan',
	    'preppy',
	    'preschool',
	    'prescribe',
	    'preseason',
	    'preset',
	    'preshow',
	    'president',
	    'presoak',
	    'press',
	    'presume',
	    'presuming',
	    'preteen',
	    'pretended',
	    'pretender',
	    'pretense',
	    'pretext',
	    'pretty',
	    'pretzel',
	    'prevail',
	    'prevalent',
	    'prevent',
	    'preview',
	    'previous',
	    'prewar',
	    'prewashed',
	    'prideful',
	    'pried',
	    'primal',
	    'primarily',
	    'primary',
	    'primate',
	    'primer',
	    'primp',
	    'princess',
	    'print',
	    'prior',
	    'prism',
	    'prison',
	    'prissy',
	    'pristine',
	    'privacy',
	    'private',
	    'privatize',
	    'prize',
	    'proactive',
	    'probable',
	    'probably',
	    'probation',
	    'probe',
	    'probing',
	    'probiotic',
	    'problem',
	    'procedure',
	    'process',
	    'proclaim',
	    'procreate',
	    'procurer',
	    'prodigal',
	    'prodigy',
	    'produce',
	    'product',
	    'profane',
	    'profanity',
	    'professed',
	    'professor',
	    'profile',
	    'profound',
	    'profusely',
	    'progeny',
	    'prognosis',
	    'program',
	    'progress',
	    'projector',
	    'prologue',
	    'prolonged',
	    'promenade',
	    'prominent',
	    'promoter',
	    'promotion',
	    'prompter',
	    'promptly',
	    'prone',
	    'prong',
	    'pronounce',
	    'pronto',
	    'proofing',
	    'proofread',
	    'proofs',
	    'propeller',
	    'properly',
	    'property',
	    'proponent',
	    'proposal',
	    'propose',
	    'props',
	    'prorate',
	    'protector',
	    'protegee',
	    'proton',
	    'prototype',
	    'protozoan',
	    'protract',
	    'protrude',
	    'proud',
	    'provable',
	    'proved',
	    'proven',
	    'provided',
	    'provider',
	    'providing',
	    'province',
	    'proving',
	    'provoke',
	    'provoking',
	    'provolone',
	    'prowess',
	    'prowler',
	    'prowling',
	    'proximity',
	    'proxy',
	    'prozac',
	    'prude',
	    'prudishly',
	    'prune',
	    'pruning',
	    'pry',
	    'psychic',
	    'public',
	    'publisher',
	    'pucker',
	    'pueblo',
	    'pug',
	    'pull',
	    'pulmonary',
	    'pulp',
	    'pulsate',
	    'pulse',
	    'pulverize',
	    'puma',
	    'pumice',
	    'pummel',
	    'punch',
	    'punctual',
	    'punctuate',
	    'punctured',
	    'pungent',
	    'punisher',
	    'punk',
	    'pupil',
	    'puppet',
	    'puppy',
	    'purchase',
	    'pureblood',
	    'purebred',
	    'purely',
	    'pureness',
	    'purgatory',
	    'purge',
	    'purging',
	    'purifier',
	    'purify',
	    'purist',
	    'puritan',
	    'purity',
	    'purple',
	    'purplish',
	    'purposely',
	    'purr',
	    'purse',
	    'pursuable',
	    'pursuant',
	    'pursuit',
	    'purveyor',
	    'pushcart',
	    'pushchair',
	    'pusher',
	    'pushiness',
	    'pushing',
	    'pushover',
	    'pushpin',
	    'pushup',
	    'pushy',
	    'putdown',
	    'putt',
	    'puzzle',
	    'puzzling',
	    'pyramid',
	    'pyromania',
	    'python',
	    'quack',
	    'quadrant',
	    'quail',
	    'quaintly',
	    'quake',
	    'quaking',
	    'qualified',
	    'qualifier',
	    'qualify',
	    'quality',
	    'qualm',
	    'quantum',
	    'quarrel',
	    'quarry',
	    'quartered',
	    'quarterly',
	    'quarters',
	    'quartet',
	    'quench',
	    'query',
	    'quicken',
	    'quickly',
	    'quickness',
	    'quicksand',
	    'quickstep',
	    'quiet',
	    'quill',
	    'quilt',
	    'quintet',
	    'quintuple',
	    'quirk',
	    'quit',
	    'quiver',
	    'quizzical',
	    'quotable',
	    'quotation',
	    'quote',
	    'rabid',
	    'race',
	    'racing',
	    'racism',
	    'rack',
	    'racoon',
	    'radar',
	    'radial',
	    'radiance',
	    'radiantly',
	    'radiated',
	    'radiation',
	    'radiator',
	    'radio',
	    'radish',
	    'raffle',
	    'raft',
	    'rage',
	    'ragged',
	    'raging',
	    'ragweed',
	    'raider',
	    'railcar',
	    'railing',
	    'railroad',
	    'railway',
	    'raisin',
	    'rake',
	    'raking',
	    'rally',
	    'ramble',
	    'rambling',
	    'ramp',
	    'ramrod',
	    'ranch',
	    'rancidity',
	    'random',
	    'ranged',
	    'ranger',
	    'ranging',
	    'ranked',
	    'ranking',
	    'ransack',
	    'ranting',
	    'rants',
	    'rare',
	    'rarity',
	    'rascal',
	    'rash',
	    'rasping',
	    'ravage',
	    'raven',
	    'ravine',
	    'raving',
	    'ravioli',
	    'ravishing',
	    'reabsorb',
	    'reach',
	    'reacquire',
	    'reaction',
	    'reactive',
	    'reactor',
	    'reaffirm',
	    'ream',
	    'reanalyze',
	    'reappear',
	    'reapply',
	    'reappoint',
	    'reapprove',
	    'rearrange',
	    'rearview',
	    'reason',
	    'reassign',
	    'reassure',
	    'reattach',
	    'reawake',
	    'rebalance',
	    'rebate',
	    'rebel',
	    'rebirth',
	    'reboot',
	    'reborn',
	    'rebound',
	    'rebuff',
	    'rebuild',
	    'rebuilt',
	    'reburial',
	    'rebuttal',
	    'recall',
	    'recant',
	    'recapture',
	    'recast',
	    'recede',
	    'recent',
	    'recess',
	    'recharger',
	    'recipient',
	    'recital',
	    'recite',
	    'reckless',
	    'reclaim',
	    'recliner',
	    'reclining',
	    'recluse',
	    'reclusive',
	    'recognize',
	    'recoil',
	    'recollect',
	    'recolor',
	    'reconcile',
	    'reconfirm',
	    'reconvene',
	    'recopy',
	    'record',
	    'recount',
	    'recoup',
	    'recovery',
	    'recreate',
	    'rectal',
	    'rectangle',
	    'rectified',
	    'rectify',
	    'recycled',
	    'recycler',
	    'recycling',
	    'reemerge',
	    'reenact',
	    'reenter',
	    'reentry',
	    'reexamine',
	    'referable',
	    'referee',
	    'reference',
	    'refill',
	    'refinance',
	    'refined',
	    'refinery',
	    'refining',
	    'refinish',
	    'reflected',
	    'reflector',
	    'reflex',
	    'reflux',
	    'refocus',
	    'refold',
	    'reforest',
	    'reformat',
	    'reformed',
	    'reformer',
	    'reformist',
	    'refract',
	    'refrain',
	    'refreeze',
	    'refresh',
	    'refried',
	    'refueling',
	    'refund',
	    'refurbish',
	    'refurnish',
	    'refusal',
	    'refuse',
	    'refusing',
	    'refutable',
	    'refute',
	    'regain',
	    'regalia',
	    'regally',
	    'reggae',
	    'regime',
	    'region',
	    'register',
	    'registrar',
	    'registry',
	    'regress',
	    'regretful',
	    'regroup',
	    'regular',
	    'regulate',
	    'regulator',
	    'rehab',
	    'reheat',
	    'rehire',
	    'rehydrate',
	    'reimburse',
	    'reissue',
	    'reiterate',
	    'rejoice',
	    'rejoicing',
	    'rejoin',
	    'rekindle',
	    'relapse',
	    'relapsing',
	    'relatable',
	    'related',
	    'relation',
	    'relative',
	    'relax',
	    'relay',
	    'relearn',
	    'release',
	    'relenting',
	    'reliable',
	    'reliably',
	    'reliance',
	    'reliant',
	    'relic',
	    'relieve',
	    'relieving',
	    'relight',
	    'relish',
	    'relive',
	    'reload',
	    'relocate',
	    'relock',
	    'reluctant',
	    'rely',
	    'remake',
	    'remark',
	    'remarry',
	    'rematch',
	    'remedial',
	    'remedy',
	    'remember',
	    'reminder',
	    'remindful',
	    'remission',
	    'remix',
	    'remnant',
	    'remodeler',
	    'remold',
	    'remorse',
	    'remote',
	    'removable',
	    'removal',
	    'removed',
	    'remover',
	    'removing',
	    'rename',
	    'renderer',
	    'rendering',
	    'rendition',
	    'renegade',
	    'renewable',
	    'renewably',
	    'renewal',
	    'renewed',
	    'renounce',
	    'renovate',
	    'renovator',
	    'rentable',
	    'rental',
	    'rented',
	    'renter',
	    'reoccupy',
	    'reoccur',
	    'reopen',
	    'reorder',
	    'repackage',
	    'repacking',
	    'repaint',
	    'repair',
	    'repave',
	    'repaying',
	    'repayment',
	    'repeal',
	    'repeated',
	    'repeater',
	    'repent',
	    'rephrase',
	    'replace',
	    'replay',
	    'replica',
	    'reply',
	    'reporter',
	    'repose',
	    'repossess',
	    'repost',
	    'repressed',
	    'reprimand',
	    'reprint',
	    'reprise',
	    'reproach',
	    'reprocess',
	    'reproduce',
	    'reprogram',
	    'reps',
	    'reptile',
	    'reptilian',
	    'repugnant',
	    'repulsion',
	    'repulsive',
	    'repurpose',
	    'reputable',
	    'reputably',
	    'request',
	    'require',
	    'requisite',
	    'reroute',
	    'rerun',
	    'resale',
	    'resample',
	    'rescuer',
	    'reseal',
	    'research',
	    'reselect',
	    'reseller',
	    'resemble',
	    'resend',
	    'resent',
	    'reset',
	    'reshape',
	    'reshoot',
	    'reshuffle',
	    'residence',
	    'residency',
	    'resident',
	    'residual',
	    'residue',
	    'resigned',
	    'resilient',
	    'resistant',
	    'resisting',
	    'resize',
	    'resolute',
	    'resolved',
	    'resonant',
	    'resonate',
	    'resort',
	    'resource',
	    'respect',
	    'resubmit',
	    'result',
	    'resume',
	    'resupply',
	    'resurface',
	    'resurrect',
	    'retail',
	    'retainer',
	    'retaining',
	    'retake',
	    'retaliate',
	    'retention',
	    'rethink',
	    'retinal',
	    'retired',
	    'retiree',
	    'retiring',
	    'retold',
	    'retool',
	    'retorted',
	    'retouch',
	    'retrace',
	    'retract',
	    'retrain',
	    'retread',
	    'retreat',
	    'retrial',
	    'retrieval',
	    'retriever',
	    'retry',
	    'return',
	    'retying',
	    'retype',
	    'reunion',
	    'reunite',
	    'reusable',
	    'reuse',
	    'reveal',
	    'reveler',
	    'revenge',
	    'revenue',
	    'reverb',
	    'revered',
	    'reverence',
	    'reverend',
	    'reversal',
	    'reverse',
	    'reversing',
	    'reversion',
	    'revert',
	    'revisable',
	    'revise',
	    'revision',
	    'revisit',
	    'revivable',
	    'revival',
	    'reviver',
	    'reviving',
	    'revocable',
	    'revoke',
	    'revolt',
	    'revolver',
	    'revolving',
	    'reward',
	    'rewash',
	    'rewind',
	    'rewire',
	    'reword',
	    'rework',
	    'rewrap',
	    'rewrite',
	    'rhyme',
	    'ribbon',
	    'ribcage',
	    'rice',
	    'riches',
	    'richly',
	    'richness',
	    'rickety',
	    'ricotta',
	    'riddance',
	    'ridden',
	    'ride',
	    'riding',
	    'rifling',
	    'rift',
	    'rigging',
	    'rigid',
	    'rigor',
	    'rimless',
	    'rimmed',
	    'rind',
	    'rink',
	    'rinse',
	    'rinsing',
	    'riot',
	    'ripcord',
	    'ripeness',
	    'ripening',
	    'ripping',
	    'ripple',
	    'rippling',
	    'riptide',
	    'rise',
	    'rising',
	    'risk',
	    'risotto',
	    'ritalin',
	    'ritzy',
	    'rival',
	    'riverbank',
	    'riverbed',
	    'riverboat',
	    'riverside',
	    'riveter',
	    'riveting',
	    'roamer',
	    'roaming',
	    'roast',
	    'robbing',
	    'robe',
	    'robin',
	    'robotics',
	    'robust',
	    'rockband',
	    'rocker',
	    'rocket',
	    'rockfish',
	    'rockiness',
	    'rocking',
	    'rocklike',
	    'rockslide',
	    'rockstar',
	    'rocky',
	    'rogue',
	    'roman',
	    'romp',
	    'rope',
	    'roping',
	    'roster',
	    'rosy',
	    'rotten',
	    'rotting',
	    'rotunda',
	    'roulette',
	    'rounding',
	    'roundish',
	    'roundness',
	    'roundup',
	    'roundworm',
	    'routine',
	    'routing',
	    'rover',
	    'roving',
	    'royal',
	    'rubbed',
	    'rubber',
	    'rubbing',
	    'rubble',
	    'rubdown',
	    'ruby',
	    'ruckus',
	    'rudder',
	    'rug',
	    'ruined',
	    'rule',
	    'rumble',
	    'rumbling',
	    'rummage',
	    'rumor',
	    'runaround',
	    'rundown',
	    'runner',
	    'running',
	    'runny',
	    'runt',
	    'runway',
	    'rupture',
	    'rural',
	    'ruse',
	    'rush',
	    'rust',
	    'rut',
	    'sabbath',
	    'sabotage',
	    'sacrament',
	    'sacred',
	    'sacrifice',
	    'sadden',
	    'saddlebag',
	    'saddled',
	    'saddling',
	    'sadly',
	    'sadness',
	    'safari',
	    'safeguard',
	    'safehouse',
	    'safely',
	    'safeness',
	    'saffron',
	    'saga',
	    'sage',
	    'sagging',
	    'saggy',
	    'said',
	    'saint',
	    'sake',
	    'salad',
	    'salami',
	    'salaried',
	    'salary',
	    'saline',
	    'salon',
	    'saloon',
	    'salsa',
	    'salt',
	    'salutary',
	    'salute',
	    'salvage',
	    'salvaging',
	    'salvation',
	    'same',
	    'sample',
	    'sampling',
	    'sanction',
	    'sanctity',
	    'sanctuary',
	    'sandal',
	    'sandbag',
	    'sandbank',
	    'sandbar',
	    'sandblast',
	    'sandbox',
	    'sanded',
	    'sandfish',
	    'sanding',
	    'sandlot',
	    'sandpaper',
	    'sandpit',
	    'sandstone',
	    'sandstorm',
	    'sandworm',
	    'sandy',
	    'sanitary',
	    'sanitizer',
	    'sank',
	    'santa',
	    'sapling',
	    'sappiness',
	    'sappy',
	    'sarcasm',
	    'sarcastic',
	    'sardine',
	    'sash',
	    'sasquatch',
	    'sassy',
	    'satchel',
	    'satiable',
	    'satin',
	    'satirical',
	    'satisfied',
	    'satisfy',
	    'saturate',
	    'saturday',
	    'sauciness',
	    'saucy',
	    'sauna',
	    'savage',
	    'savanna',
	    'saved',
	    'savings',
	    'savior',
	    'savor',
	    'saxophone',
	    'say',
	    'scabbed',
	    'scabby',
	    'scalded',
	    'scalding',
	    'scale',
	    'scaling',
	    'scallion',
	    'scallop',
	    'scalping',
	    'scam',
	    'scandal',
	    'scanner',
	    'scanning',
	    'scant',
	    'scapegoat',
	    'scarce',
	    'scarcity',
	    'scarecrow',
	    'scared',
	    'scarf',
	    'scarily',
	    'scariness',
	    'scarring',
	    'scary',
	    'scavenger',
	    'scenic',
	    'schedule',
	    'schematic',
	    'scheme',
	    'scheming',
	    'schilling',
	    'schnapps',
	    'scholar',
	    'science',
	    'scientist',
	    'scion',
	    'scoff',
	    'scolding',
	    'scone',
	    'scoop',
	    'scooter',
	    'scope',
	    'scorch',
	    'scorebook',
	    'scorecard',
	    'scored',
	    'scoreless',
	    'scorer',
	    'scoring',
	    'scorn',
	    'scorpion',
	    'scotch',
	    'scoundrel',
	    'scoured',
	    'scouring',
	    'scouting',
	    'scouts',
	    'scowling',
	    'scrabble',
	    'scraggly',
	    'scrambled',
	    'scrambler',
	    'scrap',
	    'scratch',
	    'scrawny',
	    'screen',
	    'scribble',
	    'scribe',
	    'scribing',
	    'scrimmage',
	    'script',
	    'scroll',
	    'scrooge',
	    'scrounger',
	    'scrubbed',
	    'scrubber',
	    'scruffy',
	    'scrunch',
	    'scrutiny',
	    'scuba',
	    'scuff',
	    'sculptor',
	    'sculpture',
	    'scurvy',
	    'scuttle',
	    'secluded',
	    'secluding',
	    'seclusion',
	    'second',
	    'secrecy',
	    'secret',
	    'sectional',
	    'sector',
	    'secular',
	    'securely',
	    'security',
	    'sedan',
	    'sedate',
	    'sedation',
	    'sedative',
	    'sediment',
	    'seduce',
	    'seducing',
	    'segment',
	    'seismic',
	    'seizing',
	    'seldom',
	    'selected',
	    'selection',
	    'selective',
	    'selector',
	    'self',
	    'seltzer',
	    'semantic',
	    'semester',
	    'semicolon',
	    'semifinal',
	    'seminar',
	    'semisoft',
	    'semisweet',
	    'senate',
	    'senator',
	    'send',
	    'senior',
	    'senorita',
	    'sensation',
	    'sensitive',
	    'sensitize',
	    'sensually',
	    'sensuous',
	    'sepia',
	    'september',
	    'septic',
	    'septum',
	    'sequel',
	    'sequence',
	    'sequester',
	    'series',
	    'sermon',
	    'serotonin',
	    'serpent',
	    'serrated',
	    'serve',
	    'service',
	    'serving',
	    'sesame',
	    'sessions',
	    'setback',
	    'setting',
	    'settle',
	    'settling',
	    'setup',
	    'sevenfold',
	    'seventeen',
	    'seventh',
	    'seventy',
	    'severity',
	    'shabby',
	    'shack',
	    'shaded',
	    'shadily',
	    'shadiness',
	    'shading',
	    'shadow',
	    'shady',
	    'shaft',
	    'shakable',
	    'shakily',
	    'shakiness',
	    'shaking',
	    'shaky',
	    'shale',
	    'shallot',
	    'shallow',
	    'shame',
	    'shampoo',
	    'shamrock',
	    'shank',
	    'shanty',
	    'shape',
	    'shaping',
	    'share',
	    'sharpener',
	    'sharper',
	    'sharpie',
	    'sharply',
	    'sharpness',
	    'shawl',
	    'sheath',
	    'shed',
	    'sheep',
	    'sheet',
	    'shelf',
	    'shell',
	    'shelter',
	    'shelve',
	    'shelving',
	    'sherry',
	    'shield',
	    'shifter',
	    'shifting',
	    'shiftless',
	    'shifty',
	    'shimmer',
	    'shimmy',
	    'shindig',
	    'shine',
	    'shingle',
	    'shininess',
	    'shining',
	    'shiny',
	    'ship',
	    'shirt',
	    'shivering',
	    'shock',
	    'shone',
	    'shoplift',
	    'shopper',
	    'shopping',
	    'shoptalk',
	    'shore',
	    'shortage',
	    'shortcake',
	    'shortcut',
	    'shorten',
	    'shorter',
	    'shorthand',
	    'shortlist',
	    'shortly',
	    'shortness',
	    'shorts',
	    'shortwave',
	    'shorty',
	    'shout',
	    'shove',
	    'showbiz',
	    'showcase',
	    'showdown',
	    'shower',
	    'showgirl',
	    'showing',
	    'showman',
	    'shown',
	    'showoff',
	    'showpiece',
	    'showplace',
	    'showroom',
	    'showy',
	    'shrank',
	    'shrapnel',
	    'shredder',
	    'shredding',
	    'shrewdly',
	    'shriek',
	    'shrill',
	    'shrimp',
	    'shrine',
	    'shrink',
	    'shrivel',
	    'shrouded',
	    'shrubbery',
	    'shrubs',
	    'shrug',
	    'shrunk',
	    'shucking',
	    'shudder',
	    'shuffle',
	    'shuffling',
	    'shun',
	    'shush',
	    'shut',
	    'shy',
	    'siamese',
	    'siberian',
	    'sibling',
	    'siding',
	    'sierra',
	    'siesta',
	    'sift',
	    'sighing',
	    'silenced',
	    'silencer',
	    'silent',
	    'silica',
	    'silicon',
	    'silk',
	    'silliness',
	    'silly',
	    'silo',
	    'silt',
	    'silver',
	    'similarly',
	    'simile',
	    'simmering',
	    'simple',
	    'simplify',
	    'simply',
	    'sincere',
	    'sincerity',
	    'singer',
	    'singing',
	    'single',
	    'singular',
	    'sinister',
	    'sinless',
	    'sinner',
	    'sinuous',
	    'sip',
	    'siren',
	    'sister',
	    'sitcom',
	    'sitter',
	    'sitting',
	    'situated',
	    'situation',
	    'sixfold',
	    'sixteen',
	    'sixth',
	    'sixties',
	    'sixtieth',
	    'sixtyfold',
	    'sizable',
	    'sizably',
	    'size',
	    'sizing',
	    'sizzle',
	    'sizzling',
	    'skater',
	    'skating',
	    'skedaddle',
	    'skeletal',
	    'skeleton',
	    'skeptic',
	    'sketch',
	    'skewed',
	    'skewer',
	    'skid',
	    'skied',
	    'skier',
	    'skies',
	    'skiing',
	    'skilled',
	    'skillet',
	    'skillful',
	    'skimmed',
	    'skimmer',
	    'skimming',
	    'skimpily',
	    'skincare',
	    'skinhead',
	    'skinless',
	    'skinning',
	    'skinny',
	    'skintight',
	    'skipper',
	    'skipping',
	    'skirmish',
	    'skirt',
	    'skittle',
	    'skydiver',
	    'skylight',
	    'skyline',
	    'skype',
	    'skyrocket',
	    'skyward',
	    'slab',
	    'slacked',
	    'slacker',
	    'slacking',
	    'slackness',
	    'slacks',
	    'slain',
	    'slam',
	    'slander',
	    'slang',
	    'slapping',
	    'slapstick',
	    'slashed',
	    'slashing',
	    'slate',
	    'slather',
	    'slaw',
	    'sled',
	    'sleek',
	    'sleep',
	    'sleet',
	    'sleeve',
	    'slept',
	    'sliceable',
	    'sliced',
	    'slicer',
	    'slicing',
	    'slick',
	    'slider',
	    'slideshow',
	    'sliding',
	    'slighted',
	    'slighting',
	    'slightly',
	    'slimness',
	    'slimy',
	    'slinging',
	    'slingshot',
	    'slinky',
	    'slip',
	    'slit',
	    'sliver',
	    'slobbery',
	    'slogan',
	    'sloped',
	    'sloping',
	    'sloppily',
	    'sloppy',
	    'slot',
	    'slouching',
	    'slouchy',
	    'sludge',
	    'slug',
	    'slum',
	    'slurp',
	    'slush',
	    'sly',
	    'small',
	    'smartly',
	    'smartness',
	    'smasher',
	    'smashing',
	    'smashup',
	    'smell',
	    'smelting',
	    'smile',
	    'smilingly',
	    'smirk',
	    'smite',
	    'smith',
	    'smitten',
	    'smock',
	    'smog',
	    'smoked',
	    'smokeless',
	    'smokiness',
	    'smoking',
	    'smoky',
	    'smolder',
	    'smooth',
	    'smother',
	    'smudge',
	    'smudgy',
	    'smuggler',
	    'smuggling',
	    'smugly',
	    'smugness',
	    'snack',
	    'snagged',
	    'snaking',
	    'snap',
	    'snare',
	    'snarl',
	    'snazzy',
	    'sneak',
	    'sneer',
	    'sneeze',
	    'sneezing',
	    'snide',
	    'sniff',
	    'snippet',
	    'snipping',
	    'snitch',
	    'snooper',
	    'snooze',
	    'snore',
	    'snoring',
	    'snorkel',
	    'snort',
	    'snout',
	    'snowbird',
	    'snowboard',
	    'snowbound',
	    'snowcap',
	    'snowdrift',
	    'snowdrop',
	    'snowfall',
	    'snowfield',
	    'snowflake',
	    'snowiness',
	    'snowless',
	    'snowman',
	    'snowplow',
	    'snowshoe',
	    'snowstorm',
	    'snowsuit',
	    'snowy',
	    'snub',
	    'snuff',
	    'snuggle',
	    'snugly',
	    'snugness',
	    'speak',
	    'spearfish',
	    'spearhead',
	    'spearman',
	    'spearmint',
	    'species',
	    'specimen',
	    'specked',
	    'speckled',
	    'specks',
	    'spectacle',
	    'spectator',
	    'spectrum',
	    'speculate',
	    'speech',
	    'speed',
	    'spellbind',
	    'speller',
	    'spelling',
	    'spendable',
	    'spender',
	    'spending',
	    'spent',
	    'spew',
	    'sphere',
	    'spherical',
	    'sphinx',
	    'spider',
	    'spied',
	    'spiffy',
	    'spill',
	    'spilt',
	    'spinach',
	    'spinal',
	    'spindle',
	    'spinner',
	    'spinning',
	    'spinout',
	    'spinster',
	    'spiny',
	    'spiral',
	    'spirited',
	    'spiritism',
	    'spirits',
	    'spiritual',
	    'splashed',
	    'splashing',
	    'splashy',
	    'splatter',
	    'spleen',
	    'splendid',
	    'splendor',
	    'splice',
	    'splicing',
	    'splinter',
	    'splotchy',
	    'splurge',
	    'spoilage',
	    'spoiled',
	    'spoiler',
	    'spoiling',
	    'spoils',
	    'spoken',
	    'spokesman',
	    'sponge',
	    'spongy',
	    'sponsor',
	    'spoof',
	    'spookily',
	    'spooky',
	    'spool',
	    'spoon',
	    'spore',
	    'sporting',
	    'sports',
	    'sporty',
	    'spotless',
	    'spotlight',
	    'spotted',
	    'spotter',
	    'spotting',
	    'spotty',
	    'spousal',
	    'spouse',
	    'spout',
	    'sprain',
	    'sprang',
	    'sprawl',
	    'spray',
	    'spree',
	    'sprig',
	    'spring',
	    'sprinkled',
	    'sprinkler',
	    'sprint',
	    'sprite',
	    'sprout',
	    'spruce',
	    'sprung',
	    'spry',
	    'spud',
	    'spur',
	    'sputter',
	    'spyglass',
	    'squabble',
	    'squad',
	    'squall',
	    'squander',
	    'squash',
	    'squatted',
	    'squatter',
	    'squatting',
	    'squeak',
	    'squealer',
	    'squealing',
	    'squeamish',
	    'squeegee',
	    'squeeze',
	    'squeezing',
	    'squid',
	    'squiggle',
	    'squiggly',
	    'squint',
	    'squire',
	    'squirt',
	    'squishier',
	    'squishy',
	    'stability',
	    'stabilize',
	    'stable',
	    'stack',
	    'stadium',
	    'staff',
	    'stage',
	    'staging',
	    'stagnant',
	    'stagnate',
	    'stainable',
	    'stained',
	    'staining',
	    'stainless',
	    'stalemate',
	    'staleness',
	    'stalling',
	    'stallion',
	    'stamina',
	    'stammer',
	    'stamp',
	    'stand',
	    'stank',
	    'staple',
	    'stapling',
	    'starboard',
	    'starch',
	    'stardom',
	    'stardust',
	    'starfish',
	    'stargazer',
	    'staring',
	    'stark',
	    'starless',
	    'starlet',
	    'starlight',
	    'starlit',
	    'starring',
	    'starry',
	    'starship',
	    'starter',
	    'starting',
	    'startle',
	    'startling',
	    'startup',
	    'starved',
	    'starving',
	    'stash',
	    'state',
	    'static',
	    'statistic',
	    'statue',
	    'stature',
	    'status',
	    'statute',
	    'statutory',
	    'staunch',
	    'stays',
	    'steadfast',
	    'steadier',
	    'steadily',
	    'steadying',
	    'steam',
	    'steed',
	    'steep',
	    'steerable',
	    'steering',
	    'steersman',
	    'stegosaur',
	    'stellar',
	    'stem',
	    'stench',
	    'stencil',
	    'step',
	    'stereo',
	    'sterile',
	    'sterility',
	    'sterilize',
	    'sterling',
	    'sternness',
	    'sternum',
	    'stew',
	    'stick',
	    'stiffen',
	    'stiffly',
	    'stiffness',
	    'stifle',
	    'stifling',
	    'stillness',
	    'stilt',
	    'stimulant',
	    'stimulate',
	    'stimuli',
	    'stimulus',
	    'stinger',
	    'stingily',
	    'stinging',
	    'stingray',
	    'stingy',
	    'stinking',
	    'stinky',
	    'stipend',
	    'stipulate',
	    'stir',
	    'stitch',
	    'stock',
	    'stoic',
	    'stoke',
	    'stole',
	    'stomp',
	    'stonewall',
	    'stoneware',
	    'stonework',
	    'stoning',
	    'stony',
	    'stood',
	    'stooge',
	    'stool',
	    'stoop',
	    'stoplight',
	    'stoppable',
	    'stoppage',
	    'stopped',
	    'stopper',
	    'stopping',
	    'stopwatch',
	    'storable',
	    'storage',
	    'storeroom',
	    'storewide',
	    'storm',
	    'stout',
	    'stove',
	    'stowaway',
	    'stowing',
	    'straddle',
	    'straggler',
	    'strained',
	    'strainer',
	    'straining',
	    'strangely',
	    'stranger',
	    'strangle',
	    'strategic',
	    'strategy',
	    'stratus',
	    'straw',
	    'stray',
	    'streak',
	    'stream',
	    'street',
	    'strength',
	    'strenuous',
	    'strep',
	    'stress',
	    'stretch',
	    'strewn',
	    'stricken',
	    'strict',
	    'stride',
	    'strife',
	    'strike',
	    'striking',
	    'strive',
	    'striving',
	    'strobe',
	    'strode',
	    'stroller',
	    'strongbox',
	    'strongly',
	    'strongman',
	    'struck',
	    'structure',
	    'strudel',
	    'struggle',
	    'strum',
	    'strung',
	    'strut',
	    'stubbed',
	    'stubble',
	    'stubbly',
	    'stubborn',
	    'stucco',
	    'stuck',
	    'student',
	    'studied',
	    'studio',
	    'study',
	    'stuffed',
	    'stuffing',
	    'stuffy',
	    'stumble',
	    'stumbling',
	    'stump',
	    'stung',
	    'stunned',
	    'stunner',
	    'stunning',
	    'stunt',
	    'stupor',
	    'sturdily',
	    'sturdy',
	    'styling',
	    'stylishly',
	    'stylist',
	    'stylized',
	    'stylus',
	    'suave',
	    'subarctic',
	    'subatomic',
	    'subdivide',
	    'subdued',
	    'subduing',
	    'subfloor',
	    'subgroup',
	    'subheader',
	    'subject',
	    'sublease',
	    'sublet',
	    'sublevel',
	    'sublime',
	    'submarine',
	    'submerge',
	    'submersed',
	    'submitter',
	    'subpanel',
	    'subpar',
	    'subplot',
	    'subprime',
	    'subscribe',
	    'subscript',
	    'subsector',
	    'subside',
	    'subsiding',
	    'subsidize',
	    'subsidy',
	    'subsoil',
	    'subsonic',
	    'substance',
	    'subsystem',
	    'subtext',
	    'subtitle',
	    'subtly',
	    'subtotal',
	    'subtract',
	    'subtype',
	    'suburb',
	    'subway',
	    'subwoofer',
	    'subzero',
	    'succulent',
	    'such',
	    'suction',
	    'sudden',
	    'sudoku',
	    'suds',
	    'sufferer',
	    'suffering',
	    'suffice',
	    'suffix',
	    'suffocate',
	    'suffrage',
	    'sugar',
	    'suggest',
	    'suing',
	    'suitable',
	    'suitably',
	    'suitcase',
	    'suitor',
	    'sulfate',
	    'sulfide',
	    'sulfite',
	    'sulfur',
	    'sulk',
	    'sullen',
	    'sulphate',
	    'sulphuric',
	    'sultry',
	    'superbowl',
	    'superglue',
	    'superhero',
	    'superior',
	    'superjet',
	    'superman',
	    'supermom',
	    'supernova',
	    'supervise',
	    'supper',
	    'supplier',
	    'supply',
	    'support',
	    'supremacy',
	    'supreme',
	    'surcharge',
	    'surely',
	    'sureness',
	    'surface',
	    'surfacing',
	    'surfboard',
	    'surfer',
	    'surgery',
	    'surgical',
	    'surging',
	    'surname',
	    'surpass',
	    'surplus',
	    'surprise',
	    'surreal',
	    'surrender',
	    'surrogate',
	    'surround',
	    'survey',
	    'survival',
	    'survive',
	    'surviving',
	    'survivor',
	    'sushi',
	    'suspect',
	    'suspend',
	    'suspense',
	    'sustained',
	    'sustainer',
	    'swab',
	    'swaddling',
	    'swagger',
	    'swampland',
	    'swan',
	    'swapping',
	    'swarm',
	    'sway',
	    'swear',
	    'sweat',
	    'sweep',
	    'swell',
	    'swept',
	    'swerve',
	    'swifter',
	    'swiftly',
	    'swiftness',
	    'swimmable',
	    'swimmer',
	    'swimming',
	    'swimsuit',
	    'swimwear',
	    'swinger',
	    'swinging',
	    'swipe',
	    'swirl',
	    'switch',
	    'swivel',
	    'swizzle',
	    'swooned',
	    'swoop',
	    'swoosh',
	    'swore',
	    'sworn',
	    'swung',
	    'sycamore',
	    'sympathy',
	    'symphonic',
	    'symphony',
	    'symptom',
	    'synapse',
	    'syndrome',
	    'synergy',
	    'synopses',
	    'synopsis',
	    'synthesis',
	    'synthetic',
	    'syrup',
	    'system',
	    't-shirt',
	    'tabasco',
	    'tabby',
	    'tableful',
	    'tables',
	    'tablet',
	    'tableware',
	    'tabloid',
	    'tackiness',
	    'tacking',
	    'tackle',
	    'tackling',
	    'tacky',
	    'taco',
	    'tactful',
	    'tactical',
	    'tactics',
	    'tactile',
	    'tactless',
	    'tadpole',
	    'taekwondo',
	    'tag',
	    'tainted',
	    'take',
	    'taking',
	    'talcum',
	    'talisman',
	    'tall',
	    'talon',
	    'tamale',
	    'tameness',
	    'tamer',
	    'tamper',
	    'tank',
	    'tanned',
	    'tannery',
	    'tanning',
	    'tantrum',
	    'tapeless',
	    'tapered',
	    'tapering',
	    'tapestry',
	    'tapioca',
	    'tapping',
	    'taps',
	    'tarantula',
	    'target',
	    'tarmac',
	    'tarnish',
	    'tarot',
	    'tartar',
	    'tartly',
	    'tartness',
	    'task',
	    'tassel',
	    'taste',
	    'tastiness',
	    'tasting',
	    'tasty',
	    'tattered',
	    'tattle',
	    'tattling',
	    'tattoo',
	    'taunt',
	    'tavern',
	    'thank',
	    'that',
	    'thaw',
	    'theater',
	    'theatrics',
	    'thee',
	    'theft',
	    'theme',
	    'theology',
	    'theorize',
	    'thermal',
	    'thermos',
	    'thesaurus',
	    'these',
	    'thesis',
	    'thespian',
	    'thicken',
	    'thicket',
	    'thickness',
	    'thieving',
	    'thievish',
	    'thigh',
	    'thimble',
	    'thing',
	    'think',
	    'thinly',
	    'thinner',
	    'thinness',
	    'thinning',
	    'thirstily',
	    'thirsting',
	    'thirsty',
	    'thirteen',
	    'thirty',
	    'thong',
	    'thorn',
	    'those',
	    'thousand',
	    'thrash',
	    'thread',
	    'threaten',
	    'threefold',
	    'thrift',
	    'thrill',
	    'thrive',
	    'thriving',
	    'throat',
	    'throbbing',
	    'throng',
	    'throttle',
	    'throwaway',
	    'throwback',
	    'thrower',
	    'throwing',
	    'thud',
	    'thumb',
	    'thumping',
	    'thursday',
	    'thus',
	    'thwarting',
	    'thyself',
	    'tiara',
	    'tibia',
	    'tidal',
	    'tidbit',
	    'tidiness',
	    'tidings',
	    'tidy',
	    'tiger',
	    'tighten',
	    'tightly',
	    'tightness',
	    'tightrope',
	    'tightwad',
	    'tigress',
	    'tile',
	    'tiling',
	    'till',
	    'tilt',
	    'timid',
	    'timing',
	    'timothy',
	    'tinderbox',
	    'tinfoil',
	    'tingle',
	    'tingling',
	    'tingly',
	    'tinker',
	    'tinkling',
	    'tinsel',
	    'tinsmith',
	    'tint',
	    'tinwork',
	    'tiny',
	    'tipoff',
	    'tipped',
	    'tipper',
	    'tipping',
	    'tiptoeing',
	    'tiptop',
	    'tiring',
	    'tissue',
	    'trace',
	    'tracing',
	    'track',
	    'traction',
	    'tractor',
	    'trade',
	    'trading',
	    'tradition',
	    'traffic',
	    'tragedy',
	    'trailing',
	    'trailside',
	    'train',
	    'traitor',
	    'trance',
	    'tranquil',
	    'transfer',
	    'transform',
	    'translate',
	    'transpire',
	    'transport',
	    'transpose',
	    'trapdoor',
	    'trapeze',
	    'trapezoid',
	    'trapped',
	    'trapper',
	    'trapping',
	    'traps',
	    'trash',
	    'travel',
	    'traverse',
	    'travesty',
	    'tray',
	    'treachery',
	    'treading',
	    'treadmill',
	    'treason',
	    'treat',
	    'treble',
	    'tree',
	    'trekker',
	    'tremble',
	    'trembling',
	    'tremor',
	    'trench',
	    'trend',
	    'trespass',
	    'triage',
	    'trial',
	    'triangle',
	    'tribesman',
	    'tribunal',
	    'tribune',
	    'tributary',
	    'tribute',
	    'triceps',
	    'trickery',
	    'trickily',
	    'tricking',
	    'trickle',
	    'trickster',
	    'tricky',
	    'tricolor',
	    'tricycle',
	    'trident',
	    'tried',
	    'trifle',
	    'trifocals',
	    'trillion',
	    'trilogy',
	    'trimester',
	    'trimmer',
	    'trimming',
	    'trimness',
	    'trinity',
	    'trio',
	    'tripod',
	    'tripping',
	    'triumph',
	    'trivial',
	    'trodden',
	    'trolling',
	    'trombone',
	    'trophy',
	    'tropical',
	    'tropics',
	    'trouble',
	    'troubling',
	    'trough',
	    'trousers',
	    'trout',
	    'trowel',
	    'truce',
	    'truck',
	    'truffle',
	    'trump',
	    'trunks',
	    'trustable',
	    'trustee',
	    'trustful',
	    'trusting',
	    'trustless',
	    'truth',
	    'try',
	    'tubby',
	    'tubeless',
	    'tubular',
	    'tucking',
	    'tuesday',
	    'tug',
	    'tuition',
	    'tulip',
	    'tumble',
	    'tumbling',
	    'tummy',
	    'turban',
	    'turbine',
	    'turbofan',
	    'turbojet',
	    'turbulent',
	    'turf',
	    'turkey',
	    'turmoil',
	    'turret',
	    'turtle',
	    'tusk',
	    'tutor',
	    'tutu',
	    'tux',
	    'tweak',
	    'tweed',
	    'tweet',
	    'tweezers',
	    'twelve',
	    'twentieth',
	    'twenty',
	    'twerp',
	    'twice',
	    'twiddle',
	    'twiddling',
	    'twig',
	    'twilight',
	    'twine',
	    'twins',
	    'twirl',
	    'twistable',
	    'twisted',
	    'twister',
	    'twisting',
	    'twisty',
	    'twitch',
	    'twitter',
	    'tycoon',
	    'tying',
	    'tyke',
	    'udder',
	    'ultimate',
	    'ultimatum',
	    'ultra',
	    'umbilical',
	    'umbrella',
	    'umpire',
	    'unabashed',
	    'unable',
	    'unadorned',
	    'unadvised',
	    'unafraid',
	    'unaired',
	    'unaligned',
	    'unaltered',
	    'unarmored',
	    'unashamed',
	    'unaudited',
	    'unawake',
	    'unaware',
	    'unbaked',
	    'unbalance',
	    'unbeaten',
	    'unbend',
	    'unbent',
	    'unbiased',
	    'unbitten',
	    'unblended',
	    'unblessed',
	    'unblock',
	    'unbolted',
	    'unbounded',
	    'unboxed',
	    'unbraided',
	    'unbridle',
	    'unbroken',
	    'unbuckled',
	    'unbundle',
	    'unburned',
	    'unbutton',
	    'uncanny',
	    'uncapped',
	    'uncaring',
	    'uncertain',
	    'unchain',
	    'unchanged',
	    'uncharted',
	    'uncheck',
	    'uncivil',
	    'unclad',
	    'unclaimed',
	    'unclamped',
	    'unclasp',
	    'uncle',
	    'unclip',
	    'uncloak',
	    'unclog',
	    'unclothed',
	    'uncoated',
	    'uncoiled',
	    'uncolored',
	    'uncombed',
	    'uncommon',
	    'uncooked',
	    'uncork',
	    'uncorrupt',
	    'uncounted',
	    'uncouple',
	    'uncouth',
	    'uncover',
	    'uncross',
	    'uncrown',
	    'uncrushed',
	    'uncured',
	    'uncurious',
	    'uncurled',
	    'uncut',
	    'undamaged',
	    'undated',
	    'undaunted',
	    'undead',
	    'undecided',
	    'undefined',
	    'underage',
	    'underarm',
	    'undercoat',
	    'undercook',
	    'undercut',
	    'underdog',
	    'underdone',
	    'underfed',
	    'underfeed',
	    'underfoot',
	    'undergo',
	    'undergrad',
	    'underhand',
	    'underline',
	    'underling',
	    'undermine',
	    'undermost',
	    'underpaid',
	    'underpass',
	    'underpay',
	    'underrate',
	    'undertake',
	    'undertone',
	    'undertook',
	    'undertow',
	    'underuse',
	    'underwear',
	    'underwent',
	    'underwire',
	    'undesired',
	    'undiluted',
	    'undivided',
	    'undocked',
	    'undoing',
	    'undone',
	    'undrafted',
	    'undress',
	    'undrilled',
	    'undusted',
	    'undying',
	    'unearned',
	    'unearth',
	    'unease',
	    'uneasily',
	    'uneasy',
	    'uneatable',
	    'uneaten',
	    'unedited',
	    'unelected',
	    'unending',
	    'unengaged',
	    'unenvied',
	    'unequal',
	    'unethical',
	    'uneven',
	    'unexpired',
	    'unexposed',
	    'unfailing',
	    'unfair',
	    'unfasten',
	    'unfazed',
	    'unfeeling',
	    'unfiled',
	    'unfilled',
	    'unfitted',
	    'unfitting',
	    'unfixable',
	    'unfixed',
	    'unflawed',
	    'unfocused',
	    'unfold',
	    'unfounded',
	    'unframed',
	    'unfreeze',
	    'unfrosted',
	    'unfrozen',
	    'unfunded',
	    'unglazed',
	    'ungloved',
	    'unglue',
	    'ungodly',
	    'ungraded',
	    'ungreased',
	    'unguarded',
	    'unguided',
	    'unhappily',
	    'unhappy',
	    'unharmed',
	    'unhealthy',
	    'unheard',
	    'unhearing',
	    'unheated',
	    'unhelpful',
	    'unhidden',
	    'unhinge',
	    'unhitched',
	    'unholy',
	    'unhook',
	    'unicorn',
	    'unicycle',
	    'unified',
	    'unifier',
	    'uniformed',
	    'uniformly',
	    'unify',
	    'unimpeded',
	    'uninjured',
	    'uninstall',
	    'uninsured',
	    'uninvited',
	    'union',
	    'uniquely',
	    'unisexual',
	    'unison',
	    'unissued',
	    'unit',
	    'universal',
	    'universe',
	    'unjustly',
	    'unkempt',
	    'unkind',
	    'unknotted',
	    'unknowing',
	    'unknown',
	    'unlaced',
	    'unlatch',
	    'unlawful',
	    'unleaded',
	    'unlearned',
	    'unleash',
	    'unless',
	    'unleveled',
	    'unlighted',
	    'unlikable',
	    'unlimited',
	    'unlined',
	    'unlinked',
	    'unlisted',
	    'unlit',
	    'unlivable',
	    'unloaded',
	    'unloader',
	    'unlocked',
	    'unlocking',
	    'unlovable',
	    'unloved',
	    'unlovely',
	    'unloving',
	    'unluckily',
	    'unlucky',
	    'unmade',
	    'unmanaged',
	    'unmanned',
	    'unmapped',
	    'unmarked',
	    'unmasked',
	    'unmasking',
	    'unmatched',
	    'unmindful',
	    'unmixable',
	    'unmixed',
	    'unmolded',
	    'unmoral',
	    'unmovable',
	    'unmoved',
	    'unmoving',
	    'unnamable',
	    'unnamed',
	    'unnatural',
	    'unneeded',
	    'unnerve',
	    'unnerving',
	    'unnoticed',
	    'unopened',
	    'unopposed',
	    'unpack',
	    'unpadded',
	    'unpaid',
	    'unpainted',
	    'unpaired',
	    'unpaved',
	    'unpeeled',
	    'unpicked',
	    'unpiloted',
	    'unpinned',
	    'unplanned',
	    'unplanted',
	    'unpleased',
	    'unpledged',
	    'unplowed',
	    'unplug',
	    'unpopular',
	    'unproven',
	    'unquote',
	    'unranked',
	    'unrated',
	    'unraveled',
	    'unreached',
	    'unread',
	    'unreal',
	    'unreeling',
	    'unrefined',
	    'unrelated',
	    'unrented',
	    'unrest',
	    'unretired',
	    'unrevised',
	    'unrigged',
	    'unripe',
	    'unrivaled',
	    'unroasted',
	    'unrobed',
	    'unroll',
	    'unruffled',
	    'unruly',
	    'unrushed',
	    'unsaddle',
	    'unsafe',
	    'unsaid',
	    'unsalted',
	    'unsaved',
	    'unsavory',
	    'unscathed',
	    'unscented',
	    'unscrew',
	    'unsealed',
	    'unseated',
	    'unsecured',
	    'unseeing',
	    'unseemly',
	    'unseen',
	    'unselect',
	    'unselfish',
	    'unsent',
	    'unsettled',
	    'unshackle',
	    'unshaken',
	    'unshaved',
	    'unshaven',
	    'unsheathe',
	    'unshipped',
	    'unsightly',
	    'unsigned',
	    'unskilled',
	    'unsliced',
	    'unsmooth',
	    'unsnap',
	    'unsocial',
	    'unsoiled',
	    'unsold',
	    'unsolved',
	    'unsorted',
	    'unspoiled',
	    'unspoken',
	    'unstable',
	    'unstaffed',
	    'unstamped',
	    'unsteady',
	    'unsterile',
	    'unstirred',
	    'unstitch',
	    'unstopped',
	    'unstuck',
	    'unstuffed',
	    'unstylish',
	    'unsubtle',
	    'unsubtly',
	    'unsuited',
	    'unsure',
	    'unsworn',
	    'untagged',
	    'untainted',
	    'untaken',
	    'untamed',
	    'untangled',
	    'untapped',
	    'untaxed',
	    'unthawed',
	    'unthread',
	    'untidy',
	    'untie',
	    'until',
	    'untimed',
	    'untimely',
	    'untitled',
	    'untoasted',
	    'untold',
	    'untouched',
	    'untracked',
	    'untrained',
	    'untreated',
	    'untried',
	    'untrimmed',
	    'untrue',
	    'untruth',
	    'unturned',
	    'untwist',
	    'untying',
	    'unusable',
	    'unused',
	    'unusual',
	    'unvalued',
	    'unvaried',
	    'unvarying',
	    'unveiled',
	    'unveiling',
	    'unvented',
	    'unviable',
	    'unvisited',
	    'unvocal',
	    'unwanted',
	    'unwarlike',
	    'unwary',
	    'unwashed',
	    'unwatched',
	    'unweave',
	    'unwed',
	    'unwelcome',
	    'unwell',
	    'unwieldy',
	    'unwilling',
	    'unwind',
	    'unwired',
	    'unwitting',
	    'unwomanly',
	    'unworldly',
	    'unworn',
	    'unworried',
	    'unworthy',
	    'unwound',
	    'unwoven',
	    'unwrapped',
	    'unwritten',
	    'unzip',
	    'upbeat',
	    'upchuck',
	    'upcoming',
	    'upcountry',
	    'update',
	    'upfront',
	    'upgrade',
	    'upheaval',
	    'upheld',
	    'uphill',
	    'uphold',
	    'uplifted',
	    'uplifting',
	    'upload',
	    'upon',
	    'upper',
	    'upright',
	    'uprising',
	    'upriver',
	    'uproar',
	    'uproot',
	    'upscale',
	    'upside',
	    'upstage',
	    'upstairs',
	    'upstart',
	    'upstate',
	    'upstream',
	    'upstroke',
	    'upswing',
	    'uptake',
	    'uptight',
	    'uptown',
	    'upturned',
	    'upward',
	    'upwind',
	    'uranium',
	    'urban',
	    'urchin',
	    'urethane',
	    'urgency',
	    'urgent',
	    'urging',
	    'urologist',
	    'urology',
	    'usable',
	    'usage',
	    'useable',
	    'used',
	    'uselessly',
	    'user',
	    'usher',
	    'usual',
	    'utensil',
	    'utility',
	    'utilize',
	    'utmost',
	    'utopia',
	    'utter',
	    'vacancy',
	    'vacant',
	    'vacate',
	    'vacation',
	    'vagabond',
	    'vagrancy',
	    'vagrantly',
	    'vaguely',
	    'vagueness',
	    'valiant',
	    'valid',
	    'valium',
	    'valley',
	    'valuables',
	    'value',
	    'vanilla',
	    'vanish',
	    'vanity',
	    'vanquish',
	    'vantage',
	    'vaporizer',
	    'variable',
	    'variably',
	    'varied',
	    'variety',
	    'various',
	    'varmint',
	    'varnish',
	    'varsity',
	    'varying',
	    'vascular',
	    'vaseline',
	    'vastly',
	    'vastness',
	    'veal',
	    'vegan',
	    'veggie',
	    'vehicular',
	    'velcro',
	    'velocity',
	    'velvet',
	    'vendetta',
	    'vending',
	    'vendor',
	    'veneering',
	    'vengeful',
	    'venomous',
	    'ventricle',
	    'venture',
	    'venue',
	    'venus',
	    'verbalize',
	    'verbally',
	    'verbose',
	    'verdict',
	    'verify',
	    'verse',
	    'version',
	    'versus',
	    'vertebrae',
	    'vertical',
	    'vertigo',
	    'very',
	    'vessel',
	    'vest',
	    'veteran',
	    'veto',
	    'vexingly',
	    'viability',
	    'viable',
	    'vibes',
	    'vice',
	    'vicinity',
	    'victory',
	    'video',
	    'viewable',
	    'viewer',
	    'viewing',
	    'viewless',
	    'viewpoint',
	    'vigorous',
	    'village',
	    'villain',
	    'vindicate',
	    'vineyard',
	    'vintage',
	    'violate',
	    'violation',
	    'violator',
	    'violet',
	    'violin',
	    'viper',
	    'viral',
	    'virtual',
	    'virtuous',
	    'virus',
	    'visa',
	    'viscosity',
	    'viscous',
	    'viselike',
	    'visible',
	    'visibly',
	    'vision',
	    'visiting',
	    'visitor',
	    'visor',
	    'vista',
	    'vitality',
	    'vitalize',
	    'vitally',
	    'vitamins',
	    'vivacious',
	    'vividly',
	    'vividness',
	    'vixen',
	    'vocalist',
	    'vocalize',
	    'vocally',
	    'vocation',
	    'voice',
	    'voicing',
	    'void',
	    'volatile',
	    'volley',
	    'voltage',
	    'volumes',
	    'voter',
	    'voting',
	    'voucher',
	    'vowed',
	    'vowel',
	    'voyage',
	    'wackiness',
	    'wad',
	    'wafer',
	    'waffle',
	    'waged',
	    'wager',
	    'wages',
	    'waggle',
	    'wagon',
	    'wake',
	    'waking',
	    'walk',
	    'walmart',
	    'walnut',
	    'walrus',
	    'waltz',
	    'wand',
	    'wannabe',
	    'wanted',
	    'wanting',
	    'wasabi',
	    'washable',
	    'washbasin',
	    'washboard',
	    'washbowl',
	    'washcloth',
	    'washday',
	    'washed',
	    'washer',
	    'washhouse',
	    'washing',
	    'washout',
	    'washroom',
	    'washstand',
	    'washtub',
	    'wasp',
	    'wasting',
	    'watch',
	    'water',
	    'waviness',
	    'waving',
	    'wavy',
	    'whacking',
	    'whacky',
	    'wham',
	    'wharf',
	    'wheat',
	    'whenever',
	    'whiff',
	    'whimsical',
	    'whinny',
	    'whiny',
	    'whisking',
	    'whoever',
	    'whole',
	    'whomever',
	    'whoopee',
	    'whooping',
	    'whoops',
	    'why',
	    'wick',
	    'widely',
	    'widen',
	    'widget',
	    'widow',
	    'width',
	    'wieldable',
	    'wielder',
	    'wife',
	    'wifi',
	    'wikipedia',
	    'wildcard',
	    'wildcat',
	    'wilder',
	    'wildfire',
	    'wildfowl',
	    'wildland',
	    'wildlife',
	    'wildly',
	    'wildness',
	    'willed',
	    'willfully',
	    'willing',
	    'willow',
	    'willpower',
	    'wilt',
	    'wimp',
	    'wince',
	    'wincing',
	    'wind',
	    'wing',
	    'winking',
	    'winner',
	    'winnings',
	    'winter',
	    'wipe',
	    'wired',
	    'wireless',
	    'wiring',
	    'wiry',
	    'wisdom',
	    'wise',
	    'wish',
	    'wisplike',
	    'wispy',
	    'wistful',
	    'wizard',
	    'wobble',
	    'wobbling',
	    'wobbly',
	    'wok',
	    'wolf',
	    'wolverine',
	    'womanhood',
	    'womankind',
	    'womanless',
	    'womanlike',
	    'womanly',
	    'womb',
	    'woof',
	    'wooing',
	    'wool',
	    'woozy',
	    'word',
	    'work',
	    'worried',
	    'worrier',
	    'worrisome',
	    'worry',
	    'worsening',
	    'worshiper',
	    'worst',
	    'wound',
	    'woven',
	    'wow',
	    'wrangle',
	    'wrath',
	    'wreath',
	    'wreckage',
	    'wrecker',
	    'wrecking',
	    'wrench',
	    'wriggle',
	    'wriggly',
	    'wrinkle',
	    'wrinkly',
	    'wrist',
	    'writing',
	    'written',
	    'wrongdoer',
	    'wronged',
	    'wrongful',
	    'wrongly',
	    'wrongness',
	    'wrought',
	    'xbox',
	    'xerox',
	    'yahoo',
	    'yam',
	    'yanking',
	    'yapping',
	    'yard',
	    'yarn',
	    'yeah',
	    'yearbook',
	    'yearling',
	    'yearly',
	    'yearning',
	    'yeast',
	    'yelling',
	    'yelp',
	    'yen',
	    'yesterday',
	    'yiddish',
	    'yield',
	    'yin',
	    'yippee',
	    'yo-yo',
	    'yodel',
	    'yoga',
	    'yogurt',
	    'yonder',
	    'yoyo',
	    'yummy',
	    'zap',
	    'zealous',
	    'zebra',
	    'zen',
	    'zeppelin',
	    'zero',
	    'zestfully',
	    'zesty',
	    'zigzagged',
	    'zipfile',
	    'zipping',
	    'zippy',
	    'zips',
	    'zit',
	    'zodiac',
	    'zombie',
	    'zone',
	    'zoning',
	    'zookeeper',
	    'zoologist',
	    'zoology',
	    'zoom',
	];
	return wordlist$1;
}

var hasRequiredNewSecureWords;

function requireNewSecureWords () {
	if (hasRequiredNewSecureWords) return newSecureWords;
	hasRequiredNewSecureWords = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(newSecureWords, "__esModule", { value: true });
	newSecureWords.newSecureWords = void 0;
	const getSecureRandom_1 = requireGetSecureRandom();
	const wordlist_1 = requireWordlist$1();
	async function newSecureWords$1(size = 6) {
	    let words = [];
	    for (let i = 0; i < size; i++) {
	        words.push(wordlist_1.wordlist[await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length)]);
	    }
	    return words;
	}
	newSecureWords.newSecureWords = newSecureWords$1;
	return newSecureWords;
}

var newSecurePassphrase = {};

var hasRequiredNewSecurePassphrase;

function requireNewSecurePassphrase () {
	if (hasRequiredNewSecurePassphrase) return newSecurePassphrase;
	hasRequiredNewSecurePassphrase = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(newSecurePassphrase, "__esModule", { value: true });
	newSecurePassphrase.newSecurePassphrase = void 0;
	const __1 = requireDist$3();
	async function newSecurePassphrase$1(size = 6) {
	    return (await (0, __1.newSecureWords)(size)).join('-');
	}
	newSecurePassphrase.newSecurePassphrase = newSecurePassphrase$1;
	return newSecurePassphrase;
}

var mnemonic = {};

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var naclFast = {exports: {}};

const __viteBrowserExternal = {};

const __viteBrowserExternal$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: __viteBrowserExternal
}, Symbol.toStringTag, { value: 'Module' }));

const require$$0$2 = /*@__PURE__*/getAugmentedNamespace(__viteBrowserExternal$1);

var hasRequiredNaclFast;

function requireNaclFast () {
	if (hasRequiredNaclFast) return naclFast.exports;
	hasRequiredNaclFast = 1;
	(function (module) {
		(function(nacl) {

		// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
		// Public domain.
		//
		// Implementation derived from TweetNaCl version 20140427.
		// See for details: http://tweetnacl.cr.yp.to/

		var gf = function(init) {
		  var i, r = new Float64Array(16);
		  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
		  return r;
		};

		//  Pluggable, initialized in high-level API below.
		var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

		var _0 = new Uint8Array(16);
		var _9 = new Uint8Array(32); _9[0] = 9;

		var gf0 = gf(),
		    gf1 = gf([1]),
		    _121665 = gf([0xdb41, 1]),
		    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
		    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
		    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
		    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
		    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

		function ts64(x, i, h, l) {
		  x[i]   = (h >> 24) & 0xff;
		  x[i+1] = (h >> 16) & 0xff;
		  x[i+2] = (h >>  8) & 0xff;
		  x[i+3] = h & 0xff;
		  x[i+4] = (l >> 24)  & 0xff;
		  x[i+5] = (l >> 16)  & 0xff;
		  x[i+6] = (l >>  8)  & 0xff;
		  x[i+7] = l & 0xff;
		}

		function vn(x, xi, y, yi, n) {
		  var i,d = 0;
		  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
		  return (1 & ((d - 1) >>> 8)) - 1;
		}

		function crypto_verify_16(x, xi, y, yi) {
		  return vn(x,xi,y,yi,16);
		}

		function crypto_verify_32(x, xi, y, yi) {
		  return vn(x,xi,y,yi,32);
		}

		function core_salsa20(o, p, k, c) {
		  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
		      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
		      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
		      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
		      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
		      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
		      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
		      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
		      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
		      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
		      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
		      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
		      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
		      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
		      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
		      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

		  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
		      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
		      x15 = j15, u;

		  for (var i = 0; i < 20; i += 2) {
		    u = x0 + x12 | 0;
		    x4 ^= u<<7 | u>>>(32-7);
		    u = x4 + x0 | 0;
		    x8 ^= u<<9 | u>>>(32-9);
		    u = x8 + x4 | 0;
		    x12 ^= u<<13 | u>>>(32-13);
		    u = x12 + x8 | 0;
		    x0 ^= u<<18 | u>>>(32-18);

		    u = x5 + x1 | 0;
		    x9 ^= u<<7 | u>>>(32-7);
		    u = x9 + x5 | 0;
		    x13 ^= u<<9 | u>>>(32-9);
		    u = x13 + x9 | 0;
		    x1 ^= u<<13 | u>>>(32-13);
		    u = x1 + x13 | 0;
		    x5 ^= u<<18 | u>>>(32-18);

		    u = x10 + x6 | 0;
		    x14 ^= u<<7 | u>>>(32-7);
		    u = x14 + x10 | 0;
		    x2 ^= u<<9 | u>>>(32-9);
		    u = x2 + x14 | 0;
		    x6 ^= u<<13 | u>>>(32-13);
		    u = x6 + x2 | 0;
		    x10 ^= u<<18 | u>>>(32-18);

		    u = x15 + x11 | 0;
		    x3 ^= u<<7 | u>>>(32-7);
		    u = x3 + x15 | 0;
		    x7 ^= u<<9 | u>>>(32-9);
		    u = x7 + x3 | 0;
		    x11 ^= u<<13 | u>>>(32-13);
		    u = x11 + x7 | 0;
		    x15 ^= u<<18 | u>>>(32-18);

		    u = x0 + x3 | 0;
		    x1 ^= u<<7 | u>>>(32-7);
		    u = x1 + x0 | 0;
		    x2 ^= u<<9 | u>>>(32-9);
		    u = x2 + x1 | 0;
		    x3 ^= u<<13 | u>>>(32-13);
		    u = x3 + x2 | 0;
		    x0 ^= u<<18 | u>>>(32-18);

		    u = x5 + x4 | 0;
		    x6 ^= u<<7 | u>>>(32-7);
		    u = x6 + x5 | 0;
		    x7 ^= u<<9 | u>>>(32-9);
		    u = x7 + x6 | 0;
		    x4 ^= u<<13 | u>>>(32-13);
		    u = x4 + x7 | 0;
		    x5 ^= u<<18 | u>>>(32-18);

		    u = x10 + x9 | 0;
		    x11 ^= u<<7 | u>>>(32-7);
		    u = x11 + x10 | 0;
		    x8 ^= u<<9 | u>>>(32-9);
		    u = x8 + x11 | 0;
		    x9 ^= u<<13 | u>>>(32-13);
		    u = x9 + x8 | 0;
		    x10 ^= u<<18 | u>>>(32-18);

		    u = x15 + x14 | 0;
		    x12 ^= u<<7 | u>>>(32-7);
		    u = x12 + x15 | 0;
		    x13 ^= u<<9 | u>>>(32-9);
		    u = x13 + x12 | 0;
		    x14 ^= u<<13 | u>>>(32-13);
		    u = x14 + x13 | 0;
		    x15 ^= u<<18 | u>>>(32-18);
		  }
		   x0 =  x0 +  j0 | 0;
		   x1 =  x1 +  j1 | 0;
		   x2 =  x2 +  j2 | 0;
		   x3 =  x3 +  j3 | 0;
		   x4 =  x4 +  j4 | 0;
		   x5 =  x5 +  j5 | 0;
		   x6 =  x6 +  j6 | 0;
		   x7 =  x7 +  j7 | 0;
		   x8 =  x8 +  j8 | 0;
		   x9 =  x9 +  j9 | 0;
		  x10 = x10 + j10 | 0;
		  x11 = x11 + j11 | 0;
		  x12 = x12 + j12 | 0;
		  x13 = x13 + j13 | 0;
		  x14 = x14 + j14 | 0;
		  x15 = x15 + j15 | 0;

		  o[ 0] = x0 >>>  0 & 0xff;
		  o[ 1] = x0 >>>  8 & 0xff;
		  o[ 2] = x0 >>> 16 & 0xff;
		  o[ 3] = x0 >>> 24 & 0xff;

		  o[ 4] = x1 >>>  0 & 0xff;
		  o[ 5] = x1 >>>  8 & 0xff;
		  o[ 6] = x1 >>> 16 & 0xff;
		  o[ 7] = x1 >>> 24 & 0xff;

		  o[ 8] = x2 >>>  0 & 0xff;
		  o[ 9] = x2 >>>  8 & 0xff;
		  o[10] = x2 >>> 16 & 0xff;
		  o[11] = x2 >>> 24 & 0xff;

		  o[12] = x3 >>>  0 & 0xff;
		  o[13] = x3 >>>  8 & 0xff;
		  o[14] = x3 >>> 16 & 0xff;
		  o[15] = x3 >>> 24 & 0xff;

		  o[16] = x4 >>>  0 & 0xff;
		  o[17] = x4 >>>  8 & 0xff;
		  o[18] = x4 >>> 16 & 0xff;
		  o[19] = x4 >>> 24 & 0xff;

		  o[20] = x5 >>>  0 & 0xff;
		  o[21] = x5 >>>  8 & 0xff;
		  o[22] = x5 >>> 16 & 0xff;
		  o[23] = x5 >>> 24 & 0xff;

		  o[24] = x6 >>>  0 & 0xff;
		  o[25] = x6 >>>  8 & 0xff;
		  o[26] = x6 >>> 16 & 0xff;
		  o[27] = x6 >>> 24 & 0xff;

		  o[28] = x7 >>>  0 & 0xff;
		  o[29] = x7 >>>  8 & 0xff;
		  o[30] = x7 >>> 16 & 0xff;
		  o[31] = x7 >>> 24 & 0xff;

		  o[32] = x8 >>>  0 & 0xff;
		  o[33] = x8 >>>  8 & 0xff;
		  o[34] = x8 >>> 16 & 0xff;
		  o[35] = x8 >>> 24 & 0xff;

		  o[36] = x9 >>>  0 & 0xff;
		  o[37] = x9 >>>  8 & 0xff;
		  o[38] = x9 >>> 16 & 0xff;
		  o[39] = x9 >>> 24 & 0xff;

		  o[40] = x10 >>>  0 & 0xff;
		  o[41] = x10 >>>  8 & 0xff;
		  o[42] = x10 >>> 16 & 0xff;
		  o[43] = x10 >>> 24 & 0xff;

		  o[44] = x11 >>>  0 & 0xff;
		  o[45] = x11 >>>  8 & 0xff;
		  o[46] = x11 >>> 16 & 0xff;
		  o[47] = x11 >>> 24 & 0xff;

		  o[48] = x12 >>>  0 & 0xff;
		  o[49] = x12 >>>  8 & 0xff;
		  o[50] = x12 >>> 16 & 0xff;
		  o[51] = x12 >>> 24 & 0xff;

		  o[52] = x13 >>>  0 & 0xff;
		  o[53] = x13 >>>  8 & 0xff;
		  o[54] = x13 >>> 16 & 0xff;
		  o[55] = x13 >>> 24 & 0xff;

		  o[56] = x14 >>>  0 & 0xff;
		  o[57] = x14 >>>  8 & 0xff;
		  o[58] = x14 >>> 16 & 0xff;
		  o[59] = x14 >>> 24 & 0xff;

		  o[60] = x15 >>>  0 & 0xff;
		  o[61] = x15 >>>  8 & 0xff;
		  o[62] = x15 >>> 16 & 0xff;
		  o[63] = x15 >>> 24 & 0xff;
		}

		function core_hsalsa20(o,p,k,c) {
		  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
		      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
		      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
		      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
		      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
		      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
		      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
		      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
		      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
		      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
		      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
		      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
		      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
		      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
		      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
		      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

		  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
		      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
		      x15 = j15, u;

		  for (var i = 0; i < 20; i += 2) {
		    u = x0 + x12 | 0;
		    x4 ^= u<<7 | u>>>(32-7);
		    u = x4 + x0 | 0;
		    x8 ^= u<<9 | u>>>(32-9);
		    u = x8 + x4 | 0;
		    x12 ^= u<<13 | u>>>(32-13);
		    u = x12 + x8 | 0;
		    x0 ^= u<<18 | u>>>(32-18);

		    u = x5 + x1 | 0;
		    x9 ^= u<<7 | u>>>(32-7);
		    u = x9 + x5 | 0;
		    x13 ^= u<<9 | u>>>(32-9);
		    u = x13 + x9 | 0;
		    x1 ^= u<<13 | u>>>(32-13);
		    u = x1 + x13 | 0;
		    x5 ^= u<<18 | u>>>(32-18);

		    u = x10 + x6 | 0;
		    x14 ^= u<<7 | u>>>(32-7);
		    u = x14 + x10 | 0;
		    x2 ^= u<<9 | u>>>(32-9);
		    u = x2 + x14 | 0;
		    x6 ^= u<<13 | u>>>(32-13);
		    u = x6 + x2 | 0;
		    x10 ^= u<<18 | u>>>(32-18);

		    u = x15 + x11 | 0;
		    x3 ^= u<<7 | u>>>(32-7);
		    u = x3 + x15 | 0;
		    x7 ^= u<<9 | u>>>(32-9);
		    u = x7 + x3 | 0;
		    x11 ^= u<<13 | u>>>(32-13);
		    u = x11 + x7 | 0;
		    x15 ^= u<<18 | u>>>(32-18);

		    u = x0 + x3 | 0;
		    x1 ^= u<<7 | u>>>(32-7);
		    u = x1 + x0 | 0;
		    x2 ^= u<<9 | u>>>(32-9);
		    u = x2 + x1 | 0;
		    x3 ^= u<<13 | u>>>(32-13);
		    u = x3 + x2 | 0;
		    x0 ^= u<<18 | u>>>(32-18);

		    u = x5 + x4 | 0;
		    x6 ^= u<<7 | u>>>(32-7);
		    u = x6 + x5 | 0;
		    x7 ^= u<<9 | u>>>(32-9);
		    u = x7 + x6 | 0;
		    x4 ^= u<<13 | u>>>(32-13);
		    u = x4 + x7 | 0;
		    x5 ^= u<<18 | u>>>(32-18);

		    u = x10 + x9 | 0;
		    x11 ^= u<<7 | u>>>(32-7);
		    u = x11 + x10 | 0;
		    x8 ^= u<<9 | u>>>(32-9);
		    u = x8 + x11 | 0;
		    x9 ^= u<<13 | u>>>(32-13);
		    u = x9 + x8 | 0;
		    x10 ^= u<<18 | u>>>(32-18);

		    u = x15 + x14 | 0;
		    x12 ^= u<<7 | u>>>(32-7);
		    u = x12 + x15 | 0;
		    x13 ^= u<<9 | u>>>(32-9);
		    u = x13 + x12 | 0;
		    x14 ^= u<<13 | u>>>(32-13);
		    u = x14 + x13 | 0;
		    x15 ^= u<<18 | u>>>(32-18);
		  }

		  o[ 0] = x0 >>>  0 & 0xff;
		  o[ 1] = x0 >>>  8 & 0xff;
		  o[ 2] = x0 >>> 16 & 0xff;
		  o[ 3] = x0 >>> 24 & 0xff;

		  o[ 4] = x5 >>>  0 & 0xff;
		  o[ 5] = x5 >>>  8 & 0xff;
		  o[ 6] = x5 >>> 16 & 0xff;
		  o[ 7] = x5 >>> 24 & 0xff;

		  o[ 8] = x10 >>>  0 & 0xff;
		  o[ 9] = x10 >>>  8 & 0xff;
		  o[10] = x10 >>> 16 & 0xff;
		  o[11] = x10 >>> 24 & 0xff;

		  o[12] = x15 >>>  0 & 0xff;
		  o[13] = x15 >>>  8 & 0xff;
		  o[14] = x15 >>> 16 & 0xff;
		  o[15] = x15 >>> 24 & 0xff;

		  o[16] = x6 >>>  0 & 0xff;
		  o[17] = x6 >>>  8 & 0xff;
		  o[18] = x6 >>> 16 & 0xff;
		  o[19] = x6 >>> 24 & 0xff;

		  o[20] = x7 >>>  0 & 0xff;
		  o[21] = x7 >>>  8 & 0xff;
		  o[22] = x7 >>> 16 & 0xff;
		  o[23] = x7 >>> 24 & 0xff;

		  o[24] = x8 >>>  0 & 0xff;
		  o[25] = x8 >>>  8 & 0xff;
		  o[26] = x8 >>> 16 & 0xff;
		  o[27] = x8 >>> 24 & 0xff;

		  o[28] = x9 >>>  0 & 0xff;
		  o[29] = x9 >>>  8 & 0xff;
		  o[30] = x9 >>> 16 & 0xff;
		  o[31] = x9 >>> 24 & 0xff;
		}

		function crypto_core_salsa20(out,inp,k,c) {
		  core_salsa20(out,inp,k,c);
		}

		function crypto_core_hsalsa20(out,inp,k,c) {
		  core_hsalsa20(out,inp,k,c);
		}

		var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
		            // "expand 32-byte k"

		function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
		  var z = new Uint8Array(16), x = new Uint8Array(64);
		  var u, i;
		  for (i = 0; i < 16; i++) z[i] = 0;
		  for (i = 0; i < 8; i++) z[i] = n[i];
		  while (b >= 64) {
		    crypto_core_salsa20(x,z,k,sigma);
		    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
		    u = 1;
		    for (i = 8; i < 16; i++) {
		      u = u + (z[i] & 0xff) | 0;
		      z[i] = u & 0xff;
		      u >>>= 8;
		    }
		    b -= 64;
		    cpos += 64;
		    mpos += 64;
		  }
		  if (b > 0) {
		    crypto_core_salsa20(x,z,k,sigma);
		    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
		  }
		  return 0;
		}

		function crypto_stream_salsa20(c,cpos,b,n,k) {
		  var z = new Uint8Array(16), x = new Uint8Array(64);
		  var u, i;
		  for (i = 0; i < 16; i++) z[i] = 0;
		  for (i = 0; i < 8; i++) z[i] = n[i];
		  while (b >= 64) {
		    crypto_core_salsa20(x,z,k,sigma);
		    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
		    u = 1;
		    for (i = 8; i < 16; i++) {
		      u = u + (z[i] & 0xff) | 0;
		      z[i] = u & 0xff;
		      u >>>= 8;
		    }
		    b -= 64;
		    cpos += 64;
		  }
		  if (b > 0) {
		    crypto_core_salsa20(x,z,k,sigma);
		    for (i = 0; i < b; i++) c[cpos+i] = x[i];
		  }
		  return 0;
		}

		function crypto_stream(c,cpos,d,n,k) {
		  var s = new Uint8Array(32);
		  crypto_core_hsalsa20(s,n,k,sigma);
		  var sn = new Uint8Array(8);
		  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
		  return crypto_stream_salsa20(c,cpos,d,sn,s);
		}

		function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
		  var s = new Uint8Array(32);
		  crypto_core_hsalsa20(s,n,k,sigma);
		  var sn = new Uint8Array(8);
		  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
		  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
		}

		/*
		* Port of Andrew Moon's Poly1305-donna-16. Public domain.
		* https://github.com/floodyberry/poly1305-donna
		*/

		var poly1305 = function(key) {
		  this.buffer = new Uint8Array(16);
		  this.r = new Uint16Array(10);
		  this.h = new Uint16Array(10);
		  this.pad = new Uint16Array(8);
		  this.leftover = 0;
		  this.fin = 0;

		  var t0, t1, t2, t3, t4, t5, t6, t7;

		  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
		  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
		  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
		  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
		  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
		  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
		  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
		  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
		  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
		  this.r[9] = ((t7 >>>  5)) & 0x007f;

		  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
		  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
		  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
		  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
		  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
		  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
		  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
		  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
		};

		poly1305.prototype.blocks = function(m, mpos, bytes) {
		  var hibit = this.fin ? 0 : (1 << 11);
		  var t0, t1, t2, t3, t4, t5, t6, t7, c;
		  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

		  var h0 = this.h[0],
		      h1 = this.h[1],
		      h2 = this.h[2],
		      h3 = this.h[3],
		      h4 = this.h[4],
		      h5 = this.h[5],
		      h6 = this.h[6],
		      h7 = this.h[7],
		      h8 = this.h[8],
		      h9 = this.h[9];

		  var r0 = this.r[0],
		      r1 = this.r[1],
		      r2 = this.r[2],
		      r3 = this.r[3],
		      r4 = this.r[4],
		      r5 = this.r[5],
		      r6 = this.r[6],
		      r7 = this.r[7],
		      r8 = this.r[8],
		      r9 = this.r[9];

		  while (bytes >= 16) {
		    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
		    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
		    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
		    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
		    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
		    h5 += ((t4 >>>  1)) & 0x1fff;
		    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
		    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
		    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
		    h9 += ((t7 >>> 5)) | hibit;

		    c = 0;

		    d0 = c;
		    d0 += h0 * r0;
		    d0 += h1 * (5 * r9);
		    d0 += h2 * (5 * r8);
		    d0 += h3 * (5 * r7);
		    d0 += h4 * (5 * r6);
		    c = (d0 >>> 13); d0 &= 0x1fff;
		    d0 += h5 * (5 * r5);
		    d0 += h6 * (5 * r4);
		    d0 += h7 * (5 * r3);
		    d0 += h8 * (5 * r2);
		    d0 += h9 * (5 * r1);
		    c += (d0 >>> 13); d0 &= 0x1fff;

		    d1 = c;
		    d1 += h0 * r1;
		    d1 += h1 * r0;
		    d1 += h2 * (5 * r9);
		    d1 += h3 * (5 * r8);
		    d1 += h4 * (5 * r7);
		    c = (d1 >>> 13); d1 &= 0x1fff;
		    d1 += h5 * (5 * r6);
		    d1 += h6 * (5 * r5);
		    d1 += h7 * (5 * r4);
		    d1 += h8 * (5 * r3);
		    d1 += h9 * (5 * r2);
		    c += (d1 >>> 13); d1 &= 0x1fff;

		    d2 = c;
		    d2 += h0 * r2;
		    d2 += h1 * r1;
		    d2 += h2 * r0;
		    d2 += h3 * (5 * r9);
		    d2 += h4 * (5 * r8);
		    c = (d2 >>> 13); d2 &= 0x1fff;
		    d2 += h5 * (5 * r7);
		    d2 += h6 * (5 * r6);
		    d2 += h7 * (5 * r5);
		    d2 += h8 * (5 * r4);
		    d2 += h9 * (5 * r3);
		    c += (d2 >>> 13); d2 &= 0x1fff;

		    d3 = c;
		    d3 += h0 * r3;
		    d3 += h1 * r2;
		    d3 += h2 * r1;
		    d3 += h3 * r0;
		    d3 += h4 * (5 * r9);
		    c = (d3 >>> 13); d3 &= 0x1fff;
		    d3 += h5 * (5 * r8);
		    d3 += h6 * (5 * r7);
		    d3 += h7 * (5 * r6);
		    d3 += h8 * (5 * r5);
		    d3 += h9 * (5 * r4);
		    c += (d3 >>> 13); d3 &= 0x1fff;

		    d4 = c;
		    d4 += h0 * r4;
		    d4 += h1 * r3;
		    d4 += h2 * r2;
		    d4 += h3 * r1;
		    d4 += h4 * r0;
		    c = (d4 >>> 13); d4 &= 0x1fff;
		    d4 += h5 * (5 * r9);
		    d4 += h6 * (5 * r8);
		    d4 += h7 * (5 * r7);
		    d4 += h8 * (5 * r6);
		    d4 += h9 * (5 * r5);
		    c += (d4 >>> 13); d4 &= 0x1fff;

		    d5 = c;
		    d5 += h0 * r5;
		    d5 += h1 * r4;
		    d5 += h2 * r3;
		    d5 += h3 * r2;
		    d5 += h4 * r1;
		    c = (d5 >>> 13); d5 &= 0x1fff;
		    d5 += h5 * r0;
		    d5 += h6 * (5 * r9);
		    d5 += h7 * (5 * r8);
		    d5 += h8 * (5 * r7);
		    d5 += h9 * (5 * r6);
		    c += (d5 >>> 13); d5 &= 0x1fff;

		    d6 = c;
		    d6 += h0 * r6;
		    d6 += h1 * r5;
		    d6 += h2 * r4;
		    d6 += h3 * r3;
		    d6 += h4 * r2;
		    c = (d6 >>> 13); d6 &= 0x1fff;
		    d6 += h5 * r1;
		    d6 += h6 * r0;
		    d6 += h7 * (5 * r9);
		    d6 += h8 * (5 * r8);
		    d6 += h9 * (5 * r7);
		    c += (d6 >>> 13); d6 &= 0x1fff;

		    d7 = c;
		    d7 += h0 * r7;
		    d7 += h1 * r6;
		    d7 += h2 * r5;
		    d7 += h3 * r4;
		    d7 += h4 * r3;
		    c = (d7 >>> 13); d7 &= 0x1fff;
		    d7 += h5 * r2;
		    d7 += h6 * r1;
		    d7 += h7 * r0;
		    d7 += h8 * (5 * r9);
		    d7 += h9 * (5 * r8);
		    c += (d7 >>> 13); d7 &= 0x1fff;

		    d8 = c;
		    d8 += h0 * r8;
		    d8 += h1 * r7;
		    d8 += h2 * r6;
		    d8 += h3 * r5;
		    d8 += h4 * r4;
		    c = (d8 >>> 13); d8 &= 0x1fff;
		    d8 += h5 * r3;
		    d8 += h6 * r2;
		    d8 += h7 * r1;
		    d8 += h8 * r0;
		    d8 += h9 * (5 * r9);
		    c += (d8 >>> 13); d8 &= 0x1fff;

		    d9 = c;
		    d9 += h0 * r9;
		    d9 += h1 * r8;
		    d9 += h2 * r7;
		    d9 += h3 * r6;
		    d9 += h4 * r5;
		    c = (d9 >>> 13); d9 &= 0x1fff;
		    d9 += h5 * r4;
		    d9 += h6 * r3;
		    d9 += h7 * r2;
		    d9 += h8 * r1;
		    d9 += h9 * r0;
		    c += (d9 >>> 13); d9 &= 0x1fff;

		    c = (((c << 2) + c)) | 0;
		    c = (c + d0) | 0;
		    d0 = c & 0x1fff;
		    c = (c >>> 13);
		    d1 += c;

		    h0 = d0;
		    h1 = d1;
		    h2 = d2;
		    h3 = d3;
		    h4 = d4;
		    h5 = d5;
		    h6 = d6;
		    h7 = d7;
		    h8 = d8;
		    h9 = d9;

		    mpos += 16;
		    bytes -= 16;
		  }
		  this.h[0] = h0;
		  this.h[1] = h1;
		  this.h[2] = h2;
		  this.h[3] = h3;
		  this.h[4] = h4;
		  this.h[5] = h5;
		  this.h[6] = h6;
		  this.h[7] = h7;
		  this.h[8] = h8;
		  this.h[9] = h9;
		};

		poly1305.prototype.finish = function(mac, macpos) {
		  var g = new Uint16Array(10);
		  var c, mask, f, i;

		  if (this.leftover) {
		    i = this.leftover;
		    this.buffer[i++] = 1;
		    for (; i < 16; i++) this.buffer[i] = 0;
		    this.fin = 1;
		    this.blocks(this.buffer, 0, 16);
		  }

		  c = this.h[1] >>> 13;
		  this.h[1] &= 0x1fff;
		  for (i = 2; i < 10; i++) {
		    this.h[i] += c;
		    c = this.h[i] >>> 13;
		    this.h[i] &= 0x1fff;
		  }
		  this.h[0] += (c * 5);
		  c = this.h[0] >>> 13;
		  this.h[0] &= 0x1fff;
		  this.h[1] += c;
		  c = this.h[1] >>> 13;
		  this.h[1] &= 0x1fff;
		  this.h[2] += c;

		  g[0] = this.h[0] + 5;
		  c = g[0] >>> 13;
		  g[0] &= 0x1fff;
		  for (i = 1; i < 10; i++) {
		    g[i] = this.h[i] + c;
		    c = g[i] >>> 13;
		    g[i] &= 0x1fff;
		  }
		  g[9] -= (1 << 13);

		  mask = (c ^ 1) - 1;
		  for (i = 0; i < 10; i++) g[i] &= mask;
		  mask = ~mask;
		  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

		  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
		  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
		  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
		  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
		  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
		  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
		  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
		  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

		  f = this.h[0] + this.pad[0];
		  this.h[0] = f & 0xffff;
		  for (i = 1; i < 8; i++) {
		    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
		    this.h[i] = f & 0xffff;
		  }

		  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
		  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
		  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
		  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
		  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
		  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
		  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
		  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
		  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
		  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
		  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
		  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
		  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
		  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
		  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
		  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
		};

		poly1305.prototype.update = function(m, mpos, bytes) {
		  var i, want;

		  if (this.leftover) {
		    want = (16 - this.leftover);
		    if (want > bytes)
		      want = bytes;
		    for (i = 0; i < want; i++)
		      this.buffer[this.leftover + i] = m[mpos+i];
		    bytes -= want;
		    mpos += want;
		    this.leftover += want;
		    if (this.leftover < 16)
		      return;
		    this.blocks(this.buffer, 0, 16);
		    this.leftover = 0;
		  }

		  if (bytes >= 16) {
		    want = bytes - (bytes % 16);
		    this.blocks(m, mpos, want);
		    mpos += want;
		    bytes -= want;
		  }

		  if (bytes) {
		    for (i = 0; i < bytes; i++)
		      this.buffer[this.leftover + i] = m[mpos+i];
		    this.leftover += bytes;
		  }
		};

		function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
		  var s = new poly1305(k);
		  s.update(m, mpos, n);
		  s.finish(out, outpos);
		  return 0;
		}

		function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
		  var x = new Uint8Array(16);
		  crypto_onetimeauth(x,0,m,mpos,n,k);
		  return crypto_verify_16(h,hpos,x,0);
		}

		function crypto_secretbox(c,m,d,n,k) {
		  var i;
		  if (d < 32) return -1;
		  crypto_stream_xor(c,0,m,0,d,n,k);
		  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
		  for (i = 0; i < 16; i++) c[i] = 0;
		  return 0;
		}

		function crypto_secretbox_open(m,c,d,n,k) {
		  var i;
		  var x = new Uint8Array(32);
		  if (d < 32) return -1;
		  crypto_stream(x,0,32,n,k);
		  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
		  crypto_stream_xor(m,0,c,0,d,n,k);
		  for (i = 0; i < 32; i++) m[i] = 0;
		  return 0;
		}

		function set25519(r, a) {
		  var i;
		  for (i = 0; i < 16; i++) r[i] = a[i]|0;
		}

		function car25519(o) {
		  var i, v, c = 1;
		  for (i = 0; i < 16; i++) {
		    v = o[i] + c + 65535;
		    c = Math.floor(v / 65536);
		    o[i] = v - c * 65536;
		  }
		  o[0] += c-1 + 37 * (c-1);
		}

		function sel25519(p, q, b) {
		  var t, c = ~(b-1);
		  for (var i = 0; i < 16; i++) {
		    t = c & (p[i] ^ q[i]);
		    p[i] ^= t;
		    q[i] ^= t;
		  }
		}

		function pack25519(o, n) {
		  var i, j, b;
		  var m = gf(), t = gf();
		  for (i = 0; i < 16; i++) t[i] = n[i];
		  car25519(t);
		  car25519(t);
		  car25519(t);
		  for (j = 0; j < 2; j++) {
		    m[0] = t[0] - 0xffed;
		    for (i = 1; i < 15; i++) {
		      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
		      m[i-1] &= 0xffff;
		    }
		    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
		    b = (m[15]>>16) & 1;
		    m[14] &= 0xffff;
		    sel25519(t, m, 1-b);
		  }
		  for (i = 0; i < 16; i++) {
		    o[2*i] = t[i] & 0xff;
		    o[2*i+1] = t[i]>>8;
		  }
		}

		function neq25519(a, b) {
		  var c = new Uint8Array(32), d = new Uint8Array(32);
		  pack25519(c, a);
		  pack25519(d, b);
		  return crypto_verify_32(c, 0, d, 0);
		}

		function par25519(a) {
		  var d = new Uint8Array(32);
		  pack25519(d, a);
		  return d[0] & 1;
		}

		function unpack25519(o, n) {
		  var i;
		  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
		  o[15] &= 0x7fff;
		}

		function A(o, a, b) {
		  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
		}

		function Z(o, a, b) {
		  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
		}

		function M(o, a, b) {
		  var v, c,
		     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
		     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
		    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
		    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
		    b0 = b[0],
		    b1 = b[1],
		    b2 = b[2],
		    b3 = b[3],
		    b4 = b[4],
		    b5 = b[5],
		    b6 = b[6],
		    b7 = b[7],
		    b8 = b[8],
		    b9 = b[9],
		    b10 = b[10],
		    b11 = b[11],
		    b12 = b[12],
		    b13 = b[13],
		    b14 = b[14],
		    b15 = b[15];

		  v = a[0];
		  t0 += v * b0;
		  t1 += v * b1;
		  t2 += v * b2;
		  t3 += v * b3;
		  t4 += v * b4;
		  t5 += v * b5;
		  t6 += v * b6;
		  t7 += v * b7;
		  t8 += v * b8;
		  t9 += v * b9;
		  t10 += v * b10;
		  t11 += v * b11;
		  t12 += v * b12;
		  t13 += v * b13;
		  t14 += v * b14;
		  t15 += v * b15;
		  v = a[1];
		  t1 += v * b0;
		  t2 += v * b1;
		  t3 += v * b2;
		  t4 += v * b3;
		  t5 += v * b4;
		  t6 += v * b5;
		  t7 += v * b6;
		  t8 += v * b7;
		  t9 += v * b8;
		  t10 += v * b9;
		  t11 += v * b10;
		  t12 += v * b11;
		  t13 += v * b12;
		  t14 += v * b13;
		  t15 += v * b14;
		  t16 += v * b15;
		  v = a[2];
		  t2 += v * b0;
		  t3 += v * b1;
		  t4 += v * b2;
		  t5 += v * b3;
		  t6 += v * b4;
		  t7 += v * b5;
		  t8 += v * b6;
		  t9 += v * b7;
		  t10 += v * b8;
		  t11 += v * b9;
		  t12 += v * b10;
		  t13 += v * b11;
		  t14 += v * b12;
		  t15 += v * b13;
		  t16 += v * b14;
		  t17 += v * b15;
		  v = a[3];
		  t3 += v * b0;
		  t4 += v * b1;
		  t5 += v * b2;
		  t6 += v * b3;
		  t7 += v * b4;
		  t8 += v * b5;
		  t9 += v * b6;
		  t10 += v * b7;
		  t11 += v * b8;
		  t12 += v * b9;
		  t13 += v * b10;
		  t14 += v * b11;
		  t15 += v * b12;
		  t16 += v * b13;
		  t17 += v * b14;
		  t18 += v * b15;
		  v = a[4];
		  t4 += v * b0;
		  t5 += v * b1;
		  t6 += v * b2;
		  t7 += v * b3;
		  t8 += v * b4;
		  t9 += v * b5;
		  t10 += v * b6;
		  t11 += v * b7;
		  t12 += v * b8;
		  t13 += v * b9;
		  t14 += v * b10;
		  t15 += v * b11;
		  t16 += v * b12;
		  t17 += v * b13;
		  t18 += v * b14;
		  t19 += v * b15;
		  v = a[5];
		  t5 += v * b0;
		  t6 += v * b1;
		  t7 += v * b2;
		  t8 += v * b3;
		  t9 += v * b4;
		  t10 += v * b5;
		  t11 += v * b6;
		  t12 += v * b7;
		  t13 += v * b8;
		  t14 += v * b9;
		  t15 += v * b10;
		  t16 += v * b11;
		  t17 += v * b12;
		  t18 += v * b13;
		  t19 += v * b14;
		  t20 += v * b15;
		  v = a[6];
		  t6 += v * b0;
		  t7 += v * b1;
		  t8 += v * b2;
		  t9 += v * b3;
		  t10 += v * b4;
		  t11 += v * b5;
		  t12 += v * b6;
		  t13 += v * b7;
		  t14 += v * b8;
		  t15 += v * b9;
		  t16 += v * b10;
		  t17 += v * b11;
		  t18 += v * b12;
		  t19 += v * b13;
		  t20 += v * b14;
		  t21 += v * b15;
		  v = a[7];
		  t7 += v * b0;
		  t8 += v * b1;
		  t9 += v * b2;
		  t10 += v * b3;
		  t11 += v * b4;
		  t12 += v * b5;
		  t13 += v * b6;
		  t14 += v * b7;
		  t15 += v * b8;
		  t16 += v * b9;
		  t17 += v * b10;
		  t18 += v * b11;
		  t19 += v * b12;
		  t20 += v * b13;
		  t21 += v * b14;
		  t22 += v * b15;
		  v = a[8];
		  t8 += v * b0;
		  t9 += v * b1;
		  t10 += v * b2;
		  t11 += v * b3;
		  t12 += v * b4;
		  t13 += v * b5;
		  t14 += v * b6;
		  t15 += v * b7;
		  t16 += v * b8;
		  t17 += v * b9;
		  t18 += v * b10;
		  t19 += v * b11;
		  t20 += v * b12;
		  t21 += v * b13;
		  t22 += v * b14;
		  t23 += v * b15;
		  v = a[9];
		  t9 += v * b0;
		  t10 += v * b1;
		  t11 += v * b2;
		  t12 += v * b3;
		  t13 += v * b4;
		  t14 += v * b5;
		  t15 += v * b6;
		  t16 += v * b7;
		  t17 += v * b8;
		  t18 += v * b9;
		  t19 += v * b10;
		  t20 += v * b11;
		  t21 += v * b12;
		  t22 += v * b13;
		  t23 += v * b14;
		  t24 += v * b15;
		  v = a[10];
		  t10 += v * b0;
		  t11 += v * b1;
		  t12 += v * b2;
		  t13 += v * b3;
		  t14 += v * b4;
		  t15 += v * b5;
		  t16 += v * b6;
		  t17 += v * b7;
		  t18 += v * b8;
		  t19 += v * b9;
		  t20 += v * b10;
		  t21 += v * b11;
		  t22 += v * b12;
		  t23 += v * b13;
		  t24 += v * b14;
		  t25 += v * b15;
		  v = a[11];
		  t11 += v * b0;
		  t12 += v * b1;
		  t13 += v * b2;
		  t14 += v * b3;
		  t15 += v * b4;
		  t16 += v * b5;
		  t17 += v * b6;
		  t18 += v * b7;
		  t19 += v * b8;
		  t20 += v * b9;
		  t21 += v * b10;
		  t22 += v * b11;
		  t23 += v * b12;
		  t24 += v * b13;
		  t25 += v * b14;
		  t26 += v * b15;
		  v = a[12];
		  t12 += v * b0;
		  t13 += v * b1;
		  t14 += v * b2;
		  t15 += v * b3;
		  t16 += v * b4;
		  t17 += v * b5;
		  t18 += v * b6;
		  t19 += v * b7;
		  t20 += v * b8;
		  t21 += v * b9;
		  t22 += v * b10;
		  t23 += v * b11;
		  t24 += v * b12;
		  t25 += v * b13;
		  t26 += v * b14;
		  t27 += v * b15;
		  v = a[13];
		  t13 += v * b0;
		  t14 += v * b1;
		  t15 += v * b2;
		  t16 += v * b3;
		  t17 += v * b4;
		  t18 += v * b5;
		  t19 += v * b6;
		  t20 += v * b7;
		  t21 += v * b8;
		  t22 += v * b9;
		  t23 += v * b10;
		  t24 += v * b11;
		  t25 += v * b12;
		  t26 += v * b13;
		  t27 += v * b14;
		  t28 += v * b15;
		  v = a[14];
		  t14 += v * b0;
		  t15 += v * b1;
		  t16 += v * b2;
		  t17 += v * b3;
		  t18 += v * b4;
		  t19 += v * b5;
		  t20 += v * b6;
		  t21 += v * b7;
		  t22 += v * b8;
		  t23 += v * b9;
		  t24 += v * b10;
		  t25 += v * b11;
		  t26 += v * b12;
		  t27 += v * b13;
		  t28 += v * b14;
		  t29 += v * b15;
		  v = a[15];
		  t15 += v * b0;
		  t16 += v * b1;
		  t17 += v * b2;
		  t18 += v * b3;
		  t19 += v * b4;
		  t20 += v * b5;
		  t21 += v * b6;
		  t22 += v * b7;
		  t23 += v * b8;
		  t24 += v * b9;
		  t25 += v * b10;
		  t26 += v * b11;
		  t27 += v * b12;
		  t28 += v * b13;
		  t29 += v * b14;
		  t30 += v * b15;

		  t0  += 38 * t16;
		  t1  += 38 * t17;
		  t2  += 38 * t18;
		  t3  += 38 * t19;
		  t4  += 38 * t20;
		  t5  += 38 * t21;
		  t6  += 38 * t22;
		  t7  += 38 * t23;
		  t8  += 38 * t24;
		  t9  += 38 * t25;
		  t10 += 38 * t26;
		  t11 += 38 * t27;
		  t12 += 38 * t28;
		  t13 += 38 * t29;
		  t14 += 38 * t30;
		  // t15 left as is

		  // first car
		  c = 1;
		  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
		  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
		  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
		  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
		  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
		  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
		  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
		  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
		  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
		  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
		  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
		  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
		  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
		  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
		  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
		  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
		  t0 += c-1 + 37 * (c-1);

		  // second car
		  c = 1;
		  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
		  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
		  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
		  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
		  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
		  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
		  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
		  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
		  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
		  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
		  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
		  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
		  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
		  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
		  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
		  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
		  t0 += c-1 + 37 * (c-1);

		  o[ 0] = t0;
		  o[ 1] = t1;
		  o[ 2] = t2;
		  o[ 3] = t3;
		  o[ 4] = t4;
		  o[ 5] = t5;
		  o[ 6] = t6;
		  o[ 7] = t7;
		  o[ 8] = t8;
		  o[ 9] = t9;
		  o[10] = t10;
		  o[11] = t11;
		  o[12] = t12;
		  o[13] = t13;
		  o[14] = t14;
		  o[15] = t15;
		}

		function S(o, a) {
		  M(o, a, a);
		}

		function inv25519(o, i) {
		  var c = gf();
		  var a;
		  for (a = 0; a < 16; a++) c[a] = i[a];
		  for (a = 253; a >= 0; a--) {
		    S(c, c);
		    if(a !== 2 && a !== 4) M(c, c, i);
		  }
		  for (a = 0; a < 16; a++) o[a] = c[a];
		}

		function pow2523(o, i) {
		  var c = gf();
		  var a;
		  for (a = 0; a < 16; a++) c[a] = i[a];
		  for (a = 250; a >= 0; a--) {
		      S(c, c);
		      if(a !== 1) M(c, c, i);
		  }
		  for (a = 0; a < 16; a++) o[a] = c[a];
		}

		function crypto_scalarmult(q, n, p) {
		  var z = new Uint8Array(32);
		  var x = new Float64Array(80), r, i;
		  var a = gf(), b = gf(), c = gf(),
		      d = gf(), e = gf(), f = gf();
		  for (i = 0; i < 31; i++) z[i] = n[i];
		  z[31]=(n[31]&127)|64;
		  z[0]&=248;
		  unpack25519(x,p);
		  for (i = 0; i < 16; i++) {
		    b[i]=x[i];
		    d[i]=a[i]=c[i]=0;
		  }
		  a[0]=d[0]=1;
		  for (i=254; i>=0; --i) {
		    r=(z[i>>>3]>>>(i&7))&1;
		    sel25519(a,b,r);
		    sel25519(c,d,r);
		    A(e,a,c);
		    Z(a,a,c);
		    A(c,b,d);
		    Z(b,b,d);
		    S(d,e);
		    S(f,a);
		    M(a,c,a);
		    M(c,b,e);
		    A(e,a,c);
		    Z(a,a,c);
		    S(b,a);
		    Z(c,d,f);
		    M(a,c,_121665);
		    A(a,a,d);
		    M(c,c,a);
		    M(a,d,f);
		    M(d,b,x);
		    S(b,e);
		    sel25519(a,b,r);
		    sel25519(c,d,r);
		  }
		  for (i = 0; i < 16; i++) {
		    x[i+16]=a[i];
		    x[i+32]=c[i];
		    x[i+48]=b[i];
		    x[i+64]=d[i];
		  }
		  var x32 = x.subarray(32);
		  var x16 = x.subarray(16);
		  inv25519(x32,x32);
		  M(x16,x16,x32);
		  pack25519(q,x16);
		  return 0;
		}

		function crypto_scalarmult_base(q, n) {
		  return crypto_scalarmult(q, n, _9);
		}

		function crypto_box_keypair(y, x) {
		  randombytes(x, 32);
		  return crypto_scalarmult_base(y, x);
		}

		function crypto_box_beforenm(k, y, x) {
		  var s = new Uint8Array(32);
		  crypto_scalarmult(s, x, y);
		  return crypto_core_hsalsa20(k, _0, s, sigma);
		}

		var crypto_box_afternm = crypto_secretbox;
		var crypto_box_open_afternm = crypto_secretbox_open;

		function crypto_box(c, m, d, n, y, x) {
		  var k = new Uint8Array(32);
		  crypto_box_beforenm(k, y, x);
		  return crypto_box_afternm(c, m, d, n, k);
		}

		function crypto_box_open(m, c, d, n, y, x) {
		  var k = new Uint8Array(32);
		  crypto_box_beforenm(k, y, x);
		  return crypto_box_open_afternm(m, c, d, n, k);
		}

		var K = [
		  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
		  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
		  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
		  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
		  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
		  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
		  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
		  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
		  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
		  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
		  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
		  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
		  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
		  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
		  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
		  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
		  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
		  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
		  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
		  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
		  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
		  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
		  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
		  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
		  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
		  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
		  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
		  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
		  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
		  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
		  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
		  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
		  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
		  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
		  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
		  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
		  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
		  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
		  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
		  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
		];

		function crypto_hashblocks_hl(hh, hl, m, n) {
		  var wh = new Int32Array(16), wl = new Int32Array(16),
		      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
		      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
		      th, tl, i, j, h, l, a, b, c, d;

		  var ah0 = hh[0],
		      ah1 = hh[1],
		      ah2 = hh[2],
		      ah3 = hh[3],
		      ah4 = hh[4],
		      ah5 = hh[5],
		      ah6 = hh[6],
		      ah7 = hh[7],

		      al0 = hl[0],
		      al1 = hl[1],
		      al2 = hl[2],
		      al3 = hl[3],
		      al4 = hl[4],
		      al5 = hl[5],
		      al6 = hl[6],
		      al7 = hl[7];

		  var pos = 0;
		  while (n >= 128) {
		    for (i = 0; i < 16; i++) {
		      j = 8 * i + pos;
		      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
		      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
		    }
		    for (i = 0; i < 80; i++) {
		      bh0 = ah0;
		      bh1 = ah1;
		      bh2 = ah2;
		      bh3 = ah3;
		      bh4 = ah4;
		      bh5 = ah5;
		      bh6 = ah6;
		      bh7 = ah7;

		      bl0 = al0;
		      bl1 = al1;
		      bl2 = al2;
		      bl3 = al3;
		      bl4 = al4;
		      bl5 = al5;
		      bl6 = al6;
		      bl7 = al7;

		      // add
		      h = ah7;
		      l = al7;

		      a = l & 0xffff; b = l >>> 16;
		      c = h & 0xffff; d = h >>> 16;

		      // Sigma1
		      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
		      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

		      a += l & 0xffff; b += l >>> 16;
		      c += h & 0xffff; d += h >>> 16;

		      // Ch
		      h = (ah4 & ah5) ^ (~ah4 & ah6);
		      l = (al4 & al5) ^ (~al4 & al6);

		      a += l & 0xffff; b += l >>> 16;
		      c += h & 0xffff; d += h >>> 16;

		      // K
		      h = K[i*2];
		      l = K[i*2+1];

		      a += l & 0xffff; b += l >>> 16;
		      c += h & 0xffff; d += h >>> 16;

		      // w
		      h = wh[i%16];
		      l = wl[i%16];

		      a += l & 0xffff; b += l >>> 16;
		      c += h & 0xffff; d += h >>> 16;

		      b += a >>> 16;
		      c += b >>> 16;
		      d += c >>> 16;

		      th = c & 0xffff | d << 16;
		      tl = a & 0xffff | b << 16;

		      // add
		      h = th;
		      l = tl;

		      a = l & 0xffff; b = l >>> 16;
		      c = h & 0xffff; d = h >>> 16;

		      // Sigma0
		      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
		      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

		      a += l & 0xffff; b += l >>> 16;
		      c += h & 0xffff; d += h >>> 16;

		      // Maj
		      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
		      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

		      a += l & 0xffff; b += l >>> 16;
		      c += h & 0xffff; d += h >>> 16;

		      b += a >>> 16;
		      c += b >>> 16;
		      d += c >>> 16;

		      bh7 = (c & 0xffff) | (d << 16);
		      bl7 = (a & 0xffff) | (b << 16);

		      // add
		      h = bh3;
		      l = bl3;

		      a = l & 0xffff; b = l >>> 16;
		      c = h & 0xffff; d = h >>> 16;

		      h = th;
		      l = tl;

		      a += l & 0xffff; b += l >>> 16;
		      c += h & 0xffff; d += h >>> 16;

		      b += a >>> 16;
		      c += b >>> 16;
		      d += c >>> 16;

		      bh3 = (c & 0xffff) | (d << 16);
		      bl3 = (a & 0xffff) | (b << 16);

		      ah1 = bh0;
		      ah2 = bh1;
		      ah3 = bh2;
		      ah4 = bh3;
		      ah5 = bh4;
		      ah6 = bh5;
		      ah7 = bh6;
		      ah0 = bh7;

		      al1 = bl0;
		      al2 = bl1;
		      al3 = bl2;
		      al4 = bl3;
		      al5 = bl4;
		      al6 = bl5;
		      al7 = bl6;
		      al0 = bl7;

		      if (i%16 === 15) {
		        for (j = 0; j < 16; j++) {
		          // add
		          h = wh[j];
		          l = wl[j];

		          a = l & 0xffff; b = l >>> 16;
		          c = h & 0xffff; d = h >>> 16;

		          h = wh[(j+9)%16];
		          l = wl[(j+9)%16];

		          a += l & 0xffff; b += l >>> 16;
		          c += h & 0xffff; d += h >>> 16;

		          // sigma0
		          th = wh[(j+1)%16];
		          tl = wl[(j+1)%16];
		          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
		          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

		          a += l & 0xffff; b += l >>> 16;
		          c += h & 0xffff; d += h >>> 16;

		          // sigma1
		          th = wh[(j+14)%16];
		          tl = wl[(j+14)%16];
		          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
		          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

		          a += l & 0xffff; b += l >>> 16;
		          c += h & 0xffff; d += h >>> 16;

		          b += a >>> 16;
		          c += b >>> 16;
		          d += c >>> 16;

		          wh[j] = (c & 0xffff) | (d << 16);
		          wl[j] = (a & 0xffff) | (b << 16);
		        }
		      }
		    }

		    // add
		    h = ah0;
		    l = al0;

		    a = l & 0xffff; b = l >>> 16;
		    c = h & 0xffff; d = h >>> 16;

		    h = hh[0];
		    l = hl[0];

		    a += l & 0xffff; b += l >>> 16;
		    c += h & 0xffff; d += h >>> 16;

		    b += a >>> 16;
		    c += b >>> 16;
		    d += c >>> 16;

		    hh[0] = ah0 = (c & 0xffff) | (d << 16);
		    hl[0] = al0 = (a & 0xffff) | (b << 16);

		    h = ah1;
		    l = al1;

		    a = l & 0xffff; b = l >>> 16;
		    c = h & 0xffff; d = h >>> 16;

		    h = hh[1];
		    l = hl[1];

		    a += l & 0xffff; b += l >>> 16;
		    c += h & 0xffff; d += h >>> 16;

		    b += a >>> 16;
		    c += b >>> 16;
		    d += c >>> 16;

		    hh[1] = ah1 = (c & 0xffff) | (d << 16);
		    hl[1] = al1 = (a & 0xffff) | (b << 16);

		    h = ah2;
		    l = al2;

		    a = l & 0xffff; b = l >>> 16;
		    c = h & 0xffff; d = h >>> 16;

		    h = hh[2];
		    l = hl[2];

		    a += l & 0xffff; b += l >>> 16;
		    c += h & 0xffff; d += h >>> 16;

		    b += a >>> 16;
		    c += b >>> 16;
		    d += c >>> 16;

		    hh[2] = ah2 = (c & 0xffff) | (d << 16);
		    hl[2] = al2 = (a & 0xffff) | (b << 16);

		    h = ah3;
		    l = al3;

		    a = l & 0xffff; b = l >>> 16;
		    c = h & 0xffff; d = h >>> 16;

		    h = hh[3];
		    l = hl[3];

		    a += l & 0xffff; b += l >>> 16;
		    c += h & 0xffff; d += h >>> 16;

		    b += a >>> 16;
		    c += b >>> 16;
		    d += c >>> 16;

		    hh[3] = ah3 = (c & 0xffff) | (d << 16);
		    hl[3] = al3 = (a & 0xffff) | (b << 16);

		    h = ah4;
		    l = al4;

		    a = l & 0xffff; b = l >>> 16;
		    c = h & 0xffff; d = h >>> 16;

		    h = hh[4];
		    l = hl[4];

		    a += l & 0xffff; b += l >>> 16;
		    c += h & 0xffff; d += h >>> 16;

		    b += a >>> 16;
		    c += b >>> 16;
		    d += c >>> 16;

		    hh[4] = ah4 = (c & 0xffff) | (d << 16);
		    hl[4] = al4 = (a & 0xffff) | (b << 16);

		    h = ah5;
		    l = al5;

		    a = l & 0xffff; b = l >>> 16;
		    c = h & 0xffff; d = h >>> 16;

		    h = hh[5];
		    l = hl[5];

		    a += l & 0xffff; b += l >>> 16;
		    c += h & 0xffff; d += h >>> 16;

		    b += a >>> 16;
		    c += b >>> 16;
		    d += c >>> 16;

		    hh[5] = ah5 = (c & 0xffff) | (d << 16);
		    hl[5] = al5 = (a & 0xffff) | (b << 16);

		    h = ah6;
		    l = al6;

		    a = l & 0xffff; b = l >>> 16;
		    c = h & 0xffff; d = h >>> 16;

		    h = hh[6];
		    l = hl[6];

		    a += l & 0xffff; b += l >>> 16;
		    c += h & 0xffff; d += h >>> 16;

		    b += a >>> 16;
		    c += b >>> 16;
		    d += c >>> 16;

		    hh[6] = ah6 = (c & 0xffff) | (d << 16);
		    hl[6] = al6 = (a & 0xffff) | (b << 16);

		    h = ah7;
		    l = al7;

		    a = l & 0xffff; b = l >>> 16;
		    c = h & 0xffff; d = h >>> 16;

		    h = hh[7];
		    l = hl[7];

		    a += l & 0xffff; b += l >>> 16;
		    c += h & 0xffff; d += h >>> 16;

		    b += a >>> 16;
		    c += b >>> 16;
		    d += c >>> 16;

		    hh[7] = ah7 = (c & 0xffff) | (d << 16);
		    hl[7] = al7 = (a & 0xffff) | (b << 16);

		    pos += 128;
		    n -= 128;
		  }

		  return n;
		}

		function crypto_hash(out, m, n) {
		  var hh = new Int32Array(8),
		      hl = new Int32Array(8),
		      x = new Uint8Array(256),
		      i, b = n;

		  hh[0] = 0x6a09e667;
		  hh[1] = 0xbb67ae85;
		  hh[2] = 0x3c6ef372;
		  hh[3] = 0xa54ff53a;
		  hh[4] = 0x510e527f;
		  hh[5] = 0x9b05688c;
		  hh[6] = 0x1f83d9ab;
		  hh[7] = 0x5be0cd19;

		  hl[0] = 0xf3bcc908;
		  hl[1] = 0x84caa73b;
		  hl[2] = 0xfe94f82b;
		  hl[3] = 0x5f1d36f1;
		  hl[4] = 0xade682d1;
		  hl[5] = 0x2b3e6c1f;
		  hl[6] = 0xfb41bd6b;
		  hl[7] = 0x137e2179;

		  crypto_hashblocks_hl(hh, hl, m, n);
		  n %= 128;

		  for (i = 0; i < n; i++) x[i] = m[b-n+i];
		  x[n] = 128;

		  n = 256-128*(n<112?1:0);
		  x[n-9] = 0;
		  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
		  crypto_hashblocks_hl(hh, hl, x, n);

		  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

		  return 0;
		}

		function add(p, q) {
		  var a = gf(), b = gf(), c = gf(),
		      d = gf(), e = gf(), f = gf(),
		      g = gf(), h = gf(), t = gf();

		  Z(a, p[1], p[0]);
		  Z(t, q[1], q[0]);
		  M(a, a, t);
		  A(b, p[0], p[1]);
		  A(t, q[0], q[1]);
		  M(b, b, t);
		  M(c, p[3], q[3]);
		  M(c, c, D2);
		  M(d, p[2], q[2]);
		  A(d, d, d);
		  Z(e, b, a);
		  Z(f, d, c);
		  A(g, d, c);
		  A(h, b, a);

		  M(p[0], e, f);
		  M(p[1], h, g);
		  M(p[2], g, f);
		  M(p[3], e, h);
		}

		function cswap(p, q, b) {
		  var i;
		  for (i = 0; i < 4; i++) {
		    sel25519(p[i], q[i], b);
		  }
		}

		function pack(r, p) {
		  var tx = gf(), ty = gf(), zi = gf();
		  inv25519(zi, p[2]);
		  M(tx, p[0], zi);
		  M(ty, p[1], zi);
		  pack25519(r, ty);
		  r[31] ^= par25519(tx) << 7;
		}

		function scalarmult(p, q, s) {
		  var b, i;
		  set25519(p[0], gf0);
		  set25519(p[1], gf1);
		  set25519(p[2], gf1);
		  set25519(p[3], gf0);
		  for (i = 255; i >= 0; --i) {
		    b = (s[(i/8)|0] >> (i&7)) & 1;
		    cswap(p, q, b);
		    add(q, p);
		    add(p, p);
		    cswap(p, q, b);
		  }
		}

		function scalarbase(p, s) {
		  var q = [gf(), gf(), gf(), gf()];
		  set25519(q[0], X);
		  set25519(q[1], Y);
		  set25519(q[2], gf1);
		  M(q[3], X, Y);
		  scalarmult(p, q, s);
		}

		function crypto_sign_keypair(pk, sk, seeded) {
		  var d = new Uint8Array(64);
		  var p = [gf(), gf(), gf(), gf()];
		  var i;

		  if (!seeded) randombytes(sk, 32);
		  crypto_hash(d, sk, 32);
		  d[0] &= 248;
		  d[31] &= 127;
		  d[31] |= 64;

		  scalarbase(p, d);
		  pack(pk, p);

		  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
		  return 0;
		}

		var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

		function modL(r, x) {
		  var carry, i, j, k;
		  for (i = 63; i >= 32; --i) {
		    carry = 0;
		    for (j = i - 32, k = i - 12; j < k; ++j) {
		      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
		      carry = Math.floor((x[j] + 128) / 256);
		      x[j] -= carry * 256;
		    }
		    x[j] += carry;
		    x[i] = 0;
		  }
		  carry = 0;
		  for (j = 0; j < 32; j++) {
		    x[j] += carry - (x[31] >> 4) * L[j];
		    carry = x[j] >> 8;
		    x[j] &= 255;
		  }
		  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
		  for (i = 0; i < 32; i++) {
		    x[i+1] += x[i] >> 8;
		    r[i] = x[i] & 255;
		  }
		}

		function reduce(r) {
		  var x = new Float64Array(64), i;
		  for (i = 0; i < 64; i++) x[i] = r[i];
		  for (i = 0; i < 64; i++) r[i] = 0;
		  modL(r, x);
		}

		// Note: difference from C - smlen returned, not passed as argument.
		function crypto_sign(sm, m, n, sk) {
		  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
		  var i, j, x = new Float64Array(64);
		  var p = [gf(), gf(), gf(), gf()];

		  crypto_hash(d, sk, 32);
		  d[0] &= 248;
		  d[31] &= 127;
		  d[31] |= 64;

		  var smlen = n + 64;
		  for (i = 0; i < n; i++) sm[64 + i] = m[i];
		  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

		  crypto_hash(r, sm.subarray(32), n+32);
		  reduce(r);
		  scalarbase(p, r);
		  pack(sm, p);

		  for (i = 32; i < 64; i++) sm[i] = sk[i];
		  crypto_hash(h, sm, n + 64);
		  reduce(h);

		  for (i = 0; i < 64; i++) x[i] = 0;
		  for (i = 0; i < 32; i++) x[i] = r[i];
		  for (i = 0; i < 32; i++) {
		    for (j = 0; j < 32; j++) {
		      x[i+j] += h[i] * d[j];
		    }
		  }

		  modL(sm.subarray(32), x);
		  return smlen;
		}

		function unpackneg(r, p) {
		  var t = gf(), chk = gf(), num = gf(),
		      den = gf(), den2 = gf(), den4 = gf(),
		      den6 = gf();

		  set25519(r[2], gf1);
		  unpack25519(r[1], p);
		  S(num, r[1]);
		  M(den, num, D);
		  Z(num, num, r[2]);
		  A(den, r[2], den);

		  S(den2, den);
		  S(den4, den2);
		  M(den6, den4, den2);
		  M(t, den6, num);
		  M(t, t, den);

		  pow2523(t, t);
		  M(t, t, num);
		  M(t, t, den);
		  M(t, t, den);
		  M(r[0], t, den);

		  S(chk, r[0]);
		  M(chk, chk, den);
		  if (neq25519(chk, num)) M(r[0], r[0], I);

		  S(chk, r[0]);
		  M(chk, chk, den);
		  if (neq25519(chk, num)) return -1;

		  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

		  M(r[3], r[0], r[1]);
		  return 0;
		}

		function crypto_sign_open(m, sm, n, pk) {
		  var i;
		  var t = new Uint8Array(32), h = new Uint8Array(64);
		  var p = [gf(), gf(), gf(), gf()],
		      q = [gf(), gf(), gf(), gf()];

		  if (n < 64) return -1;

		  if (unpackneg(q, pk)) return -1;

		  for (i = 0; i < n; i++) m[i] = sm[i];
		  for (i = 0; i < 32; i++) m[i+32] = pk[i];
		  crypto_hash(h, m, n);
		  reduce(h);
		  scalarmult(p, q, h);

		  scalarbase(q, sm.subarray(32));
		  add(p, q);
		  pack(t, p);

		  n -= 64;
		  if (crypto_verify_32(sm, 0, t, 0)) {
		    for (i = 0; i < n; i++) m[i] = 0;
		    return -1;
		  }

		  for (i = 0; i < n; i++) m[i] = sm[i + 64];
		  return n;
		}

		var crypto_secretbox_KEYBYTES = 32,
		    crypto_secretbox_NONCEBYTES = 24,
		    crypto_secretbox_ZEROBYTES = 32,
		    crypto_secretbox_BOXZEROBYTES = 16,
		    crypto_scalarmult_BYTES = 32,
		    crypto_scalarmult_SCALARBYTES = 32,
		    crypto_box_PUBLICKEYBYTES = 32,
		    crypto_box_SECRETKEYBYTES = 32,
		    crypto_box_BEFORENMBYTES = 32,
		    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
		    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
		    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
		    crypto_sign_BYTES = 64,
		    crypto_sign_PUBLICKEYBYTES = 32,
		    crypto_sign_SECRETKEYBYTES = 64,
		    crypto_sign_SEEDBYTES = 32,
		    crypto_hash_BYTES = 64;

		nacl.lowlevel = {
		  crypto_core_hsalsa20: crypto_core_hsalsa20,
		  crypto_stream_xor: crypto_stream_xor,
		  crypto_stream: crypto_stream,
		  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
		  crypto_stream_salsa20: crypto_stream_salsa20,
		  crypto_onetimeauth: crypto_onetimeauth,
		  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
		  crypto_verify_16: crypto_verify_16,
		  crypto_verify_32: crypto_verify_32,
		  crypto_secretbox: crypto_secretbox,
		  crypto_secretbox_open: crypto_secretbox_open,
		  crypto_scalarmult: crypto_scalarmult,
		  crypto_scalarmult_base: crypto_scalarmult_base,
		  crypto_box_beforenm: crypto_box_beforenm,
		  crypto_box_afternm: crypto_box_afternm,
		  crypto_box: crypto_box,
		  crypto_box_open: crypto_box_open,
		  crypto_box_keypair: crypto_box_keypair,
		  crypto_hash: crypto_hash,
		  crypto_sign: crypto_sign,
		  crypto_sign_keypair: crypto_sign_keypair,
		  crypto_sign_open: crypto_sign_open,

		  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
		  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
		  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
		  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
		  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
		  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
		  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
		  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
		  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
		  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
		  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
		  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
		  crypto_sign_BYTES: crypto_sign_BYTES,
		  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
		  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
		  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
		  crypto_hash_BYTES: crypto_hash_BYTES,

		  gf: gf,
		  D: D,
		  L: L,
		  pack25519: pack25519,
		  unpack25519: unpack25519,
		  M: M,
		  A: A,
		  S: S,
		  Z: Z,
		  pow2523: pow2523,
		  add: add,
		  set25519: set25519,
		  modL: modL,
		  scalarmult: scalarmult,
		  scalarbase: scalarbase,
		};

		/* High-level API */

		function checkLengths(k, n) {
		  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
		  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
		}

		function checkBoxLengths(pk, sk) {
		  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
		  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
		}

		function checkArrayTypes() {
		  for (var i = 0; i < arguments.length; i++) {
		    if (!(arguments[i] instanceof Uint8Array))
		      throw new TypeError('unexpected type, use Uint8Array');
		  }
		}

		function cleanup(arr) {
		  for (var i = 0; i < arr.length; i++) arr[i] = 0;
		}

		nacl.randomBytes = function(n) {
		  var b = new Uint8Array(n);
		  randombytes(b, n);
		  return b;
		};

		nacl.secretbox = function(msg, nonce, key) {
		  checkArrayTypes(msg, nonce, key);
		  checkLengths(key, nonce);
		  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
		  var c = new Uint8Array(m.length);
		  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
		  crypto_secretbox(c, m, m.length, nonce, key);
		  return c.subarray(crypto_secretbox_BOXZEROBYTES);
		};

		nacl.secretbox.open = function(box, nonce, key) {
		  checkArrayTypes(box, nonce, key);
		  checkLengths(key, nonce);
		  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
		  var m = new Uint8Array(c.length);
		  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
		  if (c.length < 32) return null;
		  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
		  return m.subarray(crypto_secretbox_ZEROBYTES);
		};

		nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
		nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
		nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

		nacl.scalarMult = function(n, p) {
		  checkArrayTypes(n, p);
		  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
		  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
		  var q = new Uint8Array(crypto_scalarmult_BYTES);
		  crypto_scalarmult(q, n, p);
		  return q;
		};

		nacl.scalarMult.base = function(n) {
		  checkArrayTypes(n);
		  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
		  var q = new Uint8Array(crypto_scalarmult_BYTES);
		  crypto_scalarmult_base(q, n);
		  return q;
		};

		nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
		nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

		nacl.box = function(msg, nonce, publicKey, secretKey) {
		  var k = nacl.box.before(publicKey, secretKey);
		  return nacl.secretbox(msg, nonce, k);
		};

		nacl.box.before = function(publicKey, secretKey) {
		  checkArrayTypes(publicKey, secretKey);
		  checkBoxLengths(publicKey, secretKey);
		  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
		  crypto_box_beforenm(k, publicKey, secretKey);
		  return k;
		};

		nacl.box.after = nacl.secretbox;

		nacl.box.open = function(msg, nonce, publicKey, secretKey) {
		  var k = nacl.box.before(publicKey, secretKey);
		  return nacl.secretbox.open(msg, nonce, k);
		};

		nacl.box.open.after = nacl.secretbox.open;

		nacl.box.keyPair = function() {
		  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
		  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
		  crypto_box_keypair(pk, sk);
		  return {publicKey: pk, secretKey: sk};
		};

		nacl.box.keyPair.fromSecretKey = function(secretKey) {
		  checkArrayTypes(secretKey);
		  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
		    throw new Error('bad secret key size');
		  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
		  crypto_scalarmult_base(pk, secretKey);
		  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
		};

		nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
		nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
		nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
		nacl.box.nonceLength = crypto_box_NONCEBYTES;
		nacl.box.overheadLength = nacl.secretbox.overheadLength;

		nacl.sign = function(msg, secretKey) {
		  checkArrayTypes(msg, secretKey);
		  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
		    throw new Error('bad secret key size');
		  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
		  crypto_sign(signedMsg, msg, msg.length, secretKey);
		  return signedMsg;
		};

		nacl.sign.open = function(signedMsg, publicKey) {
		  checkArrayTypes(signedMsg, publicKey);
		  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
		    throw new Error('bad public key size');
		  var tmp = new Uint8Array(signedMsg.length);
		  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
		  if (mlen < 0) return null;
		  var m = new Uint8Array(mlen);
		  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
		  return m;
		};

		nacl.sign.detached = function(msg, secretKey) {
		  var signedMsg = nacl.sign(msg, secretKey);
		  var sig = new Uint8Array(crypto_sign_BYTES);
		  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
		  return sig;
		};

		nacl.sign.detached.verify = function(msg, sig, publicKey) {
		  checkArrayTypes(msg, sig, publicKey);
		  if (sig.length !== crypto_sign_BYTES)
		    throw new Error('bad signature size');
		  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
		    throw new Error('bad public key size');
		  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
		  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
		  var i;
		  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
		  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
		  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
		};

		nacl.sign.keyPair = function() {
		  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
		  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
		  crypto_sign_keypair(pk, sk);
		  return {publicKey: pk, secretKey: sk};
		};

		nacl.sign.keyPair.fromSecretKey = function(secretKey) {
		  checkArrayTypes(secretKey);
		  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
		    throw new Error('bad secret key size');
		  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
		  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
		  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
		};

		nacl.sign.keyPair.fromSeed = function(seed) {
		  checkArrayTypes(seed);
		  if (seed.length !== crypto_sign_SEEDBYTES)
		    throw new Error('bad seed size');
		  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
		  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
		  for (var i = 0; i < 32; i++) sk[i] = seed[i];
		  crypto_sign_keypair(pk, sk, true);
		  return {publicKey: pk, secretKey: sk};
		};

		nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
		nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
		nacl.sign.seedLength = crypto_sign_SEEDBYTES;
		nacl.sign.signatureLength = crypto_sign_BYTES;

		nacl.hash = function(msg) {
		  checkArrayTypes(msg);
		  var h = new Uint8Array(crypto_hash_BYTES);
		  crypto_hash(h, msg, msg.length);
		  return h;
		};

		nacl.hash.hashLength = crypto_hash_BYTES;

		nacl.verify = function(x, y) {
		  checkArrayTypes(x, y);
		  // Zero length arguments are considered not equal.
		  if (x.length === 0 || y.length === 0) return false;
		  if (x.length !== y.length) return false;
		  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
		};

		nacl.setPRNG = function(fn) {
		  randombytes = fn;
		};

		(function() {
		  // Initialize PRNG if environment provides CSPRNG.
		  // If not, methods calling randombytes will throw.
		  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
		  if (crypto && crypto.getRandomValues) {
		    // Browsers.
		    var QUOTA = 65536;
		    nacl.setPRNG(function(x, n) {
		      var i, v = new Uint8Array(n);
		      for (i = 0; i < n; i += QUOTA) {
		        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
		      }
		      for (i = 0; i < n; i++) x[i] = v[i];
		      cleanup(v);
		    });
		  } else if (typeof commonjsRequire !== 'undefined') {
		    // Node.js.
		    crypto = require$$0$2;
		    if (crypto && crypto.randomBytes) {
		      nacl.setPRNG(function(x, n) {
		        var i, v = crypto.randomBytes(n);
		        for (i = 0; i < n; i++) x[i] = v[i];
		        cleanup(v);
		      });
		    }
		  }
		})();

		})(module.exports ? module.exports : (self.nacl = self.nacl || {})); 
	} (naclFast));
	return naclFast.exports;
}

var binary = {};

var hasRequiredBinary;

function requireBinary () {
	if (hasRequiredBinary) return binary;
	hasRequiredBinary = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(binary, "__esModule", { value: true });
	binary.bitsToBytes = binary.bytesToBits = binary.lpad = void 0;
	function lpad(str, padString, length) {
	    while (str.length < length) {
	        str = padString + str;
	    }
	    return str;
	}
	binary.lpad = lpad;
	function bytesToBits(bytes) {
	    let res = '';
	    for (let i = 0; i < bytes.length; i++) {
	        let x = bytes.at(i);
	        res += lpad(x.toString(2), '0', 8);
	    }
	    return res;
	}
	binary.bytesToBits = bytesToBits;
	function bitsToBytes(src) {
	    if (src.length % 8 !== 0) {
	        throw Error('Uneven bits');
	    }
	    let res = [];
	    while (src.length > 0) {
	        res.push(parseInt(src.slice(0, 8), 2));
	        src = src.slice(8);
	    }
	    return Buffer.from(res);
	}
	binary.bitsToBytes = bitsToBytes;
	return binary;
}

var wordlist = {};

var hasRequiredWordlist;

function requireWordlist () {
	if (hasRequiredWordlist) return wordlist;
	hasRequiredWordlist = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(wordlist, "__esModule", { value: true });
	wordlist.wordlist = void 0;
	const EN = ['abandon', 'ability', 'able', 'about', 'above', 'absent', 'absorb', 'abstract', 'absurd', 'abuse', 'access', 'accident', 'account', 'accuse', 'achieve', 'acid', 'acoustic', 'acquire', 'across', 'act', 'action', 'actor', 'actress', 'actual', 'adapt', 'add', 'addict', 'address', 'adjust', 'admit', 'adult', 'advance', 'advice', 'aerobic', 'affair', 'afford', 'afraid', 'again', 'age', 'agent', 'agree', 'ahead', 'aim', 'air', 'airport', 'aisle', 'alarm', 'album', 'alcohol', 'alert', 'alien', 'all', 'alley', 'allow', 'almost', 'alone', 'alpha', 'already', 'also', 'alter', 'always', 'amateur', 'amazing', 'among', 'amount', 'amused', 'analyst', 'anchor', 'ancient', 'anger', 'angle', 'angry', 'animal', 'ankle', 'announce', 'annual', 'another', 'answer', 'antenna', 'antique', 'anxiety', 'any', 'apart', 'apology', 'appear', 'apple', 'approve', 'april', 'arch', 'arctic', 'area', 'arena', 'argue', 'arm', 'armed', 'armor', 'army', 'around', 'arrange', 'arrest', 'arrive', 'arrow', 'art', 'artefact', 'artist', 'artwork', 'ask', 'aspect', 'assault', 'asset', 'assist', 'assume', 'asthma', 'athlete', 'atom', 'attack', 'attend', 'attitude', 'attract', 'auction', 'audit', 'august', 'aunt', 'author', 'auto', 'autumn', 'average', 'avocado', 'avoid', 'awake', 'aware', 'away', 'awesome', 'awful', 'awkward', 'axis',
	    'baby', 'bachelor', 'bacon', 'badge', 'bag', 'balance', 'balcony', 'ball', 'bamboo', 'banana', 'banner', 'bar', 'barely', 'bargain', 'barrel', 'base', 'basic', 'basket', 'battle', 'beach', 'bean', 'beauty', 'because', 'become', 'beef', 'before', 'begin', 'behave', 'behind', 'believe', 'below', 'belt', 'bench', 'benefit', 'best', 'betray', 'better', 'between', 'beyond', 'bicycle', 'bid', 'bike', 'bind', 'biology', 'bird', 'birth', 'bitter', 'black', 'blade', 'blame', 'blanket', 'blast', 'bleak', 'bless', 'blind', 'blood', 'blossom', 'blouse', 'blue', 'blur', 'blush', 'board', 'boat', 'body', 'boil', 'bomb', 'bone', 'bonus', 'book', 'boost', 'border', 'boring', 'borrow', 'boss', 'bottom', 'bounce', 'box', 'boy', 'bracket', 'brain', 'brand', 'brass', 'brave', 'bread', 'breeze', 'brick', 'bridge', 'brief', 'bright', 'bring', 'brisk', 'broccoli', 'broken', 'bronze', 'broom', 'brother', 'brown', 'brush', 'bubble', 'buddy', 'budget', 'buffalo', 'build', 'bulb', 'bulk', 'bullet', 'bundle', 'bunker', 'burden', 'burger', 'burst', 'bus', 'business', 'busy', 'butter', 'buyer', 'buzz',
	    'cabbage', 'cabin', 'cable', 'cactus', 'cage', 'cake', 'call', 'calm', 'camera', 'camp', 'can', 'canal', 'cancel', 'candy', 'cannon', 'canoe', 'canvas', 'canyon', 'capable', 'capital', 'captain', 'car', 'carbon', 'card', 'cargo', 'carpet', 'carry', 'cart', 'case', 'cash', 'casino', 'castle', 'casual', 'cat', 'catalog', 'catch', 'category', 'cattle', 'caught', 'cause', 'caution', 'cave', 'ceiling', 'celery', 'cement', 'census', 'century', 'cereal', 'certain', 'chair', 'chalk', 'champion', 'change', 'chaos', 'chapter', 'charge', 'chase', 'chat', 'cheap', 'check', 'cheese', 'chef', 'cherry', 'chest', 'chicken', 'chief', 'child', 'chimney', 'choice', 'choose', 'chronic', 'chuckle', 'chunk', 'churn', 'cigar', 'cinnamon', 'circle', 'citizen', 'city', 'civil', 'claim', 'clap', 'clarify', 'claw', 'clay', 'clean', 'clerk', 'clever', 'click', 'client', 'cliff', 'climb', 'clinic', 'clip', 'clock', 'clog', 'close', 'cloth', 'cloud', 'clown', 'club', 'clump', 'cluster', 'clutch', 'coach', 'coast', 'coconut', 'code', 'coffee', 'coil', 'coin', 'collect', 'color', 'column', 'combine', 'come', 'comfort', 'comic', 'common', 'company', 'concert', 'conduct', 'confirm', 'congress', 'connect', 'consider', 'control', 'convince', 'cook', 'cool', 'copper', 'copy', 'coral', 'core', 'corn', 'correct', 'cost', 'cotton', 'couch', 'country', 'couple', 'course', 'cousin', 'cover', 'coyote', 'crack', 'cradle', 'craft', 'cram', 'crane', 'crash', 'crater', 'crawl', 'crazy', 'cream', 'credit', 'creek', 'crew', 'cricket', 'crime', 'crisp', 'critic', 'crop', 'cross', 'crouch', 'crowd', 'crucial', 'cruel', 'cruise', 'crumble', 'crunch', 'crush', 'cry', 'crystal', 'cube', 'culture', 'cup', 'cupboard', 'curious', 'current', 'curtain', 'curve', 'cushion', 'custom', 'cute', 'cycle',
	    'dad', 'damage', 'damp', 'dance', 'danger', 'daring', 'dash', 'daughter', 'dawn', 'day', 'deal', 'debate', 'debris', 'decade', 'december', 'decide', 'decline', 'decorate', 'decrease', 'deer', 'defense', 'define', 'defy', 'degree', 'delay', 'deliver', 'demand', 'demise', 'denial', 'dentist', 'deny', 'depart', 'depend', 'deposit', 'depth', 'deputy', 'derive', 'describe', 'desert', 'design', 'desk', 'despair', 'destroy', 'detail', 'detect', 'develop', 'device', 'devote', 'diagram', 'dial', 'diamond', 'diary', 'dice', 'diesel', 'diet', 'differ', 'digital', 'dignity', 'dilemma', 'dinner', 'dinosaur', 'direct', 'dirt', 'disagree', 'discover', 'disease', 'dish', 'dismiss', 'disorder', 'display', 'distance', 'divert', 'divide', 'divorce', 'dizzy', 'doctor', 'document', 'dog', 'doll', 'dolphin', 'domain', 'donate', 'donkey', 'donor', 'door', 'dose', 'double', 'dove', 'draft', 'dragon', 'drama', 'drastic', 'draw', 'dream', 'dress', 'drift', 'drill', 'drink', 'drip', 'drive', 'drop', 'drum', 'dry', 'duck', 'dumb', 'dune', 'during', 'dust', 'dutch', 'duty', 'dwarf', 'dynamic',
	    'eager', 'eagle', 'early', 'earn', 'earth', 'easily', 'east', 'easy', 'echo', 'ecology', 'economy', 'edge', 'edit', 'educate', 'effort', 'egg', 'eight', 'either', 'elbow', 'elder', 'electric', 'elegant', 'element', 'elephant', 'elevator', 'elite', 'else', 'embark', 'embody', 'embrace', 'emerge', 'emotion', 'employ', 'empower', 'empty', 'enable', 'enact', 'end', 'endless', 'endorse', 'enemy', 'energy', 'enforce', 'engage', 'engine', 'enhance', 'enjoy', 'enlist', 'enough', 'enrich', 'enroll', 'ensure', 'enter', 'entire', 'entry', 'envelope', 'episode', 'equal', 'equip', 'era', 'erase', 'erode', 'erosion', 'error', 'erupt', 'escape', 'essay', 'essence', 'estate', 'eternal', 'ethics', 'evidence', 'evil', 'evoke', 'evolve', 'exact', 'example', 'excess', 'exchange', 'excite', 'exclude', 'excuse', 'execute', 'exercise', 'exhaust', 'exhibit', 'exile', 'exist', 'exit', 'exotic', 'expand', 'expect', 'expire', 'explain', 'expose', 'express', 'extend', 'extra', 'eye', 'eyebrow',
	    'fabric', 'face', 'faculty', 'fade', 'faint', 'faith', 'fall', 'false', 'fame', 'family', 'famous', 'fan', 'fancy', 'fantasy', 'farm', 'fashion', 'fat', 'fatal', 'father', 'fatigue', 'fault', 'favorite', 'feature', 'february', 'federal', 'fee', 'feed', 'feel', 'female', 'fence', 'festival', 'fetch', 'fever', 'few', 'fiber', 'fiction', 'field', 'figure', 'file', 'film', 'filter', 'final', 'find', 'fine', 'finger', 'finish', 'fire', 'firm', 'first', 'fiscal', 'fish', 'fit', 'fitness', 'fix', 'flag', 'flame', 'flash', 'flat', 'flavor', 'flee', 'flight', 'flip', 'float', 'flock', 'floor', 'flower', 'fluid', 'flush', 'fly', 'foam', 'focus', 'fog', 'foil', 'fold', 'follow', 'food', 'foot', 'force', 'forest', 'forget', 'fork', 'fortune', 'forum', 'forward', 'fossil', 'foster', 'found', 'fox', 'fragile', 'frame', 'frequent', 'fresh', 'friend', 'fringe', 'frog', 'front', 'frost', 'frown', 'frozen', 'fruit', 'fuel', 'fun', 'funny', 'furnace', 'fury', 'future',
	    'gadget', 'gain', 'galaxy', 'gallery', 'game', 'gap', 'garage', 'garbage', 'garden', 'garlic', 'garment', 'gas', 'gasp', 'gate', 'gather', 'gauge', 'gaze', 'general', 'genius', 'genre', 'gentle', 'genuine', 'gesture', 'ghost', 'giant', 'gift', 'giggle', 'ginger', 'giraffe', 'girl', 'give', 'glad', 'glance', 'glare', 'glass', 'glide', 'glimpse', 'globe', 'gloom', 'glory', 'glove', 'glow', 'glue', 'goat', 'goddess', 'gold', 'good', 'goose', 'gorilla', 'gospel', 'gossip', 'govern', 'gown', 'grab', 'grace', 'grain', 'grant', 'grape', 'grass', 'gravity', 'great', 'green', 'grid', 'grief', 'grit', 'grocery', 'group', 'grow', 'grunt', 'guard', 'guess', 'guide', 'guilt', 'guitar', 'gun', 'gym',
	    'habit', 'hair', 'half', 'hammer', 'hamster', 'hand', 'happy', 'harbor', 'hard', 'harsh', 'harvest', 'hat', 'have', 'hawk', 'hazard', 'head', 'health', 'heart', 'heavy', 'hedgehog', 'height', 'hello', 'helmet', 'help', 'hen', 'hero', 'hidden', 'high', 'hill', 'hint', 'hip', 'hire', 'history', 'hobby', 'hockey', 'hold', 'hole', 'holiday', 'hollow', 'home', 'honey', 'hood', 'hope', 'horn', 'horror', 'horse', 'hospital', 'host', 'hotel', 'hour', 'hover', 'hub', 'huge', 'human', 'humble', 'humor', 'hundred', 'hungry', 'hunt', 'hurdle', 'hurry', 'hurt', 'husband', 'hybrid',
	    'ice', 'icon', 'idea', 'identify', 'idle', 'ignore', 'ill', 'illegal', 'illness', 'image', 'imitate', 'immense', 'immune', 'impact', 'impose', 'improve', 'impulse', 'inch', 'include', 'income', 'increase', 'index', 'indicate', 'indoor', 'industry', 'infant', 'inflict', 'inform', 'inhale', 'inherit', 'initial', 'inject', 'injury', 'inmate', 'inner', 'innocent', 'input', 'inquiry', 'insane', 'insect', 'inside', 'inspire', 'install', 'intact', 'interest', 'into', 'invest', 'invite', 'involve', 'iron', 'island', 'isolate', 'issue', 'item', 'ivory',
	    'jacket', 'jaguar', 'jar', 'jazz', 'jealous', 'jeans', 'jelly', 'jewel', 'job', 'join', 'joke', 'journey', 'joy', 'judge', 'juice', 'jump', 'jungle', 'junior', 'junk', 'just',
	    'kangaroo', 'keen', 'keep', 'ketchup', 'key', 'kick', 'kid', 'kidney', 'kind', 'kingdom', 'kiss', 'kit', 'kitchen', 'kite', 'kitten', 'kiwi', 'knee', 'knife', 'knock', 'know',
	    'lab', 'label', 'labor', 'ladder', 'lady', 'lake', 'lamp', 'language', 'laptop', 'large', 'later', 'latin', 'laugh', 'laundry', 'lava', 'law', 'lawn', 'lawsuit', 'layer', 'lazy', 'leader', 'leaf', 'learn', 'leave', 'lecture', 'left', 'leg', 'legal', 'legend', 'leisure', 'lemon', 'lend', 'length', 'lens', 'leopard', 'lesson', 'letter', 'level', 'liar', 'liberty', 'library', 'license', 'life', 'lift', 'light', 'like', 'limb', 'limit', 'link', 'lion', 'liquid', 'list', 'little', 'live', 'lizard', 'load', 'loan', 'lobster', 'local', 'lock', 'logic', 'lonely', 'long', 'loop', 'lottery', 'loud', 'lounge', 'love', 'loyal', 'lucky', 'luggage', 'lumber', 'lunar', 'lunch', 'luxury', 'lyrics',
	    'machine', 'mad', 'magic', 'magnet', 'maid', 'mail', 'main', 'major', 'make', 'mammal', 'man', 'manage', 'mandate', 'mango', 'mansion', 'manual', 'maple', 'marble', 'march', 'margin', 'marine', 'market', 'marriage', 'mask', 'mass', 'master', 'match', 'material', 'math', 'matrix', 'matter', 'maximum', 'maze', 'meadow', 'mean', 'measure', 'meat', 'mechanic', 'medal', 'media', 'melody', 'melt', 'member', 'memory', 'mention', 'menu', 'mercy', 'merge', 'merit', 'merry', 'mesh', 'message', 'metal', 'method', 'middle', 'midnight', 'milk', 'million', 'mimic', 'mind', 'minimum', 'minor', 'minute', 'miracle', 'mirror', 'misery', 'miss', 'mistake', 'mix', 'mixed', 'mixture', 'mobile', 'model', 'modify', 'mom', 'moment', 'monitor', 'monkey', 'monster', 'month', 'moon', 'moral', 'more', 'morning', 'mosquito', 'mother', 'motion', 'motor', 'mountain', 'mouse', 'move', 'movie', 'much', 'muffin', 'mule', 'multiply', 'muscle', 'museum', 'mushroom', 'music', 'must', 'mutual', 'myself', 'mystery', 'myth',
	    'naive', 'name', 'napkin', 'narrow', 'nasty', 'nation', 'nature', 'near', 'neck', 'need', 'negative', 'neglect', 'neither', 'nephew', 'nerve', 'nest', 'net', 'network', 'neutral', 'never', 'news', 'next', 'nice', 'night', 'noble', 'noise', 'nominee', 'noodle', 'normal', 'north', 'nose', 'notable', 'note', 'nothing', 'notice', 'novel', 'now', 'nuclear', 'number', 'nurse', 'nut',
	    'oak', 'obey', 'object', 'oblige', 'obscure', 'observe', 'obtain', 'obvious', 'occur', 'ocean', 'october', 'odor', 'off', 'offer', 'office', 'often', 'oil', 'okay', 'old', 'olive', 'olympic', 'omit', 'once', 'one', 'onion', 'online', 'only', 'open', 'opera', 'opinion', 'oppose', 'option', 'orange', 'orbit', 'orchard', 'order', 'ordinary', 'organ', 'orient', 'original', 'orphan', 'ostrich', 'other', 'outdoor', 'outer', 'output', 'outside', 'oval', 'oven', 'over', 'own', 'owner', 'oxygen', 'oyster', 'ozone',
	    'pact', 'paddle', 'page', 'pair', 'palace', 'palm', 'panda', 'panel', 'panic', 'panther', 'paper', 'parade', 'parent', 'park', 'parrot', 'party', 'pass', 'patch', 'path', 'patient', 'patrol', 'pattern', 'pause', 'pave', 'payment', 'peace', 'peanut', 'pear', 'peasant', 'pelican', 'pen', 'penalty', 'pencil', 'people', 'pepper', 'perfect', 'permit', 'person', 'pet', 'phone', 'photo', 'phrase', 'physical', 'piano', 'picnic', 'picture', 'piece', 'pig', 'pigeon', 'pill', 'pilot', 'pink', 'pioneer', 'pipe', 'pistol', 'pitch', 'pizza', 'place', 'planet', 'plastic', 'plate', 'play', 'please', 'pledge', 'pluck', 'plug', 'plunge', 'poem', 'poet', 'point', 'polar', 'pole', 'police', 'pond', 'pony', 'pool', 'popular', 'portion', 'position', 'possible', 'post', 'potato', 'pottery', 'poverty', 'powder', 'power', 'practice', 'praise', 'predict', 'prefer', 'prepare', 'present', 'pretty', 'prevent', 'price', 'pride', 'primary', 'print', 'priority', 'prison', 'private', 'prize', 'problem', 'process', 'produce', 'profit', 'program', 'project', 'promote', 'proof', 'property', 'prosper', 'protect', 'proud', 'provide', 'public', 'pudding', 'pull', 'pulp', 'pulse', 'pumpkin', 'punch', 'pupil', 'puppy', 'purchase', 'purity', 'purpose', 'purse', 'push', 'put', 'puzzle', 'pyramid',
	    'quality', 'quantum', 'quarter', 'question', 'quick', 'quit', 'quiz', 'quote',
	    'rabbit', 'raccoon', 'race', 'rack', 'radar', 'radio', 'rail', 'rain', 'raise', 'rally', 'ramp', 'ranch', 'random', 'range', 'rapid', 'rare', 'rate', 'rather', 'raven', 'raw', 'razor', 'ready', 'real', 'reason', 'rebel', 'rebuild', 'recall', 'receive', 'recipe', 'record', 'recycle', 'reduce', 'reflect', 'reform', 'refuse', 'region', 'regret', 'regular', 'reject', 'relax', 'release', 'relief', 'rely', 'remain', 'remember', 'remind', 'remove', 'render', 'renew', 'rent', 'reopen', 'repair', 'repeat', 'replace', 'report', 'require', 'rescue', 'resemble', 'resist', 'resource', 'response', 'result', 'retire', 'retreat', 'return', 'reunion', 'reveal', 'review', 'reward', 'rhythm', 'rib', 'ribbon', 'rice', 'rich', 'ride', 'ridge', 'rifle', 'right', 'rigid', 'ring', 'riot', 'ripple', 'risk', 'ritual', 'rival', 'river', 'road', 'roast', 'robot', 'robust', 'rocket', 'romance', 'roof', 'rookie', 'room', 'rose', 'rotate', 'rough', 'round', 'route', 'royal', 'rubber', 'rude', 'rug', 'rule', 'run', 'runway', 'rural',
	    'sad', 'saddle', 'sadness', 'safe', 'sail', 'salad', 'salmon', 'salon', 'salt', 'salute', 'same', 'sample', 'sand', 'satisfy', 'satoshi', 'sauce', 'sausage', 'save', 'say', 'scale', 'scan', 'scare', 'scatter', 'scene', 'scheme', 'school', 'science', 'scissors', 'scorpion', 'scout', 'scrap', 'screen', 'script', 'scrub', 'sea', 'search', 'season', 'seat', 'second', 'secret', 'section', 'security', 'seed', 'seek', 'segment', 'select', 'sell', 'seminar', 'senior', 'sense', 'sentence', 'series', 'service', 'session', 'settle', 'setup', 'seven', 'shadow', 'shaft', 'shallow', 'share', 'shed', 'shell', 'sheriff', 'shield', 'shift', 'shine', 'ship', 'shiver', 'shock', 'shoe', 'shoot', 'shop', 'short', 'shoulder', 'shove', 'shrimp', 'shrug', 'shuffle', 'shy', 'sibling', 'sick', 'side', 'siege', 'sight', 'sign', 'silent', 'silk', 'silly', 'silver', 'similar', 'simple', 'since', 'sing', 'siren', 'sister', 'situate', 'six', 'size', 'skate', 'sketch', 'ski', 'skill', 'skin', 'skirt', 'skull', 'slab', 'slam', 'sleep', 'slender', 'slice', 'slide', 'slight', 'slim', 'slogan', 'slot', 'slow', 'slush', 'small', 'smart', 'smile', 'smoke', 'smooth', 'snack', 'snake', 'snap', 'sniff', 'snow', 'soap', 'soccer', 'social', 'sock', 'soda', 'soft', 'solar', 'soldier', 'solid', 'solution', 'solve', 'someone', 'song', 'soon', 'sorry', 'sort', 'soul', 'sound', 'soup', 'source', 'south', 'space', 'spare', 'spatial', 'spawn', 'speak', 'special', 'speed', 'spell', 'spend', 'sphere', 'spice', 'spider', 'spike', 'spin', 'spirit', 'split', 'spoil', 'sponsor', 'spoon', 'sport', 'spot', 'spray', 'spread', 'spring', 'spy', 'square', 'squeeze', 'squirrel', 'stable', 'stadium', 'staff', 'stage', 'stairs', 'stamp', 'stand', 'start', 'state', 'stay', 'steak', 'steel', 'stem', 'step', 'stereo', 'stick', 'still', 'sting', 'stock', 'stomach', 'stone', 'stool', 'story', 'stove', 'strategy', 'street', 'strike', 'strong', 'struggle', 'student', 'stuff', 'stumble', 'style', 'subject', 'submit', 'subway', 'success', 'such', 'sudden', 'suffer', 'sugar', 'suggest', 'suit', 'summer', 'sun', 'sunny', 'sunset', 'super', 'supply', 'supreme', 'sure', 'surface', 'surge', 'surprise', 'surround', 'survey', 'suspect', 'sustain', 'swallow', 'swamp', 'swap', 'swarm', 'swear', 'sweet', 'swift', 'swim', 'swing', 'switch', 'sword', 'symbol', 'symptom', 'syrup', 'system',
	    'table', 'tackle', 'tag', 'tail', 'talent', 'talk', 'tank', 'tape', 'target', 'task', 'taste', 'tattoo', 'taxi', 'teach', 'team', 'tell', 'ten', 'tenant', 'tennis', 'tent', 'term', 'test', 'text', 'thank', 'that', 'theme', 'then', 'theory', 'there', 'they', 'thing', 'this', 'thought', 'three', 'thrive', 'throw', 'thumb', 'thunder', 'ticket', 'tide', 'tiger', 'tilt', 'timber', 'time', 'tiny', 'tip', 'tired', 'tissue', 'title', 'toast', 'tobacco', 'today', 'toddler', 'toe', 'together', 'toilet', 'token', 'tomato', 'tomorrow', 'tone', 'tongue', 'tonight', 'tool', 'tooth', 'top', 'topic', 'topple', 'torch', 'tornado', 'tortoise', 'toss', 'total', 'tourist', 'toward', 'tower', 'town', 'toy', 'track', 'trade', 'traffic', 'tragic', 'train', 'transfer', 'trap', 'trash', 'travel', 'tray', 'treat', 'tree', 'trend', 'trial', 'tribe', 'trick', 'trigger', 'trim', 'trip', 'trophy', 'trouble', 'truck', 'true', 'truly', 'trumpet', 'trust', 'truth', 'try', 'tube', 'tuition', 'tumble', 'tuna', 'tunnel', 'turkey', 'turn', 'turtle', 'twelve', 'twenty', 'twice', 'twin', 'twist', 'two', 'type', 'typical',
	    'ugly', 'umbrella', 'unable', 'unaware', 'uncle', 'uncover', 'under', 'undo', 'unfair', 'unfold', 'unhappy', 'uniform', 'unique', 'unit', 'universe', 'unknown', 'unlock', 'until', 'unusual', 'unveil', 'update', 'upgrade', 'uphold', 'upon', 'upper', 'upset', 'urban', 'urge', 'usage', 'use', 'used', 'useful', 'useless', 'usual', 'utility',
	    'vacant', 'vacuum', 'vague', 'valid', 'valley', 'valve', 'van', 'vanish', 'vapor', 'various', 'vast', 'vault', 'vehicle', 'velvet', 'vendor', 'venture', 'venue', 'verb', 'verify', 'version', 'very', 'vessel', 'veteran', 'viable', 'vibrant', 'vicious', 'victory', 'video', 'view', 'village', 'vintage', 'violin', 'virtual', 'virus', 'visa', 'visit', 'visual', 'vital', 'vivid', 'vocal', 'voice', 'void', 'volcano', 'volume', 'vote', 'voyage',
	    'wage', 'wagon', 'wait', 'walk', 'wall', 'walnut', 'want', 'warfare', 'warm', 'warrior', 'wash', 'wasp', 'waste', 'water', 'wave', 'way', 'wealth', 'weapon', 'wear', 'weasel', 'weather', 'web', 'wedding', 'weekend', 'weird', 'welcome', 'west', 'wet', 'whale', 'what', 'wheat', 'wheel', 'when', 'where', 'whip', 'whisper', 'wide', 'width', 'wife', 'wild', 'will', 'win', 'window', 'wine', 'wing', 'wink', 'winner', 'winter', 'wire', 'wisdom', 'wise', 'wish', 'witness', 'wolf', 'woman', 'wonder', 'wood', 'wool', 'word', 'work', 'world', 'worry', 'worth', 'wrap', 'wreck', 'wrestle', 'wrist', 'write', 'wrong',
	    'yard', 'year', 'yellow', 'you', 'young', 'youth',
	    'zebra', 'zero', 'zone', 'zoo'];
	wordlist.wordlist = EN;
	return wordlist;
}

var hasRequiredMnemonic;

function requireMnemonic () {
	if (hasRequiredMnemonic) return mnemonic;
	hasRequiredMnemonic = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var __importDefault = (mnemonic && mnemonic.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(mnemonic, "__esModule", { value: true });
	mnemonic.mnemonicFromRandomSeed = mnemonic.mnemonicIndexesToBytes = mnemonic.bytesToMnemonics = mnemonic.bytesToMnemonicIndexes = mnemonic.mnemonicNew = mnemonic.mnemonicValidate = mnemonic.mnemonicToHDSeed = mnemonic.mnemonicToWalletKey = mnemonic.mnemonicToPrivateKey = mnemonic.mnemonicToSeed = mnemonic.mnemonicToEntropy = void 0;
	const tweetnacl_1 = __importDefault(requireNaclFast());
	const getSecureRandom_1 = requireGetSecureRandom();
	const hmac_sha512_1 = requireHmac_sha512();
	const pbkdf2_sha512_1 = requirePbkdf2_sha512();
	const binary_1 = requireBinary();
	const wordlist_1 = requireWordlist();
	const PBKDF_ITERATIONS = 100000;
	async function isPasswordNeeded(mnemonicArray) {
	    const passlessEntropy = await mnemonicToEntropy(mnemonicArray);
	    return (await isPasswordSeed(passlessEntropy)) && !(await isBasicSeed(passlessEntropy));
	}
	function normalizeMnemonic(src) {
	    return src.map((v) => v.toLowerCase().trim());
	}
	async function isBasicSeed(entropy) {
	    // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L68
	    // bool Mnemonic::is_basic_seed() {
	    //   td::SecureString hash(64);
	    //   td::pbkdf2_sha512(as_slice(to_entropy()), "TON seed version", td::max(1, PBKDF_ITERATIONS / 256),
	    //                     hash.as_mutable_slice());
	    //   return hash.as_slice()[0] == 0;
	    // }
	    const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, 'TON seed version', Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), 64);
	    return seed[0] == 0;
	}
	async function isPasswordSeed(entropy) {
	    // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L75
	    // bool Mnemonic::is_password_seed() {
	    //   td::SecureString hash(64);
	    //   td::pbkdf2_sha512(as_slice(to_entropy()), "TON fast seed version", 1, hash.as_mutable_slice());
	    //   return hash.as_slice()[0] == 1;
	    // }
	    const seed = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, 'TON fast seed version', 1, 64);
	    return seed[0] == 1;
	}
	async function mnemonicToEntropy(mnemonicArray, password) {
	    // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L52
	    // td::SecureString Mnemonic::to_entropy() const {
	    //   td::SecureString res(64);
	    //   td::hmac_sha512(join(words_), password_, res.as_mutable_slice());
	    //   return res;
	    // }
	    return await (0, hmac_sha512_1.hmac_sha512)(mnemonicArray.join(' '), password && password.length > 0 ? password : '');
	}
	mnemonic.mnemonicToEntropy = mnemonicToEntropy;
	async function mnemonicToSeed(mnemonicArray, seed, password) {
	    // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L58
	    // td::SecureString Mnemonic::to_seed() const {
	    //   td::SecureString hash(64);
	    //   td::pbkdf2_sha512(as_slice(to_entropy()), "TON default seed", PBKDF_ITERATIONS, hash.as_mutable_slice());
	    //   return hash;
	    // }
	    const entropy = await mnemonicToEntropy(mnemonicArray, password);
	    return await (0, pbkdf2_sha512_1.pbkdf2_sha512)(entropy, seed, PBKDF_ITERATIONS, 64);
	}
	mnemonic.mnemonicToSeed = mnemonicToSeed;
	/**
	 * Extract private key from mnemonic
	 * @param mnemonicArray mnemonic array
	 * @param password mnemonic password
	 * @returns Key Pair
	 */
	async function mnemonicToPrivateKey(mnemonicArray, password) {
	    // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L64
	    // td::Ed25519::PrivateKey Mnemonic::to_private_key() const {
	    //   return td::Ed25519::PrivateKey(td::SecureString(as_slice(to_seed()).substr(0, td::Ed25519::PrivateKey::LENGTH)));
	    // }
	    mnemonicArray = normalizeMnemonic(mnemonicArray);
	    const seed = (await mnemonicToSeed(mnemonicArray, 'TON default seed', password));
	    let keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seed.slice(0, 32));
	    return {
	        publicKey: Buffer.from(keyPair.publicKey),
	        secretKey: Buffer.from(keyPair.secretKey)
	    };
	}
	mnemonic.mnemonicToPrivateKey = mnemonicToPrivateKey;
	/**
	 * Convert mnemonic to wallet key pair
	 * @param mnemonicArray mnemonic array
	 * @param password mnemonic password
	 * @returns Key Pair
	 */
	async function mnemonicToWalletKey(mnemonicArray, password) {
	    let seedPk = await mnemonicToPrivateKey(mnemonicArray, password);
	    let seedSecret = seedPk.secretKey.slice(0, 32);
	    const keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(seedSecret);
	    return {
	        publicKey: Buffer.from(keyPair.publicKey),
	        secretKey: Buffer.from(keyPair.secretKey)
	    };
	}
	mnemonic.mnemonicToWalletKey = mnemonicToWalletKey;
	/**
	 * Convert mnemonics to HD seed
	 * @param mnemonicArray mnemonic array
	 * @param password mnemonic password
	 * @returns 64 byte seed
	 */
	async function mnemonicToHDSeed(mnemonicArray, password) {
	    mnemonicArray = normalizeMnemonic(mnemonicArray);
	    return (await mnemonicToSeed(mnemonicArray, 'TON HD Keys seed', password));
	}
	mnemonic.mnemonicToHDSeed = mnemonicToHDSeed;
	/**
	 * Validate Mnemonic
	 * @param mnemonicArray mnemonic array
	 * @param password mnemonic password
	 * @returns true for valid mnemonic
	 */
	async function mnemonicValidate(mnemonicArray, password) {
	    // Normalize
	    mnemonicArray = normalizeMnemonic(mnemonicArray);
	    // Validate mnemonic words
	    for (let word of mnemonicArray) {
	        if (wordlist_1.wordlist.indexOf(word) < 0) {
	            return false;
	        }
	    }
	    // Check password
	    if (password && password.length > 0) {
	        if (!await isPasswordNeeded(mnemonicArray)) {
	            return false;
	        }
	    }
	    // Validate seed
	    return await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password));
	}
	mnemonic.mnemonicValidate = mnemonicValidate;
	/**
	 * Generate new Mnemonic
	 * @param wordsCount number of words to generate
	 * @param password mnemonic password
	 * @returns
	 */
	async function mnemonicNew(wordsCount = 24, password) {
	    // https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/tonlib/tonlib/keys/Mnemonic.cpp#L159
	    let mnemonicArray = [];
	    while (true) {
	        // Regenerate new mnemonics
	        mnemonicArray = [];
	        for (let i = 0; i < wordsCount; i++) {
	            let ind = await (0, getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length);
	            mnemonicArray.push(wordlist_1.wordlist[ind]);
	        }
	        // Chek password conformance
	        if (password && password.length > 0) {
	            if (!await isPasswordNeeded(mnemonicArray)) {
	                continue;
	            }
	        }
	        // Check if basic seed correct
	        if (!(await isBasicSeed(await mnemonicToEntropy(mnemonicArray, password)))) {
	            continue;
	        }
	        break;
	    }
	    return mnemonicArray;
	}
	mnemonic.mnemonicNew = mnemonicNew;
	/**
	 * Converts bytes to mnemonics array (could be invalid for TON)
	 * @param src source buffer
	 * @param wordsCount number of words
	 */
	function bytesToMnemonicIndexes(src, wordsCount) {
	    let bits = (0, binary_1.bytesToBits)(src);
	    let indexes = [];
	    for (let i = 0; i < wordsCount; i++) {
	        let sl = bits.slice(i * 11, i * 11 + 11);
	        indexes.push(parseInt(sl, 2));
	    }
	    return indexes;
	}
	mnemonic.bytesToMnemonicIndexes = bytesToMnemonicIndexes;
	function bytesToMnemonics(src, wordsCount) {
	    let mnemonics = bytesToMnemonicIndexes(src, wordsCount);
	    let res = [];
	    for (let m of mnemonics) {
	        res.push(wordlist_1.wordlist[m]);
	    }
	    return res;
	}
	mnemonic.bytesToMnemonics = bytesToMnemonics;
	/**
	 * Converts mnemonics indexes to buffer with zero padding in the end
	 * @param src source indexes
	 * @returns Buffer
	 */
	function mnemonicIndexesToBytes(src) {
	    let res = '';
	    for (let s of src) {
	        if (!Number.isSafeInteger(s)) {
	            throw Error('Invalid input');
	        }
	        if (s < 0 || s >= 2028) {
	            throw Error('Invalid input');
	        }
	        res += (0, binary_1.lpad)(s.toString(2), '0', 11);
	    }
	    while (res.length % 8 !== 0) {
	        res = res + '0';
	    }
	    return (0, binary_1.bitsToBytes)(res);
	}
	mnemonic.mnemonicIndexesToBytes = mnemonicIndexesToBytes;
	/**
	 * Generates deterministically mnemonics
	 * @param seed
	 * @param wordsCount
	 * @param password
	 */
	async function mnemonicFromRandomSeed(seed, wordsCount = 24, password) {
	    const bytesLength = Math.ceil(wordsCount * 11 / 8);
	    let currentSeed = seed;
	    while (true) {
	        // Create entropy
	        let entropy = await (0, pbkdf2_sha512_1.pbkdf2_sha512)(currentSeed, 'TON mnemonic seed', Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), bytesLength);
	        // Create mnemonics
	        let mnemonics = bytesToMnemonics(entropy, wordsCount);
	        // Check if mnemonics are valid
	        if (await mnemonicValidate(mnemonics, password)) {
	            return mnemonics;
	        }
	        currentSeed = entropy;
	    }
	}
	mnemonic.mnemonicFromRandomSeed = mnemonicFromRandomSeed;
	return mnemonic;
}

var nacl$2 = {};

var hasRequiredNacl;

function requireNacl () {
	if (hasRequiredNacl) return nacl$2;
	hasRequiredNacl = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var __importDefault = (nacl$2 && nacl$2.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(nacl$2, "__esModule", { value: true });
	nacl$2.openBox = nacl$2.sealBox = nacl$2.signVerify = nacl$2.sign = nacl$2.keyPairFromSeed = nacl$2.keyPairFromSecretKey = void 0;
	const tweetnacl_1 = __importDefault(requireNaclFast());
	function keyPairFromSecretKey(secretKey) {
	    let res = tweetnacl_1.default.sign.keyPair.fromSecretKey(new Uint8Array(secretKey));
	    return {
	        publicKey: Buffer.from(res.publicKey),
	        secretKey: Buffer.from(res.secretKey),
	    };
	}
	nacl$2.keyPairFromSecretKey = keyPairFromSecretKey;
	function keyPairFromSeed(secretKey) {
	    let res = tweetnacl_1.default.sign.keyPair.fromSeed(new Uint8Array(secretKey));
	    return {
	        publicKey: Buffer.from(res.publicKey),
	        secretKey: Buffer.from(res.secretKey),
	    };
	}
	nacl$2.keyPairFromSeed = keyPairFromSeed;
	function sign(data, secretKey) {
	    return Buffer.from(tweetnacl_1.default.sign.detached(new Uint8Array(data), new Uint8Array(secretKey)));
	}
	nacl$2.sign = sign;
	function signVerify(data, signature, publicKey) {
	    return tweetnacl_1.default.sign.detached.verify(new Uint8Array(data), new Uint8Array(signature), new Uint8Array(publicKey));
	}
	nacl$2.signVerify = signVerify;
	function sealBox(data, nonce, key) {
	    return Buffer.from(tweetnacl_1.default.secretbox(data, nonce, key));
	}
	nacl$2.sealBox = sealBox;
	function openBox(data, nonce, key) {
	    let res = tweetnacl_1.default.secretbox.open(data, nonce, key);
	    if (!res) {
	        return null;
	    }
	    return Buffer.from(res);
	}
	nacl$2.openBox = openBox;
	return nacl$2;
}

var ed25519 = {};

var hasRequiredEd25519;

function requireEd25519 () {
	if (hasRequiredEd25519) return ed25519;
	hasRequiredEd25519 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(ed25519, "__esModule", { value: true });
	ed25519.deriveEd25519Path = ed25519.deriveED25519HardenedKey = ed25519.getED25519MasterKeyFromSeed = void 0;
	const hmac_sha512_1 = requireHmac_sha512();
	const ED25519_CURVE = 'ed25519 seed';
	const HARDENED_OFFSET = 0x80000000;
	async function getED25519MasterKeyFromSeed(seed) {
	    const I = await (0, hmac_sha512_1.hmac_sha512)(ED25519_CURVE, seed);
	    const IL = I.slice(0, 32);
	    const IR = I.slice(32);
	    return {
	        key: IL,
	        chainCode: IR,
	    };
	}
	ed25519.getED25519MasterKeyFromSeed = getED25519MasterKeyFromSeed;
	async function deriveED25519HardenedKey(parent, index) {
	    if (index >= HARDENED_OFFSET) {
	        throw Error('Key index must be less than offset');
	    }
	    // Key Derive Path: 0x00 + parent.key + index;
	    const indexBuffer = Buffer.alloc(4);
	    indexBuffer.writeUInt32BE(index + HARDENED_OFFSET, 0);
	    const data = Buffer.concat([Buffer.alloc(1, 0), parent.key, indexBuffer]);
	    // Derive key
	    const I = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
	    const IL = I.slice(0, 32);
	    const IR = I.slice(32);
	    return {
	        key: IL,
	        chainCode: IR,
	    };
	}
	ed25519.deriveED25519HardenedKey = deriveED25519HardenedKey;
	async function deriveEd25519Path(seed, path) {
	    let state = await getED25519MasterKeyFromSeed(seed);
	    let remaining = [...path];
	    while (remaining.length > 0) {
	        let index = remaining[0];
	        remaining = remaining.slice(1);
	        state = await deriveED25519HardenedKey(state, index);
	    }
	    return state.key;
	}
	ed25519.deriveEd25519Path = deriveEd25519Path;
	return ed25519;
}

var symmetric = {};

var hasRequiredSymmetric;

function requireSymmetric () {
	if (hasRequiredSymmetric) return symmetric;
	hasRequiredSymmetric = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(symmetric, "__esModule", { value: true });
	symmetric.deriveSymmetricPath = symmetric.deriveSymmetricHardenedKey = symmetric.getSymmetricMasterKeyFromSeed = void 0;
	const hmac_sha512_1 = requireHmac_sha512();
	const SYMMETRIC_SEED = 'Symmetric key seed';
	async function getSymmetricMasterKeyFromSeed(seed) {
	    const I = await (0, hmac_sha512_1.hmac_sha512)(SYMMETRIC_SEED, seed);
	    const IL = I.slice(32);
	    const IR = I.slice(0, 32);
	    return {
	        key: IL,
	        chainCode: IR,
	    };
	}
	symmetric.getSymmetricMasterKeyFromSeed = getSymmetricMasterKeyFromSeed;
	async function deriveSymmetricHardenedKey(parent, offset) {
	    // Prepare data
	    const data = Buffer.concat([Buffer.alloc(1, 0), Buffer.from(offset)]);
	    // Derive key
	    const I = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
	    const IL = I.slice(32);
	    const IR = I.slice(0, 32);
	    return {
	        key: IL,
	        chainCode: IR,
	    };
	}
	symmetric.deriveSymmetricHardenedKey = deriveSymmetricHardenedKey;
	async function deriveSymmetricPath(seed, path) {
	    let state = await getSymmetricMasterKeyFromSeed(seed);
	    let remaining = [...path];
	    while (remaining.length > 0) {
	        let index = remaining[0];
	        remaining = remaining.slice(1);
	        state = await deriveSymmetricHardenedKey(state, index);
	    }
	    return state.key;
	}
	symmetric.deriveSymmetricPath = deriveSymmetricPath;
	return symmetric;
}

var mnemonics = {};

var hasRequiredMnemonics;

function requireMnemonics () {
	if (hasRequiredMnemonics) return mnemonics;
	hasRequiredMnemonics = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(mnemonics, "__esModule", { value: true });
	mnemonics.deriveMnemonicsPath = mnemonics.deriveMnemonicHardenedKey = mnemonics.getMnemonicsMasterKeyFromSeed = void 0;
	const mnemonic_1 = requireMnemonic();
	const hmac_sha512_1 = requireHmac_sha512();
	const HARDENED_OFFSET = 0x80000000;
	const MNEMONICS_SEED = 'TON Mnemonics HD seed';
	async function getMnemonicsMasterKeyFromSeed(seed) {
	    const I = await (0, hmac_sha512_1.hmac_sha512)(MNEMONICS_SEED, seed);
	    const IL = I.slice(0, 32);
	    const IR = I.slice(32);
	    return {
	        key: IL,
	        chainCode: IR,
	    };
	}
	mnemonics.getMnemonicsMasterKeyFromSeed = getMnemonicsMasterKeyFromSeed;
	async function deriveMnemonicHardenedKey(parent, index) {
	    if (index >= HARDENED_OFFSET) {
	        throw Error('Key index must be less than offset');
	    }
	    // Key Derive Path: 0x00 + parent.key + index;
	    const indexBuffer = Buffer.alloc(4);
	    indexBuffer.writeUInt32BE(index + HARDENED_OFFSET, 0);
	    const data = Buffer.concat([Buffer.alloc(1, 0), parent.key, indexBuffer]);
	    // Derive key
	    const I = await (0, hmac_sha512_1.hmac_sha512)(parent.chainCode, data);
	    const IL = I.slice(0, 32);
	    const IR = I.slice(32);
	    return {
	        key: IL,
	        chainCode: IR,
	    };
	}
	mnemonics.deriveMnemonicHardenedKey = deriveMnemonicHardenedKey;
	async function deriveMnemonicsPath(seed, path, wordsCount = 24, password) {
	    let state = await getMnemonicsMasterKeyFromSeed(seed);
	    let remaining = [...path];
	    while (remaining.length > 0) {
	        let index = remaining[0];
	        remaining = remaining.slice(1);
	        state = await deriveMnemonicHardenedKey(state, index);
	    }
	    return await (0, mnemonic_1.mnemonicFromRandomSeed)(state.key, wordsCount, password);
	}
	mnemonics.deriveMnemonicsPath = deriveMnemonicsPath;
	return mnemonics;
}

var hasRequiredDist$3;

function requireDist$3 () {
	if (hasRequiredDist$3) return dist$1;
	hasRequiredDist$3 = 1;
	(function (exports) {
		/**
		 * Copyright (c) Whales Corp.
		 * All Rights Reserved.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getMnemonicsMasterKeyFromSeed = exports.deriveMnemonicHardenedKey = exports.deriveMnemonicsPath = exports.deriveSymmetricPath = exports.deriveSymmetricHardenedKey = exports.getSymmetricMasterKeyFromSeed = exports.deriveEd25519Path = exports.deriveED25519HardenedKey = exports.getED25519MasterKeyFromSeed = exports.signVerify = exports.sign = exports.keyPairFromSecretKey = exports.keyPairFromSeed = exports.openBox = exports.sealBox = exports.mnemonicWordList = exports.mnemonicToHDSeed = exports.mnemonicToSeed = exports.mnemonicToWalletKey = exports.mnemonicToPrivateKey = exports.mnemonicValidate = exports.mnemonicNew = exports.newSecurePassphrase = exports.newSecureWords = exports.getSecureRandomNumber = exports.getSecureRandomWords = exports.getSecureRandomBytes = exports.hmac_sha512 = exports.pbkdf2_sha512 = exports.sha512_sync = exports.sha512 = exports.sha256_sync = exports.sha256 = void 0;
		var sha256_1 = requireSha256();
		Object.defineProperty(exports, "sha256", { enumerable: true, get: function () { return sha256_1.sha256; } });
		Object.defineProperty(exports, "sha256_sync", { enumerable: true, get: function () { return sha256_1.sha256_sync; } });
		var sha512_1 = requireSha512();
		Object.defineProperty(exports, "sha512", { enumerable: true, get: function () { return sha512_1.sha512; } });
		Object.defineProperty(exports, "sha512_sync", { enumerable: true, get: function () { return sha512_1.sha512_sync; } });
		var pbkdf2_sha512_1 = requirePbkdf2_sha512();
		Object.defineProperty(exports, "pbkdf2_sha512", { enumerable: true, get: function () { return pbkdf2_sha512_1.pbkdf2_sha512; } });
		var hmac_sha512_1 = requireHmac_sha512();
		Object.defineProperty(exports, "hmac_sha512", { enumerable: true, get: function () { return hmac_sha512_1.hmac_sha512; } });
		var getSecureRandom_1 = requireGetSecureRandom();
		Object.defineProperty(exports, "getSecureRandomBytes", { enumerable: true, get: function () { return getSecureRandom_1.getSecureRandomBytes; } });
		Object.defineProperty(exports, "getSecureRandomWords", { enumerable: true, get: function () { return getSecureRandom_1.getSecureRandomWords; } });
		Object.defineProperty(exports, "getSecureRandomNumber", { enumerable: true, get: function () { return getSecureRandom_1.getSecureRandomNumber; } });
		var newSecureWords_1 = requireNewSecureWords();
		Object.defineProperty(exports, "newSecureWords", { enumerable: true, get: function () { return newSecureWords_1.newSecureWords; } });
		var newSecurePassphrase_1 = requireNewSecurePassphrase();
		Object.defineProperty(exports, "newSecurePassphrase", { enumerable: true, get: function () { return newSecurePassphrase_1.newSecurePassphrase; } });
		var mnemonic_1 = requireMnemonic();
		Object.defineProperty(exports, "mnemonicNew", { enumerable: true, get: function () { return mnemonic_1.mnemonicNew; } });
		Object.defineProperty(exports, "mnemonicValidate", { enumerable: true, get: function () { return mnemonic_1.mnemonicValidate; } });
		Object.defineProperty(exports, "mnemonicToPrivateKey", { enumerable: true, get: function () { return mnemonic_1.mnemonicToPrivateKey; } });
		Object.defineProperty(exports, "mnemonicToWalletKey", { enumerable: true, get: function () { return mnemonic_1.mnemonicToWalletKey; } });
		Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function () { return mnemonic_1.mnemonicToSeed; } });
		Object.defineProperty(exports, "mnemonicToHDSeed", { enumerable: true, get: function () { return mnemonic_1.mnemonicToHDSeed; } });
		var wordlist_1 = requireWordlist();
		Object.defineProperty(exports, "mnemonicWordList", { enumerable: true, get: function () { return wordlist_1.wordlist; } });
		var nacl_1 = requireNacl();
		Object.defineProperty(exports, "sealBox", { enumerable: true, get: function () { return nacl_1.sealBox; } });
		Object.defineProperty(exports, "openBox", { enumerable: true, get: function () { return nacl_1.openBox; } });
		var nacl_2 = requireNacl();
		Object.defineProperty(exports, "keyPairFromSeed", { enumerable: true, get: function () { return nacl_2.keyPairFromSeed; } });
		Object.defineProperty(exports, "keyPairFromSecretKey", { enumerable: true, get: function () { return nacl_2.keyPairFromSecretKey; } });
		Object.defineProperty(exports, "sign", { enumerable: true, get: function () { return nacl_2.sign; } });
		Object.defineProperty(exports, "signVerify", { enumerable: true, get: function () { return nacl_2.signVerify; } });
		var ed25519_1 = requireEd25519();
		Object.defineProperty(exports, "getED25519MasterKeyFromSeed", { enumerable: true, get: function () { return ed25519_1.getED25519MasterKeyFromSeed; } });
		Object.defineProperty(exports, "deriveED25519HardenedKey", { enumerable: true, get: function () { return ed25519_1.deriveED25519HardenedKey; } });
		Object.defineProperty(exports, "deriveEd25519Path", { enumerable: true, get: function () { return ed25519_1.deriveEd25519Path; } });
		var symmetric_1 = requireSymmetric();
		Object.defineProperty(exports, "getSymmetricMasterKeyFromSeed", { enumerable: true, get: function () { return symmetric_1.getSymmetricMasterKeyFromSeed; } });
		Object.defineProperty(exports, "deriveSymmetricHardenedKey", { enumerable: true, get: function () { return symmetric_1.deriveSymmetricHardenedKey; } });
		Object.defineProperty(exports, "deriveSymmetricPath", { enumerable: true, get: function () { return symmetric_1.deriveSymmetricPath; } });
		var mnemonics_1 = requireMnemonics();
		Object.defineProperty(exports, "deriveMnemonicsPath", { enumerable: true, get: function () { return mnemonics_1.deriveMnemonicsPath; } });
		Object.defineProperty(exports, "deriveMnemonicHardenedKey", { enumerable: true, get: function () { return mnemonics_1.deriveMnemonicHardenedKey; } });
		Object.defineProperty(exports, "getMnemonicsMasterKeyFromSeed", { enumerable: true, get: function () { return mnemonics_1.getMnemonicsMasterKeyFromSeed; } }); 
	} (dist$1));
	return dist$1;
}

var hasRequiredWonderCalculator;

function requireWonderCalculator () {
	if (hasRequiredWonderCalculator) return wonderCalculator;
	hasRequiredWonderCalculator = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(wonderCalculator, "__esModule", { value: true });
	wonderCalculator.wonderCalculator = void 0;
	const BitString_1 = requireBitString();
	const CellType_1 = requireCellType();
	const LevelMask_1 = requireLevelMask();
	const exoticPruned_1 = requireExoticPruned();
	const exoticMerkleProof_1 = requireExoticMerkleProof();
	const descriptor_1 = requireDescriptor();
	const crypto_1 = requireDist$3();
	const exoticMerkleUpdate_1 = requireExoticMerkleUpdate();
	const exoticLibrary_1 = requireExoticLibrary();
	//
	// This function replicates unknown logic of resolving cell data
	// https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/vm/cells/DataCell.cpp#L214
	//
	function wonderCalculator$1(type, bits, refs) {
	    //
	    // Resolving level mask
	    //
	    let levelMask;
	    let pruned = null;
	    if (type === CellType_1.CellType.Ordinary) {
	        let mask = 0;
	        for (let r of refs) {
	            mask = mask | r.mask.value;
	        }
	        levelMask = new LevelMask_1.LevelMask(mask);
	    }
	    else if (type === CellType_1.CellType.PrunedBranch) {
	        // Parse pruned
	        pruned = (0, exoticPruned_1.exoticPruned)(bits, refs);
	        // Load level
	        levelMask = new LevelMask_1.LevelMask(pruned.mask);
	    }
	    else if (type === CellType_1.CellType.MerkleProof) {
	        // Parse proof
	        (0, exoticMerkleProof_1.exoticMerkleProof)(bits, refs);
	        // Load level
	        levelMask = new LevelMask_1.LevelMask(refs[0].mask.value >> 1);
	    }
	    else if (type === CellType_1.CellType.MerkleUpdate) {
	        // Parse update
	        (0, exoticMerkleUpdate_1.exoticMerkleUpdate)(bits, refs);
	        // Load level
	        levelMask = new LevelMask_1.LevelMask((refs[0].mask.value | refs[1].mask.value) >> 1);
	    }
	    else if (type === CellType_1.CellType.Library) {
	        // Parse library
	        (0, exoticLibrary_1.exoticLibrary)(bits, refs);
	        // Load level
	        levelMask = new LevelMask_1.LevelMask();
	    }
	    else {
	        throw new Error("Unsupported exotic type");
	    }
	    //
	    // Calculate hashes and depths
	    // NOTE: https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/vm/cells/DataCell.cpp#L214
	    //
	    let depths = [];
	    let hashes = [];
	    let hashCount = type === CellType_1.CellType.PrunedBranch ? 1 : levelMask.hashCount;
	    let totalHashCount = levelMask.hashCount;
	    let hashIOffset = totalHashCount - hashCount;
	    for (let levelI = 0, hashI = 0; levelI <= levelMask.level; levelI++) {
	        if (!levelMask.isSignificant(levelI)) {
	            continue;
	        }
	        if (hashI < hashIOffset) {
	            hashI++;
	            continue;
	        }
	        //
	        // Bits
	        //
	        let currentBits;
	        if (hashI === hashIOffset) {
	            if (!(levelI === 0 || type === CellType_1.CellType.PrunedBranch)) {
	                throw Error('Invalid');
	            }
	            currentBits = bits;
	        }
	        else {
	            if (!(levelI !== 0 && type !== CellType_1.CellType.PrunedBranch)) {
	                throw Error('Invalid: ' + levelI + ', ' + type);
	            }
	            currentBits = new BitString_1.BitString(hashes[hashI - hashIOffset - 1], 0, 256);
	        }
	        //
	        // Depth
	        //
	        let currentDepth = 0;
	        for (let c of refs) {
	            let childDepth;
	            if (type == CellType_1.CellType.MerkleProof || type == CellType_1.CellType.MerkleUpdate) {
	                childDepth = c.depth(levelI + 1);
	            }
	            else {
	                childDepth = c.depth(levelI);
	            }
	            currentDepth = Math.max(currentDepth, childDepth);
	        }
	        if (refs.length > 0) {
	            currentDepth++;
	        }
	        //
	        // Hash
	        //
	        let repr = (0, descriptor_1.getRepr)(bits, currentBits, refs, levelI, levelMask.apply(levelI).value, type);
	        let hash = (0, crypto_1.sha256_sync)(repr);
	        //
	        // Persist next
	        //
	        let destI = hashI - hashIOffset;
	        depths[destI] = currentDepth;
	        hashes[destI] = hash;
	        //
	        // Next
	        //
	        hashI++;
	    }
	    //
	    // Calculate hash and depth for all levels
	    //
	    let resolvedHashes = [];
	    let resolvedDepths = [];
	    if (pruned) {
	        for (let i = 0; i < 4; i++) {
	            const { hashIndex } = levelMask.apply(i);
	            const { hashIndex: thisHashIndex } = levelMask;
	            if (hashIndex !== thisHashIndex) {
	                resolvedHashes.push(pruned.pruned[hashIndex].hash);
	                resolvedDepths.push(pruned.pruned[hashIndex].depth);
	            }
	            else {
	                resolvedHashes.push(hashes[0]);
	                resolvedDepths.push(depths[0]);
	            }
	        }
	    }
	    else {
	        for (let i = 0; i < 4; i++) {
	            resolvedHashes.push(hashes[levelMask.apply(i).hashIndex]);
	            resolvedDepths.push(depths[levelMask.apply(i).hashIndex]);
	        }
	    }
	    //
	    // Result
	    //
	    return {
	        mask: levelMask,
	        hashes: resolvedHashes,
	        depths: resolvedDepths
	    };
	}
	wonderCalculator.wonderCalculator = wonderCalculator$1;
	return wonderCalculator;
}

var serialization = {};

var topologicalSort = {};

var hasRequiredTopologicalSort;

function requireTopologicalSort () {
	if (hasRequiredTopologicalSort) return topologicalSort;
	hasRequiredTopologicalSort = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(topologicalSort, "__esModule", { value: true });
	topologicalSort.topologicalSort = void 0;
	function topologicalSort$1(src) {
	    let pending = [src];
	    let allCells = new Map();
	    let notPermCells = new Set();
	    let sorted = [];
	    while (pending.length > 0) {
	        const cells = [...pending];
	        pending = [];
	        for (let cell of cells) {
	            const hash = cell.hash().toString('hex');
	            if (allCells.has(hash)) {
	                continue;
	            }
	            notPermCells.add(hash);
	            allCells.set(hash, { cell: cell, refs: cell.refs.map((v) => v.hash().toString('hex')) });
	            for (let r of cell.refs) {
	                pending.push(r);
	            }
	        }
	    }
	    let tempMark = new Set();
	    function visit(hash) {
	        if (!notPermCells.has(hash)) {
	            return;
	        }
	        if (tempMark.has(hash)) {
	            throw Error('Not a DAG');
	        }
	        tempMark.add(hash);
	        let refs = allCells.get(hash).refs;
	        for (let ci = refs.length - 1; ci >= 0; ci--) {
	            visit(refs[ci]);
	        }
	        sorted.push(hash);
	        tempMark.delete(hash);
	        notPermCells.delete(hash);
	    }
	    while (notPermCells.size > 0) {
	        const id = Array.from(notPermCells)[0];
	        visit(id);
	    }
	    let indexes = new Map();
	    for (let i = 0; i < sorted.length; i++) {
	        indexes.set(sorted[sorted.length - i - 1], i);
	    }
	    let result = [];
	    for (let i = sorted.length - 1; i >= 0; i--) {
	        let ent = sorted[i];
	        const rrr = allCells.get(ent);
	        result.push({ cell: rrr.cell, refs: rrr.refs.map((v) => indexes.get(v)) });
	    }
	    return result;
	}
	topologicalSort.topologicalSort = topologicalSort$1;
	return topologicalSort;
}

var bitsForNumber = {};

var hasRequiredBitsForNumber;

function requireBitsForNumber () {
	if (hasRequiredBitsForNumber) return bitsForNumber;
	hasRequiredBitsForNumber = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(bitsForNumber, "__esModule", { value: true });
	bitsForNumber.bitsForNumber = void 0;
	function bitsForNumber$1(src, mode) {
	    let v = BigInt(src);
	    // Handle negative values
	    if (mode === 'int') {
	        // Corner case for zero or -1 value
	        if (v === 0n || v === -1n) {
	            return 1;
	        }
	        let v2 = v > 0 ? v : -v;
	        return (v2.toString(2).length + 1 /* Sign bit */);
	    }
	    else if (mode === 'uint') {
	        if (v < 0) {
	            throw Error(`value is negative. Got ${src}`);
	        }
	        return (v.toString(2).length);
	    }
	    else {
	        throw Error(`invalid mode. Got ${mode}`);
	    }
	}
	bitsForNumber.bitsForNumber = bitsForNumber$1;
	return bitsForNumber;
}

var crc32c = {};

var hasRequiredCrc32c;

function requireCrc32c () {
	if (hasRequiredCrc32c) return crc32c;
	hasRequiredCrc32c = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(crc32c, "__esModule", { value: true });
	crc32c.crc32c = void 0;
	const POLY = 0x82f63b78;
	function crc32c$1(source) {
	    let crc = 0 ^ 0xffffffff;
	    for (let n = 0; n < source.length; n++) {
	        crc ^= source[n];
	        crc = crc & 1 ? (crc >>> 1) ^ POLY : crc >>> 1;
	        crc = crc & 1 ? (crc >>> 1) ^ POLY : crc >>> 1;
	        crc = crc & 1 ? (crc >>> 1) ^ POLY : crc >>> 1;
	        crc = crc & 1 ? (crc >>> 1) ^ POLY : crc >>> 1;
	        crc = crc & 1 ? (crc >>> 1) ^ POLY : crc >>> 1;
	        crc = crc & 1 ? (crc >>> 1) ^ POLY : crc >>> 1;
	        crc = crc & 1 ? (crc >>> 1) ^ POLY : crc >>> 1;
	        crc = crc & 1 ? (crc >>> 1) ^ POLY : crc >>> 1;
	    }
	    crc = crc ^ 0xffffffff;
	    // Convert endianness
	    let res = Buffer.alloc(4);
	    res.writeInt32LE(crc);
	    return res;
	}
	crc32c.crc32c = crc32c$1;
	return crc32c;
}

var hasRequiredSerialization;

function requireSerialization () {
	if (hasRequiredSerialization) return serialization;
	hasRequiredSerialization = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(serialization, "__esModule", { value: true });
	serialization.serializeBoc = serialization.deserializeBoc = serialization.parseBoc = void 0;
	const BitReader_1 = requireBitReader();
	const BitString_1 = requireBitString();
	const Cell_1 = requireCell();
	const topologicalSort_1 = requireTopologicalSort();
	const bitsForNumber_1 = requireBitsForNumber();
	const BitBuilder_1 = requireBitBuilder();
	const descriptor_1 = requireDescriptor();
	const paddedBits_1 = requirePaddedBits();
	const crc32c_1 = requireCrc32c();
	function getHashesCount(levelMask) {
	    return getHashesCountFromMask(levelMask & 7);
	}
	function getHashesCountFromMask(mask) {
	    let n = 0;
	    for (let i = 0; i < 3; i++) {
	        n += (mask & 1);
	        mask = mask >> 1;
	    }
	    return n + 1; // 1 repr + up to 3 higher hashes
	}
	function readCell(reader, sizeBytes) {
	    // D1
	    const d1 = reader.loadUint(8);
	    const refsCount = d1 % 8;
	    const exotic = !!(d1 & 8);
	    // D2
	    const d2 = reader.loadUint(8);
	    const dataBytesize = Math.ceil(d2 / 2);
	    const paddingAdded = !!(d2 % 2);
	    const levelMask = d1 >> 5;
	    const hasHashes = (d1 & 16) != 0;
	    const hash_bytes = 32;
	    const hashesSize = hasHashes ? getHashesCount(levelMask) * hash_bytes : 0;
	    const depthSize = hasHashes ? getHashesCount(levelMask) * 2 : 0;
	    reader.skip(hashesSize * 8);
	    reader.skip(depthSize * 8);
	    // Bits
	    let bits = BitString_1.BitString.EMPTY;
	    if (dataBytesize > 0) {
	        if (paddingAdded) {
	            bits = reader.loadPaddedBits(dataBytesize * 8);
	        }
	        else {
	            bits = reader.loadBits(dataBytesize * 8);
	        }
	    }
	    // Refs
	    let refs = [];
	    for (let i = 0; i < refsCount; i++) {
	        refs.push(reader.loadUint(sizeBytes * 8));
	    }
	    // Result
	    return {
	        bits,
	        refs,
	        exotic
	    };
	}
	function calcCellSize(cell, sizeBytes) {
	    return 2 /* D1+D2 */ + Math.ceil(cell.bits.length / 8) + cell.refs.length * sizeBytes;
	}
	function parseBoc(src) {
	    let reader = new BitReader_1.BitReader(new BitString_1.BitString(src, 0, src.length * 8));
	    let magic = reader.loadUint(32);
	    if (magic === 0x68ff65f3) {
	        let size = reader.loadUint(8);
	        let offBytes = reader.loadUint(8);
	        let cells = reader.loadUint(size * 8);
	        let roots = reader.loadUint(size * 8); // Must be 1
	        let absent = reader.loadUint(size * 8);
	        let totalCellSize = reader.loadUint(offBytes * 8);
	        let index = reader.loadBuffer(cells * offBytes);
	        let cellData = reader.loadBuffer(totalCellSize);
	        return {
	            size,
	            offBytes,
	            cells,
	            roots,
	            absent,
	            totalCellSize,
	            index,
	            cellData,
	            root: [0]
	        };
	    }
	    else if (magic === 0xacc3a728) {
	        let size = reader.loadUint(8);
	        let offBytes = reader.loadUint(8);
	        let cells = reader.loadUint(size * 8);
	        let roots = reader.loadUint(size * 8); // Must be 1
	        let absent = reader.loadUint(size * 8);
	        let totalCellSize = reader.loadUint(offBytes * 8);
	        let index = reader.loadBuffer(cells * offBytes);
	        let cellData = reader.loadBuffer(totalCellSize);
	        let crc32 = reader.loadBuffer(4);
	        if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {
	            throw Error('Invalid CRC32C');
	        }
	        return {
	            size,
	            offBytes,
	            cells,
	            roots,
	            absent,
	            totalCellSize,
	            index,
	            cellData,
	            root: [0]
	        };
	    }
	    else if (magic === 0xb5ee9c72) {
	        let hasIdx = reader.loadUint(1);
	        let hasCrc32c = reader.loadUint(1);
	        reader.loadUint(1);
	        reader.loadUint(2); // Must be 0
	        let size = reader.loadUint(3);
	        let offBytes = reader.loadUint(8);
	        let cells = reader.loadUint(size * 8);
	        let roots = reader.loadUint(size * 8);
	        let absent = reader.loadUint(size * 8);
	        let totalCellSize = reader.loadUint(offBytes * 8);
	        let root = [];
	        for (let i = 0; i < roots; i++) {
	            root.push(reader.loadUint(size * 8));
	        }
	        let index = null;
	        if (hasIdx) {
	            index = reader.loadBuffer(cells * offBytes);
	        }
	        let cellData = reader.loadBuffer(totalCellSize);
	        if (hasCrc32c) {
	            let crc32 = reader.loadBuffer(4);
	            if (!(0, crc32c_1.crc32c)(src.subarray(0, src.length - 4)).equals(crc32)) {
	                throw Error('Invalid CRC32C');
	            }
	        }
	        return {
	            size,
	            offBytes,
	            cells,
	            roots,
	            absent,
	            totalCellSize,
	            index,
	            cellData,
	            root
	        };
	    }
	    else {
	        throw Error('Invalid magic');
	    }
	}
	serialization.parseBoc = parseBoc;
	function deserializeBoc(src) {
	    //
	    // Parse BOC
	    //
	    let boc = parseBoc(src);
	    let reader = new BitReader_1.BitReader(new BitString_1.BitString(boc.cellData, 0, boc.cellData.length * 8));
	    //
	    // Load cells
	    //
	    let cells = [];
	    for (let i = 0; i < boc.cells; i++) {
	        let cll = readCell(reader, boc.size);
	        cells.push({ ...cll, result: null });
	    }
	    //
	    // Build cells
	    //
	    for (let i = cells.length - 1; i >= 0; i--) {
	        if (cells[i].result) {
	            throw Error('Impossible');
	        }
	        let refs = [];
	        for (let r of cells[i].refs) {
	            if (!cells[r].result) {
	                throw Error('Invalid BOC file');
	            }
	            refs.push(cells[r].result);
	        }
	        cells[i].result = new Cell_1.Cell({ bits: cells[i].bits, refs, exotic: cells[i].exotic });
	    }
	    //
	    // Load roots
	    //
	    let roots = [];
	    for (let i = 0; i < boc.root.length; i++) {
	        roots.push(cells[boc.root[i]].result);
	    }
	    //
	    // Return
	    //
	    return roots;
	}
	serialization.deserializeBoc = deserializeBoc;
	function writeCellToBuilder(cell, refs, sizeBytes, to) {
	    let d1 = (0, descriptor_1.getRefsDescriptor)(cell.refs, cell.mask.value, cell.type);
	    let d2 = (0, descriptor_1.getBitsDescriptor)(cell.bits);
	    to.writeUint(d1, 8);
	    to.writeUint(d2, 8);
	    to.writeBuffer((0, paddedBits_1.bitsToPaddedBuffer)(cell.bits));
	    for (let r of refs) {
	        to.writeUint(r, sizeBytes * 8);
	    }
	}
	function serializeBoc(root, opts) {
	    // Sort cells
	    let allCells = (0, topologicalSort_1.topologicalSort)(root);
	    // Calculcate parameters
	    let cellsNum = allCells.length;
	    let has_idx = opts.idx;
	    let has_crc32c = opts.crc32;
	    let has_cache_bits = false;
	    let flags = 0;
	    let sizeBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(cellsNum, 'uint') / 8), 1);
	    let totalCellSize = 0;
	    let index = [];
	    for (let c of allCells) {
	        let sz = calcCellSize(c.cell, sizeBytes);
	        totalCellSize += sz;
	        index.push(totalCellSize);
	    }
	    let offsetBytes = Math.max(Math.ceil((0, bitsForNumber_1.bitsForNumber)(totalCellSize, 'uint') / 8), 1);
	    let totalSize = (4 + // magic
	        1 + // flags and s_bytes
	        1 + // offset_bytes
	        3 * sizeBytes + // cells_num, roots, complete
	        offsetBytes + // full_size
	        1 * sizeBytes + // root_idx
	        (has_idx ? cellsNum * offsetBytes : 0) +
	        totalCellSize +
	        (has_crc32c ? 4 : 0)) * 8;
	    // Serialize
	    let builder = new BitBuilder_1.BitBuilder(totalSize);
	    builder.writeUint(0xb5ee9c72, 32); // Magic
	    builder.writeBit(has_idx); // Has index
	    builder.writeBit(has_crc32c); // Has crc32c
	    builder.writeBit(has_cache_bits); // Has cache bits
	    builder.writeUint(flags, 2); // Flags
	    builder.writeUint(sizeBytes, 3); // Size bytes
	    builder.writeUint(offsetBytes, 8); // Offset bytes
	    builder.writeUint(cellsNum, sizeBytes * 8); // Cells num
	    builder.writeUint(1, sizeBytes * 8); // Roots num
	    builder.writeUint(0, sizeBytes * 8); // Absent num
	    builder.writeUint(totalCellSize, offsetBytes * 8); // Total cell size
	    builder.writeUint(0, sizeBytes * 8); // Root id == 0
	    if (has_idx) { // Index
	        for (let i = 0; i < cellsNum; i++) {
	            builder.writeUint(index[i], offsetBytes * 8);
	        }
	    }
	    for (let i = 0; i < cellsNum; i++) { // Cells
	        writeCellToBuilder(allCells[i].cell, allCells[i].refs, sizeBytes, builder);
	    }
	    if (has_crc32c) {
	        let crc32 = (0, crc32c_1.crc32c)(builder.buffer()); // builder.buffer() is fast since it doesn't allocate new memory
	        builder.writeBuffer(crc32);
	    }
	    // Sanity Check
	    let res = builder.buffer();
	    if (res.length !== totalSize / 8) {
	        throw Error('Internal error');
	    }
	    return res;
	}
	serialization.serializeBoc = serializeBoc;
	return serialization;
}

var hasRequiredCell;

function requireCell () {
	if (hasRequiredCell) return Cell;
	hasRequiredCell = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var __importDefault = (Cell && Cell.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	var _a;
	Object.defineProperty(Cell, "__esModule", { value: true });
	Cell.Cell = void 0;
	const symbol_inspect_1 = __importDefault(requireSymbol_inspect());
	const BitString_1 = requireBitString();
	const CellType_1 = requireCellType();
	const Slice_1 = requireSlice();
	const resolveExotic_1 = requireResolveExotic();
	const wonderCalculator_1 = requireWonderCalculator();
	const serialization_1 = requireSerialization();
	const BitReader_1 = requireBitReader();
	const Builder_1 = requireBuilder$1();
	/**
	 * Cell as described in TVM spec
	 */
	let Cell$1 = class Cell {
	    /**
	     * Deserialize cells from BOC
	     * @param src source buffer
	     * @returns array of cells
	     */
	    static fromBoc(src) {
	        return (0, serialization_1.deserializeBoc)(src);
	    }
	    /**
	     * Helper function that deserializes a single cell from BOC in base64
	     * @param src source string
	     */
	    static fromBase64(src) {
	        let parsed = Cell.fromBoc(Buffer.from(src, 'base64'));
	        if (parsed.length !== 1) {
	            throw new Error("Deserialized more than one cell");
	        }
	        return parsed[0];
	    }
	    /**
	     * Helper function that deserializes a single cell from BOC in hex
	     * @param src source string
	     */
	    static fromHex(src) {
	        let parsed = Cell.fromBoc(Buffer.from(src, 'hex'));
	        if (parsed.length !== 1) {
	            throw new Error("Deserialized more than one cell");
	        }
	        return parsed[0];
	    }
	    constructor(opts) {
	        // Level and depth information
	        this._hashes = [];
	        this._depths = [];
	        /**
	         * Beging cell parsing
	         * @returns a new slice
	         */
	        this.beginParse = (allowExotic = false) => {
	            if (this.isExotic && !allowExotic) {
	                throw new Error("Exotic cells cannot be parsed");
	            }
	            return new Slice_1.Slice(new BitReader_1.BitReader(this.bits), this.refs);
	        };
	        /**
	         * Get cell hash
	         * @param level level
	         * @returns cell hash
	         */
	        this.hash = (level = 3) => {
	            return this._hashes[Math.min(this._hashes.length - 1, level)];
	        };
	        /**
	         * Get cell depth
	         * @param level level
	         * @returns cell depth
	         */
	        this.depth = (level = 3) => {
	            return this._depths[Math.min(this._depths.length - 1, level)];
	        };
	        /**
	         * Get cell level
	         * @returns cell level
	         */
	        this.level = () => {
	            return this.mask.level;
	        };
	        /**
	         * Checks cell to be euqal to another cell
	         * @param other other cell
	         * @returns true if cells are equal
	         */
	        this.equals = (other) => {
	            return this.hash().equals(other.hash());
	        };
	        this[_a] = () => this.toString();
	        // Resolve bits
	        let bits = BitString_1.BitString.EMPTY;
	        if (opts && opts.bits) {
	            bits = opts.bits;
	        }
	        // Resolve refs
	        let refs = [];
	        if (opts && opts.refs) {
	            refs = [...opts.refs];
	        }
	        // Resolve type
	        let hashes;
	        let depths;
	        let mask;
	        let type = CellType_1.CellType.Ordinary;
	        if (opts && opts.exotic) {
	            // Resolve exotic cell
	            let resolved = (0, resolveExotic_1.resolveExotic)(bits, refs);
	            // Perform wonders
	            let wonders = (0, wonderCalculator_1.wonderCalculator)(resolved.type, bits, refs);
	            // Copy results
	            mask = wonders.mask;
	            depths = wonders.depths;
	            hashes = wonders.hashes;
	            type = resolved.type;
	        }
	        else {
	            // Check correctness
	            if (refs.length > 4) {
	                throw new Error("Invalid number of references");
	            }
	            if (bits.length > 1023) {
	                throw new Error(`Bits overflow: ${bits.length} > 1023`);
	            }
	            // Perform wonders
	            let wonders = (0, wonderCalculator_1.wonderCalculator)(CellType_1.CellType.Ordinary, bits, refs);
	            // Copy results
	            mask = wonders.mask;
	            depths = wonders.depths;
	            hashes = wonders.hashes;
	            type = CellType_1.CellType.Ordinary;
	        }
	        // Set fields
	        this.type = type;
	        this.bits = bits;
	        this.refs = refs;
	        this.mask = mask;
	        this._depths = depths;
	        this._hashes = hashes;
	        Object.freeze(this);
	        Object.freeze(this.refs);
	        Object.freeze(this.bits);
	        Object.freeze(this.mask);
	        Object.freeze(this._depths);
	        Object.freeze(this._hashes);
	    }
	    /**
	     * Check if cell is exotic
	     */
	    get isExotic() {
	        return this.type !== CellType_1.CellType.Ordinary;
	    }
	    /**
	     * Serializes cell to BOC
	     * @param opts options
	     */
	    toBoc(opts) {
	        let idx = (opts && opts.idx !== null && opts.idx !== undefined) ? opts.idx : false;
	        let crc32 = (opts && opts.crc32 !== null && opts.crc32 !== undefined) ? opts.crc32 : true;
	        return (0, serialization_1.serializeBoc)(this, { idx, crc32 });
	    }
	    /**
	     * Format cell to string
	     * @param indent indentation
	     * @returns string representation
	     */
	    toString(indent) {
	        let id = indent || '';
	        let t = 'x';
	        if (this.isExotic) {
	            if (this.type === CellType_1.CellType.MerkleProof) {
	                t = 'p';
	            }
	            else if (this.type === CellType_1.CellType.MerkleUpdate) {
	                t = 'u';
	            }
	            else if (this.type === CellType_1.CellType.PrunedBranch) {
	                t = 'p';
	            }
	        }
	        let s = id + (this.isExotic ? t : 'x') + '{' + this.bits.toString() + '}';
	        for (let k in this.refs) {
	            const i = this.refs[k];
	            s += '\n' + i.toString(id + ' ');
	        }
	        return s;
	    }
	    /**
	     * Covnert cell to slice
	     * @returns slice
	     */
	    asSlice() {
	        return this.beginParse();
	    }
	    /**
	     * Convert cell to a builder that has this cell stored
	     * @returns builder
	     */
	    asBuilder() {
	        return (0, Builder_1.beginCell)().storeSlice(this.asSlice());
	    }
	};
	Cell.Cell = Cell$1;
	_a = symbol_inspect_1.default;
	Cell$1.EMPTY = new Cell$1();
	return Cell;
}

var hasRequiredBuilder$1;

function requireBuilder$1 () {
	if (hasRequiredBuilder$1) return Builder$3;
	hasRequiredBuilder$1 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(Builder$3, "__esModule", { value: true });
	Builder$3.Builder = Builder$3.beginCell = void 0;
	const BitBuilder_1 = requireBitBuilder();
	const Cell_1 = requireCell();
	const strings_1 = requireStrings();
	/**
	 * Start building a cell
	 * @returns a new builder
	 */
	function beginCell() {
	    return new Builder();
	}
	Builder$3.beginCell = beginCell;
	/**
	 * Builder for Cells
	 */
	class Builder {
	    constructor() {
	        this._bits = new BitBuilder_1.BitBuilder();
	        this._refs = [];
	    }
	    /**
	     * Bits written so far
	     */
	    get bits() {
	        return this._bits.length;
	    }
	    /**
	     * References written so far
	     */
	    get refs() {
	        return this._refs.length;
	    }
	    /**
	     * Available bits
	     */
	    get availableBits() {
	        return 1023 - this.bits;
	    }
	    /**
	     * Available references
	     */
	    get availableRefs() {
	        return 4 - this.refs;
	    }
	    /**
	     * Write a single bit
	     * @param value bit to write, true or positive number for 1, false or zero or negative for 0
	     * @returns this builder
	     */
	    storeBit(value) {
	        this._bits.writeBit(value);
	        return this;
	    }
	    /**
	     * Write bits from BitString
	     * @param src source bits
	     * @returns this builder
	     */
	    storeBits(src) {
	        this._bits.writeBits(src);
	        return this;
	    }
	    /**
	     * Store Buffer
	     * @param src source buffer
	     * @param bytes optional number of bytes to write
	     * @returns this builder
	     */
	    storeBuffer(src, bytes) {
	        if (bytes !== undefined && bytes !== null) {
	            if (src.length !== bytes) {
	                throw Error(`Buffer length ${src.length} is not equal to ${bytes}`);
	            }
	        }
	        this._bits.writeBuffer(src);
	        return this;
	    }
	    /**
	     * Store Maybe Buffer
	     * @param src source buffer or null
	     * @param bytes optional number of bytes to write
	     * @returns this builder
	     */
	    storeMaybeBuffer(src, bytes) {
	        if (src !== null) {
	            this.storeBit(1);
	            this.storeBuffer(src, bytes);
	        }
	        else {
	            this.storeBit(0);
	        }
	        return this;
	    }
	    /**
	     * Store uint value
	     * @param value value as bigint or number
	     * @param bits number of bits to write
	     * @returns this builder
	     */
	    storeUint(value, bits) {
	        this._bits.writeUint(value, bits);
	        return this;
	    }
	    /**
	     * Store maybe uint value
	     * @param value value as bigint or number, null or undefined
	     * @param bits number of bits to write
	     * @returns this builder
	     */
	    storeMaybeUint(value, bits) {
	        if (value !== null && value !== undefined) {
	            this.storeBit(1);
	            this.storeUint(value, bits);
	        }
	        else {
	            this.storeBit(0);
	        }
	        return this;
	    }
	    /**
	     * Store int value
	     * @param value value as bigint or number
	     * @param bits number of bits to write
	     * @returns this builder
	     */
	    storeInt(value, bits) {
	        this._bits.writeInt(value, bits);
	        return this;
	    }
	    /**
	     * Store maybe int value
	     * @param value value as bigint or number, null or undefined
	     * @param bits number of bits to write
	     * @returns this builder
	     */
	    storeMaybeInt(value, bits) {
	        if (value !== null && value !== undefined) {
	            this.storeBit(1);
	            this.storeInt(value, bits);
	        }
	        else {
	            this.storeBit(0);
	        }
	        return this;
	    }
	    /**
	     * Store varuint value
	     * @param value value as bigint or number
	     * @param bits number of bits to write to header
	     * @returns this builder
	     */
	    storeVarUint(value, bits) {
	        this._bits.writeVarUint(value, bits);
	        return this;
	    }
	    /**
	     * Store maybe varuint value
	     * @param value value as bigint or number, null or undefined
	     * @param bits number of bits to write to header
	     * @returns this builder
	     */
	    storeMaybeVarUint(value, bits) {
	        if (value !== null && value !== undefined) {
	            this.storeBit(1);
	            this.storeVarUint(value, bits);
	        }
	        else {
	            this.storeBit(0);
	        }
	        return this;
	    }
	    /**
	     * Store varint value
	     * @param value value as bigint or number
	     * @param bits number of bits to write to header
	     * @returns this builder
	     */
	    storeVarInt(value, bits) {
	        this._bits.writeVarInt(value, bits);
	        return this;
	    }
	    /**
	     * Store maybe varint value
	     * @param value value as bigint or number, null or undefined
	     * @param bits number of bits to write to header
	     * @returns this builder
	     */
	    storeMaybeVarInt(value, bits) {
	        if (value !== null && value !== undefined) {
	            this.storeBit(1);
	            this.storeVarInt(value, bits);
	        }
	        else {
	            this.storeBit(0);
	        }
	        return this;
	    }
	    /**
	     * Store coins value
	     * @param amount amount of coins
	     * @returns this builder
	     */
	    storeCoins(amount) {
	        this._bits.writeCoins(amount);
	        return this;
	    }
	    /**
	     * Store maybe coins value
	     * @param amount amount of coins, null or undefined
	     * @returns this builder
	     */
	    storeMaybeCoins(amount) {
	        if (amount !== null && amount !== undefined) {
	            this.storeBit(1);
	            this.storeCoins(amount);
	        }
	        else {
	            this.storeBit(0);
	        }
	        return this;
	    }
	    /**
	     * Store address
	     * @param addres address to store
	     * @returns this builder
	     */
	    storeAddress(address) {
	        this._bits.writeAddress(address);
	        return this;
	    }
	    /**
	     * Store reference
	     * @param cell cell or builder to store
	     * @returns this builder
	     */
	    storeRef(cell) {
	        // Check refs
	        if (this._refs.length >= 4) {
	            throw new Error("Too many references");
	        }
	        // Store reference
	        if (cell instanceof Cell_1.Cell) {
	            this._refs.push(cell);
	        }
	        else if (cell instanceof Builder) {
	            this._refs.push(cell.endCell());
	        }
	        else {
	            throw new Error("Invalid argument");
	        }
	        return this;
	    }
	    /**
	     * Store reference if not null
	     * @param cell cell or builder to store
	     * @returns this builder
	     */
	    storeMaybeRef(cell) {
	        if (cell) {
	            this.storeBit(1);
	            this.storeRef(cell);
	        }
	        else {
	            this.storeBit(0);
	        }
	        return this;
	    }
	    /**
	     * Store slice it in this builder
	     * @param src source slice
	     */
	    storeSlice(src) {
	        let c = src.clone();
	        if (c.remainingBits > 0) {
	            this.storeBits(c.loadBits(c.remainingBits));
	        }
	        while (c.remainingRefs > 0) {
	            this.storeRef(c.loadRef());
	        }
	        return this;
	    }
	    /**
	     * Store slice in this builder if not null
	     * @param src source slice
	     */
	    storeMaybeSlice(src) {
	        if (src) {
	            this.storeBit(1);
	            this.storeSlice(src);
	        }
	        else {
	            this.storeBit(0);
	        }
	        return this;
	    }
	    /**
	     * Store builder
	     * @param src builder to store
	     * @returns this builder
	     */
	    storeBuilder(src) {
	        return this.storeSlice(src.endCell().beginParse());
	    }
	    /**
	     * Store builder if not null
	     * @param src builder to store
	     * @returns this builder
	     */
	    storeMaybeBuilder(src) {
	        if (src) {
	            this.storeBit(1);
	            this.storeBuilder(src);
	        }
	        else {
	            this.storeBit(0);
	        }
	        return this;
	    }
	    /**
	     * Store writer or builder
	     * @param writer writer or builder to store
	     * @returns this builder
	     */
	    storeWritable(writer) {
	        if (typeof writer === 'object') {
	            writer.writeTo(this);
	        }
	        else {
	            writer(this);
	        }
	        return this;
	    }
	    /**
	     * Store writer or builder if not null
	     * @param writer writer or builder to store
	     * @returns this builder
	     */
	    storeMaybeWritable(writer) {
	        if (writer) {
	            this.storeBit(1);
	            this.storeWritable(writer);
	        }
	        else {
	            this.storeBit(0);
	        }
	        return this;
	    }
	    /**
	     * Store object in this builder
	     * @param writer Writable or writer functuin
	     */
	    store(writer) {
	        this.storeWritable(writer);
	        return this;
	    }
	    /**
	     * Store string tail
	     * @param src source string
	     * @returns this builder
	     */
	    storeStringTail(src) {
	        (0, strings_1.writeString)(src, this);
	        return this;
	    }
	    /**
	     * Store string tail
	     * @param src source string
	     * @returns this builder
	     */
	    storeMaybeStringTail(src) {
	        if (src !== null && src !== undefined) {
	            this.storeBit(1);
	            (0, strings_1.writeString)(src, this);
	        }
	        else {
	            this.storeBit(0);
	        }
	        return this;
	    }
	    /**
	     * Store string tail in ref
	     * @param src source string
	     * @returns this builder
	     */
	    storeStringRefTail(src) {
	        this.storeRef(beginCell()
	            .storeStringTail(src));
	        return this;
	    }
	    /**
	     * Store maybe string tail in ref
	     * @param src source string
	     * @returns this builder
	     */
	    storeMaybeStringRefTail(src) {
	        if (src !== null && src !== undefined) {
	            this.storeBit(1);
	            this.storeStringRefTail(src);
	        }
	        else {
	            this.storeBit(0);
	        }
	        return this;
	    }
	    /**
	     * Store dictionary in this builder
	     * @param dict dictionary to store
	     * @returns this builder
	     */
	    storeDict(dict, key, value) {
	        if (dict) {
	            dict.store(this, key, value);
	        }
	        else {
	            this.storeBit(0);
	        }
	        return this;
	    }
	    /**
	     * Store dictionary in this builder directly
	     * @param dict dictionary to store
	     * @returns this builder
	     */
	    storeDictDirect(dict, key, value) {
	        dict.storeDirect(this, key, value);
	        return this;
	    }
	    /**
	     * Complete cell
	     * @param opts options
	     * @returns cell
	     */
	    endCell(opts) {
	        return new Cell_1.Cell({
	            bits: this._bits.build(),
	            refs: this._refs,
	            exotic: opts?.exotic
	        });
	    }
	    /**
	     * Convert to cell
	     * @returns cell
	     */
	    asCell() {
	        return this.endCell();
	    }
	    /**
	     * Convert to slice
	     * @returns slice
	     */
	    asSlice() {
	        return this.endCell().beginParse();
	    }
	}
	Builder$3.Builder = Builder;
	return Builder$3;
}

var StateInit = {};

var SimpleLibrary = {};

var hasRequiredSimpleLibrary;

function requireSimpleLibrary () {
	if (hasRequiredSimpleLibrary) return SimpleLibrary;
	hasRequiredSimpleLibrary = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(SimpleLibrary, "__esModule", { value: true });
	SimpleLibrary.SimpleLibraryValue = SimpleLibrary.storeSimpleLibrary = SimpleLibrary.loadSimpleLibrary = void 0;
	function loadSimpleLibrary(slice) {
	    return {
	        public: slice.loadBit(),
	        root: slice.loadRef()
	    };
	}
	SimpleLibrary.loadSimpleLibrary = loadSimpleLibrary;
	function storeSimpleLibrary(src) {
	    return (builder) => {
	        builder.storeBit(src.public);
	        builder.storeRef(src.root);
	    };
	}
	SimpleLibrary.storeSimpleLibrary = storeSimpleLibrary;
	SimpleLibrary.SimpleLibraryValue = {
	    serialize(src, builder) {
	        storeSimpleLibrary(src)(builder);
	    },
	    parse(src) {
	        return loadSimpleLibrary(src);
	    },
	};
	return SimpleLibrary;
}

var TickTock = {};

var hasRequiredTickTock;

function requireTickTock () {
	if (hasRequiredTickTock) return TickTock;
	hasRequiredTickTock = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(TickTock, "__esModule", { value: true });
	TickTock.storeTickTock = TickTock.loadTickTock = void 0;
	function loadTickTock(slice) {
	    return {
	        tick: slice.loadBit(),
	        tock: slice.loadBit()
	    };
	}
	TickTock.loadTickTock = loadTickTock;
	function storeTickTock(src) {
	    return (builder) => {
	        builder.storeBit(src.tick);
	        builder.storeBit(src.tock);
	    };
	}
	TickTock.storeTickTock = storeTickTock;
	return TickTock;
}

var hasRequiredStateInit;

function requireStateInit () {
	if (hasRequiredStateInit) return StateInit;
	hasRequiredStateInit = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(StateInit, "__esModule", { value: true });
	StateInit.storeStateInit = StateInit.loadStateInit = void 0;
	const Dictionary_1 = requireDictionary();
	const SimpleLibrary_1 = requireSimpleLibrary();
	const TickTock_1 = requireTickTock();
	function loadStateInit(slice) {
	    // Split Depth
	    let splitDepth;
	    if (slice.loadBit()) {
	        splitDepth = slice.loadUint(5);
	    }
	    // TickTock
	    let special;
	    if (slice.loadBit()) {
	        special = (0, TickTock_1.loadTickTock)(slice);
	    }
	    // Code and Data
	    let code = slice.loadMaybeRef();
	    let data = slice.loadMaybeRef();
	    // Libs
	    let libraries = slice.loadDict(Dictionary_1.Dictionary.Keys.BigUint(256), SimpleLibrary_1.SimpleLibraryValue);
	    if (libraries.size === 0) {
	        libraries = undefined;
	    }
	    return {
	        splitDepth,
	        special,
	        code,
	        data,
	        libraries
	    };
	}
	StateInit.loadStateInit = loadStateInit;
	function storeStateInit(src) {
	    return (builder) => {
	        if (src.splitDepth !== null && src.splitDepth !== undefined) {
	            builder.storeBit(true);
	            builder.storeUint(src.splitDepth, 5);
	        }
	        else {
	            builder.storeBit(false);
	        }
	        if (src.special !== null && src.special !== undefined) {
	            builder.storeBit(true);
	            builder.store((0, TickTock_1.storeTickTock)(src.special));
	        }
	        else {
	            builder.storeBit(false);
	        }
	        builder.storeMaybeRef(src.code);
	        builder.storeMaybeRef(src.data);
	        builder.storeDict(src.libraries);
	    };
	}
	StateInit.storeStateInit = storeStateInit;
	return StateInit;
}

var hasRequiredContractAddress;

function requireContractAddress () {
	if (hasRequiredContractAddress) return contractAddress;
	hasRequiredContractAddress = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(contractAddress, "__esModule", { value: true });
	contractAddress.contractAddress = void 0;
	const Builder_1 = requireBuilder$1();
	const StateInit_1 = requireStateInit();
	const Address_1 = requireAddress();
	function contractAddress$1(workchain, init) {
	    let hash = (0, Builder_1.beginCell)()
	        .store((0, StateInit_1.storeStateInit)(init))
	        .endCell()
	        .hash();
	    return new Address_1.Address(workchain, hash);
	}
	contractAddress.contractAddress = contractAddress$1;
	return contractAddress;
}

var tuple = {};

var hasRequiredTuple;

function requireTuple () {
	if (hasRequiredTuple) return tuple;
	hasRequiredTuple = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(tuple, "__esModule", { value: true });
	tuple.parseTuple = tuple.serializeTuple = void 0;
	const Builder_1 = requireBuilder$1();
	const INT64_MIN = BigInt('-9223372036854775808');
	const INT64_MAX = BigInt('9223372036854775807');
	// vm_stk_null#00 = VmStackValue;
	// vm_stk_tinyint#01 value:int64 = VmStackValue;
	// vm_stk_int#0201_ value:int257 = VmStackValue;
	// vm_stk_nan#02ff = VmStackValue;
	// vm_stk_cell#03 cell:^Cell = VmStackValue;
	//_ cell:^Cell st_bits:(## 10) end_bits:(## 10) { st_bits <= end_bits }
	//   st_ref:(#<= 4) end_ref:(#<= 4) { st_ref <= end_ref } = VmCellSlice;
	// vm_stk_slice#04 _:VmCellSlice = VmStackValue;
	// vm_stk_builder#05 cell:^Cell = VmStackValue;
	// vm_stk_cont#06 cont:VmCont = VmStackValue;
	// vm_tupref_nil$_ = VmTupleRef 0;
	// vm_tupref_single$_ entry:^VmStackValue = VmTupleRef 1;
	// vm_tupref_any$_ {n:#} ref:^(VmTuple (n + 2)) = VmTupleRef (n + 2);
	// vm_tuple_nil$_ = VmTuple 0;
	// vm_tuple_tcons$_ {n:#} head:(VmTupleRef n) tail:^VmStackValue = VmTuple (n + 1);
	// vm_stk_tuple#07 len:(## 16) data:(VmTuple len) = VmStackValue;
	function serializeTupleItem(src, builder) {
	    if (src.type === 'null') {
	        builder.storeUint(0x00, 8);
	    }
	    else if (src.type === 'int') {
	        if (src.value <= INT64_MAX && src.value >= INT64_MIN) {
	            builder.storeUint(0x01, 8);
	            builder.storeInt(src.value, 64);
	        }
	        else {
	            builder.storeUint(0x0100, 15);
	            builder.storeInt(src.value, 257);
	        }
	    }
	    else if (src.type === 'nan') {
	        builder.storeInt(0x02ff, 16);
	    }
	    else if (src.type === 'cell') {
	        builder.storeUint(0x03, 8);
	        builder.storeRef(src.cell);
	    }
	    else if (src.type === 'slice') {
	        builder.storeUint(0x04, 8);
	        builder.storeUint(0, 10);
	        builder.storeUint(src.cell.bits.length, 10);
	        builder.storeUint(0, 3);
	        builder.storeUint(src.cell.refs.length, 3);
	        builder.storeRef(src.cell);
	    }
	    else if (src.type === 'builder') {
	        builder.storeUint(0x05, 8);
	        builder.storeRef(src.cell);
	    }
	    else if (src.type === 'tuple') {
	        let head = null;
	        let tail = null;
	        for (let i = 0; i < src.items.length; i++) {
	            // Swap
	            let s = head;
	            head = tail;
	            tail = s;
	            if (i > 1) {
	                head = (0, Builder_1.beginCell)()
	                    .storeRef(tail)
	                    .storeRef(head)
	                    .endCell();
	            }
	            let bc = (0, Builder_1.beginCell)();
	            serializeTupleItem(src.items[i], bc);
	            tail = bc.endCell();
	        }
	        builder.storeUint(0x07, 8);
	        builder.storeUint(src.items.length, 16);
	        if (head) {
	            builder.storeRef(head);
	        }
	        if (tail) {
	            builder.storeRef(tail);
	        }
	    }
	    else {
	        throw Error('Invalid value');
	    }
	}
	function parseStackItem(cs) {
	    let kind = cs.loadUint(8);
	    if (kind === 0) {
	        return { type: 'null' };
	    }
	    else if (kind === 1) {
	        return { type: 'int', value: cs.loadIntBig(64) };
	    }
	    else if (kind === 2) {
	        if (cs.loadUint(7) === 0) {
	            return { type: 'int', value: cs.loadIntBig(257) };
	        }
	        else {
	            cs.loadBit(); // must eq 1
	            return { type: 'nan' };
	        }
	    }
	    else if (kind === 3) {
	        return { type: 'cell', cell: cs.loadRef() };
	    }
	    else if (kind === 4) {
	        let startBits = cs.loadUint(10);
	        let endBits = cs.loadUint(10);
	        let startRefs = cs.loadUint(3);
	        let endRefs = cs.loadUint(3);
	        // Copy to new cell
	        let rs = cs.loadRef().beginParse();
	        rs.skip(startBits);
	        let dt = rs.loadBits(endBits - startBits);
	        let builder = (0, Builder_1.beginCell)()
	            .storeBits(dt);
	        // Copy refs if exist
	        if (startRefs < endRefs) {
	            for (let i = 0; i < startRefs; i++) {
	                rs.loadRef();
	            }
	            for (let i = 0; i < endRefs - startRefs; i++) {
	                builder.storeRef(rs.loadRef());
	            }
	        }
	        return { type: 'slice', cell: builder.endCell() };
	    }
	    else if (kind === 5) {
	        return { type: 'builder', cell: cs.loadRef() };
	    }
	    else if (kind === 7) {
	        let length = cs.loadUint(16);
	        let items = [];
	        if (length > 1) {
	            let head = cs.loadRef().beginParse();
	            let tail = cs.loadRef().beginParse();
	            items.unshift(parseStackItem(tail));
	            for (let i = 0; i < length - 2; i++) {
	                let ohead = head;
	                head = ohead.loadRef().beginParse();
	                tail = ohead.loadRef().beginParse();
	                items.unshift(parseStackItem(tail));
	            }
	            items.unshift(parseStackItem(head));
	        }
	        else if (length === 1) {
	            items.push(parseStackItem(cs.loadRef().beginParse()));
	        }
	        return { type: 'tuple', items };
	    }
	    else {
	        throw Error('Unsupported stack item');
	    }
	}
	//
	// Stack parsing
	// Source: https://github.com/ton-foundation/ton/blob/ae5c0720143e231c32c3d2034cfe4e533a16d969/crypto/block/block.tlb#L783
	//
	// vm_stack#_ depth:(## 24) stack:(VmStackList depth) = VmStack;
	// vm_stk_cons#_ {n:#} rest:^(VmStackList n) tos:VmStackValue = VmStackList (n + 1);
	// vm_stk_nil#_ = VmStackList 0;
	//
	function serializeTupleTail(src, builder) {
	    if (src.length > 0) {
	        // rest:^(VmStackList n)
	        let tail = (0, Builder_1.beginCell)();
	        serializeTupleTail(src.slice(0, src.length - 1), tail);
	        builder.storeRef(tail.endCell());
	        // tos
	        serializeTupleItem(src[src.length - 1], builder);
	    }
	}
	function serializeTuple(src) {
	    let builder = (0, Builder_1.beginCell)();
	    builder.storeUint(src.length, 24);
	    let r = [...src];
	    serializeTupleTail(r, builder);
	    return builder.endCell();
	}
	tuple.serializeTuple = serializeTuple;
	function parseTuple(src) {
	    let res = [];
	    let cs = src.beginParse();
	    let size = cs.loadUint(24);
	    for (let i = 0; i < size; i++) {
	        let next = cs.loadRef();
	        res.unshift(parseStackItem(cs));
	        cs = next.beginParse();
	    }
	    return res;
	}
	tuple.parseTuple = parseTuple;
	return tuple;
}

var reader = {};

var hasRequiredReader;

function requireReader () {
	if (hasRequiredReader) return reader;
	hasRequiredReader = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(reader, "__esModule", { value: true });
	reader.TupleReader = void 0;
	class TupleReader {
	    constructor(items) {
	        this.items = [...items];
	    }
	    get remaining() {
	        return this.items.length;
	    }
	    peek() {
	        if (this.items.length === 0) {
	            throw Error('EOF');
	        }
	        return this.items[0];
	    }
	    pop() {
	        if (this.items.length === 0) {
	            throw Error('EOF');
	        }
	        let res = this.items[0];
	        this.items.splice(0, 1);
	        return res;
	    }
	    skip(num = 1) {
	        for (let i = 0; i < num; i++) {
	            this.pop();
	        }
	        return this;
	    }
	    readBigNumber() {
	        let popped = this.pop();
	        if (popped.type !== 'int') {
	            throw Error('Not a number');
	        }
	        return popped.value;
	    }
	    readBigNumberOpt() {
	        let popped = this.pop();
	        if (popped.type === 'null') {
	            return null;
	        }
	        if (popped.type !== 'int') {
	            throw Error('Not a number');
	        }
	        return popped.value;
	    }
	    readNumber() {
	        return Number(this.readBigNumber());
	    }
	    readNumberOpt() {
	        let r = this.readBigNumberOpt();
	        if (r !== null) {
	            return Number(r);
	        }
	        else {
	            return null;
	        }
	    }
	    readBoolean() {
	        let res = this.readNumber();
	        return res === 0 ? false : true;
	    }
	    readBooleanOpt() {
	        let res = this.readNumberOpt();
	        if (res !== null) {
	            return res === 0 ? false : true;
	        }
	        else {
	            return null;
	        }
	    }
	    readAddress() {
	        let r = this.readCell().beginParse().loadAddress();
	        if (r !== null) {
	            return r;
	        }
	        else {
	            throw Error('Not an address');
	        }
	    }
	    readAddressOpt() {
	        let r = this.readCellOpt();
	        if (r !== null) {
	            return r.beginParse().loadMaybeAddress();
	        }
	        else {
	            return null;
	        }
	    }
	    readCell() {
	        let popped = this.pop();
	        if (popped.type !== 'cell' && popped.type !== 'slice' && popped.type !== 'builder') {
	            throw Error('Not a cell: ' + popped.type);
	        }
	        return popped.cell;
	    }
	    readCellOpt() {
	        let popped = this.pop();
	        if (popped.type === 'null') {
	            return null;
	        }
	        if (popped.type !== 'cell' && popped.type !== 'slice' && popped.type !== 'builder') {
	            throw Error('Not a cell');
	        }
	        return popped.cell;
	    }
	    readTuple() {
	        let popped = this.pop();
	        if (popped.type !== 'tuple') {
	            throw Error('Not a tuple');
	        }
	        return new TupleReader(popped.items);
	    }
	    readTupleOpt() {
	        let popped = this.pop();
	        if (popped.type === 'null') {
	            return null;
	        }
	        if (popped.type !== 'tuple') {
	            throw Error('Not a tuple');
	        }
	        return new TupleReader(popped.items);
	    }
	    static readLispList(reader) {
	        const result = [];
	        let tail = reader;
	        while (tail !== null) {
	            var head = tail.pop();
	            if (tail.items.length === 0 || (tail.items[0].type !== 'tuple' && tail.items[0].type !== 'null')) {
	                throw Error('Lisp list consists only from (any, tuple) elements and ends with null');
	            }
	            tail = tail.readTupleOpt();
	            result.push(head);
	        }
	        return result;
	    }
	    readLispListDirect() {
	        if (this.items.length === 1 && this.items[0].type === 'null') {
	            return [];
	        }
	        return TupleReader.readLispList(this);
	    }
	    readLispList() {
	        return TupleReader.readLispList(this.readTupleOpt());
	    }
	    readBuffer() {
	        let s = this.readCell().beginParse();
	        if (s.remainingRefs !== 0) {
	            throw Error('Not a buffer');
	        }
	        if (s.remainingBits % 8 !== 0) {
	            throw Error('Not a buffer');
	        }
	        return s.loadBuffer(s.remainingBits / 8);
	    }
	    readBufferOpt() {
	        let r = this.readCellOpt();
	        if (r !== null) {
	            let s = r.beginParse();
	            if (s.remainingRefs !== 0 || s.remainingBits % 8 !== 0) {
	                throw Error('Not a buffer');
	            }
	            return s.loadBuffer(s.remainingBits / 8);
	        }
	        else {
	            return null;
	        }
	    }
	    readString() {
	        let s = this.readCell().beginParse();
	        return s.loadStringTail();
	    }
	    readStringOpt() {
	        let r = this.readCellOpt();
	        if (r !== null) {
	            let s = r.beginParse();
	            return s.loadStringTail();
	        }
	        else {
	            return null;
	        }
	    }
	}
	reader.TupleReader = TupleReader;
	return reader;
}

var builder = {};

var hasRequiredBuilder;

function requireBuilder () {
	if (hasRequiredBuilder) return builder;
	hasRequiredBuilder = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(builder, "__esModule", { value: true });
	builder.TupleBuilder = void 0;
	const Builder_1 = requireBuilder$1();
	const Cell_1 = requireCell();
	const Slice_1 = requireSlice();
	class TupleBuilder {
	    constructor() {
	        this._tuple = [];
	    }
	    writeNumber(v) {
	        if (v === null || v === undefined) {
	            this._tuple.push({ type: 'null' });
	        }
	        else {
	            this._tuple.push({ type: 'int', value: BigInt(v) });
	        }
	    }
	    writeBoolean(v) {
	        if (v === null || v === undefined) {
	            this._tuple.push({ type: 'null' });
	        }
	        else {
	            this._tuple.push({ type: 'int', value: v ? -1n : 0n });
	        }
	    }
	    writeBuffer(v) {
	        if (v === null || v === undefined) {
	            this._tuple.push({ type: 'null' });
	        }
	        else {
	            this._tuple.push({ type: 'slice', cell: (0, Builder_1.beginCell)().storeBuffer(v).endCell() });
	        }
	    }
	    writeString(v) {
	        if (v === null || v === undefined) {
	            this._tuple.push({ type: 'null' });
	        }
	        else {
	            this._tuple.push({ type: 'slice', cell: (0, Builder_1.beginCell)().storeStringTail(v).endCell() });
	        }
	    }
	    writeCell(v) {
	        if (v === null || v === undefined) {
	            this._tuple.push({ type: 'null' });
	        }
	        else {
	            if (v instanceof Cell_1.Cell) {
	                this._tuple.push({ type: 'cell', cell: v });
	            }
	            else if (v instanceof Slice_1.Slice) {
	                this._tuple.push({ type: 'cell', cell: v.asCell() });
	            }
	        }
	    }
	    writeSlice(v) {
	        if (v === null || v === undefined) {
	            this._tuple.push({ type: 'null' });
	        }
	        else {
	            if (v instanceof Cell_1.Cell) {
	                this._tuple.push({ type: 'slice', cell: v });
	            }
	            else if (v instanceof Slice_1.Slice) {
	                this._tuple.push({ type: 'slice', cell: v.asCell() });
	            }
	        }
	    }
	    writeBuilder(v) {
	        if (v === null || v === undefined) {
	            this._tuple.push({ type: 'null' });
	        }
	        else {
	            if (v instanceof Cell_1.Cell) {
	                this._tuple.push({ type: 'builder', cell: v });
	            }
	            else if (v instanceof Slice_1.Slice) {
	                this._tuple.push({ type: 'builder', cell: v.asCell() });
	            }
	        }
	    }
	    writeTuple(v) {
	        if (v === null || v === undefined) {
	            this._tuple.push({ type: 'null' });
	        }
	        else {
	            this._tuple.push({ type: 'tuple', items: v });
	        }
	    }
	    writeAddress(v) {
	        if (v === null || v === undefined) {
	            this._tuple.push({ type: 'null' });
	        }
	        else {
	            this._tuple.push({ type: 'slice', cell: (0, Builder_1.beginCell)().storeAddress(v).endCell() });
	        }
	    }
	    build() {
	        return [...this._tuple];
	    }
	}
	builder.TupleBuilder = TupleBuilder;
	return builder;
}

var _export = {};

var _helpers = {};

var convert = {};

var hasRequiredConvert;

function requireConvert () {
	if (hasRequiredConvert) return convert;
	hasRequiredConvert = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(convert, "__esModule", { value: true });
	convert.fromNano = convert.toNano = void 0;
	function toNano(src) {
	    if (typeof src === 'bigint') {
	        return src * 1000000000n;
	    }
	    else {
	        if (typeof src === 'number') {
	            if (!Number.isFinite(src)) {
	                throw Error('Invalid number');
	            }
	            if (Math.log10(src) <= 6) {
	                src = src.toLocaleString('en', { minimumFractionDigits: 9, useGrouping: false });
	            }
	            else if (src - Math.trunc(src) === 0) {
	                src = src.toLocaleString('en', { maximumFractionDigits: 0, useGrouping: false });
	            }
	            else {
	                throw Error('Not enough precision for a number value. Use string value instead');
	            }
	        }
	        // Check sign
	        let neg = false;
	        while (src.startsWith('-')) {
	            neg = !neg;
	            src = src.slice(1);
	        }
	        // Split string
	        if (src === '.') {
	            throw Error('Invalid number');
	        }
	        let parts = src.split('.');
	        if (parts.length > 2) {
	            throw Error('Invalid number');
	        }
	        // Prepare parts
	        let whole = parts[0];
	        let frac = parts[1];
	        if (!whole) {
	            whole = '0';
	        }
	        if (!frac) {
	            frac = '0';
	        }
	        if (frac.length > 9) {
	            throw Error('Invalid number');
	        }
	        while (frac.length < 9) {
	            frac += '0';
	        }
	        // Convert
	        let r = BigInt(whole) * 1000000000n + BigInt(frac);
	        if (neg) {
	            r = -r;
	        }
	        return r;
	    }
	}
	convert.toNano = toNano;
	function fromNano(src) {
	    let v = BigInt(src);
	    let neg = false;
	    if (v < 0) {
	        neg = true;
	        v = -v;
	    }
	    // Convert fraction
	    let frac = v % 1000000000n;
	    let facStr = frac.toString();
	    while (facStr.length < 9) {
	        facStr = '0' + facStr;
	    }
	    facStr = facStr.match(/^([0-9]*[1-9]|0)(0*)/)[1];
	    // Convert whole
	    let whole = v / 1000000000n;
	    let wholeStr = whole.toString();
	    // Value
	    let value = `${wholeStr}${facStr === '0' ? '' : `.${facStr}`}`;
	    if (neg) {
	        value = '-' + value;
	    }
	    return value;
	}
	convert.fromNano = fromNano;
	return convert;
}

var ExtraCurrency = {};

var hasRequiredExtraCurrency;

function requireExtraCurrency () {
	if (hasRequiredExtraCurrency) return ExtraCurrency;
	hasRequiredExtraCurrency = 1;
	Object.defineProperty(ExtraCurrency, "__esModule", { value: true });
	ExtraCurrency.packExtraCurrencyCell = ExtraCurrency.packExtraCurrencyDict = ExtraCurrency.storeExtraCurrency = ExtraCurrency.loadMaybeExtraCurrency = ExtraCurrency.loadExtraCurrency = void 0;
	const Builder_1 = requireBuilder$1();
	const Dictionary_1 = requireDictionary();
	function loadExtraCurrency(data) {
	    let ecDict = data instanceof Dictionary_1.Dictionary ? data : Dictionary_1.Dictionary.loadDirect(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(5), data);
	    let ecMap = {};
	    for (let [k, v] of ecDict) {
	        ecMap[k] = v;
	    }
	    return ecMap;
	}
	ExtraCurrency.loadExtraCurrency = loadExtraCurrency;
	function loadMaybeExtraCurrency(data) {
	    const ecData = data.loadMaybeRef();
	    return ecData === null ? ecData : loadExtraCurrency(ecData);
	}
	ExtraCurrency.loadMaybeExtraCurrency = loadMaybeExtraCurrency;
	function storeExtraCurrency(extracurrency) {
	    return (builder) => {
	        builder.storeDict(packExtraCurrencyDict(extracurrency));
	    };
	}
	ExtraCurrency.storeExtraCurrency = storeExtraCurrency;
	function packExtraCurrencyDict(extracurrency) {
	    const resEc = Dictionary_1.Dictionary.empty(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(5));
	    Object.entries(extracurrency).map(([k, v]) => resEc.set(Number(k), v));
	    return resEc;
	}
	ExtraCurrency.packExtraCurrencyDict = packExtraCurrencyDict;
	function packExtraCurrencyCell(extracurrency) {
	    return (0, Builder_1.beginCell)().storeDictDirect(packExtraCurrencyDict(extracurrency)).endCell();
	}
	ExtraCurrency.packExtraCurrencyCell = packExtraCurrencyCell;
	return ExtraCurrency;
}

var hasRequired_helpers;

function require_helpers () {
	if (hasRequired_helpers) return _helpers;
	hasRequired_helpers = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(_helpers, "__esModule", { value: true });
	_helpers.comment = _helpers.external = _helpers.internal = void 0;
	const Address_1 = requireAddress();
	const Cell_1 = requireCell();
	const Builder_1 = requireBuilder$1();
	const convert_1 = requireConvert();
	const ExtraCurrency_1 = requireExtraCurrency();
	function internal(src) {
	    // Resolve bounce
	    let bounce = true;
	    if (src.bounce !== null && src.bounce !== undefined) {
	        bounce = src.bounce;
	    }
	    // Resolve address
	    let to;
	    if (typeof src.to === 'string') {
	        to = Address_1.Address.parse(src.to);
	    }
	    else if (Address_1.Address.isAddress(src.to)) {
	        to = src.to;
	    }
	    else {
	        throw new Error(`Invalid address ${src.to}`);
	    }
	    // Resolve value
	    let value;
	    if (typeof src.value === 'string') {
	        value = (0, convert_1.toNano)(src.value);
	    }
	    else {
	        value = src.value;
	    }
	    let other;
	    if (src.extracurrency) {
	        // Resolve value
	        other = (0, ExtraCurrency_1.packExtraCurrencyDict)(src.extracurrency);
	    }
	    // Resolve body
	    let body = Cell_1.Cell.EMPTY;
	    if (typeof src.body === 'string') {
	        body = (0, Builder_1.beginCell)().storeUint(0, 32).storeStringTail(src.body).endCell();
	    }
	    else if (src.body) {
	        body = src.body;
	    }
	    // Create message
	    return {
	        info: {
	            type: 'internal',
	            dest: to,
	            value: { coins: value, other },
	            bounce,
	            ihrDisabled: true,
	            bounced: false,
	            ihrFee: 0n,
	            forwardFee: 0n,
	            createdAt: 0,
	            createdLt: 0n
	        },
	        init: src.init ?? undefined,
	        body: body
	    };
	}
	_helpers.internal = internal;
	function external(src) {
	    // Resolve address
	    let to;
	    if (typeof src.to === 'string') {
	        to = Address_1.Address.parse(src.to);
	    }
	    else if (Address_1.Address.isAddress(src.to)) {
	        to = src.to;
	    }
	    else {
	        throw new Error(`Invalid address ${src.to}`);
	    }
	    return {
	        info: {
	            type: 'external-in',
	            dest: to,
	            importFee: 0n
	        },
	        init: src.init ?? undefined,
	        body: src.body || Cell_1.Cell.EMPTY
	    };
	}
	_helpers.external = external;
	function comment(src) {
	    return (0, Builder_1.beginCell)()
	        .storeUint(0, 32)
	        .storeStringTail(src)
	        .endCell();
	}
	_helpers.comment = comment;
	return _helpers;
}

var Account = {};

var AccountStorage = {};

var AccountState = {};

var hasRequiredAccountState;

function requireAccountState () {
	if (hasRequiredAccountState) return AccountState;
	hasRequiredAccountState = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(AccountState, "__esModule", { value: true });
	AccountState.storeAccountState = AccountState.loadAccountState = void 0;
	const StateInit_1 = requireStateInit();
	function loadAccountState(cs) {
	    if (cs.loadBit()) {
	        return { type: 'active', state: (0, StateInit_1.loadStateInit)(cs) };
	    }
	    else if (cs.loadBit()) {
	        return { type: 'frozen', stateHash: cs.loadUintBig(256) };
	    }
	    else {
	        return { type: 'uninit' };
	    }
	}
	AccountState.loadAccountState = loadAccountState;
	function storeAccountState(src) {
	    return (builder) => {
	        if (src.type === 'active') {
	            builder.storeBit(true);
	            builder.store((0, StateInit_1.storeStateInit)(src.state));
	        }
	        else if (src.type === 'frozen') {
	            builder.storeBit(false);
	            builder.storeBit(true);
	            builder.storeUint(src.stateHash, 256);
	        }
	        else if (src.type === 'uninit') {
	            builder.storeBit(false);
	            builder.storeBit(false);
	        }
	    };
	}
	AccountState.storeAccountState = storeAccountState;
	return AccountState;
}

var CurrencyCollection = {};

var hasRequiredCurrencyCollection;

function requireCurrencyCollection () {
	if (hasRequiredCurrencyCollection) return CurrencyCollection;
	hasRequiredCurrencyCollection = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(CurrencyCollection, "__esModule", { value: true });
	CurrencyCollection.storeCurrencyCollection = CurrencyCollection.loadCurrencyCollection = void 0;
	const Dictionary_1 = requireDictionary();
	function loadCurrencyCollection(slice) {
	    const coins = slice.loadCoins();
	    const other = slice.loadDict(Dictionary_1.Dictionary.Keys.Uint(32), Dictionary_1.Dictionary.Values.BigVarUint(5 /* log2(32) */));
	    if (other.size === 0) {
	        return { coins };
	    }
	    else {
	        return { other, coins };
	    }
	}
	CurrencyCollection.loadCurrencyCollection = loadCurrencyCollection;
	function storeCurrencyCollection(collection) {
	    return (builder) => {
	        builder.storeCoins(collection.coins);
	        if (collection.other) {
	            builder.storeDict(collection.other);
	        }
	        else {
	            builder.storeBit(0);
	        }
	    };
	}
	CurrencyCollection.storeCurrencyCollection = storeCurrencyCollection;
	return CurrencyCollection;
}

var hasRequiredAccountStorage;

function requireAccountStorage () {
	if (hasRequiredAccountStorage) return AccountStorage;
	hasRequiredAccountStorage = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(AccountStorage, "__esModule", { value: true });
	AccountStorage.storeAccountStorage = AccountStorage.loadAccountStorage = void 0;
	const AccountState_1 = requireAccountState();
	const CurrencyCollection_1 = requireCurrencyCollection();
	function loadAccountStorage(slice) {
	    return {
	        lastTransLt: slice.loadUintBig(64),
	        balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice),
	        state: (0, AccountState_1.loadAccountState)(slice)
	    };
	}
	AccountStorage.loadAccountStorage = loadAccountStorage;
	function storeAccountStorage(src) {
	    return (builder) => {
	        builder.storeUint(src.lastTransLt, 64);
	        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.balance));
	        builder.store((0, AccountState_1.storeAccountState)(src.state));
	    };
	}
	AccountStorage.storeAccountStorage = storeAccountStorage;
	return AccountStorage;
}

var StorageInfo = {};

var StorageExtraInfo = {};

var hasRequiredStorageExtraInfo;

function requireStorageExtraInfo () {
	if (hasRequiredStorageExtraInfo) return StorageExtraInfo;
	hasRequiredStorageExtraInfo = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(StorageExtraInfo, "__esModule", { value: true });
	StorageExtraInfo.storeStorageExtraInfo = StorageExtraInfo.loadStorageExtraInfo = void 0;
	function loadStorageExtraInfo(slice) {
	    let header = slice.loadUint(3);
	    if (header === 0) {
	        return null;
	    }
	    if (header === 1) {
	        return {
	            dictHash: slice.loadUintBig(256),
	        };
	    }
	    throw new Error(`Invalid storage extra info header: ${header}`);
	}
	StorageExtraInfo.loadStorageExtraInfo = loadStorageExtraInfo;
	function storeStorageExtraInfo(src) {
	    return (builder) => {
	        if (src === null) {
	            builder.storeUint(0, 3);
	        }
	        else {
	            builder.storeUint(1, 3);
	            builder.storeUint(src.dictHash, 256);
	        }
	    };
	}
	StorageExtraInfo.storeStorageExtraInfo = storeStorageExtraInfo;
	return StorageExtraInfo;
}

var StorageUsed = {};

var hasRequiredStorageUsed;

function requireStorageUsed () {
	if (hasRequiredStorageUsed) return StorageUsed;
	hasRequiredStorageUsed = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(StorageUsed, "__esModule", { value: true });
	StorageUsed.storeStorageUsed = StorageUsed.loadStorageUsed = void 0;
	function loadStorageUsed(cs) {
	    return {
	        cells: cs.loadVarUintBig(3),
	        bits: cs.loadVarUintBig(3),
	    };
	}
	StorageUsed.loadStorageUsed = loadStorageUsed;
	function storeStorageUsed(src) {
	    return (builder) => {
	        builder.storeVarUint(src.cells, 3);
	        builder.storeVarUint(src.bits, 3);
	    };
	}
	StorageUsed.storeStorageUsed = storeStorageUsed;
	return StorageUsed;
}

var hasRequiredStorageInfo;

function requireStorageInfo () {
	if (hasRequiredStorageInfo) return StorageInfo;
	hasRequiredStorageInfo = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(StorageInfo, "__esModule", { value: true });
	StorageInfo.storeStorageInfo = StorageInfo.loadStorageInfo = void 0;
	const StorageExtraInfo_1 = requireStorageExtraInfo();
	const StorageUsed_1 = requireStorageUsed();
	function loadStorageInfo(slice) {
	    return {
	        used: (0, StorageUsed_1.loadStorageUsed)(slice),
	        storageExtra: (0, StorageExtraInfo_1.loadStorageExtraInfo)(slice),
	        lastPaid: slice.loadUint(32),
	        duePayment: slice.loadMaybeCoins()
	    };
	}
	StorageInfo.loadStorageInfo = loadStorageInfo;
	function storeStorageInfo(src) {
	    return (builder) => {
	        builder.store((0, StorageUsed_1.storeStorageUsed)(src.used));
	        builder.store((0, StorageExtraInfo_1.storeStorageExtraInfo)(src.storageExtra));
	        builder.storeUint(src.lastPaid, 32);
	        builder.storeMaybeCoins(src.duePayment);
	    };
	}
	StorageInfo.storeStorageInfo = storeStorageInfo;
	return StorageInfo;
}

var hasRequiredAccount;

function requireAccount () {
	if (hasRequiredAccount) return Account;
	hasRequiredAccount = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(Account, "__esModule", { value: true });
	Account.storeAccount = Account.loadAccount = void 0;
	const AccountStorage_1 = requireAccountStorage();
	const StorageInfo_1 = requireStorageInfo();
	function loadAccount(slice) {
	    return {
	        addr: slice.loadAddress(),
	        storageStats: (0, StorageInfo_1.loadStorageInfo)(slice),
	        storage: (0, AccountStorage_1.loadAccountStorage)(slice)
	    };
	}
	Account.loadAccount = loadAccount;
	function storeAccount(src) {
	    return (builder) => {
	        builder.storeAddress(src.addr);
	        builder.store((0, StorageInfo_1.storeStorageInfo)(src.storageStats));
	        builder.store((0, AccountStorage_1.storeAccountStorage)(src.storage));
	    };
	}
	Account.storeAccount = storeAccount;
	return Account;
}

var AccountStatus = {};

var hasRequiredAccountStatus;

function requireAccountStatus () {
	if (hasRequiredAccountStatus) return AccountStatus;
	hasRequiredAccountStatus = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(AccountStatus, "__esModule", { value: true });
	AccountStatus.storeAccountStatus = AccountStatus.loadAccountStatus = void 0;
	/**
	 * Load account state from slice
	 * @param slice
	 * @returns AccountState
	 */
	function loadAccountStatus(slice) {
	    const status = slice.loadUint(2);
	    if (status === 0x00) {
	        return 'uninitialized';
	    }
	    if (status === 0x01) {
	        return 'frozen';
	    }
	    if (status === 0x02) {
	        return 'active';
	    }
	    if (status === 0x03) {
	        return 'non-existing';
	    }
	    throw Error('Invalid data');
	}
	AccountStatus.loadAccountStatus = loadAccountStatus;
	/**
	 * Store account state to builder
	 * @param src account state
	 * @param builder buidler
	 */
	function storeAccountStatus(src) {
	    return (builder) => {
	        if (src === 'uninitialized') {
	            builder.storeUint(0x00, 2);
	        }
	        else if (src === 'frozen') {
	            builder.storeUint(0x01, 2);
	        }
	        else if (src === 'active') {
	            builder.storeUint(0x02, 2);
	        }
	        else if (src === 'non-existing') {
	            builder.storeUint(0x03, 2);
	        }
	        else {
	            throw Error('Invalid data');
	        }
	        return builder;
	    };
	}
	AccountStatus.storeAccountStatus = storeAccountStatus;
	return AccountStatus;
}

var AccountStatusChange = {};

var hasRequiredAccountStatusChange;

function requireAccountStatusChange () {
	if (hasRequiredAccountStatusChange) return AccountStatusChange;
	hasRequiredAccountStatusChange = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(AccountStatusChange, "__esModule", { value: true });
	AccountStatusChange.storeAccountStatusChange = AccountStatusChange.loadAccountStatusChange = void 0;
	function loadAccountStatusChange(slice) {
	    if (!slice.loadBit()) {
	        return 'unchanged';
	    }
	    if (slice.loadBit()) {
	        return 'deleted';
	    }
	    else {
	        return 'frozen';
	    }
	}
	AccountStatusChange.loadAccountStatusChange = loadAccountStatusChange;
	function storeAccountStatusChange(src) {
	    return (builder) => {
	        if (src == 'unchanged') {
	            builder.storeBit(0);
	        }
	        else if (src === 'frozen') {
	            builder.storeBit(1);
	            builder.storeBit(0);
	        }
	        else if (src === 'deleted') {
	            builder.storeBit(1);
	            builder.storeBit(1);
	        }
	        else {
	            throw Error('Invalid account status change');
	        }
	    };
	}
	AccountStatusChange.storeAccountStatusChange = storeAccountStatusChange;
	return AccountStatusChange;
}

var OutList = {};

var MessageRelaxed = {};

var CommonMessageInfoRelaxed = {};

var hasRequiredCommonMessageInfoRelaxed;

function requireCommonMessageInfoRelaxed () {
	if (hasRequiredCommonMessageInfoRelaxed) return CommonMessageInfoRelaxed;
	hasRequiredCommonMessageInfoRelaxed = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(CommonMessageInfoRelaxed, "__esModule", { value: true });
	CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = void 0;
	const CurrencyCollection_1 = requireCurrencyCollection();
	function loadCommonMessageInfoRelaxed(slice) {
	    // Internal message
	    if (!slice.loadBit()) {
	        const ihrDisabled = slice.loadBit();
	        const bounce = slice.loadBit();
	        const bounced = slice.loadBit();
	        const src = slice.loadMaybeAddress();
	        const dest = slice.loadAddress();
	        const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
	        const ihrFee = slice.loadCoins();
	        const forwardFee = slice.loadCoins();
	        const createdLt = slice.loadUintBig(64);
	        const createdAt = slice.loadUint(32);
	        return {
	            type: 'internal',
	            ihrDisabled,
	            bounce,
	            bounced,
	            src,
	            dest,
	            value,
	            ihrFee,
	            forwardFee,
	            createdLt,
	            createdAt,
	        };
	    }
	    // External In mesage
	    if (!slice.loadBit()) {
	        throw Error('External In message is not possible for CommonMessageInfoRelaxed');
	    }
	    // External Out message
	    const src = slice.loadMaybeAddress();
	    const dest = slice.loadMaybeExternalAddress();
	    const createdLt = slice.loadUintBig(64);
	    const createdAt = slice.loadUint(32);
	    return {
	        type: 'external-out',
	        src,
	        dest,
	        createdLt,
	        createdAt,
	    };
	}
	CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = loadCommonMessageInfoRelaxed;
	function storeCommonMessageInfoRelaxed(source) {
	    return (builder) => {
	        if (source.type === 'internal') {
	            builder.storeBit(0);
	            builder.storeBit(source.ihrDisabled);
	            builder.storeBit(source.bounce);
	            builder.storeBit(source.bounced);
	            builder.storeAddress(source.src);
	            builder.storeAddress(source.dest);
	            builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
	            builder.storeCoins(source.ihrFee);
	            builder.storeCoins(source.forwardFee);
	            builder.storeUint(source.createdLt, 64);
	            builder.storeUint(source.createdAt, 32);
	        }
	        else if (source.type === 'external-out') {
	            builder.storeBit(1);
	            builder.storeBit(1);
	            builder.storeAddress(source.src);
	            builder.storeAddress(source.dest);
	            builder.storeUint(source.createdLt, 64);
	            builder.storeUint(source.createdAt, 32);
	        }
	        else {
	            throw new Error('Unknown CommonMessageInfo type');
	        }
	    };
	}
	CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = storeCommonMessageInfoRelaxed;
	return CommonMessageInfoRelaxed;
}

var hasRequiredMessageRelaxed;

function requireMessageRelaxed () {
	if (hasRequiredMessageRelaxed) return MessageRelaxed;
	hasRequiredMessageRelaxed = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(MessageRelaxed, "__esModule", { value: true });
	MessageRelaxed.storeMessageRelaxed = MessageRelaxed.loadMessageRelaxed = void 0;
	const Builder_1 = requireBuilder$1();
	const CommonMessageInfoRelaxed_1 = requireCommonMessageInfoRelaxed();
	const StateInit_1 = requireStateInit();
	function loadMessageRelaxed(slice) {
	    const info = (0, CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed)(slice);
	    let init = null;
	    if (slice.loadBit()) {
	        if (!slice.loadBit()) {
	            init = (0, StateInit_1.loadStateInit)(slice);
	        }
	        else {
	            init = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
	        }
	    }
	    const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
	    return {
	        info,
	        init,
	        body
	    };
	}
	MessageRelaxed.loadMessageRelaxed = loadMessageRelaxed;
	function storeMessageRelaxed(message, opts) {
	    return (builder) => {
	        // Store CommonMsgInfo
	        builder.store((0, CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed)(message.info));
	        // Store init
	        if (message.init) {
	            builder.storeBit(true);
	            let initCell = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
	            // Check if ref is needed
	            let needRef = false;
	            if (opts && opts.forceRef) {
	                needRef = true;
	            }
	            else {
	                if (builder.availableBits - 2 /* At least on byte for ref flag */ >= initCell.bits) {
	                    needRef = false;
	                }
	                else {
	                    needRef = true;
	                }
	            }
	            // Store ref
	            if (needRef) {
	                builder.storeBit(true);
	                builder.storeRef(initCell);
	            }
	            else {
	                builder.storeBit(false);
	                builder.storeBuilder(initCell);
	            }
	        }
	        else {
	            builder.storeBit(false);
	        }
	        // Store body
	        let needRef = false;
	        if (opts && opts.forceRef) {
	            needRef = true;
	        }
	        else {
	            /*
	             1. If at least one bit for ref flag
	             2. If enough space for refs
	             3. If not exotic
	            */
	            if (builder.availableBits - 1 >= message.body.bits.length &&
	                builder.refs + message.body.refs.length <= 4 &&
	                !message.body.isExotic) {
	                needRef = false;
	            }
	            else {
	                needRef = true;
	            }
	        }
	        if (needRef) {
	            builder.storeBit(true);
	            builder.storeRef(message.body);
	        }
	        else {
	            builder.storeBit(false);
	            builder.storeBuilder(message.body.asBuilder());
	        }
	    };
	}
	MessageRelaxed.storeMessageRelaxed = storeMessageRelaxed;
	return MessageRelaxed;
}

var LibRef = {};

var hasRequiredLibRef;

function requireLibRef () {
	if (hasRequiredLibRef) return LibRef;
	hasRequiredLibRef = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(LibRef, "__esModule", { value: true });
	LibRef.storeLibRef = LibRef.loadLibRef = void 0;
	function loadLibRef(slice) {
	    const type = slice.loadUint(1);
	    if (type === 0) {
	        return {
	            type: 'hash',
	            libHash: slice.loadBuffer(32)
	        };
	    }
	    else {
	        return {
	            type: 'ref',
	            library: slice.loadRef()
	        };
	    }
	}
	LibRef.loadLibRef = loadLibRef;
	function storeLibRef(src) {
	    return (builder) => {
	        if (src.type === 'hash') {
	            builder.storeUint(0, 1);
	            builder.storeBuffer(src.libHash);
	        }
	        else {
	            builder.storeUint(1, 1);
	            builder.storeRef(src.library);
	        }
	    };
	}
	LibRef.storeLibRef = storeLibRef;
	return LibRef;
}

var hasRequiredOutList;

function requireOutList () {
	if (hasRequiredOutList) return OutList;
	hasRequiredOutList = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(OutList, "__esModule", { value: true });
	OutList.loadOutList = OutList.storeOutList = OutList.loadOutAction = OutList.storeOutAction = void 0;
	const MessageRelaxed_1 = requireMessageRelaxed();
	const Builder_1 = requireBuilder$1();
	const CurrencyCollection_1 = requireCurrencyCollection();
	const LibRef_1 = requireLibRef();
	function storeOutAction(action) {
	    switch (action.type) {
	        case 'sendMsg':
	            return storeOutActionSendMsg(action);
	        case 'setCode':
	            return storeOutActionSetCode(action);
	        case 'reserve':
	            return storeOutActionReserve(action);
	        case 'changeLibrary':
	            return storeOutActionChangeLibrary(action);
	        default:
	            throw new Error(`Unknown action type ${action.type}`);
	    }
	}
	OutList.storeOutAction = storeOutAction;
	/*
	action_send_msg#0ec3c86d mode:(## 8)
	  out_msg:^(MessageRelaxed Any) = OutAction;
	*/
	const outActionSendMsgTag = 0x0ec3c86d;
	function storeOutActionSendMsg(action) {
	    return (builder) => {
	        builder.storeUint(outActionSendMsgTag, 32)
	            .storeUint(action.mode, 8)
	            .storeRef((0, Builder_1.beginCell)().store((0, MessageRelaxed_1.storeMessageRelaxed)(action.outMsg)).endCell());
	    };
	}
	/*
	action_set_code#ad4de08e new_code:^Cell = OutAction;
	 */
	const outActionSetCodeTag = 0xad4de08e;
	function storeOutActionSetCode(action) {
	    return (builder) => {
	        builder.storeUint(outActionSetCodeTag, 32).storeRef(action.newCode);
	    };
	}
	/*
	action_reserve_currency#36e6b809 mode:(## 8)
	  currency:CurrencyCollection = OutAction;
	 */
	const outActionReserveTag = 0x36e6b809;
	function storeOutActionReserve(action) {
	    return (builder) => {
	        builder.storeUint(outActionReserveTag, 32)
	            .storeUint(action.mode, 8)
	            .store((0, CurrencyCollection_1.storeCurrencyCollection)(action.currency));
	    };
	}
	/*
	action_change_library#26fa1dd4 mode:(## 7)
	  libref:LibRef = OutAction;
	 */
	const outActionChangeLibraryTag = 0x26fa1dd4;
	function storeOutActionChangeLibrary(action) {
	    return (builder) => {
	        builder.storeUint(outActionChangeLibraryTag, 32)
	            .storeUint(action.mode, 7)
	            .store((0, LibRef_1.storeLibRef)(action.libRef));
	    };
	}
	function loadOutAction(slice) {
	    const tag = slice.loadUint(32);
	    if (tag === outActionSendMsgTag) {
	        const mode = slice.loadUint(8);
	        const outMsg = (0, MessageRelaxed_1.loadMessageRelaxed)(slice.loadRef().beginParse());
	        return {
	            type: 'sendMsg',
	            mode,
	            outMsg
	        };
	    }
	    if (tag === outActionSetCodeTag) {
	        const newCode = slice.loadRef();
	        return {
	            type: 'setCode',
	            newCode
	        };
	    }
	    if (tag === outActionReserveTag) {
	        const mode = slice.loadUint(8);
	        const currency = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
	        return {
	            type: 'reserve',
	            mode,
	            currency
	        };
	    }
	    if (tag === outActionChangeLibraryTag) {
	        const mode = slice.loadUint(7);
	        const libRef = (0, LibRef_1.loadLibRef)(slice);
	        return {
	            type: 'changeLibrary',
	            mode,
	            libRef
	        };
	    }
	    throw new Error(`Unknown out action tag 0x${tag.toString(16)}`);
	}
	OutList.loadOutAction = loadOutAction;
	/*
	out_list_empty$_ = OutList 0;
	out_list$_ {n:#} prev:^(OutList n) action:OutAction
	  = OutList (n + 1);
	 */
	function storeOutList(actions) {
	    const cell = actions.reduce((cell, action) => (0, Builder_1.beginCell)()
	        .storeRef(cell)
	        .store(storeOutAction(action))
	        .endCell(), (0, Builder_1.beginCell)().endCell());
	    return (builder) => {
	        builder.storeSlice(cell.beginParse());
	    };
	}
	OutList.storeOutList = storeOutList;
	function loadOutList(slice) {
	    const actions = [];
	    while (slice.remainingRefs) {
	        const nextCell = slice.loadRef();
	        actions.push(loadOutAction(slice));
	        slice = nextCell.beginParse();
	    }
	    return actions.reverse();
	}
	OutList.loadOutList = loadOutList;
	return OutList;
}

var CommonMessageInfo = {};

var hasRequiredCommonMessageInfo;

function requireCommonMessageInfo () {
	if (hasRequiredCommonMessageInfo) return CommonMessageInfo;
	hasRequiredCommonMessageInfo = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(CommonMessageInfo, "__esModule", { value: true });
	CommonMessageInfo.storeCommonMessageInfo = CommonMessageInfo.loadCommonMessageInfo = void 0;
	const CurrencyCollection_1 = requireCurrencyCollection();
	function loadCommonMessageInfo(slice) {
	    // Internal message
	    if (!slice.loadBit()) {
	        const ihrDisabled = slice.loadBit();
	        const bounce = slice.loadBit();
	        const bounced = slice.loadBit();
	        const src = slice.loadAddress();
	        const dest = slice.loadAddress();
	        const value = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
	        const ihrFee = slice.loadCoins();
	        const forwardFee = slice.loadCoins();
	        const createdLt = slice.loadUintBig(64);
	        const createdAt = slice.loadUint(32);
	        return {
	            type: 'internal',
	            ihrDisabled,
	            bounce,
	            bounced,
	            src,
	            dest,
	            value,
	            ihrFee,
	            forwardFee,
	            createdLt,
	            createdAt,
	        };
	    }
	    // External In mesage
	    if (!slice.loadBit()) {
	        const src = slice.loadMaybeExternalAddress();
	        const dest = slice.loadAddress();
	        const importFee = slice.loadCoins();
	        return {
	            type: 'external-in',
	            src,
	            dest,
	            importFee,
	        };
	    }
	    // External Out message
	    const src = slice.loadAddress();
	    const dest = slice.loadMaybeExternalAddress();
	    const createdLt = slice.loadUintBig(64);
	    const createdAt = slice.loadUint(32);
	    return {
	        type: 'external-out',
	        src,
	        dest,
	        createdLt,
	        createdAt,
	    };
	}
	CommonMessageInfo.loadCommonMessageInfo = loadCommonMessageInfo;
	function storeCommonMessageInfo(source) {
	    return (builder) => {
	        if (source.type === 'internal') {
	            builder.storeBit(0);
	            builder.storeBit(source.ihrDisabled);
	            builder.storeBit(source.bounce);
	            builder.storeBit(source.bounced);
	            builder.storeAddress(source.src);
	            builder.storeAddress(source.dest);
	            builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(source.value));
	            builder.storeCoins(source.ihrFee);
	            builder.storeCoins(source.forwardFee);
	            builder.storeUint(source.createdLt, 64);
	            builder.storeUint(source.createdAt, 32);
	        }
	        else if (source.type === 'external-in') {
	            builder.storeBit(1);
	            builder.storeBit(0);
	            builder.storeAddress(source.src);
	            builder.storeAddress(source.dest);
	            builder.storeCoins(source.importFee);
	        }
	        else if (source.type === 'external-out') {
	            builder.storeBit(1);
	            builder.storeBit(1);
	            builder.storeAddress(source.src);
	            builder.storeAddress(source.dest);
	            builder.storeUint(source.createdLt, 64);
	            builder.storeUint(source.createdAt, 32);
	        }
	        else {
	            throw new Error('Unknown CommonMessageInfo type');
	        }
	    };
	}
	CommonMessageInfo.storeCommonMessageInfo = storeCommonMessageInfo;
	return CommonMessageInfo;
}

var ComputeSkipReason = {};

var hasRequiredComputeSkipReason;

function requireComputeSkipReason () {
	if (hasRequiredComputeSkipReason) return ComputeSkipReason;
	hasRequiredComputeSkipReason = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(ComputeSkipReason, "__esModule", { value: true });
	ComputeSkipReason.storeComputeSkipReason = ComputeSkipReason.loadComputeSkipReason = void 0;
	function loadComputeSkipReason(slice) {
	    let reason = slice.loadUint(2);
	    if (reason === 0x00) {
	        return 'no-state';
	    }
	    else if (reason === 0x01) {
	        return 'bad-state';
	    }
	    else if (reason === 0x02) {
	        return 'no-gas';
	    }
	    throw new Error(`Unknown ComputeSkipReason: ${reason}`);
	}
	ComputeSkipReason.loadComputeSkipReason = loadComputeSkipReason;
	function storeComputeSkipReason(src) {
	    return (builder) => {
	        if (src === 'no-state') {
	            builder.storeUint(0x00, 2);
	        }
	        else if (src === 'bad-state') {
	            builder.storeUint(0x01, 2);
	        }
	        else if (src === 'no-gas') {
	            builder.storeUint(0x02, 2);
	        }
	        else {
	            throw new Error(`Unknown ComputeSkipReason: ${src}`);
	        }
	    };
	}
	ComputeSkipReason.storeComputeSkipReason = storeComputeSkipReason;
	return ComputeSkipReason;
}

var DepthBalanceInfo = {};

var hasRequiredDepthBalanceInfo;

function requireDepthBalanceInfo () {
	if (hasRequiredDepthBalanceInfo) return DepthBalanceInfo;
	hasRequiredDepthBalanceInfo = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(DepthBalanceInfo, "__esModule", { value: true });
	DepthBalanceInfo.storeDepthBalanceInfo = DepthBalanceInfo.loadDepthBalanceInfo = void 0;
	const CurrencyCollection_1 = requireCurrencyCollection();
	function loadDepthBalanceInfo(slice) {
	    let splitDepth = slice.loadUint(5);
	    return {
	        splitDepth,
	        balance: (0, CurrencyCollection_1.loadCurrencyCollection)(slice)
	    };
	}
	DepthBalanceInfo.loadDepthBalanceInfo = loadDepthBalanceInfo;
	function storeDepthBalanceInfo(src) {
	    return (builder) => {
	        builder.storeUint(src.splitDepth, 5);
	        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.balance));
	    };
	}
	DepthBalanceInfo.storeDepthBalanceInfo = storeDepthBalanceInfo;
	return DepthBalanceInfo;
}

var HashUpdate = {};

var hasRequiredHashUpdate;

function requireHashUpdate () {
	if (hasRequiredHashUpdate) return HashUpdate;
	hasRequiredHashUpdate = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(HashUpdate, "__esModule", { value: true });
	HashUpdate.storeHashUpdate = HashUpdate.loadHashUpdate = void 0;
	function loadHashUpdate(slice) {
	    if (slice.loadUint(8) !== 0x72) {
	        throw Error('Invalid data');
	    }
	    const oldHash = slice.loadBuffer(32);
	    const newHash = slice.loadBuffer(32);
	    return { oldHash, newHash };
	}
	HashUpdate.loadHashUpdate = loadHashUpdate;
	function storeHashUpdate(src) {
	    return (builder) => {
	        builder.storeUint(0x72, 8);
	        builder.storeBuffer(src.oldHash);
	        builder.storeBuffer(src.newHash);
	    };
	}
	HashUpdate.storeHashUpdate = storeHashUpdate;
	return HashUpdate;
}

var MasterchainStateExtra = {};

var hasRequiredMasterchainStateExtra;

function requireMasterchainStateExtra () {
	if (hasRequiredMasterchainStateExtra) return MasterchainStateExtra;
	hasRequiredMasterchainStateExtra = 1;
	Object.defineProperty(MasterchainStateExtra, "__esModule", { value: true });
	MasterchainStateExtra.loadMasterchainStateExtra = void 0;
	const Dictionary_1 = requireDictionary();
	const CurrencyCollection_1 = requireCurrencyCollection();
	function loadMasterchainStateExtra(cs) {
	  if (cs.loadUint(16) !== 52262) {
	    throw Error("Invalid data");
	  }
	  if (cs.loadBit()) {
	    cs.loadRef();
	  }
	  let configAddress = cs.loadUintBig(256);
	  let config = Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.Int(32), Dictionary_1.Dictionary.Values.Cell(), cs);
	  const globalBalance = (0, CurrencyCollection_1.loadCurrencyCollection)(cs);
	  return {
	    config,
	    configAddress,
	    globalBalance
	  };
	}
	MasterchainStateExtra.loadMasterchainStateExtra = loadMasterchainStateExtra;
	return MasterchainStateExtra;
}

var Message = {};

var hasRequiredMessage;

function requireMessage () {
	if (hasRequiredMessage) return Message;
	hasRequiredMessage = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(Message, "__esModule", { value: true });
	Message.MessageValue = Message.storeMessage = Message.loadMessage = void 0;
	const Builder_1 = requireBuilder$1();
	const CommonMessageInfo_1 = requireCommonMessageInfo();
	const StateInit_1 = requireStateInit();
	function loadMessage(slice) {
	    const info = (0, CommonMessageInfo_1.loadCommonMessageInfo)(slice);
	    let init = null;
	    if (slice.loadBit()) {
	        if (!slice.loadBit()) {
	            init = (0, StateInit_1.loadStateInit)(slice);
	        }
	        else {
	            init = (0, StateInit_1.loadStateInit)(slice.loadRef().beginParse());
	        }
	    }
	    const body = slice.loadBit() ? slice.loadRef() : slice.asCell();
	    return {
	        info,
	        init,
	        body
	    };
	}
	Message.loadMessage = loadMessage;
	function storeMessage(message, opts) {
	    return (builder) => {
	        // Store CommonMsgInfo
	        builder.store((0, CommonMessageInfo_1.storeCommonMessageInfo)(message.info));
	        // Store init
	        if (message.init) {
	            builder.storeBit(true);
	            let initCell = (0, Builder_1.beginCell)().store((0, StateInit_1.storeStateInit)(message.init));
	            // Check if need to store it in ref
	            let needRef = false;
	            if (opts && opts.forceRef) {
	                needRef = true;
	            }
	            else {
	                needRef = builder.availableBits - 2 /* At least two bits for ref flags */ < initCell.bits + message.body.bits.length;
	            }
	            // Persist init
	            if (needRef) {
	                builder.storeBit(true);
	                builder.storeRef(initCell);
	            }
	            else {
	                builder.storeBit(false);
	                builder.storeBuilder(initCell);
	            }
	        }
	        else {
	            builder.storeBit(false);
	        }
	        // Store body
	        let needRef = false;
	        if (opts && opts.forceRef) {
	            needRef = true;
	        }
	        else {
	            needRef = builder.availableBits - 1 /* At least one bit for ref flag */ < message.body.bits.length ||
	                builder.refs + message.body.refs.length > 4;
	        }
	        if (needRef) {
	            builder.storeBit(true);
	            builder.storeRef(message.body);
	        }
	        else {
	            builder.storeBit(false);
	            builder.storeBuilder(message.body.asBuilder());
	        }
	    };
	}
	Message.storeMessage = storeMessage;
	Message.MessageValue = {
	    serialize(src, builder) {
	        builder.storeRef((0, Builder_1.beginCell)()
	            .store(storeMessage(src)));
	    },
	    parse(slice) {
	        return loadMessage(slice.loadRef().beginParse());
	    }
	};
	return Message;
}

var SendMode = {};

var hasRequiredSendMode;

function requireSendMode () {
	if (hasRequiredSendMode) return SendMode;
	hasRequiredSendMode = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(SendMode, "__esModule", { value: true });
	SendMode.SendMode = void 0;
	var SendMode$1;
	(function (SendMode) {
	    SendMode[SendMode["CARRY_ALL_REMAINING_BALANCE"] = 128] = "CARRY_ALL_REMAINING_BALANCE";
	    SendMode[SendMode["CARRY_ALL_REMAINING_INCOMING_VALUE"] = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE";
	    SendMode[SendMode["DESTROY_ACCOUNT_IF_ZERO"] = 32] = "DESTROY_ACCOUNT_IF_ZERO";
	    SendMode[SendMode["PAY_GAS_SEPARATELY"] = 1] = "PAY_GAS_SEPARATELY";
	    SendMode[SendMode["IGNORE_ERRORS"] = 2] = "IGNORE_ERRORS";
	    SendMode[SendMode["NONE"] = 0] = "NONE";
	})(SendMode$1 || (SendMode.SendMode = SendMode$1 = {}));
	return SendMode;
}

var ReserveMode = {};

var hasRequiredReserveMode;

function requireReserveMode () {
	if (hasRequiredReserveMode) return ReserveMode;
	hasRequiredReserveMode = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(ReserveMode, "__esModule", { value: true });
	ReserveMode.ReserveMode = void 0;
	var ReserveMode$1;
	(function (ReserveMode) {
	    ReserveMode[ReserveMode["THIS_AMOUNT"] = 0] = "THIS_AMOUNT";
	    ReserveMode[ReserveMode["LEAVE_THIS_AMOUNT"] = 1] = "LEAVE_THIS_AMOUNT";
	    ReserveMode[ReserveMode["AT_MOST_THIS_AMOUNT"] = 2] = "AT_MOST_THIS_AMOUNT";
	    ReserveMode[ReserveMode["LEAVE_MAX_THIS_AMOUNT"] = 3] = "LEAVE_MAX_THIS_AMOUNT";
	    ReserveMode[ReserveMode["BEFORE_BALANCE_PLUS_THIS_AMOUNT"] = 4] = "BEFORE_BALANCE_PLUS_THIS_AMOUNT";
	    ReserveMode[ReserveMode["LEAVE_BBALANCE_PLUS_THIS_AMOUNT"] = 5] = "LEAVE_BBALANCE_PLUS_THIS_AMOUNT";
	    ReserveMode[ReserveMode["BEFORE_BALANCE_MINUS_THIS_AMOUNT"] = 12] = "BEFORE_BALANCE_MINUS_THIS_AMOUNT";
	    ReserveMode[ReserveMode["LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT"] = 13] = "LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT";
	})(ReserveMode$1 || (ReserveMode.ReserveMode = ReserveMode$1 = {}));
	return ReserveMode;
}

var ShardAccount = {};

var hasRequiredShardAccount;

function requireShardAccount () {
	if (hasRequiredShardAccount) return ShardAccount;
	hasRequiredShardAccount = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(ShardAccount, "__esModule", { value: true });
	ShardAccount.storeShardAccount = ShardAccount.loadShardAccount = void 0;
	const Builder_1 = requireBuilder$1();
	const Account_1 = requireAccount();
	function loadShardAccount(slice) {
	    let accountRef = slice.loadRef();
	    let account = undefined;
	    if (!accountRef.isExotic) {
	        let accountSlice = accountRef.beginParse();
	        if (accountSlice.loadBit()) {
	            account = (0, Account_1.loadAccount)(accountSlice);
	        }
	    }
	    return {
	        account,
	        lastTransactionHash: slice.loadUintBig(256),
	        lastTransactionLt: slice.loadUintBig(64)
	    };
	}
	ShardAccount.loadShardAccount = loadShardAccount;
	function storeShardAccount(src) {
	    return (builder) => {
	        if (src.account) {
	            builder.storeRef((0, Builder_1.beginCell)()
	                .storeBit(true)
	                .store((0, Account_1.storeAccount)(src.account)));
	        }
	        else {
	            builder.storeRef((0, Builder_1.beginCell)()
	                .storeBit(false));
	        }
	        builder.storeUint(src.lastTransactionHash, 256);
	        builder.storeUint(src.lastTransactionLt, 64);
	    };
	}
	ShardAccount.storeShardAccount = storeShardAccount;
	return ShardAccount;
}

var ShardAccounts = {};

var hasRequiredShardAccounts;

function requireShardAccounts () {
	if (hasRequiredShardAccounts) return ShardAccounts;
	hasRequiredShardAccounts = 1;
	(function (exports) {
		/**
		 * Copyright (c) Whales Corp.
		 * All Rights Reserved.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = void 0;
		const Dictionary_1 = requireDictionary();
		const DepthBalanceInfo_1 = requireDepthBalanceInfo();
		const ShardAccount_1 = requireShardAccount();
		exports.ShardAccountRefValue = {
		    parse: (cs) => {
		        let depthBalanceInfo = (0, DepthBalanceInfo_1.loadDepthBalanceInfo)(cs);
		        let shardAccount = (0, ShardAccount_1.loadShardAccount)(cs);
		        return {
		            depthBalanceInfo,
		            shardAccount
		        };
		    },
		    serialize(src, builder) {
		        builder.store((0, DepthBalanceInfo_1.storeDepthBalanceInfo)(src.depthBalanceInfo));
		        builder.store((0, ShardAccount_1.storeShardAccount)(src.shardAccount));
		    },
		};
		function loadShardAccounts(cs) {
		    return Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.BigUint(256), exports.ShardAccountRefValue, cs);
		}
		exports.loadShardAccounts = loadShardAccounts;
		function storeShardAccounts(src) {
		    return (Builder) => {
		        Builder.storeDict(src);
		    };
		}
		exports.storeShardAccounts = storeShardAccounts; 
	} (ShardAccounts));
	return ShardAccounts;
}

var ShardIdent = {};

var hasRequiredShardIdent;

function requireShardIdent () {
	if (hasRequiredShardIdent) return ShardIdent;
	hasRequiredShardIdent = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(ShardIdent, "__esModule", { value: true });
	ShardIdent.storeShardIdent = ShardIdent.loadShardIdent = void 0;
	function loadShardIdent(slice) {
	    if (slice.loadUint(2) !== 0) {
	        throw Error('Invalid data');
	    }
	    return {
	        shardPrefixBits: slice.loadUint(6),
	        workchainId: slice.loadInt(32),
	        shardPrefix: slice.loadUintBig(64)
	    };
	}
	ShardIdent.loadShardIdent = loadShardIdent;
	function storeShardIdent(src) {
	    return (builder) => {
	        builder.storeUint(0, 2);
	        builder.storeUint(src.shardPrefixBits, 6);
	        builder.storeInt(src.workchainId, 32);
	        builder.storeUint(src.shardPrefix, 64);
	    };
	}
	ShardIdent.storeShardIdent = storeShardIdent;
	return ShardIdent;
}

var ShardStateUnsplit = {};

var hasRequiredShardStateUnsplit;

function requireShardStateUnsplit () {
	if (hasRequiredShardStateUnsplit) return ShardStateUnsplit;
	hasRequiredShardStateUnsplit = 1;
	Object.defineProperty(ShardStateUnsplit, "__esModule", { value: true });
	ShardStateUnsplit.loadShardStateUnsplit = void 0;
	const MasterchainStateExtra_1 = requireMasterchainStateExtra();
	const ShardAccounts_1 = requireShardAccounts();
	const ShardIdent_1 = requireShardIdent();
	function loadShardStateUnsplit(cs) {
	  if (cs.loadUint(32) !== 2418257890) {
	    throw Error("Invalid data");
	  }
	  let globalId = cs.loadInt(32);
	  let shardId = (0, ShardIdent_1.loadShardIdent)(cs);
	  let seqno = cs.loadUint(32);
	  let vertSeqNo = cs.loadUint(32);
	  let genUtime = cs.loadUint(32);
	  let genLt = cs.loadUintBig(64);
	  let minRefMcSeqno = cs.loadUint(32);
	  cs.loadRef();
	  let beforeSplit = cs.loadBit();
	  let shardAccountsRef = cs.loadRef();
	  let accounts = void 0;
	  if (!shardAccountsRef.isExotic) {
	    accounts = (0, ShardAccounts_1.loadShardAccounts)(shardAccountsRef.beginParse());
	  }
	  cs.loadRef();
	  let mcStateExtra = cs.loadBit();
	  let extras = null;
	  if (mcStateExtra) {
	    let cell = cs.loadRef();
	    if (!cell.isExotic) {
	      extras = (0, MasterchainStateExtra_1.loadMasterchainStateExtra)(cell.beginParse());
	    }
	  }
	  return {
	    globalId,
	    shardId,
	    seqno,
	    vertSeqNo,
	    genUtime,
	    genLt,
	    minRefMcSeqno,
	    beforeSplit,
	    accounts,
	    extras
	  };
	}
	ShardStateUnsplit.loadShardStateUnsplit = loadShardStateUnsplit;
	return ShardStateUnsplit;
}

var SplitMergeInfo = {};

var hasRequiredSplitMergeInfo;

function requireSplitMergeInfo () {
	if (hasRequiredSplitMergeInfo) return SplitMergeInfo;
	hasRequiredSplitMergeInfo = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(SplitMergeInfo, "__esModule", { value: true });
	SplitMergeInfo.storeSplitMergeInfo = SplitMergeInfo.loadSplitMergeInfo = void 0;
	function loadSplitMergeInfo(slice) {
	    let currentShardPrefixLength = slice.loadUint(6);
	    let accountSplitDepth = slice.loadUint(6);
	    let thisAddress = slice.loadUintBig(256);
	    let siblingAddress = slice.loadUintBig(256);
	    return {
	        currentShardPrefixLength,
	        accountSplitDepth,
	        thisAddress,
	        siblingAddress
	    };
	}
	SplitMergeInfo.loadSplitMergeInfo = loadSplitMergeInfo;
	function storeSplitMergeInfo(src) {
	    return (builder) => {
	        builder.storeUint(src.currentShardPrefixLength, 6);
	        builder.storeUint(src.accountSplitDepth, 6);
	        builder.storeUint(src.thisAddress, 256);
	        builder.storeUint(src.siblingAddress, 256);
	    };
	}
	SplitMergeInfo.storeSplitMergeInfo = storeSplitMergeInfo;
	return SplitMergeInfo;
}

var Transaction = {};

var TransactionDescription = {};

var TransactionActionPhase = {};

var hasRequiredTransactionActionPhase;

function requireTransactionActionPhase () {
	if (hasRequiredTransactionActionPhase) return TransactionActionPhase;
	hasRequiredTransactionActionPhase = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(TransactionActionPhase, "__esModule", { value: true });
	TransactionActionPhase.storeTransactionActionPhase = TransactionActionPhase.loadTransactionActionPhase = void 0;
	const AccountStatusChange_1 = requireAccountStatusChange();
	const StorageUsed_1 = requireStorageUsed();
	function loadTransactionActionPhase(slice) {
	    let success = slice.loadBit();
	    let valid = slice.loadBit();
	    let noFunds = slice.loadBit();
	    let statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
	    let totalFwdFees = slice.loadBit() ? slice.loadCoins() : undefined;
	    let totalActionFees = slice.loadBit() ? slice.loadCoins() : undefined;
	    let resultCode = slice.loadInt(32);
	    let resultArg = slice.loadBit() ? slice.loadInt(32) : undefined;
	    let totalActions = slice.loadUint(16);
	    let specActions = slice.loadUint(16);
	    let skippedActions = slice.loadUint(16);
	    let messagesCreated = slice.loadUint(16);
	    let actionListHash = slice.loadUintBig(256);
	    let totalMessageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
	    return {
	        success,
	        valid,
	        noFunds,
	        statusChange,
	        totalFwdFees,
	        totalActionFees,
	        resultCode,
	        resultArg,
	        totalActions,
	        specActions,
	        skippedActions,
	        messagesCreated,
	        actionListHash,
	        totalMessageSize
	    };
	}
	TransactionActionPhase.loadTransactionActionPhase = loadTransactionActionPhase;
	function storeTransactionActionPhase(src) {
	    return (builder) => {
	        builder.storeBit(src.success);
	        builder.storeBit(src.valid);
	        builder.storeBit(src.noFunds);
	        builder.store((0, AccountStatusChange_1.storeAccountStatusChange)(src.statusChange));
	        builder.storeMaybeCoins(src.totalFwdFees);
	        builder.storeMaybeCoins(src.totalActionFees);
	        builder.storeInt(src.resultCode, 32);
	        builder.storeMaybeInt(src.resultArg, 32);
	        builder.storeUint(src.totalActions, 16);
	        builder.storeUint(src.specActions, 16);
	        builder.storeUint(src.skippedActions, 16);
	        builder.storeUint(src.messagesCreated, 16);
	        builder.storeUint(src.actionListHash, 256);
	        builder.store((0, StorageUsed_1.storeStorageUsed)(src.totalMessageSize));
	    };
	}
	TransactionActionPhase.storeTransactionActionPhase = storeTransactionActionPhase;
	return TransactionActionPhase;
}

var TransactionBouncePhase = {};

var hasRequiredTransactionBouncePhase;

function requireTransactionBouncePhase () {
	if (hasRequiredTransactionBouncePhase) return TransactionBouncePhase;
	hasRequiredTransactionBouncePhase = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(TransactionBouncePhase, "__esModule", { value: true });
	TransactionBouncePhase.storeTransactionBouncePhase = TransactionBouncePhase.loadTransactionBouncePhase = void 0;
	const StorageUsed_1 = requireStorageUsed();
	function loadTransactionBouncePhase(slice) {
	    // Ok
	    if (slice.loadBit()) {
	        let messageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
	        let messageFees = slice.loadCoins();
	        let forwardFees = slice.loadCoins();
	        return {
	            type: "ok",
	            messageSize,
	            messageFees,
	            forwardFees,
	        };
	    }
	    // No funds
	    if (slice.loadBit()) {
	        let messageSize = (0, StorageUsed_1.loadStorageUsed)(slice);
	        let requiredForwardFees = slice.loadCoins();
	        return {
	            type: "no-funds",
	            messageSize,
	            requiredForwardFees,
	        };
	    }
	    // Negative funds
	    return {
	        type: "negative-funds",
	    };
	}
	TransactionBouncePhase.loadTransactionBouncePhase = loadTransactionBouncePhase;
	function storeTransactionBouncePhase(src) {
	    return (builder) => {
	        if (src.type === 'ok') {
	            builder.storeBit(true);
	            builder.store((0, StorageUsed_1.storeStorageUsed)(src.messageSize));
	            builder.storeCoins(src.messageFees);
	            builder.storeCoins(src.forwardFees);
	        }
	        else if (src.type === 'negative-funds') {
	            builder.storeBit(false);
	            builder.storeBit(false);
	        }
	        else if (src.type === 'no-funds') {
	            builder.storeBit(false);
	            builder.storeBit(true);
	            builder.store((0, StorageUsed_1.storeStorageUsed)(src.messageSize));
	            builder.storeCoins(src.requiredForwardFees);
	        }
	        else {
	            throw new Error("Invalid TransactionBouncePhase type");
	        }
	    };
	}
	TransactionBouncePhase.storeTransactionBouncePhase = storeTransactionBouncePhase;
	return TransactionBouncePhase;
}

var TransactionComputePhase = {};

var hasRequiredTransactionComputePhase;

function requireTransactionComputePhase () {
	if (hasRequiredTransactionComputePhase) return TransactionComputePhase;
	hasRequiredTransactionComputePhase = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(TransactionComputePhase, "__esModule", { value: true });
	TransactionComputePhase.storeTransactionComputePhase = TransactionComputePhase.loadTransactionComputePhase = void 0;
	const Builder_1 = requireBuilder$1();
	const ComputeSkipReason_1 = requireComputeSkipReason();
	function loadTransactionComputePhase(slice) {
	    // Skipped
	    if (!slice.loadBit()) {
	        let reason = (0, ComputeSkipReason_1.loadComputeSkipReason)(slice);
	        return {
	            type: 'skipped',
	            reason
	        };
	    }
	    let success = slice.loadBit();
	    let messageStateUsed = slice.loadBit();
	    let accountActivated = slice.loadBit();
	    let gasFees = slice.loadCoins();
	    const vmState = slice.loadRef().beginParse();
	    let gasUsed = vmState.loadVarUintBig(3);
	    let gasLimit = vmState.loadVarUintBig(3);
	    let gasCredit = vmState.loadBit() ? vmState.loadVarUintBig(2) : undefined;
	    let mode = vmState.loadUint(8);
	    let exitCode = vmState.loadInt(32);
	    let exitArg = vmState.loadBit() ? vmState.loadInt(32) : undefined;
	    let vmSteps = vmState.loadUint(32);
	    let vmInitStateHash = vmState.loadUintBig(256);
	    let vmFinalStateHash = vmState.loadUintBig(256);
	    return {
	        type: 'vm',
	        success,
	        messageStateUsed,
	        accountActivated,
	        gasFees,
	        gasUsed,
	        gasLimit,
	        gasCredit,
	        mode,
	        exitCode,
	        exitArg,
	        vmSteps,
	        vmInitStateHash,
	        vmFinalStateHash
	    };
	}
	TransactionComputePhase.loadTransactionComputePhase = loadTransactionComputePhase;
	function storeTransactionComputePhase(src) {
	    return (builder) => {
	        if (src.type === 'skipped') {
	            builder.storeBit(0);
	            builder.store((0, ComputeSkipReason_1.storeComputeSkipReason)(src.reason));
	            return;
	        }
	        builder.storeBit(1);
	        builder.storeBit(src.success);
	        builder.storeBit(src.messageStateUsed);
	        builder.storeBit(src.accountActivated);
	        builder.storeCoins(src.gasFees);
	        builder.storeRef((0, Builder_1.beginCell)()
	            .storeVarUint(src.gasUsed, 3)
	            .storeVarUint(src.gasLimit, 3)
	            .store((b) => (src.gasCredit !== undefined && src.gasCredit !== null) ? b.storeBit(1).storeVarUint(src.gasCredit, 2) : b.storeBit(0))
	            .storeUint(src.mode, 8)
	            .storeInt(src.exitCode, 32)
	            .store((b) => (src.exitArg !== undefined && src.exitArg !== null) ? b.storeBit(1).storeInt(src.exitArg, 32) : b.storeBit(0))
	            .storeUint(src.vmSteps, 32)
	            .storeUint(src.vmInitStateHash, 256)
	            .storeUint(src.vmFinalStateHash, 256)
	            .endCell());
	    };
	}
	TransactionComputePhase.storeTransactionComputePhase = storeTransactionComputePhase;
	return TransactionComputePhase;
}

var TransactionCreditPhase = {};

var hasRequiredTransactionCreditPhase;

function requireTransactionCreditPhase () {
	if (hasRequiredTransactionCreditPhase) return TransactionCreditPhase;
	hasRequiredTransactionCreditPhase = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(TransactionCreditPhase, "__esModule", { value: true });
	TransactionCreditPhase.storeTransactionCreditPhase = TransactionCreditPhase.loadTransactionCreditPhase = void 0;
	const CurrencyCollection_1 = requireCurrencyCollection();
	function loadTransactionCreditPhase(slice) {
	    const dueFeesColelcted = slice.loadBit() ? slice.loadCoins() : undefined;
	    const credit = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
	    return {
	        dueFeesColelcted,
	        credit
	    };
	}
	TransactionCreditPhase.loadTransactionCreditPhase = loadTransactionCreditPhase;
	function storeTransactionCreditPhase(src) {
	    return (builder) => {
	        if (src.dueFeesColelcted === null || src.dueFeesColelcted === undefined) {
	            builder.storeBit(false);
	        }
	        else {
	            builder.storeBit(true);
	            builder.storeCoins(src.dueFeesColelcted);
	        }
	        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.credit));
	    };
	}
	TransactionCreditPhase.storeTransactionCreditPhase = storeTransactionCreditPhase;
	return TransactionCreditPhase;
}

var TransactionStoragePhase = {};

var hasRequiredTransactionStoragePhase;

function requireTransactionStoragePhase () {
	if (hasRequiredTransactionStoragePhase) return TransactionStoragePhase;
	hasRequiredTransactionStoragePhase = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(TransactionStoragePhase, "__esModule", { value: true });
	TransactionStoragePhase.storeTransactionsStoragePhase = TransactionStoragePhase.loadTransactionStoragePhase = void 0;
	const AccountStatusChange_1 = requireAccountStatusChange();
	function loadTransactionStoragePhase(slice) {
	    const storageFeesCollected = slice.loadCoins();
	    let storageFeesDue = undefined;
	    if (slice.loadBit()) {
	        storageFeesDue = slice.loadCoins();
	    }
	    const statusChange = (0, AccountStatusChange_1.loadAccountStatusChange)(slice);
	    return {
	        storageFeesCollected,
	        storageFeesDue,
	        statusChange
	    };
	}
	TransactionStoragePhase.loadTransactionStoragePhase = loadTransactionStoragePhase;
	function storeTransactionsStoragePhase(src) {
	    return (builder) => {
	        builder.storeCoins(src.storageFeesCollected);
	        if (src.storageFeesDue === null || src.storageFeesDue === undefined) {
	            builder.storeBit(false);
	        }
	        else {
	            builder.storeBit(true);
	            builder.storeCoins(src.storageFeesDue);
	        }
	        builder.store((0, AccountStatusChange_1.storeAccountStatusChange)(src.statusChange));
	    };
	}
	TransactionStoragePhase.storeTransactionsStoragePhase = storeTransactionsStoragePhase;
	return TransactionStoragePhase;
}

var hasRequiredTransactionDescription;

function requireTransactionDescription () {
	if (hasRequiredTransactionDescription) return TransactionDescription;
	hasRequiredTransactionDescription = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(TransactionDescription, "__esModule", { value: true });
	TransactionDescription.storeTransactionDescription = TransactionDescription.loadTransactionDescription = void 0;
	const Builder_1 = requireBuilder$1();
	const SplitMergeInfo_1 = requireSplitMergeInfo();
	const Transaction_1 = requireTransaction();
	const TransactionActionPhase_1 = requireTransactionActionPhase();
	const TransactionBouncePhase_1 = requireTransactionBouncePhase();
	const TransactionComputePhase_1 = requireTransactionComputePhase();
	const TransactionCreditPhase_1 = requireTransactionCreditPhase();
	const TransactionStoragePhase_1 = requireTransactionStoragePhase();
	function loadTransactionDescription(slice) {
	    let type = slice.loadUint(4);
	    if (type === 0x00) {
	        const creditFirst = slice.loadBit();
	        let storagePhase = undefined;
	        if (slice.loadBit()) {
	            storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
	        }
	        let creditPhase = undefined;
	        if (slice.loadBit()) {
	            creditPhase = (0, TransactionCreditPhase_1.loadTransactionCreditPhase)(slice);
	        }
	        let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
	        let actionPhase = undefined;
	        if (slice.loadBit()) {
	            actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
	        }
	        let aborted = slice.loadBit();
	        let bouncePhase = undefined;
	        if (slice.loadBit()) {
	            bouncePhase = (0, TransactionBouncePhase_1.loadTransactionBouncePhase)(slice);
	        }
	        const destroyed = slice.loadBit();
	        return {
	            type: 'generic',
	            creditFirst,
	            storagePhase,
	            creditPhase,
	            computePhase,
	            actionPhase,
	            bouncePhase,
	            aborted,
	            destroyed
	        };
	    }
	    if (type === 0x01) {
	        return {
	            type: 'storage',
	            storagePhase: (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice)
	        };
	    }
	    if (type === 0x2 || type === 0x03) {
	        const isTock = type === 0x03;
	        let storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
	        let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
	        let actionPhase = undefined;
	        if (slice.loadBit()) {
	            actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
	        }
	        const aborted = slice.loadBit();
	        const destroyed = slice.loadBit();
	        return {
	            type: 'tick-tock',
	            isTock,
	            storagePhase,
	            computePhase,
	            actionPhase,
	            aborted,
	            destroyed
	        };
	    }
	    if (type === 0x04) {
	        let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
	        let storagePhase = undefined;
	        if (slice.loadBit()) {
	            storagePhase = (0, TransactionStoragePhase_1.loadTransactionStoragePhase)(slice);
	        }
	        let computePhase = (0, TransactionComputePhase_1.loadTransactionComputePhase)(slice);
	        let actionPhase = undefined;
	        if (slice.loadBit()) {
	            actionPhase = (0, TransactionActionPhase_1.loadTransactionActionPhase)(slice.loadRef().beginParse());
	        }
	        const aborted = slice.loadBit();
	        const destroyed = slice.loadBit();
	        return {
	            type: 'split-prepare',
	            splitInfo,
	            storagePhase,
	            computePhase,
	            actionPhase,
	            aborted,
	            destroyed
	        };
	    }
	    if (type === 0x05) {
	        let splitInfo = (0, SplitMergeInfo_1.loadSplitMergeInfo)(slice);
	        let prepareTransaction = (0, Transaction_1.loadTransaction)(slice.loadRef().beginParse());
	        const installed = slice.loadBit();
	        return {
	            type: 'split-install',
	            splitInfo,
	            prepareTransaction,
	            installed
	        };
	    }
	    throw Error(`Unsupported transaction description type ${type}`);
	}
	TransactionDescription.loadTransactionDescription = loadTransactionDescription;
	function storeTransactionDescription(src) {
	    return (builder) => {
	        if (src.type === 'generic') {
	            builder.storeUint(0x00, 4);
	            builder.storeBit(src.creditFirst);
	            if (src.storagePhase) {
	                builder.storeBit(true);
	                builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
	            }
	            else {
	                builder.storeBit(false);
	            }
	            if (src.creditPhase) {
	                builder.storeBit(true);
	                builder.store((0, TransactionCreditPhase_1.storeTransactionCreditPhase)(src.creditPhase));
	            }
	            else {
	                builder.storeBit(false);
	            }
	            builder.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
	            if (src.actionPhase) {
	                builder.storeBit(true);
	                builder.storeRef((0, Builder_1.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase)));
	            }
	            else {
	                builder.storeBit(false);
	            }
	            builder.storeBit(src.aborted);
	            if (src.bouncePhase) {
	                builder.storeBit(true);
	                builder.store((0, TransactionBouncePhase_1.storeTransactionBouncePhase)(src.bouncePhase));
	            }
	            else {
	                builder.storeBit(false);
	            }
	            builder.storeBit(src.destroyed);
	        }
	        else if (src.type === 'storage') {
	            builder.storeUint(0x01, 4);
	            builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
	        }
	        else if (src.type === 'tick-tock') {
	            builder.storeUint(src.isTock ? 0x03 : 0x02, 4);
	            builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
	            builder.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
	            if (src.actionPhase) {
	                builder.storeBit(true);
	                builder.storeRef((0, Builder_1.beginCell)().store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase)));
	            }
	            else {
	                builder.storeBit(false);
	            }
	            builder.storeBit(src.aborted);
	            builder.storeBit(src.destroyed);
	        }
	        else if (src.type === 'split-prepare') {
	            builder.storeUint(0x04, 4);
	            builder.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src.splitInfo));
	            if (src.storagePhase) {
	                builder.storeBit(true);
	                builder.store((0, TransactionStoragePhase_1.storeTransactionsStoragePhase)(src.storagePhase));
	            }
	            else {
	                builder.storeBit(false);
	            }
	            builder.store((0, TransactionComputePhase_1.storeTransactionComputePhase)(src.computePhase));
	            if (src.actionPhase) {
	                builder.storeBit(true);
	                builder.store((0, TransactionActionPhase_1.storeTransactionActionPhase)(src.actionPhase));
	            }
	            else {
	                builder.storeBit(false);
	            }
	            builder.storeBit(src.aborted);
	            builder.storeBit(src.destroyed);
	        }
	        else if (src.type === 'split-install') {
	            builder.storeUint(0x05, 4);
	            builder.store((0, SplitMergeInfo_1.storeSplitMergeInfo)(src.splitInfo));
	            builder.storeRef((0, Builder_1.beginCell)().store((0, Transaction_1.storeTransaction)(src.prepareTransaction)));
	            builder.storeBit(src.installed);
	        }
	        else {
	            throw Error(`Unsupported transaction description type ${src.type}`);
	        }
	    };
	}
	TransactionDescription.storeTransactionDescription = storeTransactionDescription;
	return TransactionDescription;
}

var hasRequiredTransaction;

function requireTransaction () {
	if (hasRequiredTransaction) return Transaction;
	hasRequiredTransaction = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(Transaction, "__esModule", { value: true });
	Transaction.storeTransaction = Transaction.loadTransaction = void 0;
	const Builder_1 = requireBuilder$1();
	const Dictionary_1 = requireDictionary();
	const AccountStatus_1 = requireAccountStatus();
	const CurrencyCollection_1 = requireCurrencyCollection();
	const HashUpdate_1 = requireHashUpdate();
	const Message_1 = requireMessage();
	const TransactionDescription_1 = requireTransactionDescription();
	function loadTransaction(slice) {
	    let raw = slice.asCell();
	    if (slice.loadUint(4) !== 0x07) {
	        throw Error('Invalid data');
	    }
	    let address = slice.loadUintBig(256);
	    let lt = slice.loadUintBig(64);
	    let prevTransactionHash = slice.loadUintBig(256);
	    let prevTransactionLt = slice.loadUintBig(64);
	    let now = slice.loadUint(32);
	    let outMessagesCount = slice.loadUint(15);
	    let oldStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
	    let endStatus = (0, AccountStatus_1.loadAccountStatus)(slice);
	    let msgRef = slice.loadRef();
	    let msgSlice = msgRef.beginParse();
	    let inMessage = msgSlice.loadBit() ? (0, Message_1.loadMessage)(msgSlice.loadRef().beginParse()) : undefined;
	    let outMessages = msgSlice.loadDict(Dictionary_1.Dictionary.Keys.Uint(15), Message_1.MessageValue);
	    msgSlice.endParse();
	    let totalFees = (0, CurrencyCollection_1.loadCurrencyCollection)(slice);
	    let stateUpdate = (0, HashUpdate_1.loadHashUpdate)(slice.loadRef().beginParse());
	    let description = (0, TransactionDescription_1.loadTransactionDescription)(slice.loadRef().beginParse());
	    return {
	        address,
	        lt,
	        prevTransactionHash,
	        prevTransactionLt,
	        now,
	        outMessagesCount,
	        oldStatus,
	        endStatus,
	        inMessage,
	        outMessages,
	        totalFees,
	        stateUpdate,
	        description,
	        raw,
	        hash: () => raw.hash(),
	    };
	}
	Transaction.loadTransaction = loadTransaction;
	function storeTransaction(src) {
	    return (builder) => {
	        builder.storeUint(0x07, 4);
	        builder.storeUint(src.address, 256);
	        builder.storeUint(src.lt, 64);
	        builder.storeUint(src.prevTransactionHash, 256);
	        builder.storeUint(src.prevTransactionLt, 64);
	        builder.storeUint(src.now, 32);
	        builder.storeUint(src.outMessagesCount, 15);
	        builder.store((0, AccountStatus_1.storeAccountStatus)(src.oldStatus));
	        builder.store((0, AccountStatus_1.storeAccountStatus)(src.endStatus));
	        let msgBuilder = (0, Builder_1.beginCell)();
	        if (src.inMessage) {
	            msgBuilder.storeBit(true);
	            msgBuilder.storeRef((0, Builder_1.beginCell)().store((0, Message_1.storeMessage)(src.inMessage)));
	        }
	        else {
	            msgBuilder.storeBit(false);
	        }
	        msgBuilder.storeDict(src.outMessages);
	        builder.storeRef(msgBuilder);
	        builder.store((0, CurrencyCollection_1.storeCurrencyCollection)(src.totalFees));
	        builder.storeRef((0, Builder_1.beginCell)().store((0, HashUpdate_1.storeHashUpdate)(src.stateUpdate)));
	        builder.storeRef((0, Builder_1.beginCell)().store((0, TransactionDescription_1.storeTransactionDescription)(src.description)));
	    };
	}
	Transaction.storeTransaction = storeTransaction;
	return Transaction;
}

var hasRequired_export;

function require_export () {
	if (hasRequired_export) return _export;
	hasRequired_export = 1;
	(function (exports) {
		/**
		 * Copyright (c) Whales Corp.
		 * All Rights Reserved.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.loadSimpleLibrary = exports.loadShardStateUnsplit = exports.storeShardIdent = exports.loadShardIdent = exports.storeShardAccounts = exports.loadShardAccounts = exports.ShardAccountRefValue = exports.storeShardAccount = exports.loadShardAccount = exports.ReserveMode = exports.SendMode = exports.storeMessageRelaxed = exports.loadMessageRelaxed = exports.storeMessage = exports.loadMessage = exports.loadMasterchainStateExtra = exports.storeHashUpdate = exports.loadHashUpdate = exports.storeExtraCurrency = exports.loadMaybeExtraCurrency = exports.loadExtraCurrency = exports.packExtraCurrencyDict = exports.packExtraCurrencyCell = exports.storeDepthBalanceInfo = exports.loadDepthBalanceInfo = exports.storeCurrencyCollection = exports.loadCurrencyCollection = exports.storeComputeSkipReason = exports.loadComputeSkipReason = exports.storeCommonMessageInfoRelaxed = exports.loadCommonMessageInfoRelaxed = exports.storeCommonMessageInfo = exports.loadCommonMessageInfo = exports.storeOutList = exports.loadOutList = exports.storeOutAction = exports.loadOutAction = exports.storeAccountStorage = exports.loadAccountStorage = exports.storeAccountStatusChange = exports.loadAccountStatusChange = exports.storeAccountStatus = exports.loadAccountStatus = exports.storeAccountState = exports.loadAccountState = exports.storeAccount = exports.loadAccount = exports.comment = exports.external = exports.internal = void 0;
		exports.storeTransactionsStoragePhase = exports.loadTransactionStoragePhase = exports.storeTransactionDescription = exports.loadTransactionDescription = exports.storeTransactionCreditPhase = exports.loadTransactionCreditPhase = exports.storeTransactionComputePhase = exports.loadTransactionComputePhase = exports.storeTransactionBouncePhase = exports.loadTransactionBouncePhase = exports.storeTransactionActionPhase = exports.loadTransactionActionPhase = exports.storeTransaction = exports.loadTransaction = exports.storeTickTock = exports.loadTickTock = exports.storeStorageUsed = exports.loadStorageUsed = exports.storeStorageInfo = exports.loadStorageInfo = exports.storeStateInit = exports.loadStateInit = exports.storeSplitMergeInfo = exports.loadSplitMergeInfo = exports.storeLibRef = exports.loadLibRef = exports.storeSimpleLibrary = void 0;
		var _helpers_1 = require_helpers();
		Object.defineProperty(exports, "internal", { enumerable: true, get: function () { return _helpers_1.internal; } });
		Object.defineProperty(exports, "external", { enumerable: true, get: function () { return _helpers_1.external; } });
		Object.defineProperty(exports, "comment", { enumerable: true, get: function () { return _helpers_1.comment; } });
		var Account_1 = requireAccount();
		Object.defineProperty(exports, "loadAccount", { enumerable: true, get: function () { return Account_1.loadAccount; } });
		Object.defineProperty(exports, "storeAccount", { enumerable: true, get: function () { return Account_1.storeAccount; } });
		var AccountState_1 = requireAccountState();
		Object.defineProperty(exports, "loadAccountState", { enumerable: true, get: function () { return AccountState_1.loadAccountState; } });
		Object.defineProperty(exports, "storeAccountState", { enumerable: true, get: function () { return AccountState_1.storeAccountState; } });
		var AccountStatus_1 = requireAccountStatus();
		Object.defineProperty(exports, "loadAccountStatus", { enumerable: true, get: function () { return AccountStatus_1.loadAccountStatus; } });
		Object.defineProperty(exports, "storeAccountStatus", { enumerable: true, get: function () { return AccountStatus_1.storeAccountStatus; } });
		var AccountStatusChange_1 = requireAccountStatusChange();
		Object.defineProperty(exports, "loadAccountStatusChange", { enumerable: true, get: function () { return AccountStatusChange_1.loadAccountStatusChange; } });
		Object.defineProperty(exports, "storeAccountStatusChange", { enumerable: true, get: function () { return AccountStatusChange_1.storeAccountStatusChange; } });
		var AccountStorage_1 = requireAccountStorage();
		Object.defineProperty(exports, "loadAccountStorage", { enumerable: true, get: function () { return AccountStorage_1.loadAccountStorage; } });
		Object.defineProperty(exports, "storeAccountStorage", { enumerable: true, get: function () { return AccountStorage_1.storeAccountStorage; } });
		var OutList_1 = requireOutList();
		Object.defineProperty(exports, "loadOutAction", { enumerable: true, get: function () { return OutList_1.loadOutAction; } });
		Object.defineProperty(exports, "storeOutAction", { enumerable: true, get: function () { return OutList_1.storeOutAction; } });
		Object.defineProperty(exports, "loadOutList", { enumerable: true, get: function () { return OutList_1.loadOutList; } });
		Object.defineProperty(exports, "storeOutList", { enumerable: true, get: function () { return OutList_1.storeOutList; } });
		var CommonMessageInfo_1 = requireCommonMessageInfo();
		Object.defineProperty(exports, "loadCommonMessageInfo", { enumerable: true, get: function () { return CommonMessageInfo_1.loadCommonMessageInfo; } });
		Object.defineProperty(exports, "storeCommonMessageInfo", { enumerable: true, get: function () { return CommonMessageInfo_1.storeCommonMessageInfo; } });
		var CommonMessageInfoRelaxed_1 = requireCommonMessageInfoRelaxed();
		Object.defineProperty(exports, "loadCommonMessageInfoRelaxed", { enumerable: true, get: function () { return CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed; } });
		Object.defineProperty(exports, "storeCommonMessageInfoRelaxed", { enumerable: true, get: function () { return CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed; } });
		var ComputeSkipReason_1 = requireComputeSkipReason();
		Object.defineProperty(exports, "loadComputeSkipReason", { enumerable: true, get: function () { return ComputeSkipReason_1.loadComputeSkipReason; } });
		Object.defineProperty(exports, "storeComputeSkipReason", { enumerable: true, get: function () { return ComputeSkipReason_1.storeComputeSkipReason; } });
		var CurrencyCollection_1 = requireCurrencyCollection();
		Object.defineProperty(exports, "loadCurrencyCollection", { enumerable: true, get: function () { return CurrencyCollection_1.loadCurrencyCollection; } });
		Object.defineProperty(exports, "storeCurrencyCollection", { enumerable: true, get: function () { return CurrencyCollection_1.storeCurrencyCollection; } });
		var DepthBalanceInfo_1 = requireDepthBalanceInfo();
		Object.defineProperty(exports, "loadDepthBalanceInfo", { enumerable: true, get: function () { return DepthBalanceInfo_1.loadDepthBalanceInfo; } });
		Object.defineProperty(exports, "storeDepthBalanceInfo", { enumerable: true, get: function () { return DepthBalanceInfo_1.storeDepthBalanceInfo; } });
		var ExtraCurrency_1 = requireExtraCurrency();
		Object.defineProperty(exports, "packExtraCurrencyCell", { enumerable: true, get: function () { return ExtraCurrency_1.packExtraCurrencyCell; } });
		Object.defineProperty(exports, "packExtraCurrencyDict", { enumerable: true, get: function () { return ExtraCurrency_1.packExtraCurrencyDict; } });
		Object.defineProperty(exports, "loadExtraCurrency", { enumerable: true, get: function () { return ExtraCurrency_1.loadExtraCurrency; } });
		Object.defineProperty(exports, "loadMaybeExtraCurrency", { enumerable: true, get: function () { return ExtraCurrency_1.loadMaybeExtraCurrency; } });
		Object.defineProperty(exports, "storeExtraCurrency", { enumerable: true, get: function () { return ExtraCurrency_1.storeExtraCurrency; } });
		var HashUpdate_1 = requireHashUpdate();
		Object.defineProperty(exports, "loadHashUpdate", { enumerable: true, get: function () { return HashUpdate_1.loadHashUpdate; } });
		Object.defineProperty(exports, "storeHashUpdate", { enumerable: true, get: function () { return HashUpdate_1.storeHashUpdate; } });
		var MasterchainStateExtra_1 = requireMasterchainStateExtra();
		Object.defineProperty(exports, "loadMasterchainStateExtra", { enumerable: true, get: function () { return MasterchainStateExtra_1.loadMasterchainStateExtra; } });
		var Message_1 = requireMessage();
		Object.defineProperty(exports, "loadMessage", { enumerable: true, get: function () { return Message_1.loadMessage; } });
		Object.defineProperty(exports, "storeMessage", { enumerable: true, get: function () { return Message_1.storeMessage; } });
		var MessageRelaxed_1 = requireMessageRelaxed();
		Object.defineProperty(exports, "loadMessageRelaxed", { enumerable: true, get: function () { return MessageRelaxed_1.loadMessageRelaxed; } });
		Object.defineProperty(exports, "storeMessageRelaxed", { enumerable: true, get: function () { return MessageRelaxed_1.storeMessageRelaxed; } });
		var SendMode_1 = requireSendMode();
		Object.defineProperty(exports, "SendMode", { enumerable: true, get: function () { return SendMode_1.SendMode; } });
		var ReserveMode_1 = requireReserveMode();
		Object.defineProperty(exports, "ReserveMode", { enumerable: true, get: function () { return ReserveMode_1.ReserveMode; } });
		var ShardAccount_1 = requireShardAccount();
		Object.defineProperty(exports, "loadShardAccount", { enumerable: true, get: function () { return ShardAccount_1.loadShardAccount; } });
		Object.defineProperty(exports, "storeShardAccount", { enumerable: true, get: function () { return ShardAccount_1.storeShardAccount; } });
		var ShardAccounts_1 = requireShardAccounts();
		Object.defineProperty(exports, "ShardAccountRefValue", { enumerable: true, get: function () { return ShardAccounts_1.ShardAccountRefValue; } });
		Object.defineProperty(exports, "loadShardAccounts", { enumerable: true, get: function () { return ShardAccounts_1.loadShardAccounts; } });
		Object.defineProperty(exports, "storeShardAccounts", { enumerable: true, get: function () { return ShardAccounts_1.storeShardAccounts; } });
		var ShardIdent_1 = requireShardIdent();
		Object.defineProperty(exports, "loadShardIdent", { enumerable: true, get: function () { return ShardIdent_1.loadShardIdent; } });
		Object.defineProperty(exports, "storeShardIdent", { enumerable: true, get: function () { return ShardIdent_1.storeShardIdent; } });
		var ShardStateUnsplit_1 = requireShardStateUnsplit();
		Object.defineProperty(exports, "loadShardStateUnsplit", { enumerable: true, get: function () { return ShardStateUnsplit_1.loadShardStateUnsplit; } });
		var SimpleLibrary_1 = requireSimpleLibrary();
		Object.defineProperty(exports, "loadSimpleLibrary", { enumerable: true, get: function () { return SimpleLibrary_1.loadSimpleLibrary; } });
		Object.defineProperty(exports, "storeSimpleLibrary", { enumerable: true, get: function () { return SimpleLibrary_1.storeSimpleLibrary; } });
		var LibRef_1 = requireLibRef();
		Object.defineProperty(exports, "loadLibRef", { enumerable: true, get: function () { return LibRef_1.loadLibRef; } });
		Object.defineProperty(exports, "storeLibRef", { enumerable: true, get: function () { return LibRef_1.storeLibRef; } });
		var SplitMergeInfo_1 = requireSplitMergeInfo();
		Object.defineProperty(exports, "loadSplitMergeInfo", { enumerable: true, get: function () { return SplitMergeInfo_1.loadSplitMergeInfo; } });
		Object.defineProperty(exports, "storeSplitMergeInfo", { enumerable: true, get: function () { return SplitMergeInfo_1.storeSplitMergeInfo; } });
		var StateInit_1 = requireStateInit();
		Object.defineProperty(exports, "loadStateInit", { enumerable: true, get: function () { return StateInit_1.loadStateInit; } });
		Object.defineProperty(exports, "storeStateInit", { enumerable: true, get: function () { return StateInit_1.storeStateInit; } });
		var StorageInfo_1 = requireStorageInfo();
		Object.defineProperty(exports, "loadStorageInfo", { enumerable: true, get: function () { return StorageInfo_1.loadStorageInfo; } });
		Object.defineProperty(exports, "storeStorageInfo", { enumerable: true, get: function () { return StorageInfo_1.storeStorageInfo; } });
		var StorageUsed_1 = requireStorageUsed();
		Object.defineProperty(exports, "loadStorageUsed", { enumerable: true, get: function () { return StorageUsed_1.loadStorageUsed; } });
		Object.defineProperty(exports, "storeStorageUsed", { enumerable: true, get: function () { return StorageUsed_1.storeStorageUsed; } });
		var TickTock_1 = requireTickTock();
		Object.defineProperty(exports, "loadTickTock", { enumerable: true, get: function () { return TickTock_1.loadTickTock; } });
		Object.defineProperty(exports, "storeTickTock", { enumerable: true, get: function () { return TickTock_1.storeTickTock; } });
		var Transaction_1 = requireTransaction();
		Object.defineProperty(exports, "loadTransaction", { enumerable: true, get: function () { return Transaction_1.loadTransaction; } });
		Object.defineProperty(exports, "storeTransaction", { enumerable: true, get: function () { return Transaction_1.storeTransaction; } });
		var TransactionActionPhase_1 = requireTransactionActionPhase();
		Object.defineProperty(exports, "loadTransactionActionPhase", { enumerable: true, get: function () { return TransactionActionPhase_1.loadTransactionActionPhase; } });
		Object.defineProperty(exports, "storeTransactionActionPhase", { enumerable: true, get: function () { return TransactionActionPhase_1.storeTransactionActionPhase; } });
		var TransactionBouncePhase_1 = requireTransactionBouncePhase();
		Object.defineProperty(exports, "loadTransactionBouncePhase", { enumerable: true, get: function () { return TransactionBouncePhase_1.loadTransactionBouncePhase; } });
		Object.defineProperty(exports, "storeTransactionBouncePhase", { enumerable: true, get: function () { return TransactionBouncePhase_1.storeTransactionBouncePhase; } });
		var TransactionComputePhase_1 = requireTransactionComputePhase();
		Object.defineProperty(exports, "loadTransactionComputePhase", { enumerable: true, get: function () { return TransactionComputePhase_1.loadTransactionComputePhase; } });
		Object.defineProperty(exports, "storeTransactionComputePhase", { enumerable: true, get: function () { return TransactionComputePhase_1.storeTransactionComputePhase; } });
		var TransactionCreditPhase_1 = requireTransactionCreditPhase();
		Object.defineProperty(exports, "loadTransactionCreditPhase", { enumerable: true, get: function () { return TransactionCreditPhase_1.loadTransactionCreditPhase; } });
		Object.defineProperty(exports, "storeTransactionCreditPhase", { enumerable: true, get: function () { return TransactionCreditPhase_1.storeTransactionCreditPhase; } });
		var TransactionDescription_1 = requireTransactionDescription();
		Object.defineProperty(exports, "loadTransactionDescription", { enumerable: true, get: function () { return TransactionDescription_1.loadTransactionDescription; } });
		Object.defineProperty(exports, "storeTransactionDescription", { enumerable: true, get: function () { return TransactionDescription_1.storeTransactionDescription; } });
		var TransactionStoragePhase_1 = requireTransactionStoragePhase();
		Object.defineProperty(exports, "loadTransactionStoragePhase", { enumerable: true, get: function () { return TransactionStoragePhase_1.loadTransactionStoragePhase; } });
		Object.defineProperty(exports, "storeTransactionsStoragePhase", { enumerable: true, get: function () { return TransactionStoragePhase_1.storeTransactionsStoragePhase; } }); 
	} (_export));
	return _export;
}

var openContract = {};

var hasRequiredOpenContract;

function requireOpenContract () {
	if (hasRequiredOpenContract) return openContract;
	hasRequiredOpenContract = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(openContract, "__esModule", { value: true });
	openContract.openContract = void 0;
	const Address_1 = requireAddress();
	const Cell_1 = requireCell();
	function openContract$1(src, factory) {
	    // Resolve parameters
	    let address;
	    let init = null;
	    if (!Address_1.Address.isAddress(src.address)) {
	        throw Error('Invalid address');
	    }
	    address = src.address;
	    if (src.init) {
	        if (!(src.init.code instanceof Cell_1.Cell)) {
	            throw Error('Invalid init.code');
	        }
	        if (!(src.init.data instanceof Cell_1.Cell)) {
	            throw Error('Invalid init.data');
	        }
	        init = src.init;
	    }
	    // Create executor
	    let executor = factory({ address, init });
	    // Create proxy
	    return new Proxy(src, {
	        get(target, prop) {
	            const value = target[prop];
	            if (typeof prop === 'string' && (prop.startsWith('get') || prop.startsWith('send') || prop.startsWith('is'))) {
	                if (typeof value === 'function') {
	                    return (...args) => value.apply(target, [executor, ...args]);
	                }
	            }
	            return value;
	        }
	    });
	}
	openContract.openContract = openContract$1;
	return openContract;
}

var ComputeError = {};

var hasRequiredComputeError;

function requireComputeError () {
	if (hasRequiredComputeError) return ComputeError;
	hasRequiredComputeError = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(ComputeError, "__esModule", { value: true });
	ComputeError.ComputeError = void 0;
	let ComputeError$1 = class ComputeError extends Error {
	    constructor(message, exitCode, opts) {
	        super(message);
	        this.exitCode = exitCode;
	        this.debugLogs = opts && opts.debugLogs ? opts.debugLogs : null;
	        this.logs = opts && opts.logs ? opts.logs : null;
	        Object.setPrototypeOf(this, ComputeError.prototype);
	    }
	};
	ComputeError.ComputeError = ComputeError$1;
	return ComputeError;
}

var getMethodId = {};

var hasRequiredGetMethodId;

function requireGetMethodId () {
	if (hasRequiredGetMethodId) return getMethodId;
	hasRequiredGetMethodId = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(getMethodId, "__esModule", { value: true });
	getMethodId.getMethodId = void 0;
	const TABLE = new Int16Array([
	    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
	    0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
	    0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
	    0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
	    0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
	    0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
	    0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,
	    0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
	    0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
	    0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
	    0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,
	    0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
	    0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,
	    0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
	    0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
	    0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
	    0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,
	    0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
	    0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,
	    0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
	    0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
	    0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
	    0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
	    0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
	    0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
	    0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,
	    0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
	    0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,
	    0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,
	    0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
	    0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
	    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0
	]);
	function crc16(data) {
	    if (!(data instanceof Buffer)) {
	        data = Buffer.from(data);
	    }
	    let crc = 0;
	    for (let index = 0; index < data.length; index++) {
	        const byte = data[index];
	        crc = (TABLE[((crc >> 8) ^ byte) & 0xff] ^ (crc << 8)) & 0xffff;
	    }
	    return crc;
	}
	function getMethodId$1(name) {
	    return (crc16(name) & 0xffff) | 0x10000;
	}
	getMethodId.getMethodId = getMethodId$1;
	return getMethodId;
}

var safeSign = {};

var hasRequiredSafeSign;

function requireSafeSign () {
	if (hasRequiredSafeSign) return safeSign;
	hasRequiredSafeSign = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(safeSign, "__esModule", { value: true });
	safeSign.safeSignVerify = safeSign.safeSign = void 0;
	const crypto_1 = requireDist$3();
	const MIN_SEED_LENGTH = 8;
	const MAX_SEED_LENGTH = 64;
	function createSafeSignHash(cell, seed) {
	    let seedData = Buffer.from(seed);
	    if (seedData.length > MAX_SEED_LENGTH) {
	        throw Error('Seed can\t be longer than 64 bytes');
	    }
	    if (seedData.length < MIN_SEED_LENGTH) {
	        throw Error('Seed must be at least 8 bytes');
	    }
	    return (0, crypto_1.sha256_sync)(Buffer.concat([Buffer.from([0xff, 0xff]), seedData, cell.hash()]));
	}
	function safeSign$1(cell, secretKey, seed = 'ton-safe-sign-magic') {
	    return (0, crypto_1.sign)(createSafeSignHash(cell, seed), secretKey);
	}
	safeSign.safeSign = safeSign$1;
	function safeSignVerify(cell, signature, publicKey, seed = 'ton-safe-sign-magic') {
	    return (0, crypto_1.signVerify)(createSafeSignHash(cell, seed), signature, publicKey);
	}
	safeSign.safeSignVerify = safeSignVerify;
	return safeSign;
}

var hasRequiredDist$2;

function requireDist$2 () {
	if (hasRequiredDist$2) return dist$2;
	hasRequiredDist$2 = 1;
	(function (exports) {
		/**
		 * Copyright (c) Whales Corp.
		 * All Rights Reserved.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 */
		var __createBinding = (dist$2 && dist$2.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (dist$2 && dist$2.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.safeSignVerify = exports.safeSign = exports.getMethodId = exports.base32Encode = exports.base32Decode = exports.crc32c = exports.crc16 = exports.fromNano = exports.toNano = exports.ComputeError = exports.openContract = exports.TupleBuilder = exports.TupleReader = exports.serializeTuple = exports.parseTuple = exports.generateMerkleUpdate = exports.generateMerkleProofDirect = exports.generateMerkleProof = exports.exoticPruned = exports.exoticMerkleUpdate = exports.convertToMerkleProof = exports.exoticMerkleProof = exports.Dictionary = exports.Cell = exports.CellType = exports.Slice = exports.beginCell = exports.Builder = exports.BitBuilder = exports.BitReader = exports.BitString = exports.contractAddress = exports.ADNLAddress = exports.ExternalAddress = exports.address = exports.Address = void 0;
		// Address
		var Address_1 = requireAddress();
		Object.defineProperty(exports, "Address", { enumerable: true, get: function () { return Address_1.Address; } });
		Object.defineProperty(exports, "address", { enumerable: true, get: function () { return Address_1.address; } });
		var ExternalAddress_1 = requireExternalAddress();
		Object.defineProperty(exports, "ExternalAddress", { enumerable: true, get: function () { return ExternalAddress_1.ExternalAddress; } });
		var ADNLAddress_1 = requireADNLAddress();
		Object.defineProperty(exports, "ADNLAddress", { enumerable: true, get: function () { return ADNLAddress_1.ADNLAddress; } });
		var contractAddress_1 = requireContractAddress();
		Object.defineProperty(exports, "contractAddress", { enumerable: true, get: function () { return contractAddress_1.contractAddress; } });
		// BitString
		var BitString_1 = requireBitString();
		Object.defineProperty(exports, "BitString", { enumerable: true, get: function () { return BitString_1.BitString; } });
		var BitReader_1 = requireBitReader();
		Object.defineProperty(exports, "BitReader", { enumerable: true, get: function () { return BitReader_1.BitReader; } });
		var BitBuilder_1 = requireBitBuilder();
		Object.defineProperty(exports, "BitBuilder", { enumerable: true, get: function () { return BitBuilder_1.BitBuilder; } });
		// Cell
		var Builder_1 = requireBuilder$1();
		Object.defineProperty(exports, "Builder", { enumerable: true, get: function () { return Builder_1.Builder; } });
		Object.defineProperty(exports, "beginCell", { enumerable: true, get: function () { return Builder_1.beginCell; } });
		var Slice_1 = requireSlice();
		Object.defineProperty(exports, "Slice", { enumerable: true, get: function () { return Slice_1.Slice; } });
		var CellType_1 = requireCellType();
		Object.defineProperty(exports, "CellType", { enumerable: true, get: function () { return CellType_1.CellType; } });
		var Cell_1 = requireCell();
		Object.defineProperty(exports, "Cell", { enumerable: true, get: function () { return Cell_1.Cell; } });
		// Dict
		var Dictionary_1 = requireDictionary();
		Object.defineProperty(exports, "Dictionary", { enumerable: true, get: function () { return Dictionary_1.Dictionary; } });
		// Exotics
		var exoticMerkleProof_1 = requireExoticMerkleProof();
		Object.defineProperty(exports, "exoticMerkleProof", { enumerable: true, get: function () { return exoticMerkleProof_1.exoticMerkleProof; } });
		Object.defineProperty(exports, "convertToMerkleProof", { enumerable: true, get: function () { return exoticMerkleProof_1.convertToMerkleProof; } });
		var exoticMerkleUpdate_1 = requireExoticMerkleUpdate();
		Object.defineProperty(exports, "exoticMerkleUpdate", { enumerable: true, get: function () { return exoticMerkleUpdate_1.exoticMerkleUpdate; } });
		var exoticPruned_1 = requireExoticPruned();
		Object.defineProperty(exports, "exoticPruned", { enumerable: true, get: function () { return exoticPruned_1.exoticPruned; } });
		// Merkle trees
		var generateMerkleProof_1 = requireGenerateMerkleProof();
		Object.defineProperty(exports, "generateMerkleProof", { enumerable: true, get: function () { return generateMerkleProof_1.generateMerkleProof; } });
		Object.defineProperty(exports, "generateMerkleProofDirect", { enumerable: true, get: function () { return generateMerkleProof_1.generateMerkleProofDirect; } });
		var generateMerkleUpdate_1 = requireGenerateMerkleUpdate();
		Object.defineProperty(exports, "generateMerkleUpdate", { enumerable: true, get: function () { return generateMerkleUpdate_1.generateMerkleUpdate; } });
		var tuple_1 = requireTuple();
		Object.defineProperty(exports, "parseTuple", { enumerable: true, get: function () { return tuple_1.parseTuple; } });
		Object.defineProperty(exports, "serializeTuple", { enumerable: true, get: function () { return tuple_1.serializeTuple; } });
		var reader_1 = requireReader();
		Object.defineProperty(exports, "TupleReader", { enumerable: true, get: function () { return reader_1.TupleReader; } });
		var builder_1 = requireBuilder();
		Object.defineProperty(exports, "TupleBuilder", { enumerable: true, get: function () { return builder_1.TupleBuilder; } });
		// Types
		__exportStar(require_export(), exports);
		var openContract_1 = requireOpenContract();
		Object.defineProperty(exports, "openContract", { enumerable: true, get: function () { return openContract_1.openContract; } });
		var ComputeError_1 = requireComputeError();
		Object.defineProperty(exports, "ComputeError", { enumerable: true, get: function () { return ComputeError_1.ComputeError; } });
		// Utility
		var convert_1 = requireConvert();
		Object.defineProperty(exports, "toNano", { enumerable: true, get: function () { return convert_1.toNano; } });
		Object.defineProperty(exports, "fromNano", { enumerable: true, get: function () { return convert_1.fromNano; } });
		var crc16_1 = requireCrc16();
		Object.defineProperty(exports, "crc16", { enumerable: true, get: function () { return crc16_1.crc16; } });
		var crc32c_1 = requireCrc32c();
		Object.defineProperty(exports, "crc32c", { enumerable: true, get: function () { return crc32c_1.crc32c; } });
		var base32_1 = requireBase32();
		Object.defineProperty(exports, "base32Decode", { enumerable: true, get: function () { return base32_1.base32Decode; } });
		Object.defineProperty(exports, "base32Encode", { enumerable: true, get: function () { return base32_1.base32Encode; } });
		var getMethodId_1 = requireGetMethodId();
		Object.defineProperty(exports, "getMethodId", { enumerable: true, get: function () { return getMethodId_1.getMethodId; } });
		// Crypto
		var safeSign_1 = requireSafeSign();
		Object.defineProperty(exports, "safeSign", { enumerable: true, get: function () { return safeSign_1.safeSign; } });
		Object.defineProperty(exports, "safeSignVerify", { enumerable: true, get: function () { return safeSign_1.safeSignVerify; } }); 
	} (dist$2));
	return dist$2;
}

var HttpApi = {};

var TonCache = {};

var hasRequiredTonCache;

function requireTonCache () {
	if (hasRequiredTonCache) return TonCache;
	hasRequiredTonCache = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(TonCache, "__esModule", { value: true });
	TonCache.InMemoryCache = void 0;
	class InMemoryCache {
	    constructor() {
	        this.cache = new Map();
	        this.set = async (namespace, key, value) => {
	            if (value !== null) {
	                this.cache.set(namespace + '$$' + key, value);
	            }
	            else {
	                this.cache.delete(namespace + '$$' + key);
	            }
	        };
	        this.get = async (namespace, key) => {
	            let res = this.cache.get(namespace + '$$' + key);
	            if (res !== undefined) {
	                return res;
	            }
	            else {
	                return null;
	            }
	        };
	    }
	}
	TonCache.InMemoryCache = InMemoryCache;
	return TonCache;
}

var dataloader;
var hasRequiredDataloader;

function requireDataloader () {
	if (hasRequiredDataloader) return dataloader;
	hasRequiredDataloader = 1;
	var DataLoader = /* @__PURE__ */ (function() {
	  function DataLoader2(batchLoadFn, options) {
	    if (typeof batchLoadFn !== "function") {
	      throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
	    }
	    this._batchLoadFn = batchLoadFn;
	    this._maxBatchSize = getValidMaxBatchSize(options);
	    this._batchScheduleFn = getValidBatchScheduleFn(options);
	    this._cacheKeyFn = getValidCacheKeyFn(options);
	    this._cacheMap = getValidCacheMap(options);
	    this._batch = null;
	    this.name = getValidName(options);
	  }
	  var _proto = DataLoader2.prototype;
	  _proto.load = function load(key) {
	    if (key === null || key === void 0) {
	      throw new TypeError("The loader.load() function must be called with a value, " + ("but got: " + String(key) + "."));
	    }
	    var batch = getCurrentBatch(this);
	    var cacheMap = this._cacheMap;
	    var cacheKey;
	    if (cacheMap) {
	      cacheKey = this._cacheKeyFn(key);
	      var cachedPromise = cacheMap.get(cacheKey);
	      if (cachedPromise) {
	        var cacheHits = batch.cacheHits || (batch.cacheHits = []);
	        return new Promise(function(resolve) {
	          cacheHits.push(function() {
	            resolve(cachedPromise);
	          });
	        });
	      }
	    }
	    batch.keys.push(key);
	    var promise = new Promise(function(resolve, reject) {
	      batch.callbacks.push({
	        resolve,
	        reject
	      });
	    });
	    if (cacheMap) {
	      cacheMap.set(cacheKey, promise);
	    }
	    return promise;
	  };
	  _proto.loadMany = function loadMany(keys) {
	    if (!isArrayLike(keys)) {
	      throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + keys + "."));
	    }
	    var loadPromises = [];
	    for (var i = 0; i < keys.length; i++) {
	      loadPromises.push(this.load(keys[i])["catch"](function(error) {
	        return error;
	      }));
	    }
	    return Promise.all(loadPromises);
	  };
	  _proto.clear = function clear(key) {
	    var cacheMap = this._cacheMap;
	    if (cacheMap) {
	      var cacheKey = this._cacheKeyFn(key);
	      cacheMap["delete"](cacheKey);
	    }
	    return this;
	  };
	  _proto.clearAll = function clearAll() {
	    var cacheMap = this._cacheMap;
	    if (cacheMap) {
	      cacheMap.clear();
	    }
	    return this;
	  };
	  _proto.prime = function prime(key, value) {
	    var cacheMap = this._cacheMap;
	    if (cacheMap) {
	      var cacheKey = this._cacheKeyFn(key);
	      if (cacheMap.get(cacheKey) === void 0) {
	        var promise;
	        if (value instanceof Error) {
	          promise = Promise.reject(value);
	          promise["catch"](function() {
	          });
	        } else {
	          promise = Promise.resolve(value);
	        }
	        cacheMap.set(cacheKey, promise);
	      }
	    }
	    return this;
	  };
	  return DataLoader2;
	})();
	var enqueuePostPromiseJob = typeof process === "object" && typeof process.nextTick === "function" ? function(fn) {
	  if (!resolvedPromise) {
	    resolvedPromise = Promise.resolve();
	  }
	  resolvedPromise.then(function() {
	    process.nextTick(fn);
	  });
	} : typeof setImmediate === "function" ? function(fn) {
	  setImmediate(fn);
	} : function(fn) {
	  setTimeout(fn);
	};
	var resolvedPromise;
	function getCurrentBatch(loader) {
	  var existingBatch = loader._batch;
	  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {
	    return existingBatch;
	  }
	  var newBatch = {
	    hasDispatched: false,
	    keys: [],
	    callbacks: []
	  };
	  loader._batch = newBatch;
	  loader._batchScheduleFn(function() {
	    dispatchBatch(loader, newBatch);
	  });
	  return newBatch;
	}
	function dispatchBatch(loader, batch) {
	  batch.hasDispatched = true;
	  if (batch.keys.length === 0) {
	    resolveCacheHits(batch);
	    return;
	  }
	  var batchPromise;
	  try {
	    batchPromise = loader._batchLoadFn(batch.keys);
	  } catch (e) {
	    return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function " + ("errored synchronously: " + String(e) + ".")));
	  }
	  if (!batchPromise || typeof batchPromise.then !== "function") {
	    return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(batchPromise) + ".")));
	  }
	  batchPromise.then(function(values) {
	    if (!isArrayLike(values)) {
	      throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(values) + "."));
	    }
	    if (values.length !== batch.keys.length) {
	      throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + ("\n\nKeys:\n" + String(batch.keys)) + ("\n\nValues:\n" + String(values)));
	    }
	    resolveCacheHits(batch);
	    for (var i = 0; i < batch.callbacks.length; i++) {
	      var _value = values[i];
	      if (_value instanceof Error) {
	        batch.callbacks[i].reject(_value);
	      } else {
	        batch.callbacks[i].resolve(_value);
	      }
	    }
	  })["catch"](function(error) {
	    failedDispatch(loader, batch, error);
	  });
	}
	function failedDispatch(loader, batch, error) {
	  resolveCacheHits(batch);
	  for (var i = 0; i < batch.keys.length; i++) {
	    loader.clear(batch.keys[i]);
	    batch.callbacks[i].reject(error);
	  }
	}
	function resolveCacheHits(batch) {
	  if (batch.cacheHits) {
	    for (var i = 0; i < batch.cacheHits.length; i++) {
	      batch.cacheHits[i]();
	    }
	  }
	}
	function getValidMaxBatchSize(options) {
	  var shouldBatch = !options || options.batch !== false;
	  if (!shouldBatch) {
	    return 1;
	  }
	  var maxBatchSize = options && options.maxBatchSize;
	  if (maxBatchSize === void 0) {
	    return Infinity;
	  }
	  if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
	    throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
	  }
	  return maxBatchSize;
	}
	function getValidBatchScheduleFn(options) {
	  var batchScheduleFn = options && options.batchScheduleFn;
	  if (batchScheduleFn === void 0) {
	    return enqueuePostPromiseJob;
	  }
	  if (typeof batchScheduleFn !== "function") {
	    throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
	  }
	  return batchScheduleFn;
	}
	function getValidCacheKeyFn(options) {
	  var cacheKeyFn = options && options.cacheKeyFn;
	  if (cacheKeyFn === void 0) {
	    return function(key) {
	      return key;
	    };
	  }
	  if (typeof cacheKeyFn !== "function") {
	    throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
	  }
	  return cacheKeyFn;
	}
	function getValidCacheMap(options) {
	  var shouldCache = !options || options.cache !== false;
	  if (!shouldCache) {
	    return null;
	  }
	  var cacheMap = options && options.cacheMap;
	  if (cacheMap === void 0) {
	    return /* @__PURE__ */ new Map();
	  }
	  if (cacheMap !== null) {
	    var cacheFunctions = ["get", "set", "delete", "clear"];
	    var missingFunctions = cacheFunctions.filter(function(fnName) {
	      return cacheMap && typeof cacheMap[fnName] !== "function";
	    });
	    if (missingFunctions.length !== 0) {
	      throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
	    }
	  }
	  return cacheMap;
	}
	function getValidName(options) {
	  if (options && options.name) {
	    return options.name;
	  }
	  return null;
	}
	function isArrayLike(x) {
	  return typeof x === "object" && x !== null && typeof x.length === "number" && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));
	}
	dataloader = DataLoader;
	return dataloader;
}

var axios_1;
var hasRequiredAxios;

function requireAxios () {
	if (hasRequiredAxios) return axios_1;
	hasRequiredAxios = 1;
	/*! Axios v1.11.0 Copyright (c) 2025 Matt Zabriskie and contributors */
	function bind(fn, thisArg) {
	  return function wrap() {
	    return fn.apply(thisArg, arguments);
	  };
	}
	const { toString } = Object.prototype;
	const { getPrototypeOf } = Object;
	const { iterator, toStringTag } = Symbol;
	const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
	  const str = toString.call(thing);
	  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
	})(/* @__PURE__ */ Object.create(null));
	const kindOfTest = (type) => {
	  type = type.toLowerCase();
	  return (thing) => kindOf(thing) === type;
	};
	const typeOfTest = (type) => (thing) => typeof thing === type;
	const { isArray } = Array;
	const isUndefined = typeOfTest("undefined");
	function isBuffer(val) {
	  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
	}
	const isArrayBuffer = kindOfTest("ArrayBuffer");
	function isArrayBufferView(val) {
	  let result;
	  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = val && val.buffer && isArrayBuffer(val.buffer);
	  }
	  return result;
	}
	const isString = typeOfTest("string");
	const isFunction = typeOfTest("function");
	const isNumber = typeOfTest("number");
	const isObject = (thing) => thing !== null && typeof thing === "object";
	const isBoolean = (thing) => thing === true || thing === false;
	const isPlainObject = (val) => {
	  if (kindOf(val) !== "object") {
	    return false;
	  }
	  const prototype2 = getPrototypeOf(val);
	  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
	};
	const isEmptyObject = (val) => {
	  if (!isObject(val) || isBuffer(val)) {
	    return false;
	  }
	  try {
	    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
	  } catch (e) {
	    return false;
	  }
	};
	const isDate = kindOfTest("Date");
	const isFile = kindOfTest("File");
	const isBlob = kindOfTest("Blob");
	const isFileList = kindOfTest("FileList");
	const isStream = (val) => isObject(val) && isFunction(val.pipe);
	const isFormData = (thing) => {
	  let kind;
	  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
	  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
	};
	const isURLSearchParams = kindOfTest("URLSearchParams");
	const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
	const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
	function forEach(obj, fn, { allOwnKeys = false } = {}) {
	  if (obj === null || typeof obj === "undefined") {
	    return;
	  }
	  let i;
	  let l;
	  if (typeof obj !== "object") {
	    obj = [obj];
	  }
	  if (isArray(obj)) {
	    for (i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    if (isBuffer(obj)) {
	      return;
	    }
	    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
	    const len = keys.length;
	    let key;
	    for (i = 0; i < len; i++) {
	      key = keys[i];
	      fn.call(null, obj[key], key, obj);
	    }
	  }
	}
	function findKey(obj, key) {
	  if (isBuffer(obj)) {
	    return null;
	  }
	  key = key.toLowerCase();
	  const keys = Object.keys(obj);
	  let i = keys.length;
	  let _key;
	  while (i-- > 0) {
	    _key = keys[i];
	    if (key === _key.toLowerCase()) {
	      return _key;
	    }
	  }
	  return null;
	}
	const _global = (() => {
	  if (typeof globalThis !== "undefined") return globalThis;
	  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : globalThis;
	})();
	const isContextDefined = (context) => !isUndefined(context) && context !== _global;
	function merge() {
	  const { caseless } = isContextDefined(this) && this || {};
	  const result = {};
	  const assignValue = (val, key) => {
	    const targetKey = caseless && findKey(result, key) || key;
	    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
	      result[targetKey] = merge(result[targetKey], val);
	    } else if (isPlainObject(val)) {
	      result[targetKey] = merge({}, val);
	    } else if (isArray(val)) {
	      result[targetKey] = val.slice();
	    } else {
	      result[targetKey] = val;
	    }
	  };
	  for (let i = 0, l = arguments.length; i < l; i++) {
	    arguments[i] && forEach(arguments[i], assignValue);
	  }
	  return result;
	}
	const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
	  forEach(b, (val, key) => {
	    if (thisArg && isFunction(val)) {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  }, { allOwnKeys });
	  return a;
	};
	const stripBOM = (content) => {
	  if (content.charCodeAt(0) === 65279) {
	    content = content.slice(1);
	  }
	  return content;
	};
	const inherits = (constructor, superConstructor, props, descriptors2) => {
	  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
	  constructor.prototype.constructor = constructor;
	  Object.defineProperty(constructor, "super", {
	    value: superConstructor.prototype
	  });
	  props && Object.assign(constructor.prototype, props);
	};
	const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
	  let props;
	  let i;
	  let prop;
	  const merged = {};
	  destObj = destObj || {};
	  if (sourceObj == null) return destObj;
	  do {
	    props = Object.getOwnPropertyNames(sourceObj);
	    i = props.length;
	    while (i-- > 0) {
	      prop = props[i];
	      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
	        destObj[prop] = sourceObj[prop];
	        merged[prop] = true;
	      }
	    }
	    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
	  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
	  return destObj;
	};
	const endsWith = (str, searchString, position) => {
	  str = String(str);
	  if (position === void 0 || position > str.length) {
	    position = str.length;
	  }
	  position -= searchString.length;
	  const lastIndex = str.indexOf(searchString, position);
	  return lastIndex !== -1 && lastIndex === position;
	};
	const toArray = (thing) => {
	  if (!thing) return null;
	  if (isArray(thing)) return thing;
	  let i = thing.length;
	  if (!isNumber(i)) return null;
	  const arr = new Array(i);
	  while (i-- > 0) {
	    arr[i] = thing[i];
	  }
	  return arr;
	};
	const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
	  return (thing) => {
	    return TypedArray && thing instanceof TypedArray;
	  };
	})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
	const forEachEntry = (obj, fn) => {
	  const generator = obj && obj[iterator];
	  const _iterator = generator.call(obj);
	  let result;
	  while ((result = _iterator.next()) && !result.done) {
	    const pair = result.value;
	    fn.call(obj, pair[0], pair[1]);
	  }
	};
	const matchAll = (regExp, str) => {
	  let matches;
	  const arr = [];
	  while ((matches = regExp.exec(str)) !== null) {
	    arr.push(matches);
	  }
	  return arr;
	};
	const isHTMLForm = kindOfTest("HTMLFormElement");
	const toCamelCase = (str) => {
	  return str.toLowerCase().replace(
	    /[-_\s]([a-z\d])(\w*)/g,
	    function replacer(m, p1, p2) {
	      return p1.toUpperCase() + p2;
	    }
	  );
	};
	const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
	const isRegExp = kindOfTest("RegExp");
	const reduceDescriptors = (obj, reducer) => {
	  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
	  const reducedDescriptors = {};
	  forEach(descriptors2, (descriptor, name) => {
	    let ret;
	    if ((ret = reducer(descriptor, name, obj)) !== false) {
	      reducedDescriptors[name] = ret || descriptor;
	    }
	  });
	  Object.defineProperties(obj, reducedDescriptors);
	};
	const freezeMethods = (obj) => {
	  reduceDescriptors(obj, (descriptor, name) => {
	    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
	      return false;
	    }
	    const value = obj[name];
	    if (!isFunction(value)) return;
	    descriptor.enumerable = false;
	    if ("writable" in descriptor) {
	      descriptor.writable = false;
	      return;
	    }
	    if (!descriptor.set) {
	      descriptor.set = () => {
	        throw Error("Can not rewrite read-only method '" + name + "'");
	      };
	    }
	  });
	};
	const toObjectSet = (arrayOrString, delimiter) => {
	  const obj = {};
	  const define = (arr) => {
	    arr.forEach((value) => {
	      obj[value] = true;
	    });
	  };
	  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
	  return obj;
	};
	const noop = () => {
	};
	const toFiniteNumber = (value, defaultValue) => {
	  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
	};
	function isSpecCompliantForm(thing) {
	  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
	}
	const toJSONObject = (obj) => {
	  const stack = new Array(10);
	  const visit = (source, i) => {
	    if (isObject(source)) {
	      if (stack.indexOf(source) >= 0) {
	        return;
	      }
	      if (isBuffer(source)) {
	        return source;
	      }
	      if (!("toJSON" in source)) {
	        stack[i] = source;
	        const target = isArray(source) ? [] : {};
	        forEach(source, (value, key) => {
	          const reducedValue = visit(value, i + 1);
	          !isUndefined(reducedValue) && (target[key] = reducedValue);
	        });
	        stack[i] = void 0;
	        return target;
	      }
	    }
	    return source;
	  };
	  return visit(obj, 0);
	};
	const isAsyncFn = kindOfTest("AsyncFunction");
	const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
	const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
	  if (setImmediateSupported) {
	    return setImmediate;
	  }
	  return postMessageSupported ? ((token, callbacks) => {
	    _global.addEventListener("message", ({ source, data }) => {
	      if (source === _global && data === token) {
	        callbacks.length && callbacks.shift()();
	      }
	    }, false);
	    return (cb) => {
	      callbacks.push(cb);
	      _global.postMessage(token, "*");
	    };
	  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
	})(
	  typeof setImmediate === "function",
	  isFunction(_global.postMessage)
	);
	const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
	const isIterable = (thing) => thing != null && isFunction(thing[iterator]);
	var utils$1 = {
	  isArray,
	  isArrayBuffer,
	  isBuffer,
	  isFormData,
	  isArrayBufferView,
	  isString,
	  isNumber,
	  isBoolean,
	  isObject,
	  isPlainObject,
	  isEmptyObject,
	  isReadableStream,
	  isRequest,
	  isResponse,
	  isHeaders,
	  isUndefined,
	  isDate,
	  isFile,
	  isBlob,
	  isRegExp,
	  isFunction,
	  isStream,
	  isURLSearchParams,
	  isTypedArray,
	  isFileList,
	  forEach,
	  merge,
	  extend,
	  trim,
	  stripBOM,
	  inherits,
	  toFlatObject,
	  kindOf,
	  kindOfTest,
	  endsWith,
	  toArray,
	  forEachEntry,
	  matchAll,
	  isHTMLForm,
	  hasOwnProperty,
	  hasOwnProp: hasOwnProperty,
	  // an alias to avoid ESLint no-prototype-builtins detection
	  reduceDescriptors,
	  freezeMethods,
	  toObjectSet,
	  toCamelCase,
	  noop,
	  toFiniteNumber,
	  findKey,
	  global: _global,
	  isContextDefined,
	  isSpecCompliantForm,
	  toJSONObject,
	  isAsyncFn,
	  isThenable,
	  setImmediate: _setImmediate,
	  asap,
	  isIterable
	};
	function AxiosError(message, code, config, request, response) {
	  Error.call(this);
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, this.constructor);
	  } else {
	    this.stack = new Error().stack;
	  }
	  this.message = message;
	  this.name = "AxiosError";
	  code && (this.code = code);
	  config && (this.config = config);
	  request && (this.request = request);
	  if (response) {
	    this.response = response;
	    this.status = response.status ? response.status : null;
	  }
	}
	utils$1.inherits(AxiosError, Error, {
	  toJSON: function toJSON() {
	    return {
	      // Standard
	      message: this.message,
	      name: this.name,
	      // Microsoft
	      description: this.description,
	      number: this.number,
	      // Mozilla
	      fileName: this.fileName,
	      lineNumber: this.lineNumber,
	      columnNumber: this.columnNumber,
	      stack: this.stack,
	      // Axios
	      config: utils$1.toJSONObject(this.config),
	      code: this.code,
	      status: this.status
	    };
	  }
	});
	const prototype$1 = AxiosError.prototype;
	const descriptors = {};
	[
	  "ERR_BAD_OPTION_VALUE",
	  "ERR_BAD_OPTION",
	  "ECONNABORTED",
	  "ETIMEDOUT",
	  "ERR_NETWORK",
	  "ERR_FR_TOO_MANY_REDIRECTS",
	  "ERR_DEPRECATED",
	  "ERR_BAD_RESPONSE",
	  "ERR_BAD_REQUEST",
	  "ERR_CANCELED",
	  "ERR_NOT_SUPPORT",
	  "ERR_INVALID_URL"
	  // eslint-disable-next-line func-names
	].forEach((code) => {
	  descriptors[code] = { value: code };
	});
	Object.defineProperties(AxiosError, descriptors);
	Object.defineProperty(prototype$1, "isAxiosError", { value: true });
	AxiosError.from = (error, code, config, request, response, customProps) => {
	  const axiosError = Object.create(prototype$1);
	  utils$1.toFlatObject(error, axiosError, function filter2(obj) {
	    return obj !== Error.prototype;
	  }, (prop) => {
	    return prop !== "isAxiosError";
	  });
	  AxiosError.call(axiosError, error.message, code, config, request, response);
	  axiosError.cause = error;
	  axiosError.name = error.name;
	  customProps && Object.assign(axiosError, customProps);
	  return axiosError;
	};
	var httpAdapter = null;
	function isVisitable(thing) {
	  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
	}
	function removeBrackets(key) {
	  return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
	}
	function renderKey(path, key, dots) {
	  if (!path) return key;
	  return path.concat(key).map(function each(token, i) {
	    token = removeBrackets(token);
	    return !dots && i ? "[" + token + "]" : token;
	  }).join(dots ? "." : "");
	}
	function isFlatArray(arr) {
	  return utils$1.isArray(arr) && !arr.some(isVisitable);
	}
	const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
	  return /^is[A-Z]/.test(prop);
	});
	function toFormData(obj, formData, options) {
	  if (!utils$1.isObject(obj)) {
	    throw new TypeError("target must be an object");
	  }
	  formData = formData || new FormData();
	  options = utils$1.toFlatObject(options, {
	    metaTokens: true,
	    dots: false,
	    indexes: false
	  }, false, function defined(option, source) {
	    return !utils$1.isUndefined(source[option]);
	  });
	  const metaTokens = options.metaTokens;
	  const visitor = options.visitor || defaultVisitor;
	  const dots = options.dots;
	  const indexes = options.indexes;
	  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
	  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
	  if (!utils$1.isFunction(visitor)) {
	    throw new TypeError("visitor must be a function");
	  }
	  function convertValue(value) {
	    if (value === null) return "";
	    if (utils$1.isDate(value)) {
	      return value.toISOString();
	    }
	    if (utils$1.isBoolean(value)) {
	      return value.toString();
	    }
	    if (!useBlob && utils$1.isBlob(value)) {
	      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
	    }
	    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
	      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
	    }
	    return value;
	  }
	  function defaultVisitor(value, key, path) {
	    let arr = value;
	    if (value && !path && typeof value === "object") {
	      if (utils$1.endsWith(key, "{}")) {
	        key = metaTokens ? key : key.slice(0, -2);
	        value = JSON.stringify(value);
	      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
	        key = removeBrackets(key);
	        arr.forEach(function each(el, index) {
	          !(utils$1.isUndefined(el) || el === null) && formData.append(
	            // eslint-disable-next-line no-nested-ternary
	            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
	            convertValue(el)
	          );
	        });
	        return false;
	      }
	    }
	    if (isVisitable(value)) {
	      return true;
	    }
	    formData.append(renderKey(path, key, dots), convertValue(value));
	    return false;
	  }
	  const stack = [];
	  const exposedHelpers = Object.assign(predicates, {
	    defaultVisitor,
	    convertValue,
	    isVisitable
	  });
	  function build(value, path) {
	    if (utils$1.isUndefined(value)) return;
	    if (stack.indexOf(value) !== -1) {
	      throw Error("Circular reference detected in " + path.join("."));
	    }
	    stack.push(value);
	    utils$1.forEach(value, function each(el, key) {
	      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
	        formData,
	        el,
	        utils$1.isString(key) ? key.trim() : key,
	        path,
	        exposedHelpers
	      );
	      if (result === true) {
	        build(el, path ? path.concat(key) : [key]);
	      }
	    });
	    stack.pop();
	  }
	  if (!utils$1.isObject(obj)) {
	    throw new TypeError("data must be an object");
	  }
	  build(obj);
	  return formData;
	}
	function encode$1(str) {
	  const charMap = {
	    "!": "%21",
	    "'": "%27",
	    "(": "%28",
	    ")": "%29",
	    "~": "%7E",
	    "%20": "+",
	    "%00": "\0"
	  };
	  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
	    return charMap[match];
	  });
	}
	function AxiosURLSearchParams(params, options) {
	  this._pairs = [];
	  params && toFormData(params, this, options);
	}
	const prototype = AxiosURLSearchParams.prototype;
	prototype.append = function append(name, value) {
	  this._pairs.push([name, value]);
	};
	prototype.toString = function toString2(encoder) {
	  const _encode = encoder ? function(value) {
	    return encoder.call(this, value, encode$1);
	  } : encode$1;
	  return this._pairs.map(function each(pair) {
	    return _encode(pair[0]) + "=" + _encode(pair[1]);
	  }, "").join("&");
	};
	function encode(val) {
	  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
	}
	function buildURL(url, params, options) {
	  if (!params) {
	    return url;
	  }
	  const _encode = options && options.encode || encode;
	  if (utils$1.isFunction(options)) {
	    options = {
	      serialize: options
	    };
	  }
	  const serializeFn = options && options.serialize;
	  let serializedParams;
	  if (serializeFn) {
	    serializedParams = serializeFn(params, options);
	  } else {
	    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
	  }
	  if (serializedParams) {
	    const hashmarkIndex = url.indexOf("#");
	    if (hashmarkIndex !== -1) {
	      url = url.slice(0, hashmarkIndex);
	    }
	    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
	  }
	  return url;
	}
	class InterceptorManager {
	  constructor() {
	    this.handlers = [];
	  }
	  /**
	   * Add a new interceptor to the stack
	   *
	   * @param {Function} fulfilled The function to handle `then` for a `Promise`
	   * @param {Function} rejected The function to handle `reject` for a `Promise`
	   *
	   * @return {Number} An ID used to remove interceptor later
	   */
	  use(fulfilled, rejected, options) {
	    this.handlers.push({
	      fulfilled,
	      rejected,
	      synchronous: options ? options.synchronous : false,
	      runWhen: options ? options.runWhen : null
	    });
	    return this.handlers.length - 1;
	  }
	  /**
	   * Remove an interceptor from the stack
	   *
	   * @param {Number} id The ID that was returned by `use`
	   *
	   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
	   */
	  eject(id) {
	    if (this.handlers[id]) {
	      this.handlers[id] = null;
	    }
	  }
	  /**
	   * Clear all interceptors from the stack
	   *
	   * @returns {void}
	   */
	  clear() {
	    if (this.handlers) {
	      this.handlers = [];
	    }
	  }
	  /**
	   * Iterate over all the registered interceptors
	   *
	   * This method is particularly useful for skipping over any
	   * interceptors that may have become `null` calling `eject`.
	   *
	   * @param {Function} fn The function to call for each interceptor
	   *
	   * @returns {void}
	   */
	  forEach(fn) {
	    utils$1.forEach(this.handlers, function forEachHandler(h) {
	      if (h !== null) {
	        fn(h);
	      }
	    });
	  }
	}
	var InterceptorManager$1 = InterceptorManager;
	var transitionalDefaults = {
	  silentJSONParsing: true,
	  forcedJSONParsing: true,
	  clarifyTimeoutError: false
	};
	var URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
	var FormData$1 = typeof FormData !== "undefined" ? FormData : null;
	var Blob$1 = typeof Blob !== "undefined" ? Blob : null;
	var platform$1 = {
	  isBrowser: true,
	  classes: {
	    URLSearchParams: URLSearchParams$1,
	    FormData: FormData$1,
	    Blob: Blob$1
	  },
	  protocols: ["http", "https", "file", "blob", "url", "data"]
	};
	const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
	const _navigator = typeof navigator === "object" && navigator || void 0;
	const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
	const hasStandardBrowserWebWorkerEnv = (() => {
	  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
	  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
	})();
	const origin = hasBrowserEnv && window.location.href || "http://localhost";
	var utils = /* @__PURE__ */ Object.freeze({
	  __proto__: null,
	  hasBrowserEnv,
	  hasStandardBrowserWebWorkerEnv,
	  hasStandardBrowserEnv,
	  navigator: _navigator,
	  origin
	});
	var platform = {
	  ...utils,
	  ...platform$1
	};
	function toURLEncodedForm(data, options) {
	  return toFormData(data, new platform.classes.URLSearchParams(), {
	    visitor: function(value, key, path, helpers) {
	      if (platform.isNode && utils$1.isBuffer(value)) {
	        this.append(key, value.toString("base64"));
	        return false;
	      }
	      return helpers.defaultVisitor.apply(this, arguments);
	    },
	    ...options
	  });
	}
	function parsePropPath(name) {
	  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
	    return match[0] === "[]" ? "" : match[1] || match[0];
	  });
	}
	function arrayToObject(arr) {
	  const obj = {};
	  const keys = Object.keys(arr);
	  let i;
	  const len = keys.length;
	  let key;
	  for (i = 0; i < len; i++) {
	    key = keys[i];
	    obj[key] = arr[key];
	  }
	  return obj;
	}
	function formDataToJSON(formData) {
	  function buildPath(path, value, target, index) {
	    let name = path[index++];
	    if (name === "__proto__") return true;
	    const isNumericKey = Number.isFinite(+name);
	    const isLast = index >= path.length;
	    name = !name && utils$1.isArray(target) ? target.length : name;
	    if (isLast) {
	      if (utils$1.hasOwnProp(target, name)) {
	        target[name] = [target[name], value];
	      } else {
	        target[name] = value;
	      }
	      return !isNumericKey;
	    }
	    if (!target[name] || !utils$1.isObject(target[name])) {
	      target[name] = [];
	    }
	    const result = buildPath(path, value, target[name], index);
	    if (result && utils$1.isArray(target[name])) {
	      target[name] = arrayToObject(target[name]);
	    }
	    return !isNumericKey;
	  }
	  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
	    const obj = {};
	    utils$1.forEachEntry(formData, (name, value) => {
	      buildPath(parsePropPath(name), value, obj, 0);
	    });
	    return obj;
	  }
	  return null;
	}
	function stringifySafely(rawValue, parser, encoder) {
	  if (utils$1.isString(rawValue)) {
	    try {
	      (parser || JSON.parse)(rawValue);
	      return utils$1.trim(rawValue);
	    } catch (e) {
	      if (e.name !== "SyntaxError") {
	        throw e;
	      }
	    }
	  }
	  return (encoder || JSON.stringify)(rawValue);
	}
	const defaults = {
	  transitional: transitionalDefaults,
	  adapter: ["xhr", "http", "fetch"],
	  transformRequest: [function transformRequest(data, headers) {
	    const contentType = headers.getContentType() || "";
	    const hasJSONContentType = contentType.indexOf("application/json") > -1;
	    const isObjectPayload = utils$1.isObject(data);
	    if (isObjectPayload && utils$1.isHTMLForm(data)) {
	      data = new FormData(data);
	    }
	    const isFormData2 = utils$1.isFormData(data);
	    if (isFormData2) {
	      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
	    }
	    if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
	      return data;
	    }
	    if (utils$1.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils$1.isURLSearchParams(data)) {
	      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
	      return data.toString();
	    }
	    let isFileList2;
	    if (isObjectPayload) {
	      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
	        return toURLEncodedForm(data, this.formSerializer).toString();
	      }
	      if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
	        const _FormData = this.env && this.env.FormData;
	        return toFormData(
	          isFileList2 ? { "files[]": data } : data,
	          _FormData && new _FormData(),
	          this.formSerializer
	        );
	      }
	    }
	    if (isObjectPayload || hasJSONContentType) {
	      headers.setContentType("application/json", false);
	      return stringifySafely(data);
	    }
	    return data;
	  }],
	  transformResponse: [function transformResponse(data) {
	    const transitional2 = this.transitional || defaults.transitional;
	    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
	    const JSONRequested = this.responseType === "json";
	    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
	      return data;
	    }
	    if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
	      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
	      const strictJSONParsing = !silentJSONParsing && JSONRequested;
	      try {
	        return JSON.parse(data);
	      } catch (e) {
	        if (strictJSONParsing) {
	          if (e.name === "SyntaxError") {
	            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
	          }
	          throw e;
	        }
	      }
	    }
	    return data;
	  }],
	  /**
	   * A timeout in milliseconds to abort a request. If set to 0 (default) a
	   * timeout is not created.
	   */
	  timeout: 0,
	  xsrfCookieName: "XSRF-TOKEN",
	  xsrfHeaderName: "X-XSRF-TOKEN",
	  maxContentLength: -1,
	  maxBodyLength: -1,
	  env: {
	    FormData: platform.classes.FormData,
	    Blob: platform.classes.Blob
	  },
	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  },
	  headers: {
	    common: {
	      "Accept": "application/json, text/plain, */*",
	      "Content-Type": void 0
	    }
	  }
	};
	utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
	  defaults.headers[method] = {};
	});
	var defaults$1 = defaults;
	const ignoreDuplicateOf = utils$1.toObjectSet([
	  "age",
	  "authorization",
	  "content-length",
	  "content-type",
	  "etag",
	  "expires",
	  "from",
	  "host",
	  "if-modified-since",
	  "if-unmodified-since",
	  "last-modified",
	  "location",
	  "max-forwards",
	  "proxy-authorization",
	  "referer",
	  "retry-after",
	  "user-agent"
	]);
	var parseHeaders = (rawHeaders) => {
	  const parsed = {};
	  let key;
	  let val;
	  let i;
	  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
	    i = line.indexOf(":");
	    key = line.substring(0, i).trim().toLowerCase();
	    val = line.substring(i + 1).trim();
	    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
	      return;
	    }
	    if (key === "set-cookie") {
	      if (parsed[key]) {
	        parsed[key].push(val);
	      } else {
	        parsed[key] = [val];
	      }
	    } else {
	      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
	    }
	  });
	  return parsed;
	};
	const $internals = Symbol("internals");
	function normalizeHeader(header) {
	  return header && String(header).trim().toLowerCase();
	}
	function normalizeValue(value) {
	  if (value === false || value == null) {
	    return value;
	  }
	  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
	}
	function parseTokens(str) {
	  const tokens = /* @__PURE__ */ Object.create(null);
	  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
	  let match;
	  while (match = tokensRE.exec(str)) {
	    tokens[match[1]] = match[2];
	  }
	  return tokens;
	}
	const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
	function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
	  if (utils$1.isFunction(filter2)) {
	    return filter2.call(this, value, header);
	  }
	  if (isHeaderNameFilter) {
	    value = header;
	  }
	  if (!utils$1.isString(value)) return;
	  if (utils$1.isString(filter2)) {
	    return value.indexOf(filter2) !== -1;
	  }
	  if (utils$1.isRegExp(filter2)) {
	    return filter2.test(value);
	  }
	}
	function formatHeader(header) {
	  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
	    return char.toUpperCase() + str;
	  });
	}
	function buildAccessors(obj, header) {
	  const accessorName = utils$1.toCamelCase(" " + header);
	  ["get", "set", "has"].forEach((methodName) => {
	    Object.defineProperty(obj, methodName + accessorName, {
	      value: function(arg1, arg2, arg3) {
	        return this[methodName].call(this, header, arg1, arg2, arg3);
	      },
	      configurable: true
	    });
	  });
	}
	class AxiosHeaders {
	  constructor(headers) {
	    headers && this.set(headers);
	  }
	  set(header, valueOrRewrite, rewrite) {
	    const self2 = this;
	    function setHeader(_value, _header, _rewrite) {
	      const lHeader = normalizeHeader(_header);
	      if (!lHeader) {
	        throw new Error("header name must be a non-empty string");
	      }
	      const key = utils$1.findKey(self2, lHeader);
	      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
	        self2[key || _header] = normalizeValue(_value);
	      }
	    }
	    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
	    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
	      setHeaders(header, valueOrRewrite);
	    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
	      setHeaders(parseHeaders(header), valueOrRewrite);
	    } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
	      let obj = {}, dest, key;
	      for (const entry of header) {
	        if (!utils$1.isArray(entry)) {
	          throw TypeError("Object iterator must return a key-value pair");
	        }
	        obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
	      }
	      setHeaders(obj, valueOrRewrite);
	    } else {
	      header != null && setHeader(valueOrRewrite, header, rewrite);
	    }
	    return this;
	  }
	  get(header, parser) {
	    header = normalizeHeader(header);
	    if (header) {
	      const key = utils$1.findKey(this, header);
	      if (key) {
	        const value = this[key];
	        if (!parser) {
	          return value;
	        }
	        if (parser === true) {
	          return parseTokens(value);
	        }
	        if (utils$1.isFunction(parser)) {
	          return parser.call(this, value, key);
	        }
	        if (utils$1.isRegExp(parser)) {
	          return parser.exec(value);
	        }
	        throw new TypeError("parser must be boolean|regexp|function");
	      }
	    }
	  }
	  has(header, matcher) {
	    header = normalizeHeader(header);
	    if (header) {
	      const key = utils$1.findKey(this, header);
	      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
	    }
	    return false;
	  }
	  delete(header, matcher) {
	    const self2 = this;
	    let deleted = false;
	    function deleteHeader(_header) {
	      _header = normalizeHeader(_header);
	      if (_header) {
	        const key = utils$1.findKey(self2, _header);
	        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
	          delete self2[key];
	          deleted = true;
	        }
	      }
	    }
	    if (utils$1.isArray(header)) {
	      header.forEach(deleteHeader);
	    } else {
	      deleteHeader(header);
	    }
	    return deleted;
	  }
	  clear(matcher) {
	    const keys = Object.keys(this);
	    let i = keys.length;
	    let deleted = false;
	    while (i--) {
	      const key = keys[i];
	      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
	        delete this[key];
	        deleted = true;
	      }
	    }
	    return deleted;
	  }
	  normalize(format) {
	    const self2 = this;
	    const headers = {};
	    utils$1.forEach(this, (value, header) => {
	      const key = utils$1.findKey(headers, header);
	      if (key) {
	        self2[key] = normalizeValue(value);
	        delete self2[header];
	        return;
	      }
	      const normalized = format ? formatHeader(header) : String(header).trim();
	      if (normalized !== header) {
	        delete self2[header];
	      }
	      self2[normalized] = normalizeValue(value);
	      headers[normalized] = true;
	    });
	    return this;
	  }
	  concat(...targets) {
	    return this.constructor.concat(this, ...targets);
	  }
	  toJSON(asStrings) {
	    const obj = /* @__PURE__ */ Object.create(null);
	    utils$1.forEach(this, (value, header) => {
	      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
	    });
	    return obj;
	  }
	  [Symbol.iterator]() {
	    return Object.entries(this.toJSON())[Symbol.iterator]();
	  }
	  toString() {
	    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
	  }
	  getSetCookie() {
	    return this.get("set-cookie") || [];
	  }
	  get [Symbol.toStringTag]() {
	    return "AxiosHeaders";
	  }
	  static from(thing) {
	    return thing instanceof this ? thing : new this(thing);
	  }
	  static concat(first, ...targets) {
	    const computed = new this(first);
	    targets.forEach((target) => computed.set(target));
	    return computed;
	  }
	  static accessor(header) {
	    const internals = this[$internals] = this[$internals] = {
	      accessors: {}
	    };
	    const accessors = internals.accessors;
	    const prototype2 = this.prototype;
	    function defineAccessor(_header) {
	      const lHeader = normalizeHeader(_header);
	      if (!accessors[lHeader]) {
	        buildAccessors(prototype2, _header);
	        accessors[lHeader] = true;
	      }
	    }
	    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
	    return this;
	  }
	}
	AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
	utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
	  let mapped = key[0].toUpperCase() + key.slice(1);
	  return {
	    get: () => value,
	    set(headerValue) {
	      this[mapped] = headerValue;
	    }
	  };
	});
	utils$1.freezeMethods(AxiosHeaders);
	var AxiosHeaders$1 = AxiosHeaders;
	function transformData(fns, response) {
	  const config = this || defaults$1;
	  const context = response || config;
	  const headers = AxiosHeaders$1.from(context.headers);
	  let data = context.data;
	  utils$1.forEach(fns, function transform(fn) {
	    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
	  });
	  headers.normalize();
	  return data;
	}
	function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	}
	function CanceledError(message, config, request) {
	  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
	  this.name = "CanceledError";
	}
	utils$1.inherits(CanceledError, AxiosError, {
	  __CANCEL__: true
	});
	function settle(resolve, reject, response) {
	  const validateStatus2 = response.config.validateStatus;
	  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
	    resolve(response);
	  } else {
	    reject(new AxiosError(
	      "Request failed with status code " + response.status,
	      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
	      response.config,
	      response.request,
	      response
	    ));
	  }
	}
	function parseProtocol(url) {
	  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
	  return match && match[1] || "";
	}
	function speedometer(samplesCount, min) {
	  samplesCount = samplesCount || 10;
	  const bytes = new Array(samplesCount);
	  const timestamps = new Array(samplesCount);
	  let head = 0;
	  let tail = 0;
	  let firstSampleTS;
	  min = min !== void 0 ? min : 1e3;
	  return function push(chunkLength) {
	    const now = Date.now();
	    const startedAt = timestamps[tail];
	    if (!firstSampleTS) {
	      firstSampleTS = now;
	    }
	    bytes[head] = chunkLength;
	    timestamps[head] = now;
	    let i = tail;
	    let bytesCount = 0;
	    while (i !== head) {
	      bytesCount += bytes[i++];
	      i = i % samplesCount;
	    }
	    head = (head + 1) % samplesCount;
	    if (head === tail) {
	      tail = (tail + 1) % samplesCount;
	    }
	    if (now - firstSampleTS < min) {
	      return;
	    }
	    const passed = startedAt && now - startedAt;
	    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
	  };
	}
	function throttle(fn, freq) {
	  let timestamp = 0;
	  let threshold = 1e3 / freq;
	  let lastArgs;
	  let timer;
	  const invoke = (args, now = Date.now()) => {
	    timestamp = now;
	    lastArgs = null;
	    if (timer) {
	      clearTimeout(timer);
	      timer = null;
	    }
	    fn(...args);
	  };
	  const throttled = (...args) => {
	    const now = Date.now();
	    const passed = now - timestamp;
	    if (passed >= threshold) {
	      invoke(args, now);
	    } else {
	      lastArgs = args;
	      if (!timer) {
	        timer = setTimeout(() => {
	          timer = null;
	          invoke(lastArgs);
	        }, threshold - passed);
	      }
	    }
	  };
	  const flush = () => lastArgs && invoke(lastArgs);
	  return [throttled, flush];
	}
	const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
	  let bytesNotified = 0;
	  const _speedometer = speedometer(50, 250);
	  return throttle((e) => {
	    const loaded = e.loaded;
	    const total = e.lengthComputable ? e.total : void 0;
	    const progressBytes = loaded - bytesNotified;
	    const rate = _speedometer(progressBytes);
	    const inRange = loaded <= total;
	    bytesNotified = loaded;
	    const data = {
	      loaded,
	      total,
	      progress: total ? loaded / total : void 0,
	      bytes: progressBytes,
	      rate: rate ? rate : void 0,
	      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
	      event: e,
	      lengthComputable: total != null,
	      [isDownloadStream ? "download" : "upload"]: true
	    };
	    listener(data);
	  }, freq);
	};
	const progressEventDecorator = (total, throttled) => {
	  const lengthComputable = total != null;
	  return [(loaded) => throttled[0]({
	    lengthComputable,
	    total,
	    loaded
	  }), throttled[1]];
	};
	const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
	var isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
	  url = new URL(url, platform.origin);
	  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
	})(
	  new URL(platform.origin),
	  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
	) : () => true;
	var cookies = platform.hasStandardBrowserEnv ? (
	  // Standard browser envs support document.cookie
	  {
	    write(name, value, expires, path, domain, secure) {
	      const cookie = [name + "=" + encodeURIComponent(value)];
	      utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
	      utils$1.isString(path) && cookie.push("path=" + path);
	      utils$1.isString(domain) && cookie.push("domain=" + domain);
	      secure === true && cookie.push("secure");
	      document.cookie = cookie.join("; ");
	    },
	    read(name) {
	      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
	      return match ? decodeURIComponent(match[3]) : null;
	    },
	    remove(name) {
	      this.write(name, "", Date.now() - 864e5);
	    }
	  }
	) : (
	  // Non-standard browser env (web workers, react-native) lack needed support.
	  {
	    write() {
	    },
	    read() {
	      return null;
	    },
	    remove() {
	    }
	  }
	);
	function isAbsoluteURL(url) {
	  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
	}
	function combineURLs(baseURL, relativeURL) {
	  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
	}
	function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
	  let isRelativeUrl = !isAbsoluteURL(requestedURL);
	  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
	    return combineURLs(baseURL, requestedURL);
	  }
	  return requestedURL;
	}
	const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
	function mergeConfig(config1, config2) {
	  config2 = config2 || {};
	  const config = {};
	  function getMergedValue(target, source, prop, caseless) {
	    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
	      return utils$1.merge.call({ caseless }, target, source);
	    } else if (utils$1.isPlainObject(source)) {
	      return utils$1.merge({}, source);
	    } else if (utils$1.isArray(source)) {
	      return source.slice();
	    }
	    return source;
	  }
	  function mergeDeepProperties(a, b, prop, caseless) {
	    if (!utils$1.isUndefined(b)) {
	      return getMergedValue(a, b, prop, caseless);
	    } else if (!utils$1.isUndefined(a)) {
	      return getMergedValue(void 0, a, prop, caseless);
	    }
	  }
	  function valueFromConfig2(a, b) {
	    if (!utils$1.isUndefined(b)) {
	      return getMergedValue(void 0, b);
	    }
	  }
	  function defaultToConfig2(a, b) {
	    if (!utils$1.isUndefined(b)) {
	      return getMergedValue(void 0, b);
	    } else if (!utils$1.isUndefined(a)) {
	      return getMergedValue(void 0, a);
	    }
	  }
	  function mergeDirectKeys(a, b, prop) {
	    if (prop in config2) {
	      return getMergedValue(a, b);
	    } else if (prop in config1) {
	      return getMergedValue(void 0, a);
	    }
	  }
	  const mergeMap = {
	    url: valueFromConfig2,
	    method: valueFromConfig2,
	    data: valueFromConfig2,
	    baseURL: defaultToConfig2,
	    transformRequest: defaultToConfig2,
	    transformResponse: defaultToConfig2,
	    paramsSerializer: defaultToConfig2,
	    timeout: defaultToConfig2,
	    timeoutMessage: defaultToConfig2,
	    withCredentials: defaultToConfig2,
	    withXSRFToken: defaultToConfig2,
	    adapter: defaultToConfig2,
	    responseType: defaultToConfig2,
	    xsrfCookieName: defaultToConfig2,
	    xsrfHeaderName: defaultToConfig2,
	    onUploadProgress: defaultToConfig2,
	    onDownloadProgress: defaultToConfig2,
	    decompress: defaultToConfig2,
	    maxContentLength: defaultToConfig2,
	    maxBodyLength: defaultToConfig2,
	    beforeRedirect: defaultToConfig2,
	    transport: defaultToConfig2,
	    httpAgent: defaultToConfig2,
	    httpsAgent: defaultToConfig2,
	    cancelToken: defaultToConfig2,
	    socketPath: defaultToConfig2,
	    responseEncoding: defaultToConfig2,
	    validateStatus: mergeDirectKeys,
	    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
	  };
	  utils$1.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
	    const merge2 = mergeMap[prop] || mergeDeepProperties;
	    const configValue = merge2(config1[prop], config2[prop], prop);
	    utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
	  });
	  return config;
	}
	var resolveConfig = (config) => {
	  const newConfig = mergeConfig({}, config);
	  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
	  newConfig.headers = headers = AxiosHeaders$1.from(headers);
	  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
	  if (auth) {
	    headers.set(
	      "Authorization",
	      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
	    );
	  }
	  let contentType;
	  if (utils$1.isFormData(data)) {
	    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
	      headers.setContentType(void 0);
	    } else if ((contentType = headers.getContentType()) !== false) {
	      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
	      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
	    }
	  }
	  if (platform.hasStandardBrowserEnv) {
	    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
	    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
	      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
	      if (xsrfValue) {
	        headers.set(xsrfHeaderName, xsrfValue);
	      }
	    }
	  }
	  return newConfig;
	};
	const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
	var xhrAdapter = isXHRAdapterSupported && function(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    const _config = resolveConfig(config);
	    let requestData = _config.data;
	    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
	    let { responseType, onUploadProgress, onDownloadProgress } = _config;
	    let onCanceled;
	    let uploadThrottled, downloadThrottled;
	    let flushUpload, flushDownload;
	    function done() {
	      flushUpload && flushUpload();
	      flushDownload && flushDownload();
	      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
	      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
	    }
	    let request = new XMLHttpRequest();
	    request.open(_config.method.toUpperCase(), _config.url, true);
	    request.timeout = _config.timeout;
	    function onloadend() {
	      if (!request) {
	        return;
	      }
	      const responseHeaders = AxiosHeaders$1.from(
	        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
	      );
	      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
	      const response = {
	        data: responseData,
	        status: request.status,
	        statusText: request.statusText,
	        headers: responseHeaders,
	        config,
	        request
	      };
	      settle(function _resolve(value) {
	        resolve(value);
	        done();
	      }, function _reject(err) {
	        reject(err);
	        done();
	      }, response);
	      request = null;
	    }
	    if ("onloadend" in request) {
	      request.onloadend = onloadend;
	    } else {
	      request.onreadystatechange = function handleLoad() {
	        if (!request || request.readyState !== 4) {
	          return;
	        }
	        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
	          return;
	        }
	        setTimeout(onloadend);
	      };
	    }
	    request.onabort = function handleAbort() {
	      if (!request) {
	        return;
	      }
	      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
	      request = null;
	    };
	    request.onerror = function handleError() {
	      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
	      request = null;
	    };
	    request.ontimeout = function handleTimeout() {
	      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
	      const transitional2 = _config.transitional || transitionalDefaults;
	      if (_config.timeoutErrorMessage) {
	        timeoutErrorMessage = _config.timeoutErrorMessage;
	      }
	      reject(new AxiosError(
	        timeoutErrorMessage,
	        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
	        config,
	        request
	      ));
	      request = null;
	    };
	    requestData === void 0 && requestHeaders.setContentType(null);
	    if ("setRequestHeader" in request) {
	      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
	        request.setRequestHeader(key, val);
	      });
	    }
	    if (!utils$1.isUndefined(_config.withCredentials)) {
	      request.withCredentials = !!_config.withCredentials;
	    }
	    if (responseType && responseType !== "json") {
	      request.responseType = _config.responseType;
	    }
	    if (onDownloadProgress) {
	      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
	      request.addEventListener("progress", downloadThrottled);
	    }
	    if (onUploadProgress && request.upload) {
	      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
	      request.upload.addEventListener("progress", uploadThrottled);
	      request.upload.addEventListener("loadend", flushUpload);
	    }
	    if (_config.cancelToken || _config.signal) {
	      onCanceled = (cancel) => {
	        if (!request) {
	          return;
	        }
	        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
	        request.abort();
	        request = null;
	      };
	      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
	      if (_config.signal) {
	        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
	      }
	    }
	    const protocol = parseProtocol(_config.url);
	    if (protocol && platform.protocols.indexOf(protocol) === -1) {
	      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
	      return;
	    }
	    request.send(requestData || null);
	  });
	};
	const composeSignals = (signals, timeout) => {
	  const { length } = signals = signals ? signals.filter(Boolean) : [];
	  if (timeout || length) {
	    let controller = new AbortController();
	    let aborted;
	    const onabort = function(reason) {
	      if (!aborted) {
	        aborted = true;
	        unsubscribe();
	        const err = reason instanceof Error ? reason : this.reason;
	        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
	      }
	    };
	    let timer = timeout && setTimeout(() => {
	      timer = null;
	      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
	    }, timeout);
	    const unsubscribe = () => {
	      if (signals) {
	        timer && clearTimeout(timer);
	        timer = null;
	        signals.forEach((signal2) => {
	          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
	        });
	        signals = null;
	      }
	    };
	    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
	    const { signal } = controller;
	    signal.unsubscribe = () => utils$1.asap(unsubscribe);
	    return signal;
	  }
	};
	var composeSignals$1 = composeSignals;
	const streamChunk = function* (chunk, chunkSize) {
	  let len = chunk.byteLength;
	  if (len < chunkSize) {
	    yield chunk;
	    return;
	  }
	  let pos = 0;
	  let end;
	  while (pos < len) {
	    end = pos + chunkSize;
	    yield chunk.slice(pos, end);
	    pos = end;
	  }
	};
	const readBytes = async function* (iterable, chunkSize) {
	  for await (const chunk of readStream(iterable)) {
	    yield* streamChunk(chunk, chunkSize);
	  }
	};
	const readStream = async function* (stream) {
	  if (stream[Symbol.asyncIterator]) {
	    yield* stream;
	    return;
	  }
	  const reader = stream.getReader();
	  try {
	    for (; ; ) {
	      const { done, value } = await reader.read();
	      if (done) {
	        break;
	      }
	      yield value;
	    }
	  } finally {
	    await reader.cancel();
	  }
	};
	const trackStream = (stream, chunkSize, onProgress, onFinish) => {
	  const iterator2 = readBytes(stream, chunkSize);
	  let bytes = 0;
	  let done;
	  let _onFinish = (e) => {
	    if (!done) {
	      done = true;
	      onFinish && onFinish(e);
	    }
	  };
	  return new ReadableStream({
	    async pull(controller) {
	      try {
	        const { done: done2, value } = await iterator2.next();
	        if (done2) {
	          _onFinish();
	          controller.close();
	          return;
	        }
	        let len = value.byteLength;
	        if (onProgress) {
	          let loadedBytes = bytes += len;
	          onProgress(loadedBytes);
	        }
	        controller.enqueue(new Uint8Array(value));
	      } catch (err) {
	        _onFinish(err);
	        throw err;
	      }
	    },
	    cancel(reason) {
	      _onFinish(reason);
	      return iterator2.return();
	    }
	  }, {
	    highWaterMark: 2
	  });
	};
	const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
	const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
	const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
	const test = (fn, ...args) => {
	  try {
	    return !!fn(...args);
	  } catch (e) {
	    return false;
	  }
	};
	const supportsRequestStream = isReadableStreamSupported && test(() => {
	  let duplexAccessed = false;
	  const hasContentType = new Request(platform.origin, {
	    body: new ReadableStream(),
	    method: "POST",
	    get duplex() {
	      duplexAccessed = true;
	      return "half";
	    }
	  }).headers.has("Content-Type");
	  return duplexAccessed && !hasContentType;
	});
	const DEFAULT_CHUNK_SIZE = 64 * 1024;
	const supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
	const resolvers = {
	  stream: supportsResponseStream && ((res) => res.body)
	};
	isFetchSupported && ((res) => {
	  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
	    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
	      throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
	    });
	  });
	})(new Response());
	const getBodyLength = async (body) => {
	  if (body == null) {
	    return 0;
	  }
	  if (utils$1.isBlob(body)) {
	    return body.size;
	  }
	  if (utils$1.isSpecCompliantForm(body)) {
	    const _request = new Request(platform.origin, {
	      method: "POST",
	      body
	    });
	    return (await _request.arrayBuffer()).byteLength;
	  }
	  if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
	    return body.byteLength;
	  }
	  if (utils$1.isURLSearchParams(body)) {
	    body = body + "";
	  }
	  if (utils$1.isString(body)) {
	    return (await encodeText(body)).byteLength;
	  }
	};
	const resolveBodyLength = async (headers, body) => {
	  const length = utils$1.toFiniteNumber(headers.getContentLength());
	  return length == null ? getBodyLength(body) : length;
	};
	var fetchAdapter = isFetchSupported && (async (config) => {
	  let {
	    url,
	    method,
	    data,
	    signal,
	    cancelToken,
	    timeout,
	    onDownloadProgress,
	    onUploadProgress,
	    responseType,
	    headers,
	    withCredentials = "same-origin",
	    fetchOptions
	  } = resolveConfig(config);
	  responseType = responseType ? (responseType + "").toLowerCase() : "text";
	  let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
	  let request;
	  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
	    composedSignal.unsubscribe();
	  });
	  let requestContentLength;
	  try {
	    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
	      let _request = new Request(url, {
	        method: "POST",
	        body: data,
	        duplex: "half"
	      });
	      let contentTypeHeader;
	      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
	        headers.setContentType(contentTypeHeader);
	      }
	      if (_request.body) {
	        const [onProgress, flush] = progressEventDecorator(
	          requestContentLength,
	          progressEventReducer(asyncDecorator(onUploadProgress))
	        );
	        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
	      }
	    }
	    if (!utils$1.isString(withCredentials)) {
	      withCredentials = withCredentials ? "include" : "omit";
	    }
	    const isCredentialsSupported = "credentials" in Request.prototype;
	    request = new Request(url, {
	      ...fetchOptions,
	      signal: composedSignal,
	      method: method.toUpperCase(),
	      headers: headers.normalize().toJSON(),
	      body: data,
	      duplex: "half",
	      credentials: isCredentialsSupported ? withCredentials : void 0
	    });
	    let response = await fetch(request, fetchOptions);
	    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
	    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
	      const options = {};
	      ["status", "statusText", "headers"].forEach((prop) => {
	        options[prop] = response[prop];
	      });
	      const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
	      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
	        responseContentLength,
	        progressEventReducer(asyncDecorator(onDownloadProgress), true)
	      ) || [];
	      response = new Response(
	        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
	          flush && flush();
	          unsubscribe && unsubscribe();
	        }),
	        options
	      );
	    }
	    responseType = responseType || "text";
	    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
	    !isStreamResponse && unsubscribe && unsubscribe();
	    return await new Promise((resolve, reject) => {
	      settle(resolve, reject, {
	        data: responseData,
	        headers: AxiosHeaders$1.from(response.headers),
	        status: response.status,
	        statusText: response.statusText,
	        config,
	        request
	      });
	    });
	  } catch (err) {
	    unsubscribe && unsubscribe();
	    if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
	      throw Object.assign(
	        new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request),
	        {
	          cause: err.cause || err
	        }
	      );
	    }
	    throw AxiosError.from(err, err && err.code, config, request);
	  }
	});
	const knownAdapters = {
	  http: httpAdapter,
	  xhr: xhrAdapter,
	  fetch: fetchAdapter
	};
	utils$1.forEach(knownAdapters, (fn, value) => {
	  if (fn) {
	    try {
	      Object.defineProperty(fn, "name", { value });
	    } catch (e) {
	    }
	    Object.defineProperty(fn, "adapterName", { value });
	  }
	});
	const renderReason = (reason) => `- ${reason}`;
	const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
	var adapters = {
	  getAdapter: (adapters2) => {
	    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
	    const { length } = adapters2;
	    let nameOrAdapter;
	    let adapter;
	    const rejectedReasons = {};
	    for (let i = 0; i < length; i++) {
	      nameOrAdapter = adapters2[i];
	      let id;
	      adapter = nameOrAdapter;
	      if (!isResolvedHandle(nameOrAdapter)) {
	        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
	        if (adapter === void 0) {
	          throw new AxiosError(`Unknown adapter '${id}'`);
	        }
	      }
	      if (adapter) {
	        break;
	      }
	      rejectedReasons[id || "#" + i] = adapter;
	    }
	    if (!adapter) {
	      const reasons = Object.entries(rejectedReasons).map(
	        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
	      );
	      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
	      throw new AxiosError(
	        `There is no suitable adapter to dispatch the request ` + s,
	        "ERR_NOT_SUPPORT"
	      );
	    }
	    return adapter;
	  },
	  adapters: knownAdapters
	};
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }
	  if (config.signal && config.signal.aborted) {
	    throw new CanceledError(null, config);
	  }
	}
	function dispatchRequest(config) {
	  throwIfCancellationRequested(config);
	  config.headers = AxiosHeaders$1.from(config.headers);
	  config.data = transformData.call(
	    config,
	    config.transformRequest
	  );
	  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
	    config.headers.setContentType("application/x-www-form-urlencoded", false);
	  }
	  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);
	    response.data = transformData.call(
	      config,
	      config.transformResponse,
	      response
	    );
	    response.headers = AxiosHeaders$1.from(response.headers);
	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel(reason)) {
	      throwIfCancellationRequested(config);
	      if (reason && reason.response) {
	        reason.response.data = transformData.call(
	          config,
	          config.transformResponse,
	          reason.response
	        );
	        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
	      }
	    }
	    return Promise.reject(reason);
	  });
	}
	const VERSION = "1.11.0";
	const validators$1 = {};
	["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
	  validators$1[type] = function validator2(thing) {
	    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
	  };
	});
	const deprecatedWarnings = {};
	validators$1.transitional = function transitional(validator2, version, message) {
	  function formatMessage(opt, desc) {
	    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
	  }
	  return (value, opt, opts) => {
	    if (validator2 === false) {
	      throw new AxiosError(
	        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
	        AxiosError.ERR_DEPRECATED
	      );
	    }
	    if (version && !deprecatedWarnings[opt]) {
	      deprecatedWarnings[opt] = true;
	      console.warn(
	        formatMessage(
	          opt,
	          " has been deprecated since v" + version + " and will be removed in the near future"
	        )
	      );
	    }
	    return validator2 ? validator2(value, opt, opts) : true;
	  };
	};
	validators$1.spelling = function spelling(correctSpelling) {
	  return (value, opt) => {
	    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
	    return true;
	  };
	};
	function assertOptions(options, schema, allowUnknown) {
	  if (typeof options !== "object") {
	    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
	  }
	  const keys = Object.keys(options);
	  let i = keys.length;
	  while (i-- > 0) {
	    const opt = keys[i];
	    const validator2 = schema[opt];
	    if (validator2) {
	      const value = options[opt];
	      const result = value === void 0 || validator2(value, opt, options);
	      if (result !== true) {
	        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
	      }
	      continue;
	    }
	    if (allowUnknown !== true) {
	      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
	    }
	  }
	}
	var validator = {
	  assertOptions,
	  validators: validators$1
	};
	const validators = validator.validators;
	class Axios {
	  constructor(instanceConfig) {
	    this.defaults = instanceConfig || {};
	    this.interceptors = {
	      request: new InterceptorManager$1(),
	      response: new InterceptorManager$1()
	    };
	  }
	  /**
	   * Dispatch a request
	   *
	   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
	   * @param {?Object} config
	   *
	   * @returns {Promise} The Promise to be fulfilled
	   */
	  async request(configOrUrl, config) {
	    try {
	      return await this._request(configOrUrl, config);
	    } catch (err) {
	      if (err instanceof Error) {
	        let dummy = {};
	        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
	        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
	        try {
	          if (!err.stack) {
	            err.stack = stack;
	          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
	            err.stack += "\n" + stack;
	          }
	        } catch (e) {
	        }
	      }
	      throw err;
	    }
	  }
	  _request(configOrUrl, config) {
	    if (typeof configOrUrl === "string") {
	      config = config || {};
	      config.url = configOrUrl;
	    } else {
	      config = configOrUrl || {};
	    }
	    config = mergeConfig(this.defaults, config);
	    const { transitional: transitional2, paramsSerializer, headers } = config;
	    if (transitional2 !== void 0) {
	      validator.assertOptions(transitional2, {
	        silentJSONParsing: validators.transitional(validators.boolean),
	        forcedJSONParsing: validators.transitional(validators.boolean),
	        clarifyTimeoutError: validators.transitional(validators.boolean)
	      }, false);
	    }
	    if (paramsSerializer != null) {
	      if (utils$1.isFunction(paramsSerializer)) {
	        config.paramsSerializer = {
	          serialize: paramsSerializer
	        };
	      } else {
	        validator.assertOptions(paramsSerializer, {
	          encode: validators.function,
	          serialize: validators.function
	        }, true);
	      }
	    }
	    if (config.allowAbsoluteUrls !== void 0) ;
	    else if (this.defaults.allowAbsoluteUrls !== void 0) {
	      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
	    } else {
	      config.allowAbsoluteUrls = true;
	    }
	    validator.assertOptions(config, {
	      baseUrl: validators.spelling("baseURL"),
	      withXsrfToken: validators.spelling("withXSRFToken")
	    }, true);
	    config.method = (config.method || this.defaults.method || "get").toLowerCase();
	    let contextHeaders = headers && utils$1.merge(
	      headers.common,
	      headers[config.method]
	    );
	    headers && utils$1.forEach(
	      ["delete", "get", "head", "post", "put", "patch", "common"],
	      (method) => {
	        delete headers[method];
	      }
	    );
	    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
	    const requestInterceptorChain = [];
	    let synchronousRequestInterceptors = true;
	    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
	        return;
	      }
	      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
	      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
	    });
	    const responseInterceptorChain = [];
	    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
	    });
	    let promise;
	    let i = 0;
	    let len;
	    if (!synchronousRequestInterceptors) {
	      const chain = [dispatchRequest.bind(this), void 0];
	      chain.unshift(...requestInterceptorChain);
	      chain.push(...responseInterceptorChain);
	      len = chain.length;
	      promise = Promise.resolve(config);
	      while (i < len) {
	        promise = promise.then(chain[i++], chain[i++]);
	      }
	      return promise;
	    }
	    len = requestInterceptorChain.length;
	    let newConfig = config;
	    i = 0;
	    while (i < len) {
	      const onFulfilled = requestInterceptorChain[i++];
	      const onRejected = requestInterceptorChain[i++];
	      try {
	        newConfig = onFulfilled(newConfig);
	      } catch (error) {
	        onRejected.call(this, error);
	        break;
	      }
	    }
	    try {
	      promise = dispatchRequest.call(this, newConfig);
	    } catch (error) {
	      return Promise.reject(error);
	    }
	    i = 0;
	    len = responseInterceptorChain.length;
	    while (i < len) {
	      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
	    }
	    return promise;
	  }
	  getUri(config) {
	    config = mergeConfig(this.defaults, config);
	    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
	    return buildURL(fullPath, config.params, config.paramsSerializer);
	  }
	}
	utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
	  Axios.prototype[method] = function(url, config) {
	    return this.request(mergeConfig(config || {}, {
	      method,
	      url,
	      data: (config || {}).data
	    }));
	  };
	});
	utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
	  function generateHTTPMethod(isForm) {
	    return function httpMethod(url, data, config) {
	      return this.request(mergeConfig(config || {}, {
	        method,
	        headers: isForm ? {
	          "Content-Type": "multipart/form-data"
	        } : {},
	        url,
	        data
	      }));
	    };
	  }
	  Axios.prototype[method] = generateHTTPMethod();
	  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
	});
	var Axios$1 = Axios;
	class CancelToken {
	  constructor(executor) {
	    if (typeof executor !== "function") {
	      throw new TypeError("executor must be a function.");
	    }
	    let resolvePromise;
	    this.promise = new Promise(function promiseExecutor(resolve) {
	      resolvePromise = resolve;
	    });
	    const token = this;
	    this.promise.then((cancel) => {
	      if (!token._listeners) return;
	      let i = token._listeners.length;
	      while (i-- > 0) {
	        token._listeners[i](cancel);
	      }
	      token._listeners = null;
	    });
	    this.promise.then = (onfulfilled) => {
	      let _resolve;
	      const promise = new Promise((resolve) => {
	        token.subscribe(resolve);
	        _resolve = resolve;
	      }).then(onfulfilled);
	      promise.cancel = function reject() {
	        token.unsubscribe(_resolve);
	      };
	      return promise;
	    };
	    executor(function cancel(message, config, request) {
	      if (token.reason) {
	        return;
	      }
	      token.reason = new CanceledError(message, config, request);
	      resolvePromise(token.reason);
	    });
	  }
	  /**
	   * Throws a `CanceledError` if cancellation has been requested.
	   */
	  throwIfRequested() {
	    if (this.reason) {
	      throw this.reason;
	    }
	  }
	  /**
	   * Subscribe to the cancel signal
	   */
	  subscribe(listener) {
	    if (this.reason) {
	      listener(this.reason);
	      return;
	    }
	    if (this._listeners) {
	      this._listeners.push(listener);
	    } else {
	      this._listeners = [listener];
	    }
	  }
	  /**
	   * Unsubscribe from the cancel signal
	   */
	  unsubscribe(listener) {
	    if (!this._listeners) {
	      return;
	    }
	    const index = this._listeners.indexOf(listener);
	    if (index !== -1) {
	      this._listeners.splice(index, 1);
	    }
	  }
	  toAbortSignal() {
	    const controller = new AbortController();
	    const abort = (err) => {
	      controller.abort(err);
	    };
	    this.subscribe(abort);
	    controller.signal.unsubscribe = () => this.unsubscribe(abort);
	    return controller.signal;
	  }
	  /**
	   * Returns an object that contains a new `CancelToken` and a function that, when called,
	   * cancels the `CancelToken`.
	   */
	  static source() {
	    let cancel;
	    const token = new CancelToken(function executor(c) {
	      cancel = c;
	    });
	    return {
	      token,
	      cancel
	    };
	  }
	}
	var CancelToken$1 = CancelToken;
	function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	}
	function isAxiosError(payload) {
	  return utils$1.isObject(payload) && payload.isAxiosError === true;
	}
	const HttpStatusCode = {
	  Continue: 100,
	  SwitchingProtocols: 101,
	  Processing: 102,
	  EarlyHints: 103,
	  Ok: 200,
	  Created: 201,
	  Accepted: 202,
	  NonAuthoritativeInformation: 203,
	  NoContent: 204,
	  ResetContent: 205,
	  PartialContent: 206,
	  MultiStatus: 207,
	  AlreadyReported: 208,
	  ImUsed: 226,
	  MultipleChoices: 300,
	  MovedPermanently: 301,
	  Found: 302,
	  SeeOther: 303,
	  NotModified: 304,
	  UseProxy: 305,
	  Unused: 306,
	  TemporaryRedirect: 307,
	  PermanentRedirect: 308,
	  BadRequest: 400,
	  Unauthorized: 401,
	  PaymentRequired: 402,
	  Forbidden: 403,
	  NotFound: 404,
	  MethodNotAllowed: 405,
	  NotAcceptable: 406,
	  ProxyAuthenticationRequired: 407,
	  RequestTimeout: 408,
	  Conflict: 409,
	  Gone: 410,
	  LengthRequired: 411,
	  PreconditionFailed: 412,
	  PayloadTooLarge: 413,
	  UriTooLong: 414,
	  UnsupportedMediaType: 415,
	  RangeNotSatisfiable: 416,
	  ExpectationFailed: 417,
	  ImATeapot: 418,
	  MisdirectedRequest: 421,
	  UnprocessableEntity: 422,
	  Locked: 423,
	  FailedDependency: 424,
	  TooEarly: 425,
	  UpgradeRequired: 426,
	  PreconditionRequired: 428,
	  TooManyRequests: 429,
	  RequestHeaderFieldsTooLarge: 431,
	  UnavailableForLegalReasons: 451,
	  InternalServerError: 500,
	  NotImplemented: 501,
	  BadGateway: 502,
	  ServiceUnavailable: 503,
	  GatewayTimeout: 504,
	  HttpVersionNotSupported: 505,
	  VariantAlsoNegotiates: 506,
	  InsufficientStorage: 507,
	  LoopDetected: 508,
	  NotExtended: 510,
	  NetworkAuthenticationRequired: 511
	};
	Object.entries(HttpStatusCode).forEach(([key, value]) => {
	  HttpStatusCode[value] = key;
	});
	var HttpStatusCode$1 = HttpStatusCode;
	function createInstance(defaultConfig) {
	  const context = new Axios$1(defaultConfig);
	  const instance = bind(Axios$1.prototype.request, context);
	  utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
	  utils$1.extend(instance, context, null, { allOwnKeys: true });
	  instance.create = function create(instanceConfig) {
	    return createInstance(mergeConfig(defaultConfig, instanceConfig));
	  };
	  return instance;
	}
	const axios = createInstance(defaults$1);
	axios.Axios = Axios$1;
	axios.CanceledError = CanceledError;
	axios.CancelToken = CancelToken$1;
	axios.isCancel = isCancel;
	axios.VERSION = VERSION;
	axios.toFormData = toFormData;
	axios.AxiosError = AxiosError;
	axios.Cancel = axios.CanceledError;
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios.spread = spread;
	axios.isAxiosError = isAxiosError;
	axios.mergeConfig = mergeConfig;
	axios.AxiosHeaders = AxiosHeaders$1;
	axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
	axios.getAdapter = adapters.getAdapter;
	axios.HttpStatusCode = HttpStatusCode$1;
	axios.default = axios;
	axios_1 = axios;
	return axios_1;
}

var zod = {};

var external = {};

var errors$a = {};

var en$1 = {};

var ZodError = {};

var util$8 = {};

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util$8;
	hasRequiredUtil = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;
		var util;
		(function (util) {
		    util.assertEqual = (_) => { };
		    function assertIs(_arg) { }
		    util.assertIs = assertIs;
		    function assertNever(_x) {
		        throw new Error();
		    }
		    util.assertNever = assertNever;
		    util.arrayToEnum = (items) => {
		        const obj = {};
		        for (const item of items) {
		            obj[item] = item;
		        }
		        return obj;
		    };
		    util.getValidEnumValues = (obj) => {
		        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
		        const filtered = {};
		        for (const k of validKeys) {
		            filtered[k] = obj[k];
		        }
		        return util.objectValues(filtered);
		    };
		    util.objectValues = (obj) => {
		        return util.objectKeys(obj).map(function (e) {
		            return obj[e];
		        });
		    };
		    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
		        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
		        : (object) => {
		            const keys = [];
		            for (const key in object) {
		                if (Object.prototype.hasOwnProperty.call(object, key)) {
		                    keys.push(key);
		                }
		            }
		            return keys;
		        };
		    util.find = (arr, checker) => {
		        for (const item of arr) {
		            if (checker(item))
		                return item;
		        }
		        return undefined;
		    };
		    util.isInteger = typeof Number.isInteger === "function"
		        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
		        : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
		    function joinValues(array, separator = " | ") {
		        return array.map((val) => (typeof val === "string" ? `'${val}'` : val)).join(separator);
		    }
		    util.joinValues = joinValues;
		    util.jsonStringifyReplacer = (_, value) => {
		        if (typeof value === "bigint") {
		            return value.toString();
		        }
		        return value;
		    };
		})(util || (exports.util = util = {}));
		var objectUtil;
		(function (objectUtil) {
		    objectUtil.mergeShapes = (first, second) => {
		        return {
		            ...first,
		            ...second, // second overwrites first
		        };
		    };
		})(objectUtil || (exports.objectUtil = objectUtil = {}));
		exports.ZodParsedType = util.arrayToEnum([
		    "string",
		    "nan",
		    "number",
		    "integer",
		    "float",
		    "boolean",
		    "date",
		    "bigint",
		    "symbol",
		    "function",
		    "undefined",
		    "null",
		    "array",
		    "object",
		    "unknown",
		    "promise",
		    "void",
		    "never",
		    "map",
		    "set",
		]);
		const getParsedType = (data) => {
		    const t = typeof data;
		    switch (t) {
		        case "undefined":
		            return exports.ZodParsedType.undefined;
		        case "string":
		            return exports.ZodParsedType.string;
		        case "number":
		            return Number.isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
		        case "boolean":
		            return exports.ZodParsedType.boolean;
		        case "function":
		            return exports.ZodParsedType.function;
		        case "bigint":
		            return exports.ZodParsedType.bigint;
		        case "symbol":
		            return exports.ZodParsedType.symbol;
		        case "object":
		            if (Array.isArray(data)) {
		                return exports.ZodParsedType.array;
		            }
		            if (data === null) {
		                return exports.ZodParsedType.null;
		            }
		            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
		                return exports.ZodParsedType.promise;
		            }
		            if (typeof Map !== "undefined" && data instanceof Map) {
		                return exports.ZodParsedType.map;
		            }
		            if (typeof Set !== "undefined" && data instanceof Set) {
		                return exports.ZodParsedType.set;
		            }
		            if (typeof Date !== "undefined" && data instanceof Date) {
		                return exports.ZodParsedType.date;
		            }
		            return exports.ZodParsedType.object;
		        default:
		            return exports.ZodParsedType.unknown;
		    }
		};
		exports.getParsedType = getParsedType; 
	} (util$8));
	return util$8;
}

var hasRequiredZodError;

function requireZodError () {
	if (hasRequiredZodError) return ZodError;
	hasRequiredZodError = 1;
	Object.defineProperty(ZodError, "__esModule", { value: true });
	ZodError.ZodError = ZodError.quotelessJson = ZodError.ZodIssueCode = void 0;
	const util_js_1 = /*@__PURE__*/ requireUtil();
	ZodError.ZodIssueCode = util_js_1.util.arrayToEnum([
	    "invalid_type",
	    "invalid_literal",
	    "custom",
	    "invalid_union",
	    "invalid_union_discriminator",
	    "invalid_enum_value",
	    "unrecognized_keys",
	    "invalid_arguments",
	    "invalid_return_type",
	    "invalid_date",
	    "invalid_string",
	    "too_small",
	    "too_big",
	    "invalid_intersection_types",
	    "not_multiple_of",
	    "not_finite",
	]);
	const quotelessJson = (obj) => {
	    const json = JSON.stringify(obj, null, 2);
	    return json.replace(/"([^"]+)":/g, "$1:");
	};
	ZodError.quotelessJson = quotelessJson;
	let ZodError$1 = class ZodError extends Error {
	    get errors() {
	        return this.issues;
	    }
	    constructor(issues) {
	        super();
	        this.issues = [];
	        this.addIssue = (sub) => {
	            this.issues = [...this.issues, sub];
	        };
	        this.addIssues = (subs = []) => {
	            this.issues = [...this.issues, ...subs];
	        };
	        const actualProto = new.target.prototype;
	        if (Object.setPrototypeOf) {
	            // eslint-disable-next-line ban/ban
	            Object.setPrototypeOf(this, actualProto);
	        }
	        else {
	            this.__proto__ = actualProto;
	        }
	        this.name = "ZodError";
	        this.issues = issues;
	    }
	    format(_mapper) {
	        const mapper = _mapper ||
	            function (issue) {
	                return issue.message;
	            };
	        const fieldErrors = { _errors: [] };
	        const processError = (error) => {
	            for (const issue of error.issues) {
	                if (issue.code === "invalid_union") {
	                    issue.unionErrors.map(processError);
	                }
	                else if (issue.code === "invalid_return_type") {
	                    processError(issue.returnTypeError);
	                }
	                else if (issue.code === "invalid_arguments") {
	                    processError(issue.argumentsError);
	                }
	                else if (issue.path.length === 0) {
	                    fieldErrors._errors.push(mapper(issue));
	                }
	                else {
	                    let curr = fieldErrors;
	                    let i = 0;
	                    while (i < issue.path.length) {
	                        const el = issue.path[i];
	                        const terminal = i === issue.path.length - 1;
	                        if (!terminal) {
	                            curr[el] = curr[el] || { _errors: [] };
	                            // if (typeof el === "string") {
	                            //   curr[el] = curr[el] || { _errors: [] };
	                            // } else if (typeof el === "number") {
	                            //   const errorArray: any = [];
	                            //   errorArray._errors = [];
	                            //   curr[el] = curr[el] || errorArray;
	                            // }
	                        }
	                        else {
	                            curr[el] = curr[el] || { _errors: [] };
	                            curr[el]._errors.push(mapper(issue));
	                        }
	                        curr = curr[el];
	                        i++;
	                    }
	                }
	            }
	        };
	        processError(this);
	        return fieldErrors;
	    }
	    static assert(value) {
	        if (!(value instanceof ZodError)) {
	            throw new Error(`Not a ZodError: ${value}`);
	        }
	    }
	    toString() {
	        return this.message;
	    }
	    get message() {
	        return JSON.stringify(this.issues, util_js_1.util.jsonStringifyReplacer, 2);
	    }
	    get isEmpty() {
	        return this.issues.length === 0;
	    }
	    flatten(mapper = (issue) => issue.message) {
	        const fieldErrors = {};
	        const formErrors = [];
	        for (const sub of this.issues) {
	            if (sub.path.length > 0) {
	                const firstEl = sub.path[0];
	                fieldErrors[firstEl] = fieldErrors[firstEl] || [];
	                fieldErrors[firstEl].push(mapper(sub));
	            }
	            else {
	                formErrors.push(mapper(sub));
	            }
	        }
	        return { formErrors, fieldErrors };
	    }
	    get formErrors() {
	        return this.flatten();
	    }
	};
	ZodError.ZodError = ZodError$1;
	ZodError$1.create = (issues) => {
	    const error = new ZodError$1(issues);
	    return error;
	};
	return ZodError;
}

var hasRequiredEn;

function requireEn () {
	if (hasRequiredEn) return en$1;
	hasRequiredEn = 1;
	Object.defineProperty(en$1, "__esModule", { value: true });
	const ZodError_js_1 = /*@__PURE__*/ requireZodError();
	const util_js_1 = /*@__PURE__*/ requireUtil();
	const errorMap = (issue, _ctx) => {
	    let message;
	    switch (issue.code) {
	        case ZodError_js_1.ZodIssueCode.invalid_type:
	            if (issue.received === util_js_1.ZodParsedType.undefined) {
	                message = "Required";
	            }
	            else {
	                message = `Expected ${issue.expected}, received ${issue.received}`;
	            }
	            break;
	        case ZodError_js_1.ZodIssueCode.invalid_literal:
	            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_js_1.util.jsonStringifyReplacer)}`;
	            break;
	        case ZodError_js_1.ZodIssueCode.unrecognized_keys:
	            message = `Unrecognized key(s) in object: ${util_js_1.util.joinValues(issue.keys, ", ")}`;
	            break;
	        case ZodError_js_1.ZodIssueCode.invalid_union:
	            message = `Invalid input`;
	            break;
	        case ZodError_js_1.ZodIssueCode.invalid_union_discriminator:
	            message = `Invalid discriminator value. Expected ${util_js_1.util.joinValues(issue.options)}`;
	            break;
	        case ZodError_js_1.ZodIssueCode.invalid_enum_value:
	            message = `Invalid enum value. Expected ${util_js_1.util.joinValues(issue.options)}, received '${issue.received}'`;
	            break;
	        case ZodError_js_1.ZodIssueCode.invalid_arguments:
	            message = `Invalid function arguments`;
	            break;
	        case ZodError_js_1.ZodIssueCode.invalid_return_type:
	            message = `Invalid function return type`;
	            break;
	        case ZodError_js_1.ZodIssueCode.invalid_date:
	            message = `Invalid date`;
	            break;
	        case ZodError_js_1.ZodIssueCode.invalid_string:
	            if (typeof issue.validation === "object") {
	                if ("includes" in issue.validation) {
	                    message = `Invalid input: must include "${issue.validation.includes}"`;
	                    if (typeof issue.validation.position === "number") {
	                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
	                    }
	                }
	                else if ("startsWith" in issue.validation) {
	                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
	                }
	                else if ("endsWith" in issue.validation) {
	                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
	                }
	                else {
	                    util_js_1.util.assertNever(issue.validation);
	                }
	            }
	            else if (issue.validation !== "regex") {
	                message = `Invalid ${issue.validation}`;
	            }
	            else {
	                message = "Invalid";
	            }
	            break;
	        case ZodError_js_1.ZodIssueCode.too_small:
	            if (issue.type === "array")
	                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
	            else if (issue.type === "string")
	                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
	            else if (issue.type === "number")
	                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
	            else if (issue.type === "bigint")
	                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
	            else if (issue.type === "date")
	                message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
	            else
	                message = "Invalid input";
	            break;
	        case ZodError_js_1.ZodIssueCode.too_big:
	            if (issue.type === "array")
	                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
	            else if (issue.type === "string")
	                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
	            else if (issue.type === "number")
	                message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
	            else if (issue.type === "bigint")
	                message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
	            else if (issue.type === "date")
	                message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
	            else
	                message = "Invalid input";
	            break;
	        case ZodError_js_1.ZodIssueCode.custom:
	            message = `Invalid input`;
	            break;
	        case ZodError_js_1.ZodIssueCode.invalid_intersection_types:
	            message = `Intersection results could not be merged`;
	            break;
	        case ZodError_js_1.ZodIssueCode.not_multiple_of:
	            message = `Number must be a multiple of ${issue.multipleOf}`;
	            break;
	        case ZodError_js_1.ZodIssueCode.not_finite:
	            message = "Number must be finite";
	            break;
	        default:
	            message = _ctx.defaultError;
	            util_js_1.util.assertNever(issue);
	    }
	    return { message };
	};
	en$1.default = errorMap;
	return en$1;
}

var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors$a;
	hasRequiredErrors = 1;
	var __importDefault = (errors$a && errors$a.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(errors$a, "__esModule", { value: true });
	errors$a.defaultErrorMap = void 0;
	errors$a.setErrorMap = setErrorMap;
	errors$a.getErrorMap = getErrorMap;
	const en_js_1 = __importDefault(/*@__PURE__*/ requireEn());
	errors$a.defaultErrorMap = en_js_1.default;
	let overrideErrorMap = en_js_1.default;
	function setErrorMap(map) {
	    overrideErrorMap = map;
	}
	function getErrorMap() {
	    return overrideErrorMap;
	}
	return errors$a;
}

var parseUtil = {};

var hasRequiredParseUtil;

function requireParseUtil () {
	if (hasRequiredParseUtil) return parseUtil;
	hasRequiredParseUtil = 1;
	(function (exports) {
		var __importDefault = parseUtil && parseUtil.__importDefault || function(mod) {
		  return mod && mod.__esModule ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.EMPTY_PATH = exports.makeIssue = void 0;
		exports.addIssueToContext = addIssueToContext;
		const errors_js_1 = /*@__PURE__*/ requireErrors();
		const en_js_1 = __importDefault(/*@__PURE__*/ requireEn());
		const makeIssue = (params) => {
		  const { data, path, errorMaps, issueData } = params;
		  const fullPath = [...path, ...issueData.path || []];
		  const fullIssue = {
		    ...issueData,
		    path: fullPath
		  };
		  if (issueData.message !== void 0) {
		    return {
		      ...issueData,
		      path: fullPath,
		      message: issueData.message
		    };
		  }
		  let errorMessage = "";
		  const maps = errorMaps.filter((m) => !!m).slice().reverse();
		  for (const map of maps) {
		    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
		  }
		  return {
		    ...issueData,
		    path: fullPath,
		    message: errorMessage
		  };
		};
		exports.makeIssue = makeIssue;
		exports.EMPTY_PATH = [];
		function addIssueToContext(ctx, issueData) {
		  const overrideMap = (0, errors_js_1.getErrorMap)();
		  const issue = (0, exports.makeIssue)({
		    issueData,
		    data: ctx.data,
		    path: ctx.path,
		    errorMaps: [
		      ctx.common.contextualErrorMap,
		      // contextual error map is first priority
		      ctx.schemaErrorMap,
		      // then schema-bound map if available
		      overrideMap,
		      // then global override map
		      overrideMap === en_js_1.default ? void 0 : en_js_1.default
		      // then global default map
		    ].filter((x) => !!x)
		  });
		  ctx.common.issues.push(issue);
		}
		class ParseStatus {
		  constructor() {
		    this.value = "valid";
		  }
		  dirty() {
		    if (this.value === "valid")
		      this.value = "dirty";
		  }
		  abort() {
		    if (this.value !== "aborted")
		      this.value = "aborted";
		  }
		  static mergeArray(status, results) {
		    const arrayValue = [];
		    for (const s of results) {
		      if (s.status === "aborted")
		        return exports.INVALID;
		      if (s.status === "dirty")
		        status.dirty();
		      arrayValue.push(s.value);
		    }
		    return { status: status.value, value: arrayValue };
		  }
		  static async mergeObjectAsync(status, pairs) {
		    const syncPairs = [];
		    for (const pair of pairs) {
		      const key = await pair.key;
		      const value = await pair.value;
		      syncPairs.push({
		        key,
		        value
		      });
		    }
		    return ParseStatus.mergeObjectSync(status, syncPairs);
		  }
		  static mergeObjectSync(status, pairs) {
		    const finalObject = {};
		    for (const pair of pairs) {
		      const { key, value } = pair;
		      if (key.status === "aborted")
		        return exports.INVALID;
		      if (value.status === "aborted")
		        return exports.INVALID;
		      if (key.status === "dirty")
		        status.dirty();
		      if (value.status === "dirty")
		        status.dirty();
		      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
		        finalObject[key.value] = value.value;
		      }
		    }
		    return { status: status.value, value: finalObject };
		  }
		}
		exports.ParseStatus = ParseStatus;
		exports.INVALID = Object.freeze({
		  status: "aborted"
		});
		const DIRTY = (value) => ({ status: "dirty", value });
		exports.DIRTY = DIRTY;
		const OK = (value) => ({ status: "valid", value });
		exports.OK = OK;
		const isAborted = (x) => x.status === "aborted";
		exports.isAborted = isAborted;
		const isDirty = (x) => x.status === "dirty";
		exports.isDirty = isDirty;
		const isValid = (x) => x.status === "valid";
		exports.isValid = isValid;
		const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
		exports.isAsync = isAsync; 
	} (parseUtil));
	return parseUtil;
}

var typeAliases = {};

var hasRequiredTypeAliases;

function requireTypeAliases () {
	if (hasRequiredTypeAliases) return typeAliases;
	hasRequiredTypeAliases = 1;
	Object.defineProperty(typeAliases, "__esModule", { value: true });
	return typeAliases;
}

var types = {};

var errorUtil = {};

var hasRequiredErrorUtil;

function requireErrorUtil () {
	if (hasRequiredErrorUtil) return errorUtil;
	hasRequiredErrorUtil = 1;
	Object.defineProperty(errorUtil, "__esModule", { value: true });
	errorUtil.errorUtil = void 0;
	var errorUtil$1;
	(function (errorUtil) {
	    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
	    // biome-ignore lint:
	    errorUtil.toString = (message) => typeof message === "string" ? message : message?.message;
	})(errorUtil$1 || (errorUtil.errorUtil = errorUtil$1 = {}));
	return errorUtil;
}

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types;
	hasRequiredTypes = 1;
	Object.defineProperty(types, "__esModule", { value: true });
	types.discriminatedUnion = types.date = types.boolean = types.bigint = types.array = types.any = types.coerce = types.ZodFirstPartyTypeKind = types.late = types.ZodSchema = types.Schema = types.ZodReadonly = types.ZodPipeline = types.ZodBranded = types.BRAND = types.ZodNaN = types.ZodCatch = types.ZodDefault = types.ZodNullable = types.ZodOptional = types.ZodTransformer = types.ZodEffects = types.ZodPromise = types.ZodNativeEnum = types.ZodEnum = types.ZodLiteral = types.ZodLazy = types.ZodFunction = types.ZodSet = types.ZodMap = types.ZodRecord = types.ZodTuple = types.ZodIntersection = types.ZodDiscriminatedUnion = types.ZodUnion = types.ZodObject = types.ZodArray = types.ZodVoid = types.ZodNever = types.ZodUnknown = types.ZodAny = types.ZodNull = types.ZodUndefined = types.ZodSymbol = types.ZodDate = types.ZodBoolean = types.ZodBigInt = types.ZodNumber = types.ZodString = types.ZodType = void 0;
	types.NEVER = types.void = types.unknown = types.union = types.undefined = types.tuple = types.transformer = types.symbol = types.string = types.strictObject = types.set = types.record = types.promise = types.preprocess = types.pipeline = types.ostring = types.optional = types.onumber = types.oboolean = types.object = types.number = types.nullable = types.null = types.never = types.nativeEnum = types.nan = types.map = types.literal = types.lazy = types.intersection = types.instanceof = types.function = types.enum = types.effect = void 0;
	types.datetimeRegex = datetimeRegex;
	types.custom = custom;
	const ZodError_js_1 = /*@__PURE__*/ requireZodError();
	const errors_js_1 = /*@__PURE__*/ requireErrors();
	const errorUtil_js_1 = /*@__PURE__*/ requireErrorUtil();
	const parseUtil_js_1 = /*@__PURE__*/ requireParseUtil();
	const util_js_1 = /*@__PURE__*/ requireUtil();
	class ParseInputLazyPath {
	    constructor(parent, value, path, key) {
	        this._cachedPath = [];
	        this.parent = parent;
	        this.data = value;
	        this._path = path;
	        this._key = key;
	    }
	    get path() {
	        if (!this._cachedPath.length) {
	            if (Array.isArray(this._key)) {
	                this._cachedPath.push(...this._path, ...this._key);
	            }
	            else {
	                this._cachedPath.push(...this._path, this._key);
	            }
	        }
	        return this._cachedPath;
	    }
	}
	const handleResult = (ctx, result) => {
	    if ((0, parseUtil_js_1.isValid)(result)) {
	        return { success: true, data: result.value };
	    }
	    else {
	        if (!ctx.common.issues.length) {
	            throw new Error("Validation failed but no issues detected.");
	        }
	        return {
	            success: false,
	            get error() {
	                if (this._error)
	                    return this._error;
	                const error = new ZodError_js_1.ZodError(ctx.common.issues);
	                this._error = error;
	                return this._error;
	            },
	        };
	    }
	};
	function processCreateParams(params) {
	    if (!params)
	        return {};
	    const { errorMap, invalid_type_error, required_error, description } = params;
	    if (errorMap && (invalid_type_error || required_error)) {
	        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
	    }
	    if (errorMap)
	        return { errorMap: errorMap, description };
	    const customMap = (iss, ctx) => {
	        const { message } = params;
	        if (iss.code === "invalid_enum_value") {
	            return { message: message ?? ctx.defaultError };
	        }
	        if (typeof ctx.data === "undefined") {
	            return { message: message ?? required_error ?? ctx.defaultError };
	        }
	        if (iss.code !== "invalid_type")
	            return { message: ctx.defaultError };
	        return { message: message ?? invalid_type_error ?? ctx.defaultError };
	    };
	    return { errorMap: customMap, description };
	}
	class ZodType {
	    get description() {
	        return this._def.description;
	    }
	    _getType(input) {
	        return (0, util_js_1.getParsedType)(input.data);
	    }
	    _getOrReturnCtx(input, ctx) {
	        return (ctx || {
	            common: input.parent.common,
	            data: input.data,
	            parsedType: (0, util_js_1.getParsedType)(input.data),
	            schemaErrorMap: this._def.errorMap,
	            path: input.path,
	            parent: input.parent,
	        });
	    }
	    _processInputParams(input) {
	        return {
	            status: new parseUtil_js_1.ParseStatus(),
	            ctx: {
	                common: input.parent.common,
	                data: input.data,
	                parsedType: (0, util_js_1.getParsedType)(input.data),
	                schemaErrorMap: this._def.errorMap,
	                path: input.path,
	                parent: input.parent,
	            },
	        };
	    }
	    _parseSync(input) {
	        const result = this._parse(input);
	        if ((0, parseUtil_js_1.isAsync)(result)) {
	            throw new Error("Synchronous parse encountered promise.");
	        }
	        return result;
	    }
	    _parseAsync(input) {
	        const result = this._parse(input);
	        return Promise.resolve(result);
	    }
	    parse(data, params) {
	        const result = this.safeParse(data, params);
	        if (result.success)
	            return result.data;
	        throw result.error;
	    }
	    safeParse(data, params) {
	        const ctx = {
	            common: {
	                issues: [],
	                async: params?.async ?? false,
	                contextualErrorMap: params?.errorMap,
	            },
	            path: params?.path || [],
	            schemaErrorMap: this._def.errorMap,
	            parent: null,
	            data,
	            parsedType: (0, util_js_1.getParsedType)(data),
	        };
	        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
	        return handleResult(ctx, result);
	    }
	    "~validate"(data) {
	        const ctx = {
	            common: {
	                issues: [],
	                async: !!this["~standard"].async,
	            },
	            path: [],
	            schemaErrorMap: this._def.errorMap,
	            parent: null,
	            data,
	            parsedType: (0, util_js_1.getParsedType)(data),
	        };
	        if (!this["~standard"].async) {
	            try {
	                const result = this._parseSync({ data, path: [], parent: ctx });
	                return (0, parseUtil_js_1.isValid)(result)
	                    ? {
	                        value: result.value,
	                    }
	                    : {
	                        issues: ctx.common.issues,
	                    };
	            }
	            catch (err) {
	                if (err?.message?.toLowerCase()?.includes("encountered")) {
	                    this["~standard"].async = true;
	                }
	                ctx.common = {
	                    issues: [],
	                    async: true,
	                };
	            }
	        }
	        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => (0, parseUtil_js_1.isValid)(result)
	            ? {
	                value: result.value,
	            }
	            : {
	                issues: ctx.common.issues,
	            });
	    }
	    async parseAsync(data, params) {
	        const result = await this.safeParseAsync(data, params);
	        if (result.success)
	            return result.data;
	        throw result.error;
	    }
	    async safeParseAsync(data, params) {
	        const ctx = {
	            common: {
	                issues: [],
	                contextualErrorMap: params?.errorMap,
	                async: true,
	            },
	            path: params?.path || [],
	            schemaErrorMap: this._def.errorMap,
	            parent: null,
	            data,
	            parsedType: (0, util_js_1.getParsedType)(data),
	        };
	        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
	        const result = await ((0, parseUtil_js_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
	        return handleResult(ctx, result);
	    }
	    refine(check, message) {
	        const getIssueProperties = (val) => {
	            if (typeof message === "string" || typeof message === "undefined") {
	                return { message };
	            }
	            else if (typeof message === "function") {
	                return message(val);
	            }
	            else {
	                return message;
	            }
	        };
	        return this._refinement((val, ctx) => {
	            const result = check(val);
	            const setError = () => ctx.addIssue({
	                code: ZodError_js_1.ZodIssueCode.custom,
	                ...getIssueProperties(val),
	            });
	            if (typeof Promise !== "undefined" && result instanceof Promise) {
	                return result.then((data) => {
	                    if (!data) {
	                        setError();
	                        return false;
	                    }
	                    else {
	                        return true;
	                    }
	                });
	            }
	            if (!result) {
	                setError();
	                return false;
	            }
	            else {
	                return true;
	            }
	        });
	    }
	    refinement(check, refinementData) {
	        return this._refinement((val, ctx) => {
	            if (!check(val)) {
	                ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
	                return false;
	            }
	            else {
	                return true;
	            }
	        });
	    }
	    _refinement(refinement) {
	        return new ZodEffects({
	            schema: this,
	            typeName: ZodFirstPartyTypeKind.ZodEffects,
	            effect: { type: "refinement", refinement },
	        });
	    }
	    superRefine(refinement) {
	        return this._refinement(refinement);
	    }
	    constructor(def) {
	        /** Alias of safeParseAsync */
	        this.spa = this.safeParseAsync;
	        this._def = def;
	        this.parse = this.parse.bind(this);
	        this.safeParse = this.safeParse.bind(this);
	        this.parseAsync = this.parseAsync.bind(this);
	        this.safeParseAsync = this.safeParseAsync.bind(this);
	        this.spa = this.spa.bind(this);
	        this.refine = this.refine.bind(this);
	        this.refinement = this.refinement.bind(this);
	        this.superRefine = this.superRefine.bind(this);
	        this.optional = this.optional.bind(this);
	        this.nullable = this.nullable.bind(this);
	        this.nullish = this.nullish.bind(this);
	        this.array = this.array.bind(this);
	        this.promise = this.promise.bind(this);
	        this.or = this.or.bind(this);
	        this.and = this.and.bind(this);
	        this.transform = this.transform.bind(this);
	        this.brand = this.brand.bind(this);
	        this.default = this.default.bind(this);
	        this.catch = this.catch.bind(this);
	        this.describe = this.describe.bind(this);
	        this.pipe = this.pipe.bind(this);
	        this.readonly = this.readonly.bind(this);
	        this.isNullable = this.isNullable.bind(this);
	        this.isOptional = this.isOptional.bind(this);
	        this["~standard"] = {
	            version: 1,
	            vendor: "zod",
	            validate: (data) => this["~validate"](data),
	        };
	    }
	    optional() {
	        return ZodOptional.create(this, this._def);
	    }
	    nullable() {
	        return ZodNullable.create(this, this._def);
	    }
	    nullish() {
	        return this.nullable().optional();
	    }
	    array() {
	        return ZodArray.create(this);
	    }
	    promise() {
	        return ZodPromise.create(this, this._def);
	    }
	    or(option) {
	        return ZodUnion.create([this, option], this._def);
	    }
	    and(incoming) {
	        return ZodIntersection.create(this, incoming, this._def);
	    }
	    transform(transform) {
	        return new ZodEffects({
	            ...processCreateParams(this._def),
	            schema: this,
	            typeName: ZodFirstPartyTypeKind.ZodEffects,
	            effect: { type: "transform", transform },
	        });
	    }
	    default(def) {
	        const defaultValueFunc = typeof def === "function" ? def : () => def;
	        return new ZodDefault({
	            ...processCreateParams(this._def),
	            innerType: this,
	            defaultValue: defaultValueFunc,
	            typeName: ZodFirstPartyTypeKind.ZodDefault,
	        });
	    }
	    brand() {
	        return new ZodBranded({
	            typeName: ZodFirstPartyTypeKind.ZodBranded,
	            type: this,
	            ...processCreateParams(this._def),
	        });
	    }
	    catch(def) {
	        const catchValueFunc = typeof def === "function" ? def : () => def;
	        return new ZodCatch({
	            ...processCreateParams(this._def),
	            innerType: this,
	            catchValue: catchValueFunc,
	            typeName: ZodFirstPartyTypeKind.ZodCatch,
	        });
	    }
	    describe(description) {
	        const This = this.constructor;
	        return new This({
	            ...this._def,
	            description,
	        });
	    }
	    pipe(target) {
	        return ZodPipeline.create(this, target);
	    }
	    readonly() {
	        return ZodReadonly.create(this);
	    }
	    isOptional() {
	        return this.safeParse(undefined).success;
	    }
	    isNullable() {
	        return this.safeParse(null).success;
	    }
	}
	types.ZodType = ZodType;
	types.Schema = ZodType;
	types.ZodSchema = ZodType;
	const cuidRegex = /^c[^\s-]{8,}$/i;
	const cuid2Regex = /^[0-9a-z]+$/;
	const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
	// const uuidRegex =
	//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
	const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
	const nanoidRegex = /^[a-z0-9_-]{21}$/i;
	const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
	const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
	// from https://stackoverflow.com/a/46181/1550155
	// old version: too slow, didn't support unicode
	// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
	//old email regex
	// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
	// eslint-disable-next-line
	// const emailRegex =
	//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
	// const emailRegex =
	//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
	// const emailRegex =
	//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
	const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
	// const emailRegex =
	//   /^[a-z0-9.!#$%&*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
	// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
	const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
	let emojiRegex;
	// faster, simpler, safer
	const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
	const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
	// const ipv6Regex =
	// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
	const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
	const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
	// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
	const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
	// https://base64.guru/standards/base64url
	const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
	// simple
	// const dateRegexSource = `\\d{4}-\\d{2}-\\d{2}`;
	// no leap year validation
	// const dateRegexSource = `\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\d|2\\d))`;
	// with leap year validation
	const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
	const dateRegex = new RegExp(`^${dateRegexSource}$`);
	function timeRegexSource(args) {
	    let secondsRegexSource = `[0-5]\\d`;
	    if (args.precision) {
	        secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
	    }
	    else if (args.precision == null) {
	        secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
	    }
	    const secondsQuantifier = args.precision ? "+" : "?"; // require seconds if precision is nonzero
	    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
	}
	function timeRegex(args) {
	    return new RegExp(`^${timeRegexSource(args)}$`);
	}
	// Adapted from https://stackoverflow.com/a/3143231
	function datetimeRegex(args) {
	    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
	    const opts = [];
	    opts.push(args.local ? `Z?` : `Z`);
	    if (args.offset)
	        opts.push(`([+-]\\d{2}:?\\d{2})`);
	    regex = `${regex}(${opts.join("|")})`;
	    return new RegExp(`^${regex}$`);
	}
	function isValidIP(ip, version) {
	    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
	        return true;
	    }
	    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
	        return true;
	    }
	    return false;
	}
	function isValidJWT(jwt, alg) {
	    if (!jwtRegex.test(jwt))
	        return false;
	    try {
	        const [header] = jwt.split(".");
	        if (!header)
	            return false;
	        // Convert base64url to base64
	        const base64 = header
	            .replace(/-/g, "+")
	            .replace(/_/g, "/")
	            .padEnd(header.length + ((4 - (header.length % 4)) % 4), "=");
	        const decoded = JSON.parse(atob(base64));
	        if (typeof decoded !== "object" || decoded === null)
	            return false;
	        if ("typ" in decoded && decoded?.typ !== "JWT")
	            return false;
	        if (!decoded.alg)
	            return false;
	        if (alg && decoded.alg !== alg)
	            return false;
	        return true;
	    }
	    catch {
	        return false;
	    }
	}
	function isValidCidr(ip, version) {
	    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
	        return true;
	    }
	    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
	        return true;
	    }
	    return false;
	}
	class ZodString extends ZodType {
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = String(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== util_js_1.ZodParsedType.string) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	                expected: util_js_1.ZodParsedType.string,
	                received: ctx.parsedType,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        const status = new parseUtil_js_1.ParseStatus();
	        let ctx = undefined;
	        for (const check of this._def.checks) {
	            if (check.kind === "min") {
	                if (input.data.length < check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        code: ZodError_js_1.ZodIssueCode.too_small,
	                        minimum: check.value,
	                        type: "string",
	                        inclusive: true,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                if (input.data.length > check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        code: ZodError_js_1.ZodIssueCode.too_big,
	                        maximum: check.value,
	                        type: "string",
	                        inclusive: true,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "length") {
	                const tooBig = input.data.length > check.value;
	                const tooSmall = input.data.length < check.value;
	                if (tooBig || tooSmall) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    if (tooBig) {
	                        (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                            code: ZodError_js_1.ZodIssueCode.too_big,
	                            maximum: check.value,
	                            type: "string",
	                            inclusive: true,
	                            exact: true,
	                            message: check.message,
	                        });
	                    }
	                    else if (tooSmall) {
	                        (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                            code: ZodError_js_1.ZodIssueCode.too_small,
	                            minimum: check.value,
	                            type: "string",
	                            inclusive: true,
	                            exact: true,
	                            message: check.message,
	                        });
	                    }
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "email") {
	                if (!emailRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        validation: "email",
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "emoji") {
	                if (!emojiRegex) {
	                    emojiRegex = new RegExp(_emojiRegex, "u");
	                }
	                if (!emojiRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        validation: "emoji",
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "uuid") {
	                if (!uuidRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        validation: "uuid",
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "nanoid") {
	                if (!nanoidRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        validation: "nanoid",
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "cuid") {
	                if (!cuidRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        validation: "cuid",
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "cuid2") {
	                if (!cuid2Regex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        validation: "cuid2",
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "ulid") {
	                if (!ulidRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        validation: "ulid",
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "url") {
	                try {
	                    new URL(input.data);
	                }
	                catch {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        validation: "url",
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "regex") {
	                check.regex.lastIndex = 0;
	                const testResult = check.regex.test(input.data);
	                if (!testResult) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        validation: "regex",
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "trim") {
	                input.data = input.data.trim();
	            }
	            else if (check.kind === "includes") {
	                if (!input.data.includes(check.value, check.position)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        validation: { includes: check.value, position: check.position },
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "toLowerCase") {
	                input.data = input.data.toLowerCase();
	            }
	            else if (check.kind === "toUpperCase") {
	                input.data = input.data.toUpperCase();
	            }
	            else if (check.kind === "startsWith") {
	                if (!input.data.startsWith(check.value)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        validation: { startsWith: check.value },
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "endsWith") {
	                if (!input.data.endsWith(check.value)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        validation: { endsWith: check.value },
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "datetime") {
	                const regex = datetimeRegex(check);
	                if (!regex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        validation: "datetime",
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "date") {
	                const regex = dateRegex;
	                if (!regex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        validation: "date",
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "time") {
	                const regex = timeRegex(check);
	                if (!regex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        validation: "time",
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "duration") {
	                if (!durationRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        validation: "duration",
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "ip") {
	                if (!isValidIP(input.data, check.version)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        validation: "ip",
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "jwt") {
	                if (!isValidJWT(input.data, check.alg)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        validation: "jwt",
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "cidr") {
	                if (!isValidCidr(input.data, check.version)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        validation: "cidr",
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "base64") {
	                if (!base64Regex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        validation: "base64",
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "base64url") {
	                if (!base64urlRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        validation: "base64url",
	                        code: ZodError_js_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util_js_1.util.assertNever(check);
	            }
	        }
	        return { status: status.value, value: input.data };
	    }
	    _regex(regex, validation, message) {
	        return this.refinement((data) => regex.test(data), {
	            validation,
	            code: ZodError_js_1.ZodIssueCode.invalid_string,
	            ...errorUtil_js_1.errorUtil.errToObj(message),
	        });
	    }
	    _addCheck(check) {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    email(message) {
	        return this._addCheck({ kind: "email", ...errorUtil_js_1.errorUtil.errToObj(message) });
	    }
	    url(message) {
	        return this._addCheck({ kind: "url", ...errorUtil_js_1.errorUtil.errToObj(message) });
	    }
	    emoji(message) {
	        return this._addCheck({ kind: "emoji", ...errorUtil_js_1.errorUtil.errToObj(message) });
	    }
	    uuid(message) {
	        return this._addCheck({ kind: "uuid", ...errorUtil_js_1.errorUtil.errToObj(message) });
	    }
	    nanoid(message) {
	        return this._addCheck({ kind: "nanoid", ...errorUtil_js_1.errorUtil.errToObj(message) });
	    }
	    cuid(message) {
	        return this._addCheck({ kind: "cuid", ...errorUtil_js_1.errorUtil.errToObj(message) });
	    }
	    cuid2(message) {
	        return this._addCheck({ kind: "cuid2", ...errorUtil_js_1.errorUtil.errToObj(message) });
	    }
	    ulid(message) {
	        return this._addCheck({ kind: "ulid", ...errorUtil_js_1.errorUtil.errToObj(message) });
	    }
	    base64(message) {
	        return this._addCheck({ kind: "base64", ...errorUtil_js_1.errorUtil.errToObj(message) });
	    }
	    base64url(message) {
	        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
	        return this._addCheck({
	            kind: "base64url",
	            ...errorUtil_js_1.errorUtil.errToObj(message),
	        });
	    }
	    jwt(options) {
	        return this._addCheck({ kind: "jwt", ...errorUtil_js_1.errorUtil.errToObj(options) });
	    }
	    ip(options) {
	        return this._addCheck({ kind: "ip", ...errorUtil_js_1.errorUtil.errToObj(options) });
	    }
	    cidr(options) {
	        return this._addCheck({ kind: "cidr", ...errorUtil_js_1.errorUtil.errToObj(options) });
	    }
	    datetime(options) {
	        if (typeof options === "string") {
	            return this._addCheck({
	                kind: "datetime",
	                precision: null,
	                offset: false,
	                local: false,
	                message: options,
	            });
	        }
	        return this._addCheck({
	            kind: "datetime",
	            precision: typeof options?.precision === "undefined" ? null : options?.precision,
	            offset: options?.offset ?? false,
	            local: options?.local ?? false,
	            ...errorUtil_js_1.errorUtil.errToObj(options?.message),
	        });
	    }
	    date(message) {
	        return this._addCheck({ kind: "date", message });
	    }
	    time(options) {
	        if (typeof options === "string") {
	            return this._addCheck({
	                kind: "time",
	                precision: null,
	                message: options,
	            });
	        }
	        return this._addCheck({
	            kind: "time",
	            precision: typeof options?.precision === "undefined" ? null : options?.precision,
	            ...errorUtil_js_1.errorUtil.errToObj(options?.message),
	        });
	    }
	    duration(message) {
	        return this._addCheck({ kind: "duration", ...errorUtil_js_1.errorUtil.errToObj(message) });
	    }
	    regex(regex, message) {
	        return this._addCheck({
	            kind: "regex",
	            regex: regex,
	            ...errorUtil_js_1.errorUtil.errToObj(message),
	        });
	    }
	    includes(value, options) {
	        return this._addCheck({
	            kind: "includes",
	            value: value,
	            position: options?.position,
	            ...errorUtil_js_1.errorUtil.errToObj(options?.message),
	        });
	    }
	    startsWith(value, message) {
	        return this._addCheck({
	            kind: "startsWith",
	            value: value,
	            ...errorUtil_js_1.errorUtil.errToObj(message),
	        });
	    }
	    endsWith(value, message) {
	        return this._addCheck({
	            kind: "endsWith",
	            value: value,
	            ...errorUtil_js_1.errorUtil.errToObj(message),
	        });
	    }
	    min(minLength, message) {
	        return this._addCheck({
	            kind: "min",
	            value: minLength,
	            ...errorUtil_js_1.errorUtil.errToObj(message),
	        });
	    }
	    max(maxLength, message) {
	        return this._addCheck({
	            kind: "max",
	            value: maxLength,
	            ...errorUtil_js_1.errorUtil.errToObj(message),
	        });
	    }
	    length(len, message) {
	        return this._addCheck({
	            kind: "length",
	            value: len,
	            ...errorUtil_js_1.errorUtil.errToObj(message),
	        });
	    }
	    /**
	     * Equivalent to `.min(1)`
	     */
	    nonempty(message) {
	        return this.min(1, errorUtil_js_1.errorUtil.errToObj(message));
	    }
	    trim() {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, { kind: "trim" }],
	        });
	    }
	    toLowerCase() {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, { kind: "toLowerCase" }],
	        });
	    }
	    toUpperCase() {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, { kind: "toUpperCase" }],
	        });
	    }
	    get isDatetime() {
	        return !!this._def.checks.find((ch) => ch.kind === "datetime");
	    }
	    get isDate() {
	        return !!this._def.checks.find((ch) => ch.kind === "date");
	    }
	    get isTime() {
	        return !!this._def.checks.find((ch) => ch.kind === "time");
	    }
	    get isDuration() {
	        return !!this._def.checks.find((ch) => ch.kind === "duration");
	    }
	    get isEmail() {
	        return !!this._def.checks.find((ch) => ch.kind === "email");
	    }
	    get isURL() {
	        return !!this._def.checks.find((ch) => ch.kind === "url");
	    }
	    get isEmoji() {
	        return !!this._def.checks.find((ch) => ch.kind === "emoji");
	    }
	    get isUUID() {
	        return !!this._def.checks.find((ch) => ch.kind === "uuid");
	    }
	    get isNANOID() {
	        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
	    }
	    get isCUID() {
	        return !!this._def.checks.find((ch) => ch.kind === "cuid");
	    }
	    get isCUID2() {
	        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
	    }
	    get isULID() {
	        return !!this._def.checks.find((ch) => ch.kind === "ulid");
	    }
	    get isIP() {
	        return !!this._def.checks.find((ch) => ch.kind === "ip");
	    }
	    get isCIDR() {
	        return !!this._def.checks.find((ch) => ch.kind === "cidr");
	    }
	    get isBase64() {
	        return !!this._def.checks.find((ch) => ch.kind === "base64");
	    }
	    get isBase64url() {
	        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
	        return !!this._def.checks.find((ch) => ch.kind === "base64url");
	    }
	    get minLength() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min;
	    }
	    get maxLength() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max;
	    }
	}
	types.ZodString = ZodString;
	ZodString.create = (params) => {
	    return new ZodString({
	        checks: [],
	        typeName: ZodFirstPartyTypeKind.ZodString,
	        coerce: params?.coerce ?? false,
	        ...processCreateParams(params),
	    });
	};
	// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
	function floatSafeRemainder(val, step) {
	    const valDecCount = (val.toString().split(".")[1] || "").length;
	    const stepDecCount = (step.toString().split(".")[1] || "").length;
	    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
	    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
	    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
	    return (valInt % stepInt) / 10 ** decCount;
	}
	class ZodNumber extends ZodType {
	    constructor() {
	        super(...arguments);
	        this.min = this.gte;
	        this.max = this.lte;
	        this.step = this.multipleOf;
	    }
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = Number(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== util_js_1.ZodParsedType.number) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	                expected: util_js_1.ZodParsedType.number,
	                received: ctx.parsedType,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        let ctx = undefined;
	        const status = new parseUtil_js_1.ParseStatus();
	        for (const check of this._def.checks) {
	            if (check.kind === "int") {
	                if (!util_js_1.util.isInteger(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        code: ZodError_js_1.ZodIssueCode.invalid_type,
	                        expected: "integer",
	                        received: "float",
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "min") {
	                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
	                if (tooSmall) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        code: ZodError_js_1.ZodIssueCode.too_small,
	                        minimum: check.value,
	                        type: "number",
	                        inclusive: check.inclusive,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
	                if (tooBig) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        code: ZodError_js_1.ZodIssueCode.too_big,
	                        maximum: check.value,
	                        type: "number",
	                        inclusive: check.inclusive,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "multipleOf") {
	                if (floatSafeRemainder(input.data, check.value) !== 0) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        code: ZodError_js_1.ZodIssueCode.not_multiple_of,
	                        multipleOf: check.value,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "finite") {
	                if (!Number.isFinite(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        code: ZodError_js_1.ZodIssueCode.not_finite,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util_js_1.util.assertNever(check);
	            }
	        }
	        return { status: status.value, value: input.data };
	    }
	    gte(value, message) {
	        return this.setLimit("min", value, true, errorUtil_js_1.errorUtil.toString(message));
	    }
	    gt(value, message) {
	        return this.setLimit("min", value, false, errorUtil_js_1.errorUtil.toString(message));
	    }
	    lte(value, message) {
	        return this.setLimit("max", value, true, errorUtil_js_1.errorUtil.toString(message));
	    }
	    lt(value, message) {
	        return this.setLimit("max", value, false, errorUtil_js_1.errorUtil.toString(message));
	    }
	    setLimit(kind, value, inclusive, message) {
	        return new ZodNumber({
	            ...this._def,
	            checks: [
	                ...this._def.checks,
	                {
	                    kind,
	                    value,
	                    inclusive,
	                    message: errorUtil_js_1.errorUtil.toString(message),
	                },
	            ],
	        });
	    }
	    _addCheck(check) {
	        return new ZodNumber({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    int(message) {
	        return this._addCheck({
	            kind: "int",
	            message: errorUtil_js_1.errorUtil.toString(message),
	        });
	    }
	    positive(message) {
	        return this._addCheck({
	            kind: "min",
	            value: 0,
	            inclusive: false,
	            message: errorUtil_js_1.errorUtil.toString(message),
	        });
	    }
	    negative(message) {
	        return this._addCheck({
	            kind: "max",
	            value: 0,
	            inclusive: false,
	            message: errorUtil_js_1.errorUtil.toString(message),
	        });
	    }
	    nonpositive(message) {
	        return this._addCheck({
	            kind: "max",
	            value: 0,
	            inclusive: true,
	            message: errorUtil_js_1.errorUtil.toString(message),
	        });
	    }
	    nonnegative(message) {
	        return this._addCheck({
	            kind: "min",
	            value: 0,
	            inclusive: true,
	            message: errorUtil_js_1.errorUtil.toString(message),
	        });
	    }
	    multipleOf(value, message) {
	        return this._addCheck({
	            kind: "multipleOf",
	            value: value,
	            message: errorUtil_js_1.errorUtil.toString(message),
	        });
	    }
	    finite(message) {
	        return this._addCheck({
	            kind: "finite",
	            message: errorUtil_js_1.errorUtil.toString(message),
	        });
	    }
	    safe(message) {
	        return this._addCheck({
	            kind: "min",
	            inclusive: true,
	            value: Number.MIN_SAFE_INTEGER,
	            message: errorUtil_js_1.errorUtil.toString(message),
	        })._addCheck({
	            kind: "max",
	            inclusive: true,
	            value: Number.MAX_SAFE_INTEGER,
	            message: errorUtil_js_1.errorUtil.toString(message),
	        });
	    }
	    get minValue() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min;
	    }
	    get maxValue() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max;
	    }
	    get isInt() {
	        return !!this._def.checks.find((ch) => ch.kind === "int" || (ch.kind === "multipleOf" && util_js_1.util.isInteger(ch.value)));
	    }
	    get isFinite() {
	        let max = null;
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
	                return true;
	            }
	            else if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	            else if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return Number.isFinite(min) && Number.isFinite(max);
	    }
	}
	types.ZodNumber = ZodNumber;
	ZodNumber.create = (params) => {
	    return new ZodNumber({
	        checks: [],
	        typeName: ZodFirstPartyTypeKind.ZodNumber,
	        coerce: params?.coerce || false,
	        ...processCreateParams(params),
	    });
	};
	class ZodBigInt extends ZodType {
	    constructor() {
	        super(...arguments);
	        this.min = this.gte;
	        this.max = this.lte;
	    }
	    _parse(input) {
	        if (this._def.coerce) {
	            try {
	                input.data = BigInt(input.data);
	            }
	            catch {
	                return this._getInvalidInput(input);
	            }
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== util_js_1.ZodParsedType.bigint) {
	            return this._getInvalidInput(input);
	        }
	        let ctx = undefined;
	        const status = new parseUtil_js_1.ParseStatus();
	        for (const check of this._def.checks) {
	            if (check.kind === "min") {
	                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
	                if (tooSmall) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        code: ZodError_js_1.ZodIssueCode.too_small,
	                        type: "bigint",
	                        minimum: check.value,
	                        inclusive: check.inclusive,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
	                if (tooBig) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        code: ZodError_js_1.ZodIssueCode.too_big,
	                        type: "bigint",
	                        maximum: check.value,
	                        inclusive: check.inclusive,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "multipleOf") {
	                if (input.data % check.value !== BigInt(0)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        code: ZodError_js_1.ZodIssueCode.not_multiple_of,
	                        multipleOf: check.value,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util_js_1.util.assertNever(check);
	            }
	        }
	        return { status: status.value, value: input.data };
	    }
	    _getInvalidInput(input) {
	        const ctx = this._getOrReturnCtx(input);
	        (0, parseUtil_js_1.addIssueToContext)(ctx, {
	            code: ZodError_js_1.ZodIssueCode.invalid_type,
	            expected: util_js_1.ZodParsedType.bigint,
	            received: ctx.parsedType,
	        });
	        return parseUtil_js_1.INVALID;
	    }
	    gte(value, message) {
	        return this.setLimit("min", value, true, errorUtil_js_1.errorUtil.toString(message));
	    }
	    gt(value, message) {
	        return this.setLimit("min", value, false, errorUtil_js_1.errorUtil.toString(message));
	    }
	    lte(value, message) {
	        return this.setLimit("max", value, true, errorUtil_js_1.errorUtil.toString(message));
	    }
	    lt(value, message) {
	        return this.setLimit("max", value, false, errorUtil_js_1.errorUtil.toString(message));
	    }
	    setLimit(kind, value, inclusive, message) {
	        return new ZodBigInt({
	            ...this._def,
	            checks: [
	                ...this._def.checks,
	                {
	                    kind,
	                    value,
	                    inclusive,
	                    message: errorUtil_js_1.errorUtil.toString(message),
	                },
	            ],
	        });
	    }
	    _addCheck(check) {
	        return new ZodBigInt({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    positive(message) {
	        return this._addCheck({
	            kind: "min",
	            value: BigInt(0),
	            inclusive: false,
	            message: errorUtil_js_1.errorUtil.toString(message),
	        });
	    }
	    negative(message) {
	        return this._addCheck({
	            kind: "max",
	            value: BigInt(0),
	            inclusive: false,
	            message: errorUtil_js_1.errorUtil.toString(message),
	        });
	    }
	    nonpositive(message) {
	        return this._addCheck({
	            kind: "max",
	            value: BigInt(0),
	            inclusive: true,
	            message: errorUtil_js_1.errorUtil.toString(message),
	        });
	    }
	    nonnegative(message) {
	        return this._addCheck({
	            kind: "min",
	            value: BigInt(0),
	            inclusive: true,
	            message: errorUtil_js_1.errorUtil.toString(message),
	        });
	    }
	    multipleOf(value, message) {
	        return this._addCheck({
	            kind: "multipleOf",
	            value,
	            message: errorUtil_js_1.errorUtil.toString(message),
	        });
	    }
	    get minValue() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min;
	    }
	    get maxValue() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max;
	    }
	}
	types.ZodBigInt = ZodBigInt;
	ZodBigInt.create = (params) => {
	    return new ZodBigInt({
	        checks: [],
	        typeName: ZodFirstPartyTypeKind.ZodBigInt,
	        coerce: params?.coerce ?? false,
	        ...processCreateParams(params),
	    });
	};
	class ZodBoolean extends ZodType {
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = Boolean(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== util_js_1.ZodParsedType.boolean) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	                expected: util_js_1.ZodParsedType.boolean,
	                received: ctx.parsedType,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        return (0, parseUtil_js_1.OK)(input.data);
	    }
	}
	types.ZodBoolean = ZodBoolean;
	ZodBoolean.create = (params) => {
	    return new ZodBoolean({
	        typeName: ZodFirstPartyTypeKind.ZodBoolean,
	        coerce: params?.coerce || false,
	        ...processCreateParams(params),
	    });
	};
	class ZodDate extends ZodType {
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = new Date(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== util_js_1.ZodParsedType.date) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	                expected: util_js_1.ZodParsedType.date,
	                received: ctx.parsedType,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        if (Number.isNaN(input.data.getTime())) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_date,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        const status = new parseUtil_js_1.ParseStatus();
	        let ctx = undefined;
	        for (const check of this._def.checks) {
	            if (check.kind === "min") {
	                if (input.data.getTime() < check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        code: ZodError_js_1.ZodIssueCode.too_small,
	                        message: check.message,
	                        inclusive: true,
	                        exact: false,
	                        minimum: check.value,
	                        type: "date",
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                if (input.data.getTime() > check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        code: ZodError_js_1.ZodIssueCode.too_big,
	                        message: check.message,
	                        inclusive: true,
	                        exact: false,
	                        maximum: check.value,
	                        type: "date",
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util_js_1.util.assertNever(check);
	            }
	        }
	        return {
	            status: status.value,
	            value: new Date(input.data.getTime()),
	        };
	    }
	    _addCheck(check) {
	        return new ZodDate({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    min(minDate, message) {
	        return this._addCheck({
	            kind: "min",
	            value: minDate.getTime(),
	            message: errorUtil_js_1.errorUtil.toString(message),
	        });
	    }
	    max(maxDate, message) {
	        return this._addCheck({
	            kind: "max",
	            value: maxDate.getTime(),
	            message: errorUtil_js_1.errorUtil.toString(message),
	        });
	    }
	    get minDate() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min != null ? new Date(min) : null;
	    }
	    get maxDate() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max != null ? new Date(max) : null;
	    }
	}
	types.ZodDate = ZodDate;
	ZodDate.create = (params) => {
	    return new ZodDate({
	        checks: [],
	        coerce: params?.coerce || false,
	        typeName: ZodFirstPartyTypeKind.ZodDate,
	        ...processCreateParams(params),
	    });
	};
	class ZodSymbol extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== util_js_1.ZodParsedType.symbol) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	                expected: util_js_1.ZodParsedType.symbol,
	                received: ctx.parsedType,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        return (0, parseUtil_js_1.OK)(input.data);
	    }
	}
	types.ZodSymbol = ZodSymbol;
	ZodSymbol.create = (params) => {
	    return new ZodSymbol({
	        typeName: ZodFirstPartyTypeKind.ZodSymbol,
	        ...processCreateParams(params),
	    });
	};
	class ZodUndefined extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== util_js_1.ZodParsedType.undefined) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	                expected: util_js_1.ZodParsedType.undefined,
	                received: ctx.parsedType,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        return (0, parseUtil_js_1.OK)(input.data);
	    }
	}
	types.ZodUndefined = ZodUndefined;
	ZodUndefined.create = (params) => {
	    return new ZodUndefined({
	        typeName: ZodFirstPartyTypeKind.ZodUndefined,
	        ...processCreateParams(params),
	    });
	};
	class ZodNull extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== util_js_1.ZodParsedType.null) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	                expected: util_js_1.ZodParsedType.null,
	                received: ctx.parsedType,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        return (0, parseUtil_js_1.OK)(input.data);
	    }
	}
	types.ZodNull = ZodNull;
	ZodNull.create = (params) => {
	    return new ZodNull({
	        typeName: ZodFirstPartyTypeKind.ZodNull,
	        ...processCreateParams(params),
	    });
	};
	class ZodAny extends ZodType {
	    constructor() {
	        super(...arguments);
	        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
	        this._any = true;
	    }
	    _parse(input) {
	        return (0, parseUtil_js_1.OK)(input.data);
	    }
	}
	types.ZodAny = ZodAny;
	ZodAny.create = (params) => {
	    return new ZodAny({
	        typeName: ZodFirstPartyTypeKind.ZodAny,
	        ...processCreateParams(params),
	    });
	};
	class ZodUnknown extends ZodType {
	    constructor() {
	        super(...arguments);
	        // required
	        this._unknown = true;
	    }
	    _parse(input) {
	        return (0, parseUtil_js_1.OK)(input.data);
	    }
	}
	types.ZodUnknown = ZodUnknown;
	ZodUnknown.create = (params) => {
	    return new ZodUnknown({
	        typeName: ZodFirstPartyTypeKind.ZodUnknown,
	        ...processCreateParams(params),
	    });
	};
	class ZodNever extends ZodType {
	    _parse(input) {
	        const ctx = this._getOrReturnCtx(input);
	        (0, parseUtil_js_1.addIssueToContext)(ctx, {
	            code: ZodError_js_1.ZodIssueCode.invalid_type,
	            expected: util_js_1.ZodParsedType.never,
	            received: ctx.parsedType,
	        });
	        return parseUtil_js_1.INVALID;
	    }
	}
	types.ZodNever = ZodNever;
	ZodNever.create = (params) => {
	    return new ZodNever({
	        typeName: ZodFirstPartyTypeKind.ZodNever,
	        ...processCreateParams(params),
	    });
	};
	class ZodVoid extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== util_js_1.ZodParsedType.undefined) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	                expected: util_js_1.ZodParsedType.void,
	                received: ctx.parsedType,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        return (0, parseUtil_js_1.OK)(input.data);
	    }
	}
	types.ZodVoid = ZodVoid;
	ZodVoid.create = (params) => {
	    return new ZodVoid({
	        typeName: ZodFirstPartyTypeKind.ZodVoid,
	        ...processCreateParams(params),
	    });
	};
	class ZodArray extends ZodType {
	    _parse(input) {
	        const { ctx, status } = this._processInputParams(input);
	        const def = this._def;
	        if (ctx.parsedType !== util_js_1.ZodParsedType.array) {
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	                expected: util_js_1.ZodParsedType.array,
	                received: ctx.parsedType,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        if (def.exactLength !== null) {
	            const tooBig = ctx.data.length > def.exactLength.value;
	            const tooSmall = ctx.data.length < def.exactLength.value;
	            if (tooBig || tooSmall) {
	                (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                    code: tooBig ? ZodError_js_1.ZodIssueCode.too_big : ZodError_js_1.ZodIssueCode.too_small,
	                    minimum: (tooSmall ? def.exactLength.value : undefined),
	                    maximum: (tooBig ? def.exactLength.value : undefined),
	                    type: "array",
	                    inclusive: true,
	                    exact: true,
	                    message: def.exactLength.message,
	                });
	                status.dirty();
	            }
	        }
	        if (def.minLength !== null) {
	            if (ctx.data.length < def.minLength.value) {
	                (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                    code: ZodError_js_1.ZodIssueCode.too_small,
	                    minimum: def.minLength.value,
	                    type: "array",
	                    inclusive: true,
	                    exact: false,
	                    message: def.minLength.message,
	                });
	                status.dirty();
	            }
	        }
	        if (def.maxLength !== null) {
	            if (ctx.data.length > def.maxLength.value) {
	                (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                    code: ZodError_js_1.ZodIssueCode.too_big,
	                    maximum: def.maxLength.value,
	                    type: "array",
	                    inclusive: true,
	                    exact: false,
	                    message: def.maxLength.message,
	                });
	                status.dirty();
	            }
	        }
	        if (ctx.common.async) {
	            return Promise.all([...ctx.data].map((item, i) => {
	                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
	            })).then((result) => {
	                return parseUtil_js_1.ParseStatus.mergeArray(status, result);
	            });
	        }
	        const result = [...ctx.data].map((item, i) => {
	            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
	        });
	        return parseUtil_js_1.ParseStatus.mergeArray(status, result);
	    }
	    get element() {
	        return this._def.type;
	    }
	    min(minLength, message) {
	        return new ZodArray({
	            ...this._def,
	            minLength: { value: minLength, message: errorUtil_js_1.errorUtil.toString(message) },
	        });
	    }
	    max(maxLength, message) {
	        return new ZodArray({
	            ...this._def,
	            maxLength: { value: maxLength, message: errorUtil_js_1.errorUtil.toString(message) },
	        });
	    }
	    length(len, message) {
	        return new ZodArray({
	            ...this._def,
	            exactLength: { value: len, message: errorUtil_js_1.errorUtil.toString(message) },
	        });
	    }
	    nonempty(message) {
	        return this.min(1, message);
	    }
	}
	types.ZodArray = ZodArray;
	ZodArray.create = (schema, params) => {
	    return new ZodArray({
	        type: schema,
	        minLength: null,
	        maxLength: null,
	        exactLength: null,
	        typeName: ZodFirstPartyTypeKind.ZodArray,
	        ...processCreateParams(params),
	    });
	};
	function deepPartialify(schema) {
	    if (schema instanceof ZodObject) {
	        const newShape = {};
	        for (const key in schema.shape) {
	            const fieldSchema = schema.shape[key];
	            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
	        }
	        return new ZodObject({
	            ...schema._def,
	            shape: () => newShape,
	        });
	    }
	    else if (schema instanceof ZodArray) {
	        return new ZodArray({
	            ...schema._def,
	            type: deepPartialify(schema.element),
	        });
	    }
	    else if (schema instanceof ZodOptional) {
	        return ZodOptional.create(deepPartialify(schema.unwrap()));
	    }
	    else if (schema instanceof ZodNullable) {
	        return ZodNullable.create(deepPartialify(schema.unwrap()));
	    }
	    else if (schema instanceof ZodTuple) {
	        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
	    }
	    else {
	        return schema;
	    }
	}
	class ZodObject extends ZodType {
	    constructor() {
	        super(...arguments);
	        this._cached = null;
	        /**
	         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
	         * If you want to pass through unknown properties, use `.passthrough()` instead.
	         */
	        this.nonstrict = this.passthrough;
	        // extend<
	        //   Augmentation extends ZodRawShape,
	        //   NewOutput extends util.flatten<{
	        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
	        //       ? Augmentation[k]["_output"]
	        //       : k extends keyof Output
	        //       ? Output[k]
	        //       : never;
	        //   }>,
	        //   NewInput extends util.flatten<{
	        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
	        //       ? Augmentation[k]["_input"]
	        //       : k extends keyof Input
	        //       ? Input[k]
	        //       : never;
	        //   }>
	        // >(
	        //   augmentation: Augmentation
	        // ): ZodObject<
	        //   extendShape<T, Augmentation>,
	        //   UnknownKeys,
	        //   Catchall,
	        //   NewOutput,
	        //   NewInput
	        // > {
	        //   return new ZodObject({
	        //     ...this._def,
	        //     shape: () => ({
	        //       ...this._def.shape(),
	        //       ...augmentation,
	        //     }),
	        //   }) as any;
	        // }
	        /**
	         * @deprecated Use `.extend` instead
	         *  */
	        this.augment = this.extend;
	    }
	    _getCached() {
	        if (this._cached !== null)
	            return this._cached;
	        const shape = this._def.shape();
	        const keys = util_js_1.util.objectKeys(shape);
	        this._cached = { shape, keys };
	        return this._cached;
	    }
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== util_js_1.ZodParsedType.object) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	                expected: util_js_1.ZodParsedType.object,
	                received: ctx.parsedType,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        const { status, ctx } = this._processInputParams(input);
	        const { shape, keys: shapeKeys } = this._getCached();
	        const extraKeys = [];
	        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
	            for (const key in ctx.data) {
	                if (!shapeKeys.includes(key)) {
	                    extraKeys.push(key);
	                }
	            }
	        }
	        const pairs = [];
	        for (const key of shapeKeys) {
	            const keyValidator = shape[key];
	            const value = ctx.data[key];
	            pairs.push({
	                key: { status: "valid", value: key },
	                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
	                alwaysSet: key in ctx.data,
	            });
	        }
	        if (this._def.catchall instanceof ZodNever) {
	            const unknownKeys = this._def.unknownKeys;
	            if (unknownKeys === "passthrough") {
	                for (const key of extraKeys) {
	                    pairs.push({
	                        key: { status: "valid", value: key },
	                        value: { status: "valid", value: ctx.data[key] },
	                    });
	                }
	            }
	            else if (unknownKeys === "strict") {
	                if (extraKeys.length > 0) {
	                    (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                        code: ZodError_js_1.ZodIssueCode.unrecognized_keys,
	                        keys: extraKeys,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (unknownKeys === "strip") ;
	            else {
	                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
	            }
	        }
	        else {
	            // run catchall validation
	            const catchall = this._def.catchall;
	            for (const key of extraKeys) {
	                const value = ctx.data[key];
	                pairs.push({
	                    key: { status: "valid", value: key },
	                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
	                    ),
	                    alwaysSet: key in ctx.data,
	                });
	            }
	        }
	        if (ctx.common.async) {
	            return Promise.resolve()
	                .then(async () => {
	                const syncPairs = [];
	                for (const pair of pairs) {
	                    const key = await pair.key;
	                    const value = await pair.value;
	                    syncPairs.push({
	                        key,
	                        value,
	                        alwaysSet: pair.alwaysSet,
	                    });
	                }
	                return syncPairs;
	            })
	                .then((syncPairs) => {
	                return parseUtil_js_1.ParseStatus.mergeObjectSync(status, syncPairs);
	            });
	        }
	        else {
	            return parseUtil_js_1.ParseStatus.mergeObjectSync(status, pairs);
	        }
	    }
	    get shape() {
	        return this._def.shape();
	    }
	    strict(message) {
	        errorUtil_js_1.errorUtil.errToObj;
	        return new ZodObject({
	            ...this._def,
	            unknownKeys: "strict",
	            ...(message !== undefined
	                ? {
	                    errorMap: (issue, ctx) => {
	                        const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
	                        if (issue.code === "unrecognized_keys")
	                            return {
	                                message: errorUtil_js_1.errorUtil.errToObj(message).message ?? defaultError,
	                            };
	                        return {
	                            message: defaultError,
	                        };
	                    },
	                }
	                : {}),
	        });
	    }
	    strip() {
	        return new ZodObject({
	            ...this._def,
	            unknownKeys: "strip",
	        });
	    }
	    passthrough() {
	        return new ZodObject({
	            ...this._def,
	            unknownKeys: "passthrough",
	        });
	    }
	    // const AugmentFactory =
	    //   <Def extends ZodObjectDef>(def: Def) =>
	    //   <Augmentation extends ZodRawShape>(
	    //     augmentation: Augmentation
	    //   ): ZodObject<
	    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
	    //     Def["unknownKeys"],
	    //     Def["catchall"]
	    //   > => {
	    //     return new ZodObject({
	    //       ...def,
	    //       shape: () => ({
	    //         ...def.shape(),
	    //         ...augmentation,
	    //       }),
	    //     }) as any;
	    //   };
	    extend(augmentation) {
	        return new ZodObject({
	            ...this._def,
	            shape: () => ({
	                ...this._def.shape(),
	                ...augmentation,
	            }),
	        });
	    }
	    /**
	     * Prior to zod@1.0.12 there was a bug in the
	     * inferred type of merged objects. Please
	     * upgrade if you are experiencing issues.
	     */
	    merge(merging) {
	        const merged = new ZodObject({
	            unknownKeys: merging._def.unknownKeys,
	            catchall: merging._def.catchall,
	            shape: () => ({
	                ...this._def.shape(),
	                ...merging._def.shape(),
	            }),
	            typeName: ZodFirstPartyTypeKind.ZodObject,
	        });
	        return merged;
	    }
	    // merge<
	    //   Incoming extends AnyZodObject,
	    //   Augmentation extends Incoming["shape"],
	    //   NewOutput extends {
	    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
	    //       ? Augmentation[k]["_output"]
	    //       : k extends keyof Output
	    //       ? Output[k]
	    //       : never;
	    //   },
	    //   NewInput extends {
	    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
	    //       ? Augmentation[k]["_input"]
	    //       : k extends keyof Input
	    //       ? Input[k]
	    //       : never;
	    //   }
	    // >(
	    //   merging: Incoming
	    // ): ZodObject<
	    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
	    //   Incoming["_def"]["unknownKeys"],
	    //   Incoming["_def"]["catchall"],
	    //   NewOutput,
	    //   NewInput
	    // > {
	    //   const merged: any = new ZodObject({
	    //     unknownKeys: merging._def.unknownKeys,
	    //     catchall: merging._def.catchall,
	    //     shape: () =>
	    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
	    //     typeName: ZodFirstPartyTypeKind.ZodObject,
	    //   }) as any;
	    //   return merged;
	    // }
	    setKey(key, schema) {
	        return this.augment({ [key]: schema });
	    }
	    // merge<Incoming extends AnyZodObject>(
	    //   merging: Incoming
	    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
	    // ZodObject<
	    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
	    //   Incoming["_def"]["unknownKeys"],
	    //   Incoming["_def"]["catchall"]
	    // > {
	    //   // const mergedShape = objectUtil.mergeShapes(
	    //   //   this._def.shape(),
	    //   //   merging._def.shape()
	    //   // );
	    //   const merged: any = new ZodObject({
	    //     unknownKeys: merging._def.unknownKeys,
	    //     catchall: merging._def.catchall,
	    //     shape: () =>
	    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
	    //     typeName: ZodFirstPartyTypeKind.ZodObject,
	    //   }) as any;
	    //   return merged;
	    // }
	    catchall(index) {
	        return new ZodObject({
	            ...this._def,
	            catchall: index,
	        });
	    }
	    pick(mask) {
	        const shape = {};
	        for (const key of util_js_1.util.objectKeys(mask)) {
	            if (mask[key] && this.shape[key]) {
	                shape[key] = this.shape[key];
	            }
	        }
	        return new ZodObject({
	            ...this._def,
	            shape: () => shape,
	        });
	    }
	    omit(mask) {
	        const shape = {};
	        for (const key of util_js_1.util.objectKeys(this.shape)) {
	            if (!mask[key]) {
	                shape[key] = this.shape[key];
	            }
	        }
	        return new ZodObject({
	            ...this._def,
	            shape: () => shape,
	        });
	    }
	    /**
	     * @deprecated
	     */
	    deepPartial() {
	        return deepPartialify(this);
	    }
	    partial(mask) {
	        const newShape = {};
	        for (const key of util_js_1.util.objectKeys(this.shape)) {
	            const fieldSchema = this.shape[key];
	            if (mask && !mask[key]) {
	                newShape[key] = fieldSchema;
	            }
	            else {
	                newShape[key] = fieldSchema.optional();
	            }
	        }
	        return new ZodObject({
	            ...this._def,
	            shape: () => newShape,
	        });
	    }
	    required(mask) {
	        const newShape = {};
	        for (const key of util_js_1.util.objectKeys(this.shape)) {
	            if (mask && !mask[key]) {
	                newShape[key] = this.shape[key];
	            }
	            else {
	                const fieldSchema = this.shape[key];
	                let newField = fieldSchema;
	                while (newField instanceof ZodOptional) {
	                    newField = newField._def.innerType;
	                }
	                newShape[key] = newField;
	            }
	        }
	        return new ZodObject({
	            ...this._def,
	            shape: () => newShape,
	        });
	    }
	    keyof() {
	        return createZodEnum(util_js_1.util.objectKeys(this.shape));
	    }
	}
	types.ZodObject = ZodObject;
	ZodObject.create = (shape, params) => {
	    return new ZodObject({
	        shape: () => shape,
	        unknownKeys: "strip",
	        catchall: ZodNever.create(),
	        typeName: ZodFirstPartyTypeKind.ZodObject,
	        ...processCreateParams(params),
	    });
	};
	ZodObject.strictCreate = (shape, params) => {
	    return new ZodObject({
	        shape: () => shape,
	        unknownKeys: "strict",
	        catchall: ZodNever.create(),
	        typeName: ZodFirstPartyTypeKind.ZodObject,
	        ...processCreateParams(params),
	    });
	};
	ZodObject.lazycreate = (shape, params) => {
	    return new ZodObject({
	        shape,
	        unknownKeys: "strip",
	        catchall: ZodNever.create(),
	        typeName: ZodFirstPartyTypeKind.ZodObject,
	        ...processCreateParams(params),
	    });
	};
	class ZodUnion extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        const options = this._def.options;
	        function handleResults(results) {
	            // return first issue-free validation if it exists
	            for (const result of results) {
	                if (result.result.status === "valid") {
	                    return result.result;
	                }
	            }
	            for (const result of results) {
	                if (result.result.status === "dirty") {
	                    // add issues from dirty option
	                    ctx.common.issues.push(...result.ctx.common.issues);
	                    return result.result;
	                }
	            }
	            // return invalid
	            const unionErrors = results.map((result) => new ZodError_js_1.ZodError(result.ctx.common.issues));
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_union,
	                unionErrors,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        if (ctx.common.async) {
	            return Promise.all(options.map(async (option) => {
	                const childCtx = {
	                    ...ctx,
	                    common: {
	                        ...ctx.common,
	                        issues: [],
	                    },
	                    parent: null,
	                };
	                return {
	                    result: await option._parseAsync({
	                        data: ctx.data,
	                        path: ctx.path,
	                        parent: childCtx,
	                    }),
	                    ctx: childCtx,
	                };
	            })).then(handleResults);
	        }
	        else {
	            let dirty = undefined;
	            const issues = [];
	            for (const option of options) {
	                const childCtx = {
	                    ...ctx,
	                    common: {
	                        ...ctx.common,
	                        issues: [],
	                    },
	                    parent: null,
	                };
	                const result = option._parseSync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: childCtx,
	                });
	                if (result.status === "valid") {
	                    return result;
	                }
	                else if (result.status === "dirty" && !dirty) {
	                    dirty = { result, ctx: childCtx };
	                }
	                if (childCtx.common.issues.length) {
	                    issues.push(childCtx.common.issues);
	                }
	            }
	            if (dirty) {
	                ctx.common.issues.push(...dirty.ctx.common.issues);
	                return dirty.result;
	            }
	            const unionErrors = issues.map((issues) => new ZodError_js_1.ZodError(issues));
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_union,
	                unionErrors,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	    }
	    get options() {
	        return this._def.options;
	    }
	}
	types.ZodUnion = ZodUnion;
	ZodUnion.create = (types, params) => {
	    return new ZodUnion({
	        options: types,
	        typeName: ZodFirstPartyTypeKind.ZodUnion,
	        ...processCreateParams(params),
	    });
	};
	/////////////////////////////////////////////////////
	/////////////////////////////////////////////////////
	//////////                                 //////////
	//////////      ZodDiscriminatedUnion      //////////
	//////////                                 //////////
	/////////////////////////////////////////////////////
	/////////////////////////////////////////////////////
	const getDiscriminator = (type) => {
	    if (type instanceof ZodLazy) {
	        return getDiscriminator(type.schema);
	    }
	    else if (type instanceof ZodEffects) {
	        return getDiscriminator(type.innerType());
	    }
	    else if (type instanceof ZodLiteral) {
	        return [type.value];
	    }
	    else if (type instanceof ZodEnum) {
	        return type.options;
	    }
	    else if (type instanceof ZodNativeEnum) {
	        // eslint-disable-next-line ban/ban
	        return util_js_1.util.objectValues(type.enum);
	    }
	    else if (type instanceof ZodDefault) {
	        return getDiscriminator(type._def.innerType);
	    }
	    else if (type instanceof ZodUndefined) {
	        return [undefined];
	    }
	    else if (type instanceof ZodNull) {
	        return [null];
	    }
	    else if (type instanceof ZodOptional) {
	        return [undefined, ...getDiscriminator(type.unwrap())];
	    }
	    else if (type instanceof ZodNullable) {
	        return [null, ...getDiscriminator(type.unwrap())];
	    }
	    else if (type instanceof ZodBranded) {
	        return getDiscriminator(type.unwrap());
	    }
	    else if (type instanceof ZodReadonly) {
	        return getDiscriminator(type.unwrap());
	    }
	    else if (type instanceof ZodCatch) {
	        return getDiscriminator(type._def.innerType);
	    }
	    else {
	        return [];
	    }
	};
	class ZodDiscriminatedUnion extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_js_1.ZodParsedType.object) {
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	                expected: util_js_1.ZodParsedType.object,
	                received: ctx.parsedType,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        const discriminator = this.discriminator;
	        const discriminatorValue = ctx.data[discriminator];
	        const option = this.optionsMap.get(discriminatorValue);
	        if (!option) {
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_union_discriminator,
	                options: Array.from(this.optionsMap.keys()),
	                path: [discriminator],
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        if (ctx.common.async) {
	            return option._parseAsync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            });
	        }
	        else {
	            return option._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            });
	        }
	    }
	    get discriminator() {
	        return this._def.discriminator;
	    }
	    get options() {
	        return this._def.options;
	    }
	    get optionsMap() {
	        return this._def.optionsMap;
	    }
	    /**
	     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
	     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
	     * have a different value for each object in the union.
	     * @param discriminator the name of the discriminator property
	     * @param types an array of object schemas
	     * @param params
	     */
	    static create(discriminator, options, params) {
	        // Get all the valid discriminator values
	        const optionsMap = new Map();
	        // try {
	        for (const type of options) {
	            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
	            if (!discriminatorValues.length) {
	                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
	            }
	            for (const value of discriminatorValues) {
	                if (optionsMap.has(value)) {
	                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
	                }
	                optionsMap.set(value, type);
	            }
	        }
	        return new ZodDiscriminatedUnion({
	            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
	            discriminator,
	            options,
	            optionsMap,
	            ...processCreateParams(params),
	        });
	    }
	}
	types.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
	function mergeValues(a, b) {
	    const aType = (0, util_js_1.getParsedType)(a);
	    const bType = (0, util_js_1.getParsedType)(b);
	    if (a === b) {
	        return { valid: true, data: a };
	    }
	    else if (aType === util_js_1.ZodParsedType.object && bType === util_js_1.ZodParsedType.object) {
	        const bKeys = util_js_1.util.objectKeys(b);
	        const sharedKeys = util_js_1.util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
	        const newObj = { ...a, ...b };
	        for (const key of sharedKeys) {
	            const sharedValue = mergeValues(a[key], b[key]);
	            if (!sharedValue.valid) {
	                return { valid: false };
	            }
	            newObj[key] = sharedValue.data;
	        }
	        return { valid: true, data: newObj };
	    }
	    else if (aType === util_js_1.ZodParsedType.array && bType === util_js_1.ZodParsedType.array) {
	        if (a.length !== b.length) {
	            return { valid: false };
	        }
	        const newArray = [];
	        for (let index = 0; index < a.length; index++) {
	            const itemA = a[index];
	            const itemB = b[index];
	            const sharedValue = mergeValues(itemA, itemB);
	            if (!sharedValue.valid) {
	                return { valid: false };
	            }
	            newArray.push(sharedValue.data);
	        }
	        return { valid: true, data: newArray };
	    }
	    else if (aType === util_js_1.ZodParsedType.date && bType === util_js_1.ZodParsedType.date && +a === +b) {
	        return { valid: true, data: a };
	    }
	    else {
	        return { valid: false };
	    }
	}
	class ZodIntersection extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        const handleParsed = (parsedLeft, parsedRight) => {
	            if ((0, parseUtil_js_1.isAborted)(parsedLeft) || (0, parseUtil_js_1.isAborted)(parsedRight)) {
	                return parseUtil_js_1.INVALID;
	            }
	            const merged = mergeValues(parsedLeft.value, parsedRight.value);
	            if (!merged.valid) {
	                (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                    code: ZodError_js_1.ZodIssueCode.invalid_intersection_types,
	                });
	                return parseUtil_js_1.INVALID;
	            }
	            if ((0, parseUtil_js_1.isDirty)(parsedLeft) || (0, parseUtil_js_1.isDirty)(parsedRight)) {
	                status.dirty();
	            }
	            return { status: status.value, value: merged.data };
	        };
	        if (ctx.common.async) {
	            return Promise.all([
	                this._def.left._parseAsync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                }),
	                this._def.right._parseAsync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                }),
	            ]).then(([left, right]) => handleParsed(left, right));
	        }
	        else {
	            return handleParsed(this._def.left._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            }), this._def.right._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            }));
	        }
	    }
	}
	types.ZodIntersection = ZodIntersection;
	ZodIntersection.create = (left, right, params) => {
	    return new ZodIntersection({
	        left: left,
	        right: right,
	        typeName: ZodFirstPartyTypeKind.ZodIntersection,
	        ...processCreateParams(params),
	    });
	};
	// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];
	class ZodTuple extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_js_1.ZodParsedType.array) {
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	                expected: util_js_1.ZodParsedType.array,
	                received: ctx.parsedType,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        if (ctx.data.length < this._def.items.length) {
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.too_small,
	                minimum: this._def.items.length,
	                inclusive: true,
	                exact: false,
	                type: "array",
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        const rest = this._def.rest;
	        if (!rest && ctx.data.length > this._def.items.length) {
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.too_big,
	                maximum: this._def.items.length,
	                inclusive: true,
	                exact: false,
	                type: "array",
	            });
	            status.dirty();
	        }
	        const items = [...ctx.data]
	            .map((item, itemIndex) => {
	            const schema = this._def.items[itemIndex] || this._def.rest;
	            if (!schema)
	                return null;
	            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
	        })
	            .filter((x) => !!x); // filter nulls
	        if (ctx.common.async) {
	            return Promise.all(items).then((results) => {
	                return parseUtil_js_1.ParseStatus.mergeArray(status, results);
	            });
	        }
	        else {
	            return parseUtil_js_1.ParseStatus.mergeArray(status, items);
	        }
	    }
	    get items() {
	        return this._def.items;
	    }
	    rest(rest) {
	        return new ZodTuple({
	            ...this._def,
	            rest,
	        });
	    }
	}
	types.ZodTuple = ZodTuple;
	ZodTuple.create = (schemas, params) => {
	    if (!Array.isArray(schemas)) {
	        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
	    }
	    return new ZodTuple({
	        items: schemas,
	        typeName: ZodFirstPartyTypeKind.ZodTuple,
	        rest: null,
	        ...processCreateParams(params),
	    });
	};
	class ZodRecord extends ZodType {
	    get keySchema() {
	        return this._def.keyType;
	    }
	    get valueSchema() {
	        return this._def.valueType;
	    }
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_js_1.ZodParsedType.object) {
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	                expected: util_js_1.ZodParsedType.object,
	                received: ctx.parsedType,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        const pairs = [];
	        const keyType = this._def.keyType;
	        const valueType = this._def.valueType;
	        for (const key in ctx.data) {
	            pairs.push({
	                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
	                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
	                alwaysSet: key in ctx.data,
	            });
	        }
	        if (ctx.common.async) {
	            return parseUtil_js_1.ParseStatus.mergeObjectAsync(status, pairs);
	        }
	        else {
	            return parseUtil_js_1.ParseStatus.mergeObjectSync(status, pairs);
	        }
	    }
	    get element() {
	        return this._def.valueType;
	    }
	    static create(first, second, third) {
	        if (second instanceof ZodType) {
	            return new ZodRecord({
	                keyType: first,
	                valueType: second,
	                typeName: ZodFirstPartyTypeKind.ZodRecord,
	                ...processCreateParams(third),
	            });
	        }
	        return new ZodRecord({
	            keyType: ZodString.create(),
	            valueType: first,
	            typeName: ZodFirstPartyTypeKind.ZodRecord,
	            ...processCreateParams(second),
	        });
	    }
	}
	types.ZodRecord = ZodRecord;
	class ZodMap extends ZodType {
	    get keySchema() {
	        return this._def.keyType;
	    }
	    get valueSchema() {
	        return this._def.valueType;
	    }
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_js_1.ZodParsedType.map) {
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	                expected: util_js_1.ZodParsedType.map,
	                received: ctx.parsedType,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        const keyType = this._def.keyType;
	        const valueType = this._def.valueType;
	        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
	            return {
	                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
	                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
	            };
	        });
	        if (ctx.common.async) {
	            const finalMap = new Map();
	            return Promise.resolve().then(async () => {
	                for (const pair of pairs) {
	                    const key = await pair.key;
	                    const value = await pair.value;
	                    if (key.status === "aborted" || value.status === "aborted") {
	                        return parseUtil_js_1.INVALID;
	                    }
	                    if (key.status === "dirty" || value.status === "dirty") {
	                        status.dirty();
	                    }
	                    finalMap.set(key.value, value.value);
	                }
	                return { status: status.value, value: finalMap };
	            });
	        }
	        else {
	            const finalMap = new Map();
	            for (const pair of pairs) {
	                const key = pair.key;
	                const value = pair.value;
	                if (key.status === "aborted" || value.status === "aborted") {
	                    return parseUtil_js_1.INVALID;
	                }
	                if (key.status === "dirty" || value.status === "dirty") {
	                    status.dirty();
	                }
	                finalMap.set(key.value, value.value);
	            }
	            return { status: status.value, value: finalMap };
	        }
	    }
	}
	types.ZodMap = ZodMap;
	ZodMap.create = (keyType, valueType, params) => {
	    return new ZodMap({
	        valueType,
	        keyType,
	        typeName: ZodFirstPartyTypeKind.ZodMap,
	        ...processCreateParams(params),
	    });
	};
	class ZodSet extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_js_1.ZodParsedType.set) {
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	                expected: util_js_1.ZodParsedType.set,
	                received: ctx.parsedType,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        const def = this._def;
	        if (def.minSize !== null) {
	            if (ctx.data.size < def.minSize.value) {
	                (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                    code: ZodError_js_1.ZodIssueCode.too_small,
	                    minimum: def.minSize.value,
	                    type: "set",
	                    inclusive: true,
	                    exact: false,
	                    message: def.minSize.message,
	                });
	                status.dirty();
	            }
	        }
	        if (def.maxSize !== null) {
	            if (ctx.data.size > def.maxSize.value) {
	                (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                    code: ZodError_js_1.ZodIssueCode.too_big,
	                    maximum: def.maxSize.value,
	                    type: "set",
	                    inclusive: true,
	                    exact: false,
	                    message: def.maxSize.message,
	                });
	                status.dirty();
	            }
	        }
	        const valueType = this._def.valueType;
	        function finalizeSet(elements) {
	            const parsedSet = new Set();
	            for (const element of elements) {
	                if (element.status === "aborted")
	                    return parseUtil_js_1.INVALID;
	                if (element.status === "dirty")
	                    status.dirty();
	                parsedSet.add(element.value);
	            }
	            return { status: status.value, value: parsedSet };
	        }
	        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
	        if (ctx.common.async) {
	            return Promise.all(elements).then((elements) => finalizeSet(elements));
	        }
	        else {
	            return finalizeSet(elements);
	        }
	    }
	    min(minSize, message) {
	        return new ZodSet({
	            ...this._def,
	            minSize: { value: minSize, message: errorUtil_js_1.errorUtil.toString(message) },
	        });
	    }
	    max(maxSize, message) {
	        return new ZodSet({
	            ...this._def,
	            maxSize: { value: maxSize, message: errorUtil_js_1.errorUtil.toString(message) },
	        });
	    }
	    size(size, message) {
	        return this.min(size, message).max(size, message);
	    }
	    nonempty(message) {
	        return this.min(1, message);
	    }
	}
	types.ZodSet = ZodSet;
	ZodSet.create = (valueType, params) => {
	    return new ZodSet({
	        valueType,
	        minSize: null,
	        maxSize: null,
	        typeName: ZodFirstPartyTypeKind.ZodSet,
	        ...processCreateParams(params),
	    });
	};
	class ZodFunction extends ZodType {
	    constructor() {
	        super(...arguments);
	        this.validate = this.implement;
	    }
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_js_1.ZodParsedType.function) {
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	                expected: util_js_1.ZodParsedType.function,
	                received: ctx.parsedType,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        function makeArgsIssue(args, error) {
	            return (0, parseUtil_js_1.makeIssue)({
	                data: args,
	                path: ctx.path,
	                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, (0, errors_js_1.getErrorMap)(), errors_js_1.defaultErrorMap].filter((x) => !!x),
	                issueData: {
	                    code: ZodError_js_1.ZodIssueCode.invalid_arguments,
	                    argumentsError: error,
	                },
	            });
	        }
	        function makeReturnsIssue(returns, error) {
	            return (0, parseUtil_js_1.makeIssue)({
	                data: returns,
	                path: ctx.path,
	                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, (0, errors_js_1.getErrorMap)(), errors_js_1.defaultErrorMap].filter((x) => !!x),
	                issueData: {
	                    code: ZodError_js_1.ZodIssueCode.invalid_return_type,
	                    returnTypeError: error,
	                },
	            });
	        }
	        const params = { errorMap: ctx.common.contextualErrorMap };
	        const fn = ctx.data;
	        if (this._def.returns instanceof ZodPromise) {
	            // Would love a way to avoid disabling this rule, but we need
	            // an alias (using an arrow function was what caused 2651).
	            // eslint-disable-next-line @typescript-eslint/no-this-alias
	            const me = this;
	            return (0, parseUtil_js_1.OK)(async function (...args) {
	                const error = new ZodError_js_1.ZodError([]);
	                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
	                    error.addIssue(makeArgsIssue(args, e));
	                    throw error;
	                });
	                const result = await Reflect.apply(fn, this, parsedArgs);
	                const parsedReturns = await me._def.returns._def.type
	                    .parseAsync(result, params)
	                    .catch((e) => {
	                    error.addIssue(makeReturnsIssue(result, e));
	                    throw error;
	                });
	                return parsedReturns;
	            });
	        }
	        else {
	            // Would love a way to avoid disabling this rule, but we need
	            // an alias (using an arrow function was what caused 2651).
	            // eslint-disable-next-line @typescript-eslint/no-this-alias
	            const me = this;
	            return (0, parseUtil_js_1.OK)(function (...args) {
	                const parsedArgs = me._def.args.safeParse(args, params);
	                if (!parsedArgs.success) {
	                    throw new ZodError_js_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
	                }
	                const result = Reflect.apply(fn, this, parsedArgs.data);
	                const parsedReturns = me._def.returns.safeParse(result, params);
	                if (!parsedReturns.success) {
	                    throw new ZodError_js_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
	                }
	                return parsedReturns.data;
	            });
	        }
	    }
	    parameters() {
	        return this._def.args;
	    }
	    returnType() {
	        return this._def.returns;
	    }
	    args(...items) {
	        return new ZodFunction({
	            ...this._def,
	            args: ZodTuple.create(items).rest(ZodUnknown.create()),
	        });
	    }
	    returns(returnType) {
	        return new ZodFunction({
	            ...this._def,
	            returns: returnType,
	        });
	    }
	    implement(func) {
	        const validatedFunc = this.parse(func);
	        return validatedFunc;
	    }
	    strictImplement(func) {
	        const validatedFunc = this.parse(func);
	        return validatedFunc;
	    }
	    static create(args, returns, params) {
	        return new ZodFunction({
	            args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())),
	            returns: returns || ZodUnknown.create(),
	            typeName: ZodFirstPartyTypeKind.ZodFunction,
	            ...processCreateParams(params),
	        });
	    }
	}
	types.ZodFunction = ZodFunction;
	class ZodLazy extends ZodType {
	    get schema() {
	        return this._def.getter();
	    }
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        const lazySchema = this._def.getter();
	        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
	    }
	}
	types.ZodLazy = ZodLazy;
	ZodLazy.create = (getter, params) => {
	    return new ZodLazy({
	        getter: getter,
	        typeName: ZodFirstPartyTypeKind.ZodLazy,
	        ...processCreateParams(params),
	    });
	};
	class ZodLiteral extends ZodType {
	    _parse(input) {
	        if (input.data !== this._def.value) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                received: ctx.data,
	                code: ZodError_js_1.ZodIssueCode.invalid_literal,
	                expected: this._def.value,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        return { status: "valid", value: input.data };
	    }
	    get value() {
	        return this._def.value;
	    }
	}
	types.ZodLiteral = ZodLiteral;
	ZodLiteral.create = (value, params) => {
	    return new ZodLiteral({
	        value: value,
	        typeName: ZodFirstPartyTypeKind.ZodLiteral,
	        ...processCreateParams(params),
	    });
	};
	function createZodEnum(values, params) {
	    return new ZodEnum({
	        values,
	        typeName: ZodFirstPartyTypeKind.ZodEnum,
	        ...processCreateParams(params),
	    });
	}
	class ZodEnum extends ZodType {
	    _parse(input) {
	        if (typeof input.data !== "string") {
	            const ctx = this._getOrReturnCtx(input);
	            const expectedValues = this._def.values;
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                expected: util_js_1.util.joinValues(expectedValues),
	                received: ctx.parsedType,
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        if (!this._cache) {
	            this._cache = new Set(this._def.values);
	        }
	        if (!this._cache.has(input.data)) {
	            const ctx = this._getOrReturnCtx(input);
	            const expectedValues = this._def.values;
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                received: ctx.data,
	                code: ZodError_js_1.ZodIssueCode.invalid_enum_value,
	                options: expectedValues,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        return (0, parseUtil_js_1.OK)(input.data);
	    }
	    get options() {
	        return this._def.values;
	    }
	    get enum() {
	        const enumValues = {};
	        for (const val of this._def.values) {
	            enumValues[val] = val;
	        }
	        return enumValues;
	    }
	    get Values() {
	        const enumValues = {};
	        for (const val of this._def.values) {
	            enumValues[val] = val;
	        }
	        return enumValues;
	    }
	    get Enum() {
	        const enumValues = {};
	        for (const val of this._def.values) {
	            enumValues[val] = val;
	        }
	        return enumValues;
	    }
	    extract(values, newDef = this._def) {
	        return ZodEnum.create(values, {
	            ...this._def,
	            ...newDef,
	        });
	    }
	    exclude(values, newDef = this._def) {
	        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
	            ...this._def,
	            ...newDef,
	        });
	    }
	}
	types.ZodEnum = ZodEnum;
	ZodEnum.create = createZodEnum;
	class ZodNativeEnum extends ZodType {
	    _parse(input) {
	        const nativeEnumValues = util_js_1.util.getValidEnumValues(this._def.values);
	        const ctx = this._getOrReturnCtx(input);
	        if (ctx.parsedType !== util_js_1.ZodParsedType.string && ctx.parsedType !== util_js_1.ZodParsedType.number) {
	            const expectedValues = util_js_1.util.objectValues(nativeEnumValues);
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                expected: util_js_1.util.joinValues(expectedValues),
	                received: ctx.parsedType,
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        if (!this._cache) {
	            this._cache = new Set(util_js_1.util.getValidEnumValues(this._def.values));
	        }
	        if (!this._cache.has(input.data)) {
	            const expectedValues = util_js_1.util.objectValues(nativeEnumValues);
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                received: ctx.data,
	                code: ZodError_js_1.ZodIssueCode.invalid_enum_value,
	                options: expectedValues,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        return (0, parseUtil_js_1.OK)(input.data);
	    }
	    get enum() {
	        return this._def.values;
	    }
	}
	types.ZodNativeEnum = ZodNativeEnum;
	ZodNativeEnum.create = (values, params) => {
	    return new ZodNativeEnum({
	        values: values,
	        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
	        ...processCreateParams(params),
	    });
	};
	class ZodPromise extends ZodType {
	    unwrap() {
	        return this._def.type;
	    }
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_js_1.ZodParsedType.promise && ctx.common.async === false) {
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	                expected: util_js_1.ZodParsedType.promise,
	                received: ctx.parsedType,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        const promisified = ctx.parsedType === util_js_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
	        return (0, parseUtil_js_1.OK)(promisified.then((data) => {
	            return this._def.type.parseAsync(data, {
	                path: ctx.path,
	                errorMap: ctx.common.contextualErrorMap,
	            });
	        }));
	    }
	}
	types.ZodPromise = ZodPromise;
	ZodPromise.create = (schema, params) => {
	    return new ZodPromise({
	        type: schema,
	        typeName: ZodFirstPartyTypeKind.ZodPromise,
	        ...processCreateParams(params),
	    });
	};
	class ZodEffects extends ZodType {
	    innerType() {
	        return this._def.schema;
	    }
	    sourceType() {
	        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
	            ? this._def.schema.sourceType()
	            : this._def.schema;
	    }
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        const effect = this._def.effect || null;
	        const checkCtx = {
	            addIssue: (arg) => {
	                (0, parseUtil_js_1.addIssueToContext)(ctx, arg);
	                if (arg.fatal) {
	                    status.abort();
	                }
	                else {
	                    status.dirty();
	                }
	            },
	            get path() {
	                return ctx.path;
	            },
	        };
	        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
	        if (effect.type === "preprocess") {
	            const processed = effect.transform(ctx.data, checkCtx);
	            if (ctx.common.async) {
	                return Promise.resolve(processed).then(async (processed) => {
	                    if (status.value === "aborted")
	                        return parseUtil_js_1.INVALID;
	                    const result = await this._def.schema._parseAsync({
	                        data: processed,
	                        path: ctx.path,
	                        parent: ctx,
	                    });
	                    if (result.status === "aborted")
	                        return parseUtil_js_1.INVALID;
	                    if (result.status === "dirty")
	                        return (0, parseUtil_js_1.DIRTY)(result.value);
	                    if (status.value === "dirty")
	                        return (0, parseUtil_js_1.DIRTY)(result.value);
	                    return result;
	                });
	            }
	            else {
	                if (status.value === "aborted")
	                    return parseUtil_js_1.INVALID;
	                const result = this._def.schema._parseSync({
	                    data: processed,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	                if (result.status === "aborted")
	                    return parseUtil_js_1.INVALID;
	                if (result.status === "dirty")
	                    return (0, parseUtil_js_1.DIRTY)(result.value);
	                if (status.value === "dirty")
	                    return (0, parseUtil_js_1.DIRTY)(result.value);
	                return result;
	            }
	        }
	        if (effect.type === "refinement") {
	            const executeRefinement = (acc) => {
	                const result = effect.refinement(acc, checkCtx);
	                if (ctx.common.async) {
	                    return Promise.resolve(result);
	                }
	                if (result instanceof Promise) {
	                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
	                }
	                return acc;
	            };
	            if (ctx.common.async === false) {
	                const inner = this._def.schema._parseSync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	                if (inner.status === "aborted")
	                    return parseUtil_js_1.INVALID;
	                if (inner.status === "dirty")
	                    status.dirty();
	                // return value is ignored
	                executeRefinement(inner.value);
	                return { status: status.value, value: inner.value };
	            }
	            else {
	                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
	                    if (inner.status === "aborted")
	                        return parseUtil_js_1.INVALID;
	                    if (inner.status === "dirty")
	                        status.dirty();
	                    return executeRefinement(inner.value).then(() => {
	                        return { status: status.value, value: inner.value };
	                    });
	                });
	            }
	        }
	        if (effect.type === "transform") {
	            if (ctx.common.async === false) {
	                const base = this._def.schema._parseSync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	                if (!(0, parseUtil_js_1.isValid)(base))
	                    return parseUtil_js_1.INVALID;
	                const result = effect.transform(base.value, checkCtx);
	                if (result instanceof Promise) {
	                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
	                }
	                return { status: status.value, value: result };
	            }
	            else {
	                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
	                    if (!(0, parseUtil_js_1.isValid)(base))
	                        return parseUtil_js_1.INVALID;
	                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
	                        status: status.value,
	                        value: result,
	                    }));
	                });
	            }
	        }
	        util_js_1.util.assertNever(effect);
	    }
	}
	types.ZodEffects = ZodEffects;
	types.ZodTransformer = ZodEffects;
	ZodEffects.create = (schema, effect, params) => {
	    return new ZodEffects({
	        schema,
	        typeName: ZodFirstPartyTypeKind.ZodEffects,
	        effect,
	        ...processCreateParams(params),
	    });
	};
	ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
	    return new ZodEffects({
	        schema,
	        effect: { type: "preprocess", transform: preprocess },
	        typeName: ZodFirstPartyTypeKind.ZodEffects,
	        ...processCreateParams(params),
	    });
	};
	class ZodOptional extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType === util_js_1.ZodParsedType.undefined) {
	            return (0, parseUtil_js_1.OK)(undefined);
	        }
	        return this._def.innerType._parse(input);
	    }
	    unwrap() {
	        return this._def.innerType;
	    }
	}
	types.ZodOptional = ZodOptional;
	ZodOptional.create = (type, params) => {
	    return new ZodOptional({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodOptional,
	        ...processCreateParams(params),
	    });
	};
	class ZodNullable extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType === util_js_1.ZodParsedType.null) {
	            return (0, parseUtil_js_1.OK)(null);
	        }
	        return this._def.innerType._parse(input);
	    }
	    unwrap() {
	        return this._def.innerType;
	    }
	}
	types.ZodNullable = ZodNullable;
	ZodNullable.create = (type, params) => {
	    return new ZodNullable({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodNullable,
	        ...processCreateParams(params),
	    });
	};
	class ZodDefault extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        let data = ctx.data;
	        if (ctx.parsedType === util_js_1.ZodParsedType.undefined) {
	            data = this._def.defaultValue();
	        }
	        return this._def.innerType._parse({
	            data,
	            path: ctx.path,
	            parent: ctx,
	        });
	    }
	    removeDefault() {
	        return this._def.innerType;
	    }
	}
	types.ZodDefault = ZodDefault;
	ZodDefault.create = (type, params) => {
	    return new ZodDefault({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodDefault,
	        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
	        ...processCreateParams(params),
	    });
	};
	class ZodCatch extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        // newCtx is used to not collect issues from inner types in ctx
	        const newCtx = {
	            ...ctx,
	            common: {
	                ...ctx.common,
	                issues: [],
	            },
	        };
	        const result = this._def.innerType._parse({
	            data: newCtx.data,
	            path: newCtx.path,
	            parent: {
	                ...newCtx,
	            },
	        });
	        if ((0, parseUtil_js_1.isAsync)(result)) {
	            return result.then((result) => {
	                return {
	                    status: "valid",
	                    value: result.status === "valid"
	                        ? result.value
	                        : this._def.catchValue({
	                            get error() {
	                                return new ZodError_js_1.ZodError(newCtx.common.issues);
	                            },
	                            input: newCtx.data,
	                        }),
	                };
	            });
	        }
	        else {
	            return {
	                status: "valid",
	                value: result.status === "valid"
	                    ? result.value
	                    : this._def.catchValue({
	                        get error() {
	                            return new ZodError_js_1.ZodError(newCtx.common.issues);
	                        },
	                        input: newCtx.data,
	                    }),
	            };
	        }
	    }
	    removeCatch() {
	        return this._def.innerType;
	    }
	}
	types.ZodCatch = ZodCatch;
	ZodCatch.create = (type, params) => {
	    return new ZodCatch({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodCatch,
	        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
	        ...processCreateParams(params),
	    });
	};
	class ZodNaN extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== util_js_1.ZodParsedType.nan) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_js_1.addIssueToContext)(ctx, {
	                code: ZodError_js_1.ZodIssueCode.invalid_type,
	                expected: util_js_1.ZodParsedType.nan,
	                received: ctx.parsedType,
	            });
	            return parseUtil_js_1.INVALID;
	        }
	        return { status: "valid", value: input.data };
	    }
	}
	types.ZodNaN = ZodNaN;
	ZodNaN.create = (params) => {
	    return new ZodNaN({
	        typeName: ZodFirstPartyTypeKind.ZodNaN,
	        ...processCreateParams(params),
	    });
	};
	types.BRAND = Symbol("zod_brand");
	class ZodBranded extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        const data = ctx.data;
	        return this._def.type._parse({
	            data,
	            path: ctx.path,
	            parent: ctx,
	        });
	    }
	    unwrap() {
	        return this._def.type;
	    }
	}
	types.ZodBranded = ZodBranded;
	class ZodPipeline extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.common.async) {
	            const handleAsync = async () => {
	                const inResult = await this._def.in._parseAsync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	                if (inResult.status === "aborted")
	                    return parseUtil_js_1.INVALID;
	                if (inResult.status === "dirty") {
	                    status.dirty();
	                    return (0, parseUtil_js_1.DIRTY)(inResult.value);
	                }
	                else {
	                    return this._def.out._parseAsync({
	                        data: inResult.value,
	                        path: ctx.path,
	                        parent: ctx,
	                    });
	                }
	            };
	            return handleAsync();
	        }
	        else {
	            const inResult = this._def.in._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            });
	            if (inResult.status === "aborted")
	                return parseUtil_js_1.INVALID;
	            if (inResult.status === "dirty") {
	                status.dirty();
	                return {
	                    status: "dirty",
	                    value: inResult.value,
	                };
	            }
	            else {
	                return this._def.out._parseSync({
	                    data: inResult.value,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	            }
	        }
	    }
	    static create(a, b) {
	        return new ZodPipeline({
	            in: a,
	            out: b,
	            typeName: ZodFirstPartyTypeKind.ZodPipeline,
	        });
	    }
	}
	types.ZodPipeline = ZodPipeline;
	class ZodReadonly extends ZodType {
	    _parse(input) {
	        const result = this._def.innerType._parse(input);
	        const freeze = (data) => {
	            if ((0, parseUtil_js_1.isValid)(data)) {
	                data.value = Object.freeze(data.value);
	            }
	            return data;
	        };
	        return (0, parseUtil_js_1.isAsync)(result) ? result.then((data) => freeze(data)) : freeze(result);
	    }
	    unwrap() {
	        return this._def.innerType;
	    }
	}
	types.ZodReadonly = ZodReadonly;
	ZodReadonly.create = (type, params) => {
	    return new ZodReadonly({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodReadonly,
	        ...processCreateParams(params),
	    });
	};
	////////////////////////////////////////
	////////////////////////////////////////
	//////////                    //////////
	//////////      z.custom      //////////
	//////////                    //////////
	////////////////////////////////////////
	////////////////////////////////////////
	function cleanParams(params, data) {
	    const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
	    const p2 = typeof p === "string" ? { message: p } : p;
	    return p2;
	}
	function custom(check, _params = {}, 
	/**
	 * @deprecated
	 *
	 * Pass `fatal` into the params object instead:
	 *
	 * ```ts
	 * z.string().custom((val) => val.length > 5, { fatal: false })
	 * ```
	 *
	 */
	fatal) {
	    if (check)
	        return ZodAny.create().superRefine((data, ctx) => {
	            const r = check(data);
	            if (r instanceof Promise) {
	                return r.then((r) => {
	                    if (!r) {
	                        const params = cleanParams(_params, data);
	                        const _fatal = params.fatal ?? fatal ?? true;
	                        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
	                    }
	                });
	            }
	            if (!r) {
	                const params = cleanParams(_params, data);
	                const _fatal = params.fatal ?? fatal ?? true;
	                ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
	            }
	            return;
	        });
	    return ZodAny.create();
	}
	types.late = {
	    object: ZodObject.lazycreate,
	};
	var ZodFirstPartyTypeKind;
	(function (ZodFirstPartyTypeKind) {
	    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
	    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
	    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
	    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
	    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
	    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
	    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
	    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
	    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
	    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
	    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
	    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
	    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
	    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
	    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
	    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
	    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
	    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
	    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
	    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
	    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
	    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
	    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
	    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
	    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
	    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
	    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
	    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
	    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
	    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
	    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
	    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
	    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
	    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
	    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
	    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
	})(ZodFirstPartyTypeKind || (types.ZodFirstPartyTypeKind = ZodFirstPartyTypeKind = {}));
	const instanceOfType = (
	// const instanceOfType = <T extends new (...args: any[]) => any>(
	cls, params = {
	    message: `Input not instance of ${cls.name}`,
	}) => custom((data) => data instanceof cls, params);
	types.instanceof = instanceOfType;
	const stringType = ZodString.create;
	types.string = stringType;
	const numberType = ZodNumber.create;
	types.number = numberType;
	const nanType = ZodNaN.create;
	types.nan = nanType;
	const bigIntType = ZodBigInt.create;
	types.bigint = bigIntType;
	const booleanType = ZodBoolean.create;
	types.boolean = booleanType;
	const dateType = ZodDate.create;
	types.date = dateType;
	const symbolType = ZodSymbol.create;
	types.symbol = symbolType;
	const undefinedType = ZodUndefined.create;
	types.undefined = undefinedType;
	const nullType = ZodNull.create;
	types.null = nullType;
	const anyType = ZodAny.create;
	types.any = anyType;
	const unknownType = ZodUnknown.create;
	types.unknown = unknownType;
	const neverType = ZodNever.create;
	types.never = neverType;
	const voidType = ZodVoid.create;
	types.void = voidType;
	const arrayType = ZodArray.create;
	types.array = arrayType;
	const objectType = ZodObject.create;
	types.object = objectType;
	const strictObjectType = ZodObject.strictCreate;
	types.strictObject = strictObjectType;
	const unionType = ZodUnion.create;
	types.union = unionType;
	const discriminatedUnionType = ZodDiscriminatedUnion.create;
	types.discriminatedUnion = discriminatedUnionType;
	const intersectionType = ZodIntersection.create;
	types.intersection = intersectionType;
	const tupleType = ZodTuple.create;
	types.tuple = tupleType;
	const recordType = ZodRecord.create;
	types.record = recordType;
	const mapType = ZodMap.create;
	types.map = mapType;
	const setType = ZodSet.create;
	types.set = setType;
	const functionType = ZodFunction.create;
	types.function = functionType;
	const lazyType = ZodLazy.create;
	types.lazy = lazyType;
	const literalType = ZodLiteral.create;
	types.literal = literalType;
	const enumType = ZodEnum.create;
	types.enum = enumType;
	const nativeEnumType = ZodNativeEnum.create;
	types.nativeEnum = nativeEnumType;
	const promiseType = ZodPromise.create;
	types.promise = promiseType;
	const effectsType = ZodEffects.create;
	types.effect = effectsType;
	types.transformer = effectsType;
	const optionalType = ZodOptional.create;
	types.optional = optionalType;
	const nullableType = ZodNullable.create;
	types.nullable = nullableType;
	const preprocessType = ZodEffects.createWithPreprocess;
	types.preprocess = preprocessType;
	const pipelineType = ZodPipeline.create;
	types.pipeline = pipelineType;
	const ostring = () => stringType().optional();
	types.ostring = ostring;
	const onumber = () => numberType().optional();
	types.onumber = onumber;
	const oboolean = () => booleanType().optional();
	types.oboolean = oboolean;
	types.coerce = {
	    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
	    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
	    boolean: ((arg) => ZodBoolean.create({
	        ...arg,
	        coerce: true,
	    })),
	    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
	    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
	};
	types.NEVER = parseUtil_js_1.INVALID;
	return types;
}

var hasRequiredExternal;

function requireExternal () {
	if (hasRequiredExternal) return external;
	hasRequiredExternal = 1;
	(function (exports) {
		var __createBinding = (external && external.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (external && external.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(/*@__PURE__*/ requireErrors(), exports);
		__exportStar(/*@__PURE__*/ requireParseUtil(), exports);
		__exportStar(/*@__PURE__*/ requireTypeAliases(), exports);
		__exportStar(/*@__PURE__*/ requireUtil(), exports);
		__exportStar(/*@__PURE__*/ requireTypes(), exports);
		__exportStar(/*@__PURE__*/ requireZodError(), exports); 
	} (external));
	return external;
}

var hasRequiredZod;

function requireZod () {
	if (hasRequiredZod) return zod;
	hasRequiredZod = 1;
	(function (exports) {
		var __createBinding = (zod && zod.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (zod && zod.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (zod && zod.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __exportStar = (zod && zod.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.z = void 0;
		const z = __importStar(/*@__PURE__*/ requireExternal());
		exports.z = z;
		__exportStar(/*@__PURE__*/ requireExternal(), exports);
		exports.default = z; 
	} (zod));
	return zod;
}

const version$3 = "15.3.1";
const require$$4 = {
  version: version$3};

var hasRequiredHttpApi;

function requireHttpApi () {
	if (hasRequiredHttpApi) return HttpApi;
	hasRequiredHttpApi = 1;
	var __importDefault = (HttpApi && HttpApi.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(HttpApi, "__esModule", { value: true });
	HttpApi.HttpApi = void 0;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	const TonCache_1 = requireTonCache();
	const dataloader_1 = __importDefault(requireDataloader());
	const axios_1 = __importDefault(/*@__PURE__*/ requireAxios());
	const zod_1 = /*@__PURE__*/ requireZod();
	const version = require$$4.version;
	const blockIdExt = zod_1.z.object({
	    '@type': zod_1.z.literal('ton.blockIdExt'),
	    workchain: zod_1.z.number(),
	    shard: zod_1.z.string(),
	    seqno: zod_1.z.number(),
	    root_hash: zod_1.z.string(),
	    file_hash: zod_1.z.string()
	});
	const addressInformation = zod_1.z.object({
	    balance: zod_1.z.union([zod_1.z.number(), zod_1.z.string()]),
	    extra_currencies: zod_1.z.optional(zod_1.z.array(zod_1.z.object({
	        '@type': zod_1.z.literal("extraCurrency"),
	        id: zod_1.z.number(),
	        amount: zod_1.z.string()
	    }))),
	    state: zod_1.z.union([zod_1.z.literal('active'), zod_1.z.literal('uninitialized'), zod_1.z.literal('frozen')]),
	    data: zod_1.z.string(),
	    code: zod_1.z.string(),
	    last_transaction_id: zod_1.z.object({
	        '@type': zod_1.z.literal('internal.transactionId'),
	        lt: zod_1.z.string(),
	        hash: zod_1.z.string()
	    }),
	    block_id: blockIdExt,
	    sync_utime: zod_1.z.number()
	});
	const bocResponse = zod_1.z.object({
	    '@type': zod_1.z.literal('ok')
	});
	const feeResponse = zod_1.z.object({
	    '@type': zod_1.z.literal('query.fees'),
	    source_fees: zod_1.z.object({
	        '@type': zod_1.z.literal('fees'),
	        in_fwd_fee: zod_1.z.number(),
	        storage_fee: zod_1.z.number(),
	        gas_fee: zod_1.z.number(),
	        fwd_fee: zod_1.z.number()
	    })
	});
	const callGetMethod = zod_1.z.object({
	    gas_used: zod_1.z.number(),
	    exit_code: zod_1.z.number(),
	    stack: zod_1.z.array(zod_1.z.unknown())
	});
	const messageData = zod_1.z.union([
	    zod_1.z.object({
	        '@type': zod_1.z.literal('msg.dataRaw'),
	        'body': zod_1.z.string()
	    }),
	    zod_1.z.object({
	        '@type': zod_1.z.literal('msg.dataText'),
	        'text': zod_1.z.string()
	    }),
	    zod_1.z.object({
	        '@type': zod_1.z.literal('msg.dataDecryptedText'),
	        'text': zod_1.z.string()
	    }),
	    zod_1.z.object({
	        '@type': zod_1.z.literal('msg.dataEncryptedText'),
	        'text': zod_1.z.string()
	    })
	]);
	const message = zod_1.z.object({
	    source: zod_1.z.string(),
	    destination: zod_1.z.string(),
	    value: zod_1.z.string(),
	    fwd_fee: zod_1.z.string(),
	    ihr_fee: zod_1.z.string(),
	    created_lt: zod_1.z.string(),
	    body_hash: zod_1.z.string(),
	    msg_data: messageData,
	    message: zod_1.z.string().optional()
	});
	const transaction = zod_1.z.object({
	    data: zod_1.z.string(),
	    utime: zod_1.z.number(),
	    transaction_id: zod_1.z.object({
	        lt: zod_1.z.string(),
	        hash: zod_1.z.string()
	    }),
	    fee: zod_1.z.string(),
	    storage_fee: zod_1.z.string(),
	    other_fee: zod_1.z.string(),
	    in_msg: zod_1.z.union([zod_1.z.undefined(), message]),
	    out_msgs: zod_1.z.array(message)
	});
	const getTransactions = zod_1.z.array(transaction);
	const getMasterchain = zod_1.z.object({
	    state_root_hash: zod_1.z.string(),
	    last: blockIdExt,
	    init: blockIdExt
	});
	const getShards = zod_1.z.object({
	    shards: zod_1.z.array(blockIdExt)
	});
	const blockShortTxt = zod_1.z.object({
	    '@type': zod_1.z.literal('blocks.shortTxId'),
	    mode: zod_1.z.number(),
	    account: zod_1.z.string(),
	    lt: zod_1.z.string(),
	    hash: zod_1.z.string()
	});
	const getBlockTransactions = zod_1.z.object({
	    id: blockIdExt,
	    req_count: zod_1.z.number(),
	    incomplete: zod_1.z.boolean(),
	    transactions: zod_1.z.array(blockShortTxt)
	});
	class TypedCache {
	    constructor(namespace, cache, codec, keyEncoder) {
	        this.namespace = namespace;
	        this.cache = cache;
	        this.codec = codec;
	        this.keyEncoder = keyEncoder;
	    }
	    async get(key) {
	        let ex = await this.cache.get(this.namespace, this.keyEncoder(key));
	        if (ex) {
	            let decoded = this.codec.safeParse(JSON.parse(ex));
	            if (decoded.success) {
	                return decoded.data;
	            }
	        }
	        return null;
	    }
	    async set(key, value) {
	        if (value !== null) {
	            await this.cache.set(this.namespace, this.keyEncoder(key), JSON.stringify(value));
	        }
	        else {
	            await this.cache.set(this.namespace, this.keyEncoder(key), null);
	        }
	    }
	}
	let HttpApi$1 = class HttpApi {
	    constructor(endpoint, parameters) {
	        this.endpoint = endpoint;
	        this.cache = new TonCache_1.InMemoryCache();
	        this.parameters = {
	            timeout: parameters?.timeout || 30000, // 30 seconds by default
	            apiKey: parameters?.apiKey,
	            adapter: parameters?.adapter
	        };
	        // Shard
	        this.shardCache = new TypedCache('ton-shard', this.cache, zod_1.z.array(blockIdExt), (src) => src + '');
	        this.shardLoader = new dataloader_1.default(async (src) => {
	            return await Promise.all(src.map(async (v) => {
	                const cached = await this.shardCache.get(v);
	                if (cached) {
	                    return cached;
	                }
	                let loaded = (await this.doCall('shards', { seqno: v }, getShards)).shards;
	                await this.shardCache.set(v, loaded);
	                return loaded;
	            }));
	        });
	        // Shard Transactions
	        this.shardTransactionsCache = new TypedCache('ton-shard-tx', this.cache, getBlockTransactions, (src) => src.workchain + ':' + src.shard + ':' + src.seqno);
	        this.shardTransactionsLoader = new dataloader_1.default(async (src) => {
	            return await Promise.all(src.map(async (v) => {
	                const cached = await this.shardTransactionsCache.get(v);
	                if (cached) {
	                    return cached;
	                }
	                let loaded = await this.doCall('getBlockTransactions', { workchain: v.workchain, seqno: v.seqno, shard: v.shard }, getBlockTransactions);
	                await this.shardTransactionsCache.set(v, loaded);
	                return loaded;
	            }));
	        }, { cacheKeyFn: (src) => src.workchain + ':' + src.shard + ':' + src.seqno });
	    }
	    getAddressInformation(address) {
	        return this.doCall('getAddressInformation', { address: address.toString() }, addressInformation);
	    }
	    async getTransactions(address, opts) {
	        const inclusive = opts.inclusive;
	        delete opts.inclusive;
	        // Convert hash
	        let hash = undefined;
	        if (opts.hash) {
	            hash = Buffer.from(opts.hash, 'base64').toString('hex');
	        }
	        // Adjust limit
	        let limit = opts.limit;
	        if (opts.hash && opts.lt && inclusive !== true) {
	            limit++;
	        }
	        // Do request
	        let res = await this.doCall('getTransactions', { address: address.toString(), ...opts, limit, hash }, getTransactions);
	        if (res.length > limit) {
	            res = res.slice(0, limit);
	        }
	        // Adjust result
	        if (opts.hash && opts.lt && inclusive !== true) {
	            res.shift();
	            return res;
	        }
	        else {
	            return res;
	        }
	    }
	    async getMasterchainInfo() {
	        return await this.doCall('getMasterchainInfo', {}, getMasterchain);
	    }
	    async getShards(seqno) {
	        return await this.shardLoader.load(seqno);
	    }
	    async getBlockTransactions(workchain, seqno, shard) {
	        return await this.shardTransactionsLoader.load({ workchain, seqno, shard });
	    }
	    async getTransaction(address, lt, hash) {
	        let convHash = Buffer.from(hash, 'base64').toString('hex');
	        let res = await this.doCall('getTransactions', { address: address.toString(), lt, hash: convHash, limit: 1 }, getTransactions);
	        let ex = res.find((v) => v.transaction_id.lt === lt && v.transaction_id.hash === hash);
	        if (ex) {
	            return ex;
	        }
	        else {
	            return null;
	        }
	    }
	    async callGetMethod(address, method, stack) {
	        return await this.doCall('runGetMethod', { address: address.toString(), method, stack: serializeStack(stack) }, callGetMethod);
	    }
	    async sendBoc(body) {
	        await this.doCall('sendBoc', { boc: body.toString('base64') }, bocResponse);
	    }
	    async estimateFee(address, args) {
	        return await this.doCall('estimateFee', {
	            address: address.toString(),
	            body: args.body.toBoc().toString('base64'),
	            'init_data': args.initData ? args.initData.toBoc().toString('base64') : '',
	            'init_code': args.initCode ? args.initCode.toBoc().toString('base64') : '',
	            ignore_chksig: args.ignoreSignature
	        }, feeResponse);
	    }
	    async tryLocateResultTx(source, destination, created_lt) {
	        return await this.doCall('tryLocateResultTx', { source: source.toString(), destination: destination.toString(), created_lt }, transaction);
	    }
	    async tryLocateSourceTx(source, destination, created_lt) {
	        return await this.doCall('tryLocateSourceTx', { source: source.toString(), destination: destination.toString(), created_lt }, transaction);
	    }
	    async doCall(method, body, codec) {
	        let headers = {
	            'Content-Type': 'application/json',
	            'X-Ton-Client-Version': version,
	        };
	        if (this.parameters.apiKey) {
	            headers['X-API-Key'] = this.parameters.apiKey;
	        }
	        let res = await axios_1.default.post(this.endpoint, JSON.stringify({
	            id: '1',
	            jsonrpc: '2.0',
	            method: method,
	            params: body
	        }), {
	            headers,
	            timeout: this.parameters.timeout,
	            adapter: this.parameters.adapter
	        });
	        if (res.status !== 200 || !res.data.ok) {
	            throw Error('Received error: ' + JSON.stringify(res.data));
	        }
	        let decoded = codec.safeParse(res.data.result);
	        if (decoded.success) {
	            return decoded.data;
	        }
	        else {
	            throw Error('Malformed response: ' + decoded.error.format()._errors.join(', '));
	        }
	    }
	};
	HttpApi.HttpApi = HttpApi$1;
	function serializeStack(src) {
	    let stack = [];
	    for (let s of src) {
	        if (s.type === 'int') {
	            stack.push(['num', s.value.toString()]);
	        }
	        else if (s.type === 'cell') {
	            stack.push(['tvm.Cell', s.cell.toBoc().toString('base64')]);
	        }
	        else if (s.type === 'slice') {
	            stack.push(['tvm.Slice', s.cell.toBoc().toString('base64')]);
	        }
	        else if (s.type === 'builder') {
	            stack.push(['tvm.Builder', s.cell.toBoc().toString('base64')]);
	        }
	        else {
	            throw Error('Unsupported stack item type: ' + s.type);
	        }
	    }
	    return stack;
	}
	return HttpApi;
}

var TonClient = {};

var hasRequiredTonClient;

function requireTonClient () {
	if (hasRequiredTonClient) return TonClient;
	hasRequiredTonClient = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(TonClient, "__esModule", { value: true });
	TonClient.TonClient = void 0;
	const HttpApi_1 = requireHttpApi();
	const core_1 = requireDist$2();
	let TonClient$1 = class TonClient {
	    constructor(parameters) {
	        this.parameters = {
	            endpoint: parameters.endpoint
	        };
	        this.api = new HttpApi_1.HttpApi(this.parameters.endpoint, {
	            timeout: parameters.timeout,
	            apiKey: parameters.apiKey,
	            adapter: parameters.httpAdapter
	        });
	    }
	    /**
	     * Get Address Balance
	     * @param address address for balance check
	     * @returns balance
	     */
	    async getBalance(address) {
	        return (await this.getContractState(address)).balance;
	    }
	    /**
	     * Invoke get method
	     * @param address contract address
	     * @param name name of method
	     * @param params optional parameters
	     * @returns stack and gas_used field
	     */
	    async runMethod(address, name, stack = []) {
	        let res = await this.api.callGetMethod(address, name, stack);
	        if (res.exit_code !== 0) {
	            throw Error('Unable to execute get method. Got exit_code: ' + res.exit_code);
	        }
	        return { gas_used: res.gas_used, stack: parseStack(res.stack) };
	    }
	    /**
	     * Invoke get method
	     * @param address contract address
	     * @param name name of method
	     * @param params optional parameters
	     * @returns stack and gas_used field
	     * @deprecated use runMethod instead
	     */
	    async callGetMethod(address, name, stack = []) {
	        return this.runMethod(address, name, stack);
	    }
	    /**
	     * Invoke get method that returns error code instead of throwing error
	     * @param address contract address
	     * @param name name of method
	     * @param params optional parameters
	     * @returns stack and gas_used field
	    */
	    async runMethodWithError(address, name, params = []) {
	        let res = await this.api.callGetMethod(address, name, params);
	        return { gas_used: res.gas_used, stack: parseStack(res.stack), exit_code: res.exit_code };
	    }
	    /**
	     * Invoke get method that returns error code instead of throwing error
	     * @param address contract address
	     * @param name name of method
	     * @param params optional parameters
	     * @returns stack and gas_used field
	     * @deprecated use runMethodWithError instead
	     */
	    async callGetMethodWithError(address, name, stack = []) {
	        return this.runMethodWithError(address, name, stack);
	    }
	    /**
	     * Get transactions
	     * @param address address
	     */
	    async getTransactions(address, opts) {
	        // Fetch transactions
	        let tx = await this.api.getTransactions(address, opts);
	        let res = [];
	        for (let r of tx) {
	            res.push((0, core_1.loadTransaction)(core_1.Cell.fromBoc(Buffer.from(r.data, 'base64'))[0].beginParse()));
	        }
	        return res;
	    }
	    /**
	     * Get transaction by it's id
	     * @param address address
	     * @param lt logical time
	     * @param hash transaction hash
	     * @returns transaction or null if not exist
	     */
	    async getTransaction(address, lt, hash) {
	        let res = await this.api.getTransaction(address, lt, hash);
	        if (res) {
	            return (0, core_1.loadTransaction)(core_1.Cell.fromBoc(Buffer.from(res.data, 'base64'))[0].beginParse());
	        }
	        else {
	            return null;
	        }
	    }
	    /**
	     * Locate outcoming transaction of destination address by incoming message
	     * @param source message source address
	     * @param destination message destination address
	     * @param created_lt message's created lt
	     * @returns transaction
	     */
	    async tryLocateResultTx(source, destination, created_lt) {
	        let res = await this.api.tryLocateResultTx(source, destination, created_lt);
	        return (0, core_1.loadTransaction)(core_1.Cell.fromBase64(res.data).beginParse());
	    }
	    /**
	     * Locate incoming transaction of source address by outcoming message
	     * @param source message source address
	     * @param destination message destination address
	     * @param created_lt message's created lt
	     * @returns transaction
	     */
	    async tryLocateSourceTx(source, destination, created_lt) {
	        let res = await this.api.tryLocateSourceTx(source, destination, created_lt);
	        return (0, core_1.loadTransaction)(core_1.Cell.fromBase64(res.data).beginParse());
	    }
	    /**
	     * Fetch latest masterchain info
	     * @returns masterchain info
	     */
	    async getMasterchainInfo() {
	        let r = await this.api.getMasterchainInfo();
	        return {
	            workchain: r.init.workchain,
	            shard: r.last.shard,
	            initSeqno: r.init.seqno,
	            latestSeqno: r.last.seqno
	        };
	    }
	    /**
	     * Fetch latest workchain shards
	     * @param seqno masterchain seqno
	     */
	    async getWorkchainShards(seqno) {
	        let r = await this.api.getShards(seqno);
	        return r.map((m) => ({
	            workchain: m.workchain,
	            shard: m.shard,
	            seqno: m.seqno
	        }));
	    }
	    /**
	     * Fetch transactions inf shards
	     * @param workchain
	     * @param seqno
	     * @param shard
	     */
	    async getShardTransactions(workchain, seqno, shard) {
	        let tx = await this.api.getBlockTransactions(workchain, seqno, shard);
	        if (tx.incomplete) {
	            throw Error('Unsupported');
	        }
	        return tx.transactions.map((v) => ({
	            account: core_1.Address.parseRaw(v.account),
	            lt: v.lt,
	            hash: v.hash
	        }));
	    }
	    /**
	     * Send message to a network
	     * @param src source message
	     */
	    async sendMessage(src) {
	        const boc = (0, core_1.beginCell)()
	            .store((0, core_1.storeMessage)(src))
	            .endCell()
	            .toBoc();
	        await this.api.sendBoc(boc);
	    }
	    /**
	     * Send file to a network
	     * @param src source file
	     */
	    async sendFile(src) {
	        await this.api.sendBoc(src);
	    }
	    /**
	     * Estimate fees for external message
	     * @param address target address
	     * @returns
	     */
	    async estimateExternalMessageFee(address, args) {
	        return await this.api.estimateFee(address, { body: args.body, initCode: args.initCode, initData: args.initData, ignoreSignature: args.ignoreSignature });
	    }
	    /**
	     * Send external message to contract
	     * @param contract contract to send message
	     * @param src message body
	     */
	    async sendExternalMessage(contract, src) {
	        if (await this.isContractDeployed(contract.address) || !contract.init) {
	            const message = (0, core_1.external)({
	                to: contract.address,
	                body: src
	            });
	            await this.sendMessage(message);
	        }
	        else {
	            const message = (0, core_1.external)({
	                to: contract.address,
	                init: contract.init,
	                body: src
	            });
	            await this.sendMessage(message);
	        }
	    }
	    /**
	     * Check if contract is deployed
	     * @param address addres to check
	     * @returns true if contract is in active state
	     */
	    async isContractDeployed(address) {
	        return (await this.getContractState(address)).state === 'active';
	    }
	    /**
	     * Resolves contract state
	     * @param address contract address
	     */
	    async getContractState(address) {
	        let info = await this.api.getAddressInformation(address);
	        let balance = BigInt(info.balance);
	        let state = info.state;
	        return {
	            balance,
	            extra_currencies: info.extra_currencies,
	            state,
	            code: info.code !== '' ? Buffer.from(info.code, 'base64') : null,
	            data: info.data !== '' ? Buffer.from(info.data, 'base64') : null,
	            lastTransaction: info.last_transaction_id.lt !== '0' ? {
	                lt: info.last_transaction_id.lt,
	                hash: info.last_transaction_id.hash,
	            } : null,
	            blockId: {
	                workchain: info.block_id.workchain,
	                shard: info.block_id.shard,
	                seqno: info.block_id.seqno
	            },
	            timestampt: info.sync_utime
	        };
	    }
	    /**
	     * Open contract
	     * @param src source contract
	     * @returns contract
	     */
	    open(src) {
	        return (0, core_1.openContract)(src, (args) => createProvider(this, args.address, args.init));
	    }
	    /**
	     * Create a provider
	     * @param address address
	     * @param init optional init
	     * @returns provider
	     */
	    provider(address, init) {
	        return createProvider(this, address, init ?? null);
	    }
	};
	TonClient.TonClient = TonClient$1;
	function parseStackEntry(x) {
	    const typeName = x['@type'];
	    switch (typeName) {
	        case 'tvm.list':
	        case 'tvm.tuple':
	            return x.elements.map(parseStackEntry);
	        case 'tvm.cell':
	            return core_1.Cell.fromBoc(Buffer.from(x.bytes, 'base64'))[0];
	        case 'tvm.slice':
	            return core_1.Cell.fromBoc(Buffer.from(x.bytes, 'base64'))[0];
	        case 'tvm.stackEntryCell':
	            return parseStackEntry(x.cell);
	        case 'tvm.stackEntrySlice':
	            return parseStackEntry(x.slice);
	        case 'tvm.stackEntryTuple':
	            return parseStackEntry(x.tuple);
	        case 'tvm.stackEntryList':
	            return parseStackEntry(x.list);
	        case 'tvm.stackEntryNumber':
	            return parseStackEntry(x.number);
	        case 'tvm.numberDecimal':
	            return BigInt(x.number);
	        default:
	            throw Error('Unsupported item type: ' + typeName);
	    }
	}
	function parseStackItem(s) {
	    if (s[0] === 'num') {
	        let val = s[1];
	        if (val.startsWith('-')) {
	            return { type: 'int', value: -BigInt(val.slice(1)) };
	        }
	        else {
	            return { type: 'int', value: BigInt(val) };
	        }
	    }
	    else if (s[0] === 'null') {
	        return { type: 'null' };
	    }
	    else if (s[0] === 'cell') {
	        return { type: 'cell', cell: core_1.Cell.fromBoc(Buffer.from(s[1].bytes, 'base64'))[0] };
	    }
	    else if (s[0] === 'slice') {
	        return { type: 'slice', cell: core_1.Cell.fromBoc(Buffer.from(s[1].bytes, 'base64'))[0] };
	    }
	    else if (s[0] === 'builder') {
	        return { type: 'builder', cell: core_1.Cell.fromBoc(Buffer.from(s[1].bytes, 'base64'))[0] };
	    }
	    else if (s[0] === 'tuple' || s[0] === 'list') {
	        if (s[1].elements.length === 0) {
	            return { type: 'null' };
	        }
	        return { type: 'tuple', items: s[1].elements.map(parseStackEntry) };
	    }
	    else {
	        throw Error('Unsupported stack item type: ' + s[0]);
	    }
	}
	function parseStack(src) {
	    let stack = [];
	    for (let s of src) {
	        stack.push(parseStackItem(s));
	    }
	    return new core_1.TupleReader(stack);
	}
	function createProvider(client, address, init) {
	    return {
	        async getState() {
	            let state = await client.getContractState(address);
	            let balance = state.balance;
	            let last = state.lastTransaction ? { lt: BigInt(state.lastTransaction.lt), hash: Buffer.from(state.lastTransaction.hash, 'base64') } : null;
	            let ecMap = null;
	            let storage;
	            if (state.state === 'active') {
	                storage = {
	                    type: 'active',
	                    code: state.code ? state.code : null,
	                    data: state.data ? state.data : null,
	                };
	            }
	            else if (state.state === 'uninitialized') {
	                storage = {
	                    type: 'uninit',
	                };
	            }
	            else if (state.state === 'frozen') {
	                storage = {
	                    type: 'frozen',
	                    stateHash: Buffer.alloc(0),
	                };
	            }
	            else {
	                throw Error('Unsupported state');
	            }
	            if (state.extra_currencies && state.extra_currencies.length > 0) {
	                ecMap = {};
	                for (let ec of state.extra_currencies) {
	                    ecMap[ec.id] = BigInt(ec.amount);
	                }
	            }
	            return {
	                balance,
	                extracurrency: ecMap,
	                last,
	                state: storage,
	            };
	        },
	        async get(name, args) {
	            if (typeof name !== 'string') {
	                throw new Error('Method name must be a string for TonClient provider');
	            }
	            let method = await client.runMethod(address, name, args);
	            return { stack: method.stack };
	        },
	        async external(message) {
	            //
	            // Resolve init
	            //
	            let neededInit = null;
	            if (init && !await client.isContractDeployed(address)) {
	                neededInit = init;
	            }
	            //
	            // Send package
	            //
	            const ext = (0, core_1.external)({
	                to: address,
	                init: neededInit,
	                body: message
	            });
	            let boc = (0, core_1.beginCell)()
	                .store((0, core_1.storeMessage)(ext))
	                .endCell()
	                .toBoc();
	            await client.sendFile(boc);
	        },
	        async internal(via, message) {
	            // Resolve init
	            let neededInit = null;
	            if (init && (!await client.isContractDeployed(address))) {
	                neededInit = init;
	            }
	            // Resolve bounce
	            let bounce = true;
	            if (message.bounce !== null && message.bounce !== undefined) {
	                bounce = message.bounce;
	            }
	            // Resolve value
	            let value;
	            if (typeof message.value === 'string') {
	                value = (0, core_1.toNano)(message.value);
	            }
	            else {
	                value = message.value;
	            }
	            // Resolve body
	            let body = null;
	            if (typeof message.body === 'string') {
	                body = (0, core_1.comment)(message.body);
	            }
	            else if (message.body) {
	                body = message.body;
	            }
	            // Send internal message
	            await via.send({
	                to: address,
	                value,
	                bounce,
	                sendMode: message.sendMode,
	                extracurrency: message.extracurrency,
	                init: neededInit,
	                body
	            });
	        },
	        open(contract) {
	            return (0, core_1.openContract)(contract, (args) => createProvider(client, args.address, args.init ?? null));
	        },
	        getTransactions(address, lt, hash, limit) {
	            return client.getTransactions(address, { limit: limit ?? 100, lt: lt.toString(), hash: hash.toString('base64'), inclusive: true });
	        }
	    };
	}
	return TonClient;
}

var TonClient4 = {};

var toUrlSafe = {};

var hasRequiredToUrlSafe;

function requireToUrlSafe () {
	if (hasRequiredToUrlSafe) return toUrlSafe;
	hasRequiredToUrlSafe = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(toUrlSafe, "__esModule", { value: true });
	toUrlSafe.toUrlSafe = toUrlSafe$1;
	function toUrlSafe$1(src) {
	    while (src.indexOf('/') >= 0) {
	        src = src.replace('/', '_');
	    }
	    while (src.indexOf('+') >= 0) {
	        src = src.replace('+', '-');
	    }
	    while (src.indexOf('=') >= 0) {
	        src = src.replace('=', '');
	    }
	    return src;
	}
	return toUrlSafe;
}

var hasRequiredTonClient4;

function requireTonClient4 () {
	if (hasRequiredTonClient4) return TonClient4;
	hasRequiredTonClient4 = 1;
	var __classPrivateFieldSet = TonClient4 && TonClient4.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
	  if (kind === "m") throw new TypeError("Private method is not writable");
	  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
	};
	var __classPrivateFieldGet = TonClient4 && TonClient4.__classPrivateFieldGet || function(receiver, state, kind, f) {
	  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
	};
	var __importDefault = TonClient4 && TonClient4.__importDefault || function(mod) {
	  return mod && mod.__esModule ? mod : { "default": mod };
	};
	var _TonClient4_endpoint, _TonClient4_timeout, _TonClient4_adapter, _TonClient4_axios;
	Object.defineProperty(TonClient4, "__esModule", { value: true });
	TonClient4.TonClient4 = void 0;
	const axios_1 = __importDefault(/*@__PURE__*/ requireAxios());
	const core_1 = requireDist$2();
	const toUrlSafe_1 = requireToUrlSafe();
	const zod_1 = /*@__PURE__*/ requireZod();
	let TonClient4$1 = class TonClient4 {
	  constructor(args) {
	    _TonClient4_endpoint.set(this, void 0);
	    _TonClient4_timeout.set(this, void 0);
	    _TonClient4_adapter.set(this, void 0);
	    _TonClient4_axios.set(this, void 0);
	    __classPrivateFieldSet(this, _TonClient4_axios, axios_1.default.create(), "f");
	    __classPrivateFieldSet(this, _TonClient4_endpoint, args.endpoint, "f");
	    __classPrivateFieldSet(this, _TonClient4_timeout, args.timeout || 5e3, "f");
	    __classPrivateFieldSet(this, _TonClient4_adapter, args.httpAdapter, "f");
	    if (args.requestInterceptor) {
	      __classPrivateFieldGet(this, _TonClient4_axios, "f").interceptors.request.use(args.requestInterceptor);
	    }
	  }
	  /**
	   * Get Last Block
	   * @returns last block info
	   */
	  async getLastBlock() {
	    let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/latest", { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
	    let lastBlock = lastBlockCodec.safeParse(res.data);
	    if (!lastBlock.success) {
	      throw Error("Mailformed response: " + lastBlock.error.format()._errors.join(", "));
	    }
	    return lastBlock.data;
	  }
	  /**
	   * Get block info
	   * @param seqno block sequence number
	   * @returns block info
	   */
	  async getBlock(seqno) {
	    let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
	    let block = blockCodec.safeParse(res.data);
	    if (!block.success) {
	      throw Error("Mailformed response");
	    }
	    if (!block.data.exist) {
	      throw Error("Block is out of scope");
	    }
	    return block.data.block;
	  }
	  /**
	   * Get block info by unix timestamp
	   * @param ts unix timestamp
	   * @returns block info
	   */
	  async getBlockByUtime(ts) {
	    let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/utime/" + ts, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
	    let block = blockCodec.safeParse(res.data);
	    if (!block.success) {
	      throw Error("Mailformed response");
	    }
	    if (!block.data.exist) {
	      throw Error("Block is out of scope");
	    }
	    return block.data.block;
	  }
	  /**
	   * Get block info by unix timestamp
	   * @param seqno block sequence number
	   * @param address account address
	   * @returns account info
	   */
	  async getAccount(seqno, address) {
	    let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
	    let account = accountCodec.safeParse(res.data);
	    if (!account.success) {
	      throw Error("Mailformed response");
	    }
	    return account.data;
	  }
	  /**
	   * Get account lite info (without code and data)
	   * @param seqno block sequence number
	   * @param address account address
	   * @returns account lite info
	   */
	  async getAccountLite(seqno, address) {
	    let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/lite", { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
	    let account = accountLiteCodec.safeParse(res.data);
	    if (!account.success) {
	      throw Error("Mailformed response");
	    }
	    return account.data;
	  }
	  /**
	   * Check if contract is deployed
	   * @param address addres to check
	   * @returns true if contract is in active state
	   */
	  async isContractDeployed(seqno, address) {
	    let account = await this.getAccountLite(seqno, address);
	    return account.account.state.type === "active";
	  }
	  /**
	   * Check if account was updated since
	   * @param seqno block sequence number
	   * @param address account address
	   * @param lt account last transaction lt
	   * @returns account change info
	   */
	  async isAccountChanged(seqno, address, lt) {
	    let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/changed/" + lt.toString(10), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
	    let changed = changedCodec.safeParse(res.data);
	    if (!changed.success) {
	      throw Error("Mailformed response");
	    }
	    return changed.data;
	  }
	  /**
	   * Load unparsed account transactions
	   * @param address address
	   * @param lt last transaction lt
	   * @param hash last transaction hash
	   * @returns unparsed transactions
	   */
	  async getAccountTransactions(address, lt, hash) {
	    let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/account/" + address.toString({ urlSafe: true }) + "/tx/" + lt.toString(10) + "/" + (0, toUrlSafe_1.toUrlSafe)(hash.toString("base64")), { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
	    let transactions = transactionsCodec.safeParse(res.data);
	    if (!transactions.success) {
	      throw Error("Mailformed response");
	    }
	    let data = transactions.data;
	    let tx = [];
	    let cells = core_1.Cell.fromBoc(Buffer.from(data.boc, "base64"));
	    for (let i = 0; i < data.blocks.length; i++) {
	      tx.push({
	        block: data.blocks[i],
	        tx: (0, core_1.loadTransaction)(cells[i].beginParse())
	      });
	    }
	    return tx;
	  }
	  /**
	   * Load parsed account transactions
	   * @param address address
	   * @param lt last transaction lt
	   * @param hash last transaction hash
	   * @param count number of transactions to load
	   * @returns parsed transactions
	   */
	  async getAccountTransactionsParsed(address, lt, hash, count = 20) {
	    let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/account/" + address.toString({ urlSafe: true }) + "/tx/parsed/" + lt.toString(10) + "/" + (0, toUrlSafe_1.toUrlSafe)(hash.toString("base64")), {
	      adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"),
	      timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f"),
	      params: {
	        count
	      }
	    });
	    let parsedTransactionsRes = parsedTransactionsCodec.safeParse(res.data);
	    if (!parsedTransactionsRes.success) {
	      throw Error("Mailformed response");
	    }
	    return parsedTransactionsRes.data;
	  }
	  /**
	   * Get network config
	   * @param seqno block sequence number
	   * @param ids optional config ids
	   * @returns network config
	   */
	  async getConfig(seqno, ids) {
	    let tail = "";
	    if (ids && ids.length > 0) {
	      tail = "/" + [...ids].sort().join(",");
	    }
	    let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/config" + tail, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
	    let config = configCodec.safeParse(res.data);
	    if (!config.success) {
	      throw Error("Mailformed response");
	    }
	    return config.data;
	  }
	  /**
	   * Execute run method
	   * @param seqno block sequence number
	   * @param address account address
	   * @param name method name
	   * @param args method arguments
	   * @returns method result
	   */
	  async runMethod(seqno, address, name, args) {
	    let tail = args && args.length > 0 ? "/" + (0, toUrlSafe_1.toUrlSafe)((0, core_1.serializeTuple)(args).toBoc({ idx: false, crc32: false }).toString("base64")) : "";
	    let url = __classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/block/" + seqno + "/" + address.toString({ urlSafe: true }) + "/run/" + encodeURIComponent(name) + tail;
	    let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").get(url, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
	    let runMethod = runMethodCodec.safeParse(res.data);
	    if (!runMethod.success) {
	      throw Error("Mailformed response");
	    }
	    let resultTuple = runMethod.data.resultRaw ? (0, core_1.parseTuple)(core_1.Cell.fromBoc(Buffer.from(runMethod.data.resultRaw, "base64"))[0]) : [];
	    return {
	      exitCode: runMethod.data.exitCode,
	      result: resultTuple,
	      resultRaw: runMethod.data.resultRaw,
	      block: runMethod.data.block,
	      shardBlock: runMethod.data.shardBlock,
	      reader: new core_1.TupleReader(resultTuple)
	    };
	  }
	  /**
	   * Send external message
	   * @param message message boc
	   * @returns message status
	   */
	  async sendMessage(message) {
	    let res = await __classPrivateFieldGet(this, _TonClient4_axios, "f").post(__classPrivateFieldGet(this, _TonClient4_endpoint, "f") + "/send", { boc: message.toString("base64") }, { adapter: __classPrivateFieldGet(this, _TonClient4_adapter, "f"), timeout: __classPrivateFieldGet(this, _TonClient4_timeout, "f") });
	    let send = sendCodec.safeParse(res.data);
	    if (!send.success) {
	      throw Error("Mailformed response");
	    }
	    return { status: res.data.status };
	  }
	  /**
	   * Open smart contract
	   * @param contract contract
	   * @returns opened contract
	   */
	  open(contract) {
	    return (0, core_1.openContract)(contract, (args) => createProvider(this, null, args.address, args.init));
	  }
	  /**
	   * Open smart contract
	   * @param block block number
	   * @param contract contract
	   * @returns opened contract
	   */
	  openAt(block, contract) {
	    return (0, core_1.openContract)(contract, (args) => createProvider(this, block, args.address, args.init));
	  }
	  /**
	   * Create provider
	   * @param address address
	   * @param init optional init data
	   * @returns provider
	   */
	  provider(address, init) {
	    return createProvider(this, null, address, init ?? null);
	  }
	  /**
	   * Create provider at specified block number
	   * @param block block number
	   * @param address address
	   * @param init optional init data
	   * @returns provider
	   */
	  providerAt(block, address, init) {
	    return createProvider(this, block, address, init ?? null);
	  }
	};
	TonClient4.TonClient4 = TonClient4$1;
	_TonClient4_endpoint = /* @__PURE__ */ new WeakMap(), _TonClient4_timeout = /* @__PURE__ */ new WeakMap(), _TonClient4_adapter = /* @__PURE__ */ new WeakMap(), _TonClient4_axios = /* @__PURE__ */ new WeakMap();
	function createProvider(client, block, address, init) {
	  return {
	    async getState() {
	      let sq = block;
	      if (sq === null) {
	        let res = await client.getLastBlock();
	        sq = res.last.seqno;
	      }
	      let state = await client.getAccount(sq, address);
	      let last = state.account.last ? { lt: BigInt(state.account.last.lt), hash: Buffer.from(state.account.last.hash, "base64") } : null;
	      let storage;
	      if (state.account.state.type === "active") {
	        storage = {
	          type: "active",
	          code: state.account.state.code ? Buffer.from(state.account.state.code, "base64") : null,
	          data: state.account.state.data ? Buffer.from(state.account.state.data, "base64") : null
	        };
	      } else if (state.account.state.type === "uninit") {
	        storage = {
	          type: "uninit"
	        };
	      } else if (state.account.state.type === "frozen") {
	        storage = {
	          type: "frozen",
	          stateHash: Buffer.from(state.account.state.stateHash, "base64")
	        };
	      } else {
	        throw Error("Unsupported state");
	      }
	      let ecMap = null;
	      if (state.account.balance.currencies) {
	        ecMap = {};
	        let currencies = state.account.balance.currencies;
	        for (let [k, v] of Object.entries(currencies)) {
	          ecMap[Number(k)] = BigInt(v);
	        }
	      }
	      return {
	        balance: BigInt(state.account.balance.coins),
	        extracurrency: ecMap,
	        last,
	        state: storage
	      };
	    },
	    async get(name, args) {
	      if (typeof name !== "string") {
	        throw new Error("Method name must be a string for TonClient4 provider");
	      }
	      let sq = block;
	      if (sq === null) {
	        let res = await client.getLastBlock();
	        sq = res.last.seqno;
	      }
	      let method = await client.runMethod(sq, address, name, args);
	      if (method.exitCode !== 0 && method.exitCode !== 1) {
	        throw Error("Exit code: " + method.exitCode);
	      }
	      return {
	        stack: new core_1.TupleReader(method.result)
	      };
	    },
	    async external(message) {
	      let last = await client.getLastBlock();
	      let neededInit = null;
	      if (init && (await client.getAccountLite(last.last.seqno, address)).account.state.type !== "active") {
	        neededInit = init;
	      }
	      const ext = (0, core_1.external)({
	        to: address,
	        init: neededInit,
	        body: message
	      });
	      let pkg = (0, core_1.beginCell)().store((0, core_1.storeMessage)(ext)).endCell().toBoc();
	      await client.sendMessage(pkg);
	    },
	    async internal(via, message) {
	      let last = await client.getLastBlock();
	      let neededInit = null;
	      if (init && (await client.getAccountLite(last.last.seqno, address)).account.state.type !== "active") {
	        neededInit = init;
	      }
	      let bounce = true;
	      if (message.bounce !== null && message.bounce !== void 0) {
	        bounce = message.bounce;
	      }
	      let value;
	      if (typeof message.value === "string") {
	        value = (0, core_1.toNano)(message.value);
	      } else {
	        value = message.value;
	      }
	      let body = null;
	      if (typeof message.body === "string") {
	        body = (0, core_1.comment)(message.body);
	      } else if (message.body) {
	        body = message.body;
	      }
	      await via.send({
	        to: address,
	        value,
	        extracurrency: message.extracurrency,
	        bounce,
	        sendMode: message.sendMode,
	        init: neededInit,
	        body
	      });
	    },
	    open(contract) {
	      return (0, core_1.openContract)(contract, (args) => createProvider(client, block, args.address, args.init ?? null));
	    },
	    async getTransactions(address2, lt, hash, limit) {
	      const useLimit = typeof limit === "number";
	      if (useLimit && limit <= 0) {
	        return [];
	      }
	      let transactions = [];
	      do {
	        const txs = await client.getAccountTransactions(address2, lt, hash);
	        const firstTx = txs[0].tx;
	        const [firstLt, firstHash] = [firstTx.lt, firstTx.hash()];
	        const needSkipFirst = transactions.length > 0 && firstLt === lt && firstHash.equals(hash);
	        if (needSkipFirst) {
	          txs.shift();
	        }
	        if (txs.length === 0) {
	          break;
	        }
	        const lastTx = txs[txs.length - 1].tx;
	        const [lastLt, lastHash] = [lastTx.lt, lastTx.hash()];
	        if (lastLt === lt && lastHash.equals(hash)) {
	          break;
	        }
	        transactions.push(...txs.map((tx) => tx.tx));
	        lt = lastLt;
	        hash = lastHash;
	      } while (useLimit && transactions.length < limit);
	      if (useLimit) {
	        transactions = transactions.slice(0, limit);
	      }
	      return transactions;
	    }
	  };
	}
	const lastBlockCodec = zod_1.z.object({
	  last: zod_1.z.object({
	    seqno: zod_1.z.number(),
	    shard: zod_1.z.string(),
	    workchain: zod_1.z.number(),
	    fileHash: zod_1.z.string(),
	    rootHash: zod_1.z.string()
	  }),
	  init: zod_1.z.object({
	    fileHash: zod_1.z.string(),
	    rootHash: zod_1.z.string()
	  }),
	  stateRootHash: zod_1.z.string(),
	  now: zod_1.z.number()
	});
	const blockCodec = zod_1.z.union([zod_1.z.object({
	  exist: zod_1.z.literal(false)
	}), zod_1.z.object({
	  exist: zod_1.z.literal(true),
	  block: zod_1.z.object({
	    shards: zod_1.z.array(zod_1.z.object({
	      workchain: zod_1.z.number(),
	      seqno: zod_1.z.number(),
	      shard: zod_1.z.string(),
	      rootHash: zod_1.z.string(),
	      fileHash: zod_1.z.string(),
	      transactions: zod_1.z.array(zod_1.z.object({
	        account: zod_1.z.string(),
	        hash: zod_1.z.string(),
	        lt: zod_1.z.string()
	      }))
	    }))
	  })
	})]);
	const storageStatCodec = zod_1.z.object({
	  lastPaid: zod_1.z.number(),
	  duePayment: zod_1.z.union([zod_1.z.null(), zod_1.z.string()]),
	  used: zod_1.z.object({
	    bits: zod_1.z.number(),
	    cells: zod_1.z.number(),
	    publicCells: zod_1.z.number().optional()
	  })
	});
	const accountCodec = zod_1.z.object({
	  account: zod_1.z.object({
	    state: zod_1.z.union([
	      zod_1.z.object({ type: zod_1.z.literal("uninit") }),
	      zod_1.z.object({ type: zod_1.z.literal("active"), code: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]), data: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]) }),
	      zod_1.z.object({ type: zod_1.z.literal("frozen"), stateHash: zod_1.z.string() })
	    ]),
	    balance: zod_1.z.object({
	      coins: zod_1.z.string(),
	      currencies: zod_1.z.record(zod_1.z.string(), zod_1.z.string())
	    }),
	    last: zod_1.z.union([
	      zod_1.z.null(),
	      zod_1.z.object({
	        lt: zod_1.z.string(),
	        hash: zod_1.z.string()
	      })
	    ]),
	    storageStat: zod_1.z.union([zod_1.z.null(), storageStatCodec])
	  }),
	  block: zod_1.z.object({
	    workchain: zod_1.z.number(),
	    seqno: zod_1.z.number(),
	    shard: zod_1.z.string(),
	    rootHash: zod_1.z.string(),
	    fileHash: zod_1.z.string()
	  })
	});
	const accountLiteCodec = zod_1.z.object({
	  account: zod_1.z.object({
	    state: zod_1.z.union([
	      zod_1.z.object({ type: zod_1.z.literal("uninit") }),
	      zod_1.z.object({ type: zod_1.z.literal("active"), codeHash: zod_1.z.string(), dataHash: zod_1.z.string() }),
	      zod_1.z.object({ type: zod_1.z.literal("frozen"), stateHash: zod_1.z.string() })
	    ]),
	    balance: zod_1.z.object({
	      coins: zod_1.z.string(),
	      currencies: zod_1.z.record(zod_1.z.string(), zod_1.z.string())
	    }),
	    last: zod_1.z.union([
	      zod_1.z.null(),
	      zod_1.z.object({
	        lt: zod_1.z.string(),
	        hash: zod_1.z.string()
	      })
	    ]),
	    storageStat: zod_1.z.union([zod_1.z.null(), storageStatCodec])
	  })
	});
	const changedCodec = zod_1.z.object({
	  changed: zod_1.z.boolean(),
	  block: zod_1.z.object({
	    workchain: zod_1.z.number(),
	    seqno: zod_1.z.number(),
	    shard: zod_1.z.string(),
	    rootHash: zod_1.z.string(),
	    fileHash: zod_1.z.string()
	  })
	});
	const runMethodCodec = zod_1.z.object({
	  exitCode: zod_1.z.number(),
	  resultRaw: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
	  block: zod_1.z.object({
	    workchain: zod_1.z.number(),
	    seqno: zod_1.z.number(),
	    shard: zod_1.z.string(),
	    rootHash: zod_1.z.string(),
	    fileHash: zod_1.z.string()
	  }),
	  shardBlock: zod_1.z.object({
	    workchain: zod_1.z.number(),
	    seqno: zod_1.z.number(),
	    shard: zod_1.z.string(),
	    rootHash: zod_1.z.string(),
	    fileHash: zod_1.z.string()
	  })
	});
	const configCodec = zod_1.z.object({
	  config: zod_1.z.object({
	    cell: zod_1.z.string(),
	    address: zod_1.z.string(),
	    globalBalance: zod_1.z.object({
	      coins: zod_1.z.string()
	    })
	  })
	});
	const sendCodec = zod_1.z.object({
	  status: zod_1.z.number()
	});
	const blocksCodec = zod_1.z.array(zod_1.z.object({
	  workchain: zod_1.z.number(),
	  seqno: zod_1.z.number(),
	  shard: zod_1.z.string(),
	  rootHash: zod_1.z.string(),
	  fileHash: zod_1.z.string()
	}));
	const transactionsCodec = zod_1.z.object({
	  blocks: blocksCodec,
	  boc: zod_1.z.string()
	});
	const parsedAddressExternalCodec = zod_1.z.object({
	  bits: zod_1.z.number(),
	  data: zod_1.z.string()
	});
	const parsedMessageInfoCodec = zod_1.z.union([
	  zod_1.z.object({
	    type: zod_1.z.literal("internal"),
	    value: zod_1.z.string(),
	    dest: zod_1.z.string(),
	    src: zod_1.z.string(),
	    bounced: zod_1.z.boolean(),
	    bounce: zod_1.z.boolean(),
	    ihrDisabled: zod_1.z.boolean(),
	    createdAt: zod_1.z.number(),
	    createdLt: zod_1.z.string(),
	    fwdFee: zod_1.z.string(),
	    ihrFee: zod_1.z.string()
	  }),
	  zod_1.z.object({
	    type: zod_1.z.literal("external-in"),
	    dest: zod_1.z.string(),
	    src: zod_1.z.union([parsedAddressExternalCodec, zod_1.z.null()]),
	    importFee: zod_1.z.string()
	  }),
	  zod_1.z.object({
	    type: zod_1.z.literal("external-out"),
	    dest: zod_1.z.union([parsedAddressExternalCodec, zod_1.z.null()])
	  })
	]);
	const parsedStateInitCodec = zod_1.z.object({
	  splitDepth: zod_1.z.union([zod_1.z.number(), zod_1.z.null()]),
	  code: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
	  data: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
	  special: zod_1.z.union([zod_1.z.object({ tick: zod_1.z.boolean(), tock: zod_1.z.boolean() }), zod_1.z.null()])
	});
	const parsedMessageCodec = zod_1.z.object({
	  body: zod_1.z.string(),
	  info: parsedMessageInfoCodec,
	  init: zod_1.z.union([parsedStateInitCodec, zod_1.z.null()])
	});
	const accountStatusCodec = zod_1.z.union([zod_1.z.literal("uninitialized"), zod_1.z.literal("frozen"), zod_1.z.literal("active"), zod_1.z.literal("non-existing")]);
	const txBodyCodec = zod_1.z.union([
	  zod_1.z.object({ type: zod_1.z.literal("comment"), comment: zod_1.z.string() }),
	  zod_1.z.object({ type: zod_1.z.literal("payload"), cell: zod_1.z.string() })
	]);
	const parsedOperationItemCodec = zod_1.z.union([
	  zod_1.z.object({ kind: zod_1.z.literal("ton"), amount: zod_1.z.string() }),
	  zod_1.z.object({ kind: zod_1.z.literal("token"), amount: zod_1.z.string() })
	]);
	const supportedMessageTypeCodec = zod_1.z.union([
	  zod_1.z.literal("jetton::excesses"),
	  zod_1.z.literal("jetton::transfer"),
	  zod_1.z.literal("jetton::transfer_notification"),
	  zod_1.z.literal("deposit"),
	  zod_1.z.literal("deposit::ok"),
	  zod_1.z.literal("withdraw"),
	  zod_1.z.literal("withdraw::all"),
	  zod_1.z.literal("withdraw::delayed"),
	  zod_1.z.literal("withdraw::ok"),
	  zod_1.z.literal("airdrop")
	]);
	const opCodec = zod_1.z.object({
	  type: supportedMessageTypeCodec,
	  options: zod_1.z.optional(zod_1.z.record(zod_1.z.string()))
	});
	const parsedOperationCodec = zod_1.z.object({
	  address: zod_1.z.string(),
	  comment: zod_1.z.optional(zod_1.z.string()),
	  items: zod_1.z.array(parsedOperationItemCodec),
	  op: zod_1.z.optional(opCodec)
	});
	const parsedTransactionCodec = zod_1.z.object({
	  address: zod_1.z.string(),
	  lt: zod_1.z.string(),
	  hash: zod_1.z.string(),
	  prevTransaction: zod_1.z.object({
	    lt: zod_1.z.string(),
	    hash: zod_1.z.string()
	  }),
	  time: zod_1.z.number(),
	  outMessagesCount: zod_1.z.number(),
	  oldStatus: accountStatusCodec,
	  newStatus: accountStatusCodec,
	  fees: zod_1.z.string(),
	  update: zod_1.z.object({
	    oldHash: zod_1.z.string(),
	    newHash: zod_1.z.string()
	  }),
	  inMessage: zod_1.z.union([parsedMessageCodec, zod_1.z.null()]),
	  outMessages: zod_1.z.array(parsedMessageCodec),
	  parsed: zod_1.z.object({
	    seqno: zod_1.z.union([zod_1.z.number(), zod_1.z.null()]),
	    body: zod_1.z.union([txBodyCodec, zod_1.z.null()]),
	    status: zod_1.z.union([zod_1.z.literal("success"), zod_1.z.literal("failed"), zod_1.z.literal("pending")]),
	    dest: zod_1.z.union([zod_1.z.string(), zod_1.z.null()]),
	    kind: zod_1.z.union([zod_1.z.literal("out"), zod_1.z.literal("in")]),
	    amount: zod_1.z.string(),
	    resolvedAddress: zod_1.z.string(),
	    bounced: zod_1.z.boolean(),
	    mentioned: zod_1.z.array(zod_1.z.string())
	  }),
	  operation: parsedOperationCodec
	});
	const parsedTransactionsCodec = zod_1.z.object({
	  blocks: blocksCodec,
	  transactions: zod_1.z.array(parsedTransactionCodec)
	});
	return TonClient4;
}

var WalletContractV1R1 = {};

var createWalletTransfer = {};

var WalletContractV5Beta$1 = {};

var WalletV5BetaWalletId = {};

var hasRequiredWalletV5BetaWalletId;

function requireWalletV5BetaWalletId () {
	if (hasRequiredWalletV5BetaWalletId) return WalletV5BetaWalletId;
	hasRequiredWalletV5BetaWalletId = 1;
	Object.defineProperty(WalletV5BetaWalletId, "__esModule", { value: true });
	WalletV5BetaWalletId.loadWalletIdV5Beta = loadWalletIdV5Beta;
	WalletV5BetaWalletId.storeWalletIdV5Beta = storeWalletIdV5Beta;
	const core_1 = requireDist$2();
	const walletV5BetaVersionsSerialisation = {
	    v5: 0
	};
	function loadWalletIdV5Beta(value) {
	    const bitReader = new core_1.BitReader(new core_1.BitString(typeof value === 'bigint' ?
	        Buffer.from(value.toString(16), 'hex') :
	        value instanceof core_1.Slice ? value.loadBuffer(10) : value, 0, 80));
	    const networkGlobalId = bitReader.loadInt(32);
	    const workchain = bitReader.loadInt(8);
	    const walletVersionRaw = bitReader.loadUint(8);
	    const subwalletNumber = bitReader.loadUint(32);
	    const walletVersion = Object.entries(walletV5BetaVersionsSerialisation).find(([_, value]) => value === walletVersionRaw)?.[0];
	    if (walletVersion === undefined) {
	        throw new Error(`Can't deserialize walletId: unknown wallet version ${walletVersionRaw}`);
	    }
	    return { networkGlobalId, workchain, walletVersion, subwalletNumber };
	}
	function storeWalletIdV5Beta(walletId) {
	    return (builder) => {
	        builder.storeInt(walletId.networkGlobalId, 32);
	        builder.storeInt(walletId.workchain, 8);
	        builder.storeUint(walletV5BetaVersionsSerialisation[walletId.walletVersion], 8);
	        builder.storeUint(walletId.subwalletNumber, 32);
	    };
	}
	return WalletV5BetaWalletId;
}

var hasRequiredWalletContractV5Beta$1;

function requireWalletContractV5Beta$1 () {
	if (hasRequiredWalletContractV5Beta$1) return WalletContractV5Beta$1;
	hasRequiredWalletContractV5Beta$1 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(WalletContractV5Beta$1, "__esModule", { value: true });
	WalletContractV5Beta$1.WalletContractV5Beta = void 0;
	const core_1 = requireDist$2();
	const createWalletTransfer_1 = requireCreateWalletTransfer();
	const WalletV5BetaWalletId_1 = requireWalletV5BetaWalletId();
	/**
	 * @deprecated
	 * use WalletContractV5R1 instead
	 */
	class WalletContractV5Beta {
	    static create(args) {
	        const walletId = {
	            networkGlobalId: args.walletId?.networkGlobalId ?? -239,
	            workchain: args?.walletId?.workchain ?? 0,
	            subwalletNumber: args?.walletId?.subwalletNumber ?? 0,
	            walletVersion: args?.walletId?.walletVersion ?? 'v5'
	        };
	        return new WalletContractV5Beta(walletId, args.publicKey);
	    }
	    constructor(walletId, publicKey) {
	        this.walletId = walletId;
	        this.publicKey = publicKey;
	        this.walletId = walletId;
	        // https://github.com/tonkeeper/w5/commit/fa1b372a417a32af104fe1b949b6b31d29cee349 code with library
	        let code = core_1.Cell.fromBoc(Buffer.from('te6cckEBAQEAIwAIQgLkzzsvTG1qYeoPK1RH0mZ4WyavNjfbLe7mvNGqgm80Eg3NjhE=', 'base64'))[0];
	        let data = (0, core_1.beginCell)()
	            .storeInt(0, 33) // Seqno
	            .store((0, WalletV5BetaWalletId_1.storeWalletIdV5Beta)(this.walletId))
	            .storeBuffer(this.publicKey, 32)
	            .storeBit(0) // Empty plugins dict
	            .endCell();
	        this.init = { code, data };
	        this.address = (0, core_1.contractAddress)(this.walletId.workchain, { code, data });
	    }
	    /**
	     * Get Wallet Balance
	     */
	    async getBalance(provider) {
	        let state = await provider.getState();
	        return state.balance;
	    }
	    /**
	     * Get Wallet Seqno
	     */
	    async getSeqno(provider) {
	        let state = await provider.getState();
	        if (state.state.type === 'active') {
	            let res = await provider.get('seqno', []);
	            return res.stack.readNumber();
	        }
	        else {
	            return 0;
	        }
	    }
	    /**
	     * Get Wallet Extensions
	     */
	    async getExtensions(provider) {
	        let state = await provider.getState();
	        if (state.state.type === 'active') {
	            const result = await provider.get('get_extensions', []);
	            return result.stack.readCellOpt();
	        }
	        else {
	            return null;
	        }
	    }
	    /**
	     * Get Wallet Extensions
	     */
	    async getExtensionsArray(provider) {
	        const extensions = await this.getExtensions(provider);
	        if (!extensions) {
	            return [];
	        }
	        const dict = core_1.Dictionary.loadDirect(core_1.Dictionary.Keys.BigUint(256), core_1.Dictionary.Values.BigInt(8), extensions);
	        return dict.keys().map(key => {
	            const wc = dict.get(key);
	            const addressHex = key ^ (wc + 1n);
	            return core_1.Address.parseRaw(`${wc}:${addressHex.toString(16).padStart(64, "0")}`);
	        });
	    }
	    /**
	     * Get is secret-key authentication enabled
	     */
	    async getIsSecretKeyAuthEnabled(provider) {
	        let res = await provider.get('get_is_signature_auth_allowed', []);
	        const result = res.stack.readNumber();
	        return result !== 0;
	    }
	    /**
	     * Send signed transfer
	     */
	    async send(provider, message) {
	        await provider.external(message);
	    }
	    /**
	     * Sign and send transfer
	     */
	    async sendTransfer(provider, args) {
	        const transfer = await this.createTransfer(args);
	        await this.send(provider, transfer);
	    }
	    /**
	     * Sign and send add extension request
	     */
	    async sendAddExtension(provider, args) {
	        const request = await this.createAddExtension(args);
	        await this.send(provider, request);
	    }
	    /**
	     * Sign and send remove extension request
	     */
	    async sendRemoveExtension(provider, args) {
	        const request = await this.createRemoveExtension(args);
	        await this.send(provider, request);
	    }
	    /**
	     * Sign and send actions batch
	     */
	    async sendActionsBatch(provider, args) {
	        const request = await this.createRequest(args);
	        await this.send(provider, request);
	    }
	    createActions(args) {
	        const actions = args.messages.map(message => ({ type: 'sendMsg', mode: args.sendMode, outMsg: message }));
	        return actions;
	    }
	    /**
	     * Create signed transfer
	     */
	    createTransfer(args) {
	        return this.createRequest({
	            ...args,
	            actions: this.createActions({ messages: args.messages, sendMode: args.sendMode })
	        });
	    }
	    /**
	     * Create signed add extension request
	     */
	    createAddExtension(args) {
	        return this.createRequest({
	            ...args,
	            actions: [{
	                    type: 'addExtension',
	                    address: args.extensionAddress
	                }]
	        });
	    }
	    /**
	     * Create signed remove extension request
	     */
	    createRemoveExtension(args) {
	        return this.createRequest({
	            ...args,
	            actions: [{
	                    type: 'removeExtension',
	                    address: args.extensionAddress
	                }]
	        });
	    }
	    /**
	     * Create signed request or extension auth request
	     */
	    createRequest(args) {
	        if (args.authType === 'extension') {
	            return (0, createWalletTransfer_1.createWalletTransferV5Beta)(args);
	        }
	        return (0, createWalletTransfer_1.createWalletTransferV5Beta)({
	            ...args,
	            walletId: (0, WalletV5BetaWalletId_1.storeWalletIdV5Beta)(this.walletId)
	        });
	    }
	    /**
	     * Create sender
	     */
	    sender(provider, secretKey) {
	        return {
	            send: async (args) => {
	                let seqno = await this.getSeqno(provider);
	                let transfer = this.createTransfer({
	                    seqno,
	                    secretKey,
	                    sendMode: args.sendMode ?? core_1.SendMode.PAY_GAS_SEPARATELY + core_1.SendMode.IGNORE_ERRORS,
	                    messages: [(0, core_1.internal)({
	                            to: args.to,
	                            value: args.value,
	                            extracurrency: args.extracurrency,
	                            init: args.init,
	                            body: args.body,
	                            bounce: args.bounce
	                        })]
	                });
	                await this.send(provider, transfer);
	            }
	        };
	    }
	}
	WalletContractV5Beta$1.WalletContractV5Beta = WalletContractV5Beta;
	WalletContractV5Beta.OpCodes = {
	    auth_extension: 0x6578746e,
	    auth_signed_external: 0x7369676e,
	    auth_signed_internal: 0x73696e74
	};
	return WalletContractV5Beta$1;
}

var WalletV5BetaActions = {};

var WalletV5OutActions = {};

var hasRequiredWalletV5OutActions;

function requireWalletV5OutActions () {
	if (hasRequiredWalletV5OutActions) return WalletV5OutActions;
	hasRequiredWalletV5OutActions = 1;
	Object.defineProperty(WalletV5OutActions, "__esModule", { value: true });
	WalletV5OutActions.isOutActionExtended = isOutActionExtended;
	WalletV5OutActions.isOutActionBasic = isOutActionBasic;
	function isOutActionExtended(action) {
	    return (action.type === 'setIsPublicKeyEnabled' || action.type === 'addExtension' || action.type === 'removeExtension');
	}
	function isOutActionBasic(action) {
	    return !isOutActionExtended(action);
	}
	return WalletV5OutActions;
}

var hasRequiredWalletV5BetaActions;

function requireWalletV5BetaActions () {
	if (hasRequiredWalletV5BetaActions) return WalletV5BetaActions;
	hasRequiredWalletV5BetaActions = 1;
	Object.defineProperty(WalletV5BetaActions, "__esModule", { value: true });
	WalletV5BetaActions.storeOutActionExtendedV5Beta = storeOutActionExtendedV5Beta;
	WalletV5BetaActions.loadOutActionV5BetaExtended = loadOutActionV5BetaExtended;
	WalletV5BetaActions.storeOutListExtendedV5Beta = storeOutListExtendedV5Beta;
	WalletV5BetaActions.loadOutListExtendedV5Beta = loadOutListExtendedV5Beta;
	const core_1 = requireDist$2();
	const WalletV5OutActions_1 = requireWalletV5OutActions();
	const outActionSetIsPublicKeyEnabledTag = 0x20cbb95a;
	function storeOutActionSetIsPublicKeyEnabled(action) {
	    return (builder) => {
	        builder.storeUint(outActionSetIsPublicKeyEnabledTag, 32).storeUint(action.isEnabled ? 1 : 0, 1);
	    };
	}
	const outActionAddExtensionTag = 0x1c40db9f;
	function storeOutActionAddExtension(action) {
	    return (builder) => {
	        builder.storeUint(outActionAddExtensionTag, 32).storeAddress(action.address);
	    };
	}
	const outActionRemoveExtensionTag = 0x5eaef4a4;
	function storeOutActionRemoveExtension(action) {
	    return (builder) => {
	        builder.storeUint(outActionRemoveExtensionTag, 32).storeAddress(action.address);
	    };
	}
	function storeOutActionExtendedV5Beta(action) {
	    switch (action.type) {
	        case 'setIsPublicKeyEnabled':
	            return storeOutActionSetIsPublicKeyEnabled(action);
	        case 'addExtension':
	            return storeOutActionAddExtension(action);
	        case 'removeExtension':
	            return storeOutActionRemoveExtension(action);
	        default:
	            throw new Error('Unknown action type' + action?.type);
	    }
	}
	function loadOutActionV5BetaExtended(slice) {
	    const tag = slice.loadUint(32);
	    switch (tag) {
	        case outActionSetIsPublicKeyEnabledTag:
	            return {
	                type: 'setIsPublicKeyEnabled',
	                isEnabled: !!slice.loadUint(1)
	            };
	        case outActionAddExtensionTag:
	            return {
	                type: 'addExtension',
	                address: slice.loadAddress()
	            };
	        case outActionRemoveExtensionTag:
	            return {
	                type: 'removeExtension',
	                address: slice.loadAddress()
	            };
	        default:
	            throw new Error(`Unknown extended out action tag 0x${tag.toString(16)}`);
	    }
	}
	function storeOutListExtendedV5Beta(actions) {
	    const [action, ...rest] = actions;
	    if (!action || !(0, WalletV5OutActions_1.isOutActionExtended)(action)) {
	        if (actions.some(WalletV5OutActions_1.isOutActionExtended)) {
	            throw new Error("Can't serialize actions list: all extended actions must be placed before out actions");
	        }
	        return (builder) => {
	            builder
	                .storeUint(0, 1)
	                .storeRef((0, core_1.beginCell)().store((0, core_1.storeOutList)(actions)).endCell());
	        };
	    }
	    return (builder) => {
	        builder.storeUint(1, 1)
	            .store(storeOutActionExtendedV5Beta(action))
	            .storeRef((0, core_1.beginCell)().store(storeOutListExtendedV5Beta(rest)).endCell());
	    };
	}
	function loadOutListExtendedV5Beta(slice) {
	    const actions = [];
	    while (slice.loadUint(1)) {
	        const action = loadOutActionV5BetaExtended(slice);
	        actions.push(action);
	        slice = slice.loadRef().beginParse();
	    }
	    const commonAction = (0, core_1.loadOutList)(slice.loadRef().beginParse());
	    if (commonAction.some(i => i.type === 'setCode')) {
	        throw new Error("Can't deserialize actions list: only sendMsg actions are allowed for wallet v5");
	    }
	    return actions.concat(commonAction);
	}
	return WalletV5BetaActions;
}

var singer = {};

var hasRequiredSinger;

function requireSinger () {
	if (hasRequiredSinger) return singer;
	hasRequiredSinger = 1;
	Object.defineProperty(singer, "__esModule", { value: true });
	singer.signPayload = signPayload;
	const crypto_1 = requireDist$3();
	function signPayload(args, signingMessage, packMessage) {
	    if ('secretKey' in args) {
	        /**
	         * Client provider an secretKey to sign transaction.
	         */
	        return packMessage((0, crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey), signingMessage);
	    }
	    else {
	        /**
	         * Client use external storage for secretKey.
	         * In this case lib could create a request to external resource to sign transaction.
	         */
	        return args.signer(signingMessage.endCell())
	            .then(signature => packMessage(signature, signingMessage));
	    }
	}
	return singer;
}

var WalletContractV5R1$1 = {};

var WalletV5R1WalletId = {};

var hasRequiredWalletV5R1WalletId;

function requireWalletV5R1WalletId () {
	if (hasRequiredWalletV5R1WalletId) return WalletV5R1WalletId;
	hasRequiredWalletV5R1WalletId = 1;
	Object.defineProperty(WalletV5R1WalletId, "__esModule", { value: true });
	WalletV5R1WalletId.isWalletIdV5R1ClientContext = isWalletIdV5R1ClientContext;
	WalletV5R1WalletId.loadWalletIdV5R1 = loadWalletIdV5R1;
	WalletV5R1WalletId.storeWalletIdV5R1 = storeWalletIdV5R1;
	const core_1 = requireDist$2();
	function isWalletIdV5R1ClientContext(context) {
	    return typeof context !== 'number';
	}
	const walletV5R1VersionsSerialisation = {
	    v5r1: 0
	};
	/**
	 * @param value serialized wallet id
	 * @param networkGlobalId -239 is mainnet, -3 is testnet
	 */
	function loadWalletIdV5R1(value, networkGlobalId) {
	    const val = new core_1.BitReader(new core_1.BitString(typeof value === 'bigint' ?
	        Buffer.from(value.toString(16), 'hex') :
	        value instanceof core_1.Slice ? value.loadBuffer(4) : value, 0, 32)).loadInt(32);
	    const context = BigInt(val) ^ BigInt(networkGlobalId);
	    const bitReader = (0, core_1.beginCell)().storeInt(context, 32).endCell().beginParse();
	    const isClientContext = bitReader.loadUint(1);
	    if (isClientContext) {
	        const workchain = bitReader.loadInt(8);
	        const walletVersionRaw = bitReader.loadUint(8);
	        const subwalletNumber = bitReader.loadUint(15);
	        const walletVersion = Object.entries(walletV5R1VersionsSerialisation).find(([_, value]) => value === walletVersionRaw)?.[0];
	        if (walletVersion === undefined) {
	            throw new Error(`Can't deserialize walletId: unknown wallet version ${walletVersionRaw}`);
	        }
	        return {
	            networkGlobalId,
	            context: {
	                walletVersion,
	                workchain,
	                subwalletNumber
	            }
	        };
	    }
	    else {
	        const context = bitReader.loadUint(31);
	        return {
	            networkGlobalId,
	            context
	        };
	    }
	}
	function storeWalletIdV5R1(walletId) {
	    return (builder) => {
	        let context;
	        if (isWalletIdV5R1ClientContext(walletId.context)) {
	            context = (0, core_1.beginCell)()
	                .storeUint(1, 1)
	                .storeInt(walletId.context.workchain, 8)
	                .storeUint(walletV5R1VersionsSerialisation[walletId.context.walletVersion], 8)
	                .storeUint(walletId.context.subwalletNumber, 15)
	                .endCell().beginParse().loadInt(32);
	        }
	        else {
	            context = (0, core_1.beginCell)()
	                .storeUint(0, 1)
	                .storeUint(walletId.context, 31)
	                .endCell().beginParse().loadInt(32);
	        }
	        return builder.storeInt(BigInt(walletId.networkGlobalId) ^ BigInt(context), 32);
	    };
	}
	return WalletV5R1WalletId;
}

var hasRequiredWalletContractV5R1$1;

function requireWalletContractV5R1$1 () {
	if (hasRequiredWalletContractV5R1$1) return WalletContractV5R1$1;
	hasRequiredWalletContractV5R1$1 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(WalletContractV5R1$1, "__esModule", { value: true });
	WalletContractV5R1$1.WalletContractV5R1 = void 0;
	const core_1 = requireDist$2();
	const createWalletTransfer_1 = requireCreateWalletTransfer();
	const WalletV5R1WalletId_1 = requireWalletV5R1WalletId();
	class WalletContractV5R1 {
	    static create(args) {
	        let workchain = 0;
	        if ('workchain' in args && args.workchain != undefined) {
	            workchain = args.workchain;
	        }
	        if (args.walletId?.context && (0, WalletV5R1WalletId_1.isWalletIdV5R1ClientContext)(args.walletId.context) && args.walletId.context.workchain != undefined) {
	            workchain = args.walletId.context.workchain;
	        }
	        return new WalletContractV5R1(workchain, args.publicKey, {
	            networkGlobalId: args.walletId?.networkGlobalId ?? -239,
	            context: args.walletId?.context ?? {
	                workchain: 0,
	                walletVersion: 'v5r1',
	                subwalletNumber: 0
	            }
	        });
	    }
	    constructor(workchain, publicKey, walletId) {
	        this.publicKey = publicKey;
	        this.walletId = walletId;
	        this.walletId = walletId;
	        // https://github.com/ton-blockchain/wallet-contract-v5/blob/4fab977f4fae3a37c1aac216ed2b7e611a9bc2af/build/wallet_v5.compiled.json
	        let code = core_1.Cell.fromBoc(Buffer.from('b5ee9c7241021401000281000114ff00f4a413f4bcf2c80b01020120020d020148030402dcd020d749c120915b8f6320d70b1f2082106578746ebd21821073696e74bdb0925f03e082106578746eba8eb48020d72101d074d721fa4030fa44f828fa443058bd915be0ed44d0810141d721f4058307f40e6fa1319130e18040d721707fdb3ce03120d749810280b99130e070e2100f020120050c020120060902016e07080019adce76a2684020eb90eb85ffc00019af1df6a2684010eb90eb858fc00201480a0b0017b325fb51341c75c875c2c7e00011b262fb513435c280200019be5f0f6a2684080a0eb90fa02c0102f20e011e20d70b1f82107369676ebaf2e08a7f0f01e68ef0eda2edfb218308d722028308d723208020d721d31fd31fd31fed44d0d200d31f20d31fd3ffd70a000af90140ccf9109a28945f0adb31e1f2c087df02b35007b0f2d0845125baf2e0855036baf2e086f823bbf2d0882292f800de01a47fc8ca00cb1f01cf16c9ed542092f80fde70db3cd81003f6eda2edfb02f404216e926c218e4c0221d73930709421c700b38e2d01d72820761e436c20d749c008f2e09320d74ac002f2e09320d71d06c712c2005230b0f2d089d74cd7393001a4e86c128407bbf2e093d74ac000f2e093ed55e2d20001c000915be0ebd72c08142091709601d72c081c12e25210b1e30f20d74a111213009601fa4001fa44f828fa443058baf2e091ed44d0810141d718f405049d7fc8ca0040048307f453f2e08b8e14038307f45bf2e08c22d70a00216e01b3b0f2d090e2c85003cf1612f400c9ed54007230d72c08248e2d21f2e092d200ed44d0d2005113baf2d08f54503091319c01810140d721d70a00f2e08ee2c8ca0058cf16c9ed5493f2c08de20010935bdb31e1d74cd0b4d6c35e', 'hex'))[0];
	        let data = (0, core_1.beginCell)()
	            .storeUint(1, 1) // is signature auth allowed
	            .storeUint(0, 32) // Seqno
	            .store((0, WalletV5R1WalletId_1.storeWalletIdV5R1)(this.walletId))
	            .storeBuffer(this.publicKey, 32)
	            .storeBit(0) // Empty plugins dict
	            .endCell();
	        this.init = { code, data };
	        this.address = (0, core_1.contractAddress)(workchain, { code, data });
	    }
	    /**
	     * Get Wallet Balance
	     */
	    async getBalance(provider) {
	        let state = await provider.getState();
	        return state.balance;
	    }
	    /**
	     * Get Wallet Seqno
	     */
	    async getSeqno(provider) {
	        let state = await provider.getState();
	        if (state.state.type === 'active') {
	            let res = await provider.get('seqno', []);
	            return res.stack.readNumber();
	        }
	        else {
	            return 0;
	        }
	    }
	    /**
	     * Get Wallet Extensions
	     */
	    async getExtensions(provider) {
	        let state = await provider.getState();
	        if (state.state.type === 'active') {
	            const result = await provider.get('get_extensions', []);
	            return result.stack.readCellOpt();
	        }
	        else {
	            return null;
	        }
	    }
	    /**
	     * Get Wallet Extensions
	     */
	    async getExtensionsArray(provider) {
	        const extensions = await this.getExtensions(provider);
	        if (!extensions) {
	            return [];
	        }
	        const dict = core_1.Dictionary.loadDirect(core_1.Dictionary.Keys.BigUint(256), core_1.Dictionary.Values.BigInt(1), extensions);
	        return dict.keys().map(addressHex => {
	            const wc = this.address.workChain;
	            return core_1.Address.parseRaw(`${wc}:${addressHex.toString(16).padStart(64, '0')}`);
	        });
	    }
	    /**
	     * Get is secret-key authentication enabled
	     */
	    async getIsSecretKeyAuthEnabled(provider) {
	        let res = await provider.get('is_signature_allowed', []);
	        return res.stack.readBoolean();
	    }
	    /**
	     * Send signed transfer
	     */
	    async send(provider, message) {
	        await provider.external(message);
	    }
	    /**
	     * Sign and send transfer
	     */
	    async sendTransfer(provider, args) {
	        const transfer = await this.createTransfer(args);
	        await this.send(provider, transfer);
	    }
	    /**
	     * Sign and send add extension request
	     */
	    async sendAddExtension(provider, args) {
	        const request = await this.createAddExtension(args);
	        await this.send(provider, request);
	    }
	    /**
	     * Sign and send remove extension request
	     */
	    async sendRemoveExtension(provider, args) {
	        const request = await this.createRemoveExtension(args);
	        await this.send(provider, request);
	    }
	    createActions(args) {
	        const actions = args.messages.map(message => ({ type: 'sendMsg', mode: args.sendMode, outMsg: message }));
	        return actions;
	    }
	    /**
	     * Create signed transfer
	     */
	    createTransfer(args) {
	        return this.createRequest({
	            actions: this.createActions({ messages: args.messages, sendMode: args.sendMode }),
	            ...args
	        });
	    }
	    /**
	     * Create signed add extension request
	     */
	    createAddExtension(args) {
	        return this.createRequest({
	            actions: [{
	                    type: 'addExtension',
	                    address: args.extensionAddress
	                }],
	            ...args
	        });
	    }
	    /**
	     * Create signed remove extension request
	     */
	    createRemoveExtension(args) {
	        return this.createRequest({
	            actions: [{
	                    type: 'removeExtension',
	                    address: args.extensionAddress
	                }],
	            ...args
	        });
	    }
	    /**
	     * Create signed request or extension auth request
	     */
	    createRequest(args) {
	        if (args.authType === 'extension') {
	            return (0, createWalletTransfer_1.createWalletTransferV5R1)(args);
	        }
	        return (0, createWalletTransfer_1.createWalletTransferV5R1)({
	            ...args,
	            walletId: (0, WalletV5R1WalletId_1.storeWalletIdV5R1)(this.walletId)
	        });
	    }
	    /**
	     * Create sender
	     */
	    sender(provider, secretKey) {
	        return {
	            send: async (args) => {
	                let seqno = await this.getSeqno(provider);
	                let transfer = this.createTransfer({
	                    seqno,
	                    secretKey,
	                    sendMode: args.sendMode ?? core_1.SendMode.PAY_GAS_SEPARATELY + core_1.SendMode.IGNORE_ERRORS,
	                    messages: [(0, core_1.internal)({
	                            to: args.to,
	                            value: args.value,
	                            extracurrency: args.extracurrency,
	                            init: args.init,
	                            body: args.body,
	                            bounce: args.bounce
	                        })]
	                });
	                await this.send(provider, transfer);
	            }
	        };
	    }
	}
	WalletContractV5R1$1.WalletContractV5R1 = WalletContractV5R1;
	WalletContractV5R1.OpCodes = {
	    auth_extension: 0x6578746e,
	    auth_signed_external: 0x7369676e,
	    auth_signed_internal: 0x73696e74
	};
	return WalletContractV5R1$1;
}

var WalletV5R1Actions = {};

var hasRequiredWalletV5R1Actions;

function requireWalletV5R1Actions () {
	if (hasRequiredWalletV5R1Actions) return WalletV5R1Actions;
	hasRequiredWalletV5R1Actions = 1;
	Object.defineProperty(WalletV5R1Actions, "__esModule", { value: true });
	WalletV5R1Actions.storeOutActionExtendedV5R1 = storeOutActionExtendedV5R1;
	WalletV5R1Actions.loadOutActionExtendedV5R1 = loadOutActionExtendedV5R1;
	WalletV5R1Actions.storeOutListExtendedV5R1 = storeOutListExtendedV5R1;
	WalletV5R1Actions.loadOutListExtendedV5R1 = loadOutListExtendedV5R1;
	WalletV5R1Actions.toSafeV5R1SendMode = toSafeV5R1SendMode;
	WalletV5R1Actions.patchV5R1ActionsSendMode = patchV5R1ActionsSendMode;
	const core_1 = requireDist$2();
	const WalletV5OutActions_1 = requireWalletV5OutActions();
	const outActionSetIsPublicKeyEnabledTag = 0x04;
	function storeOutActionSetIsPublicKeyEnabled(action) {
	    return (builder) => {
	        builder.storeUint(outActionSetIsPublicKeyEnabledTag, 8).storeUint(action.isEnabled ? 1 : 0, 1);
	    };
	}
	const outActionAddExtensionTag = 0x02;
	function storeOutActionAddExtension(action) {
	    return (builder) => {
	        builder.storeUint(outActionAddExtensionTag, 8).storeAddress(action.address);
	    };
	}
	const outActionRemoveExtensionTag = 0x03;
	function storeOutActionRemoveExtension(action) {
	    return (builder) => {
	        builder.storeUint(outActionRemoveExtensionTag, 8).storeAddress(action.address);
	    };
	}
	function storeOutActionExtendedV5R1(action) {
	    switch (action.type) {
	        case 'setIsPublicKeyEnabled':
	            return storeOutActionSetIsPublicKeyEnabled(action);
	        case 'addExtension':
	            return storeOutActionAddExtension(action);
	        case 'removeExtension':
	            return storeOutActionRemoveExtension(action);
	        default:
	            throw new Error('Unknown action type' + action?.type);
	    }
	}
	function loadOutActionExtendedV5R1(slice) {
	    const tag = slice.loadUint(8);
	    switch (tag) {
	        case outActionSetIsPublicKeyEnabledTag:
	            return {
	                type: 'setIsPublicKeyEnabled',
	                isEnabled: !!slice.loadUint(1)
	            };
	        case outActionAddExtensionTag:
	            return {
	                type: 'addExtension',
	                address: slice.loadAddress()
	            };
	        case outActionRemoveExtensionTag:
	            return {
	                type: 'removeExtension',
	                address: slice.loadAddress()
	            };
	        default:
	            throw new Error(`Unknown extended out action tag 0x${tag.toString(16)}`);
	    }
	}
	function storeOutListExtendedV5R1(actions) {
	    const extendedActions = actions.filter(WalletV5OutActions_1.isOutActionExtended);
	    const basicActions = actions.filter(WalletV5OutActions_1.isOutActionBasic);
	    return (builder) => {
	        const outListPacked = basicActions.length ? (0, core_1.beginCell)().store((0, core_1.storeOutList)(basicActions.slice().reverse())) : null;
	        builder.storeMaybeRef(outListPacked);
	        if (extendedActions.length === 0) {
	            builder.storeUint(0, 1);
	        }
	        else {
	            const [first, ...rest] = extendedActions;
	            builder
	                .storeUint(1, 1)
	                .store(storeOutActionExtendedV5R1(first));
	            if (rest.length > 0) {
	                builder.storeRef(packExtendedActionsRec(rest));
	            }
	        }
	    };
	}
	function packExtendedActionsRec(extendedActions) {
	    const [first, ...rest] = extendedActions;
	    let builder = (0, core_1.beginCell)()
	        .store(storeOutActionExtendedV5R1(first));
	    if (rest.length > 0) {
	        builder = builder.storeRef(packExtendedActionsRec(rest));
	    }
	    return builder.endCell();
	}
	function loadOutListExtendedV5R1(slice) {
	    const actions = [];
	    const outListPacked = slice.loadMaybeRef();
	    if (outListPacked) {
	        const loadedActions = (0, core_1.loadOutList)(outListPacked.beginParse());
	        if (loadedActions.some(a => a.type !== 'sendMsg')) {
	            throw new Error("Can't deserialize actions list: only sendMsg actions are allowed for wallet v5r1");
	        }
	        actions.push(...loadedActions);
	    }
	    if (slice.loadBoolean()) {
	        const action = loadOutActionExtendedV5R1(slice);
	        actions.push(action);
	    }
	    while (slice.remainingRefs > 0) {
	        slice = slice.loadRef().beginParse();
	        const action = loadOutActionExtendedV5R1(slice);
	        actions.push(action);
	    }
	    return actions;
	}
	/**
	 * Safety rules -- actions of external messages must have +2 in the SendMode. Internal messages actions may have arbitrary SendMode.
	 */
	function toSafeV5R1SendMode(sendMode, authType) {
	    if (authType === 'internal' || authType === 'extension') {
	        return sendMode;
	    }
	    return sendMode | core_1.SendMode.IGNORE_ERRORS;
	}
	function patchV5R1ActionsSendMode(actions, authType) {
	    return actions.map(action => action.type === 'sendMsg' ? ({
	        ...action,
	        mode: toSafeV5R1SendMode(action.mode, authType)
	    }) : action);
	}
	return WalletV5R1Actions;
}

var hasRequiredCreateWalletTransfer;

function requireCreateWalletTransfer () {
	if (hasRequiredCreateWalletTransfer) return createWalletTransfer;
	hasRequiredCreateWalletTransfer = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(createWalletTransfer, "__esModule", { value: true });
	createWalletTransfer.createWalletTransferV1 = createWalletTransferV1;
	createWalletTransfer.createWalletTransferV2 = createWalletTransferV2;
	createWalletTransfer.createWalletTransferV3 = createWalletTransferV3;
	createWalletTransfer.createWalletTransferV4 = createWalletTransferV4;
	createWalletTransfer.createWalletTransferV5Beta = createWalletTransferV5Beta;
	createWalletTransfer.createWalletTransferV5R1 = createWalletTransferV5R1;
	const core_1 = requireDist$2();
	const crypto_1 = requireDist$3();
	const WalletContractV5Beta_1 = requireWalletContractV5Beta$1();
	const WalletV5BetaActions_1 = requireWalletV5BetaActions();
	const singer_1 = requireSinger();
	const WalletContractV5R1_1 = requireWalletContractV5R1$1();
	const WalletV5R1Actions_1 = requireWalletV5R1Actions();
	function packSignatureToFront(signature, signingMessage) {
	    const body = (0, core_1.beginCell)()
	        .storeBuffer(signature)
	        .storeBuilder(signingMessage)
	        .endCell();
	    return body;
	}
	function packSignatureToTail(signature, signingMessage) {
	    const body = (0, core_1.beginCell)()
	        .storeBuilder(signingMessage)
	        .storeBuffer(signature)
	        .endCell();
	    return body;
	}
	function createWalletTransferV1(args) {
	    // Create message
	    let signingMessage = (0, core_1.beginCell)()
	        .storeUint(args.seqno, 32);
	    if (args.message) {
	        signingMessage.storeUint(args.sendMode, 8);
	        signingMessage.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(args.message)));
	    }
	    // Sign message
	    let signature = (0, crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
	    // Body
	    const body = (0, core_1.beginCell)()
	        .storeBuffer(signature)
	        .storeBuilder(signingMessage)
	        .endCell();
	    return body;
	}
	function createWalletTransferV2(args) {
	    // Check number of messages
	    if (args.messages.length > 4) {
	        throw Error("Maximum number of messages in a single transfer is 4");
	    }
	    // Create message
	    let signingMessage = (0, core_1.beginCell)()
	        .storeUint(args.seqno, 32);
	    if (args.seqno === 0) {
	        for (let i = 0; i < 32; i++) {
	            signingMessage.storeBit(1);
	        }
	    }
	    else {
	        signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32); // Default timeout: 60 seconds
	    }
	    for (let m of args.messages) {
	        signingMessage.storeUint(args.sendMode, 8);
	        signingMessage.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(m)));
	    }
	    // Sign message
	    let signature = (0, crypto_1.sign)(signingMessage.endCell().hash(), args.secretKey);
	    // Body
	    const body = (0, core_1.beginCell)()
	        .storeBuffer(signature)
	        .storeBuilder(signingMessage)
	        .endCell();
	    return body;
	}
	function createWalletTransferV3(args) {
	    // Check number of messages
	    if (args.messages.length > 4) {
	        throw Error("Maximum number of messages in a single transfer is 4");
	    }
	    // Create message to sign
	    let signingMessage = (0, core_1.beginCell)()
	        .storeUint(args.walletId, 32);
	    if (args.seqno === 0) {
	        for (let i = 0; i < 32; i++) {
	            signingMessage.storeBit(1);
	        }
	    }
	    else {
	        signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32); // Default timeout: 60 seconds
	    }
	    signingMessage.storeUint(args.seqno, 32);
	    for (let m of args.messages) {
	        signingMessage.storeUint(args.sendMode, 8);
	        signingMessage.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(m)));
	    }
	    return (0, singer_1.signPayload)(args, signingMessage, packSignatureToFront);
	}
	function createWalletTransferV4(args) {
	    // Check number of messages
	    if (args.messages.length > 4) {
	        throw Error("Maximum number of messages in a single transfer is 4");
	    }
	    let signingMessage = (0, core_1.beginCell)()
	        .storeUint(args.walletId, 32);
	    if (args.seqno === 0) {
	        for (let i = 0; i < 32; i++) {
	            signingMessage.storeBit(1);
	        }
	    }
	    else {
	        signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32); // Default timeout: 60 seconds
	    }
	    signingMessage.storeUint(args.seqno, 32);
	    signingMessage.storeUint(0, 8); // Simple order
	    for (let m of args.messages) {
	        signingMessage.storeUint(args.sendMode, 8);
	        signingMessage.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(m)));
	    }
	    return (0, singer_1.signPayload)(args, signingMessage, packSignatureToFront);
	}
	function createWalletTransferV5Beta(args) {
	    // Check number of actions
	    if (args.actions.length > 255) {
	        throw Error("Maximum number of OutActions in a single request is 255");
	    }
	    if (args.authType === 'extension') {
	        return (0, core_1.beginCell)()
	            .storeUint(WalletContractV5Beta_1.WalletContractV5Beta.OpCodes.auth_extension, 32)
	            .store((0, WalletV5BetaActions_1.storeOutListExtendedV5Beta)(args.actions))
	            .endCell();
	    }
	    const signingMessage = (0, core_1.beginCell)()
	        .storeUint(args.authType === 'internal'
	        ? WalletContractV5Beta_1.WalletContractV5Beta.OpCodes.auth_signed_internal
	        : WalletContractV5Beta_1.WalletContractV5Beta.OpCodes.auth_signed_external, 32)
	        .store(args.walletId);
	    if (args.seqno === 0) {
	        for (let i = 0; i < 32; i++) {
	            signingMessage.storeBit(1);
	        }
	    }
	    else {
	        signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32); // Default timeout: 60 seconds
	    }
	    signingMessage
	        .storeUint(args.seqno, 32)
	        .store((0, WalletV5BetaActions_1.storeOutListExtendedV5Beta)(args.actions));
	    return (0, singer_1.signPayload)(args, signingMessage, packSignatureToTail);
	}
	function createWalletTransferV5R1(args) {
	    // Check number of actions
	    if (args.actions.length > 255) {
	        throw Error("Maximum number of OutActions in a single request is 255");
	    }
	    args = { ...args };
	    if (args.authType === 'extension') {
	        return (0, core_1.beginCell)()
	            .storeUint(WalletContractV5R1_1.WalletContractV5R1.OpCodes.auth_extension, 32)
	            .storeUint(args.queryId ?? 0, 64)
	            .store((0, WalletV5R1Actions_1.storeOutListExtendedV5R1)(args.actions))
	            .endCell();
	    }
	    args.actions = (0, WalletV5R1Actions_1.patchV5R1ActionsSendMode)(args.actions, args.authType);
	    const signingMessage = (0, core_1.beginCell)()
	        .storeUint(args.authType === 'internal'
	        ? WalletContractV5R1_1.WalletContractV5R1.OpCodes.auth_signed_internal
	        : WalletContractV5R1_1.WalletContractV5R1.OpCodes.auth_signed_external, 32)
	        .store(args.walletId);
	    if (args.seqno === 0) {
	        for (let i = 0; i < 32; i++) {
	            signingMessage.storeBit(1);
	        }
	    }
	    else {
	        signingMessage.storeUint(args.timeout || Math.floor(Date.now() / 1e3) + 60, 32); // Default timeout: 60 seconds
	    }
	    signingMessage
	        .storeUint(args.seqno, 32)
	        .store((0, WalletV5R1Actions_1.storeOutListExtendedV5R1)(args.actions));
	    return (0, singer_1.signPayload)(args, signingMessage, packSignatureToTail);
	}
	return createWalletTransfer;
}

var hasRequiredWalletContractV1R1;

function requireWalletContractV1R1 () {
	if (hasRequiredWalletContractV1R1) return WalletContractV1R1;
	hasRequiredWalletContractV1R1 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(WalletContractV1R1, "__esModule", { value: true });
	WalletContractV1R1.WalletContractV1R1 = void 0;
	const core_1 = requireDist$2();
	const createWalletTransfer_1 = requireCreateWalletTransfer();
	let WalletContractV1R1$1 = class WalletContractV1R1 {
	    static create(args) {
	        return new WalletContractV1R1(args.workchain, args.publicKey);
	    }
	    constructor(workchain, publicKey) {
	        this.workchain = workchain;
	        this.publicKey = publicKey;
	        // Build initial code and data
	        let code = core_1.Cell.fromBoc(Buffer.from('te6cckEBAQEARAAAhP8AIN2k8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVEH98Ik=', 'base64'))[0];
	        let data = (0, core_1.beginCell)()
	            .storeUint(0, 32) // Seqno
	            .storeBuffer(publicKey)
	            .endCell();
	        this.init = { code, data };
	        this.address = (0, core_1.contractAddress)(workchain, { code, data });
	    }
	    /**
	     * Get Wallet Balance
	     */
	    async getBalance(provider) {
	        let state = await provider.getState();
	        return state.balance;
	    }
	    /**
	     * Get Wallet Seqno
	     */
	    async getSeqno(provider) {
	        let state = await provider.getState();
	        if (state.state.type === 'active') {
	            return core_1.Cell.fromBoc(state.state.data)[0].beginParse().loadUint(32);
	        }
	        else {
	            return 0;
	        }
	    }
	    /**
	     * Send signed transfer
	     */
	    async send(provider, message) {
	        await provider.external(message);
	    }
	    /**
	     * Sign and send transfer
	     */
	    async sendTransfer(provider, args) {
	        let transfer = this.createTransfer(args);
	        await this.send(provider, transfer);
	    }
	    /**
	     * Create signed transfer
	     */
	    createTransfer(args) {
	        let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
	        if (args.sendMode !== null && args.sendMode !== undefined) {
	            sendMode = args.sendMode;
	        }
	        return (0, createWalletTransfer_1.createWalletTransferV1)({
	            seqno: args.seqno,
	            sendMode,
	            secretKey: args.secretKey,
	            message: args.message
	        });
	    }
	    /**
	     * Create sender
	     */
	    sender(provider, secretKey) {
	        return {
	            send: async (args) => {
	                let seqno = await this.getSeqno(provider);
	                let transfer = this.createTransfer({
	                    seqno,
	                    secretKey,
	                    sendMode: args.sendMode,
	                    message: (0, core_1.internal)({
	                        to: args.to,
	                        value: args.value,
	                        extracurrency: args.extracurrency,
	                        init: args.init,
	                        body: args.body,
	                        bounce: args.bounce
	                    })
	                });
	                await this.send(provider, transfer);
	            }
	        };
	    }
	};
	WalletContractV1R1.WalletContractV1R1 = WalletContractV1R1$1;
	return WalletContractV1R1;
}

var WalletContractV1R2 = {};

var hasRequiredWalletContractV1R2;

function requireWalletContractV1R2 () {
	if (hasRequiredWalletContractV1R2) return WalletContractV1R2;
	hasRequiredWalletContractV1R2 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(WalletContractV1R2, "__esModule", { value: true });
	WalletContractV1R2.WalletContractV1R2 = void 0;
	const core_1 = requireDist$2();
	const createWalletTransfer_1 = requireCreateWalletTransfer();
	let WalletContractV1R2$1 = class WalletContractV1R2 {
	    static create(args) {
	        return new WalletContractV1R2(args.workchain, args.publicKey);
	    }
	    constructor(workchain, publicKey) {
	        this.workchain = workchain;
	        this.publicKey = publicKey;
	        // Build initial code and data
	        let code = core_1.Cell.fromBoc(Buffer.from('te6cckEBAQEAUwAAov8AIN0gggFMl7qXMO1E0NcLH+Ck8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVNDieG8=', 'base64'))[0];
	        let data = (0, core_1.beginCell)()
	            .storeUint(0, 32) // Seqno
	            .storeBuffer(publicKey)
	            .endCell();
	        this.init = { code, data };
	        this.address = (0, core_1.contractAddress)(workchain, { code, data });
	    }
	    /**
	     * Get Wallet Balance
	     */
	    async getBalance(provider) {
	        let state = await provider.getState();
	        return state.balance;
	    }
	    /**
	     * Get Wallet Seqno
	     */
	    async getSeqno(provider) {
	        let state = await provider.getState();
	        if (state.state.type === 'active') {
	            let res = await provider.get('seqno', []);
	            return res.stack.readNumber();
	        }
	        else {
	            return 0;
	        }
	    }
	    /**
	     * Send signed transfer
	     */
	    async send(provider, message) {
	        await provider.external(message);
	    }
	    /**
	     * Sign and send transfer
	     */
	    async sendTransfer(provider, args) {
	        let transfer = this.createTransfer(args);
	        await this.send(provider, transfer);
	    }
	    /**
	     * Create signed transfer
	     */
	    createTransfer(args) {
	        let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
	        if (args.sendMode !== null && args.sendMode !== undefined) {
	            sendMode = args.sendMode;
	        }
	        return (0, createWalletTransfer_1.createWalletTransferV1)({
	            seqno: args.seqno,
	            sendMode,
	            secretKey: args.secretKey,
	            message: args.message
	        });
	    }
	    /**
	     * Create sender
	     */
	    sender(provider, secretKey) {
	        return {
	            send: async (args) => {
	                let seqno = await this.getSeqno(provider);
	                let transfer = this.createTransfer({
	                    seqno,
	                    secretKey,
	                    sendMode: args.sendMode,
	                    message: (0, core_1.internal)({
	                        to: args.to,
	                        value: args.value,
	                        extracurrency: args.extracurrency,
	                        init: args.init,
	                        body: args.body,
	                        bounce: args.bounce
	                    })
	                });
	                await this.send(provider, transfer);
	            }
	        };
	    }
	};
	WalletContractV1R2.WalletContractV1R2 = WalletContractV1R2$1;
	return WalletContractV1R2;
}

var WalletContractV1R3 = {};

var hasRequiredWalletContractV1R3;

function requireWalletContractV1R3 () {
	if (hasRequiredWalletContractV1R3) return WalletContractV1R3;
	hasRequiredWalletContractV1R3 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(WalletContractV1R3, "__esModule", { value: true });
	WalletContractV1R3.WalletContractV1R3 = void 0;
	const core_1 = requireDist$2();
	const createWalletTransfer_1 = requireCreateWalletTransfer();
	let WalletContractV1R3$1 = class WalletContractV1R3 {
	    static create(args) {
	        return new WalletContractV1R3(args.workchain, args.publicKey);
	    }
	    constructor(workchain, publicKey) {
	        this.workchain = workchain;
	        this.publicKey = publicKey;
	        // Build initial code and data
	        let code = core_1.Cell.fromBoc(Buffer.from('te6cckEBAQEAXwAAuv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVLW4bkI=', 'base64'))[0];
	        let data = (0, core_1.beginCell)()
	            .storeUint(0, 32) // Seqno
	            .storeBuffer(publicKey)
	            .endCell();
	        this.init = { code, data };
	        this.address = (0, core_1.contractAddress)(workchain, { code, data });
	    }
	    /**
	     * Get Wallet Balance
	     */
	    async getBalance(provider) {
	        let state = await provider.getState();
	        return state.balance;
	    }
	    /**
	     * Get Wallet Seqno
	     */
	    async getSeqno(provider) {
	        let state = await provider.getState();
	        if (state.state.type === 'active') {
	            let res = await provider.get('seqno', []);
	            return res.stack.readNumber();
	        }
	        else {
	            return 0;
	        }
	    }
	    /**
	     * Send signed transfer
	     */
	    async send(executor, message) {
	        await executor.external(message);
	    }
	    /**
	     * Sign and send transfer
	     */
	    async sendTransfer(provider, args) {
	        let transfer = this.createTransfer(args);
	        await this.send(provider, transfer);
	    }
	    /**
	     * Create signed transfer
	     */
	    createTransfer(args) {
	        let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
	        if (args.sendMode !== null && args.sendMode !== undefined) {
	            sendMode = args.sendMode;
	        }
	        return (0, createWalletTransfer_1.createWalletTransferV1)({
	            seqno: args.seqno,
	            sendMode: sendMode,
	            secretKey: args.secretKey,
	            message: args.message
	        });
	    }
	    /**
	     * Create sender
	     */
	    sender(provider, secretKey) {
	        return {
	            send: async (args) => {
	                let seqno = await this.getSeqno(provider);
	                let transfer = this.createTransfer({
	                    seqno,
	                    secretKey,
	                    sendMode: args.sendMode,
	                    message: (0, core_1.internal)({
	                        to: args.to,
	                        value: args.value,
	                        init: args.init,
	                        body: args.body,
	                        bounce: args.bounce
	                    })
	                });
	                await this.send(provider, transfer);
	            }
	        };
	    }
	};
	WalletContractV1R3.WalletContractV1R3 = WalletContractV1R3$1;
	return WalletContractV1R3;
}

var WalletContractV2R1 = {};

var hasRequiredWalletContractV2R1;

function requireWalletContractV2R1 () {
	if (hasRequiredWalletContractV2R1) return WalletContractV2R1;
	hasRequiredWalletContractV2R1 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(WalletContractV2R1, "__esModule", { value: true });
	WalletContractV2R1.WalletContractV2R1 = void 0;
	const core_1 = requireDist$2();
	const createWalletTransfer_1 = requireCreateWalletTransfer();
	let WalletContractV2R1$1 = class WalletContractV2R1 {
	    static create(args) {
	        return new WalletContractV2R1(args.workchain, args.publicKey);
	    }
	    constructor(workchain, publicKey) {
	        this.workchain = workchain;
	        this.publicKey = publicKey;
	        // Build initial code and data
	        let code = core_1.Cell.fromBoc(Buffer.from('te6cckEBAQEAVwAAqv8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VShNwu2', 'base64'))[0];
	        let data = (0, core_1.beginCell)()
	            .storeUint(0, 32) // Seqno
	            .storeBuffer(publicKey)
	            .endCell();
	        this.init = { code, data };
	        this.address = (0, core_1.contractAddress)(workchain, { code, data });
	    }
	    /**
	     * Get Wallet Balance
	     */
	    async getBalance(provider) {
	        let state = await provider.getState();
	        return state.balance;
	    }
	    /**
	     * Get Wallet Seqno
	     */
	    async getSeqno(provider) {
	        let state = await provider.getState();
	        if (state.state.type === 'active') {
	            let res = await provider.get('seqno', []);
	            return res.stack.readNumber();
	        }
	        else {
	            return 0;
	        }
	    }
	    /**
	     * Send signed transfer
	     */
	    async send(provider, message) {
	        await provider.external(message);
	    }
	    /**
	     * Sign and send transfer
	     */
	    async sendTransfer(provider, args) {
	        let transfer = this.createTransfer(args);
	        await this.send(provider, transfer);
	    }
	    /**
	     * Create signed transfer
	     */
	    createTransfer(args) {
	        let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
	        if (args.sendMode !== null && args.sendMode !== undefined) {
	            sendMode = args.sendMode;
	        }
	        return (0, createWalletTransfer_1.createWalletTransferV2)({
	            seqno: args.seqno,
	            sendMode,
	            secretKey: args.secretKey,
	            messages: args.messages,
	            timeout: args.timeout
	        });
	    }
	    /**
	     * Create sender
	     */
	    sender(provider, secretKey) {
	        return {
	            send: async (args) => {
	                let seqno = await this.getSeqno(provider);
	                let transfer = this.createTransfer({
	                    seqno,
	                    secretKey,
	                    sendMode: args.sendMode,
	                    messages: [(0, core_1.internal)({
	                            to: args.to,
	                            value: args.value,
	                            extracurrency: args.extracurrency,
	                            init: args.init,
	                            body: args.body,
	                            bounce: args.bounce
	                        })]
	                });
	                await this.send(provider, transfer);
	            }
	        };
	    }
	};
	WalletContractV2R1.WalletContractV2R1 = WalletContractV2R1$1;
	return WalletContractV2R1;
}

var WalletContractV2R2 = {};

var hasRequiredWalletContractV2R2;

function requireWalletContractV2R2 () {
	if (hasRequiredWalletContractV2R2) return WalletContractV2R2;
	hasRequiredWalletContractV2R2 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(WalletContractV2R2, "__esModule", { value: true });
	WalletContractV2R2.WalletContractV2R2 = void 0;
	const core_1 = requireDist$2();
	const createWalletTransfer_1 = requireCreateWalletTransfer();
	let WalletContractV2R2$1 = class WalletContractV2R2 {
	    static create(args) {
	        return new WalletContractV2R2(args.workchain, args.publicKey);
	    }
	    constructor(workchain, publicKey) {
	        this.workchain = workchain;
	        this.publicKey = publicKey;
	        // Build initial code and data
	        let code = core_1.Cell.fromBoc(Buffer.from('te6cckEBAQEAYwAAwv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VQETNeh', 'base64'))[0];
	        let data = (0, core_1.beginCell)()
	            .storeUint(0, 32) // Seqno
	            .storeBuffer(publicKey)
	            .endCell();
	        this.init = { code, data };
	        this.address = (0, core_1.contractAddress)(workchain, { code, data });
	    }
	    /**
	     * Get Wallet Balance
	     */
	    async getBalance(provider) {
	        let state = await provider.getState();
	        return state.balance;
	    }
	    /**
	     * Get Wallet Seqno
	     */
	    async getSeqno(provider) {
	        let state = await provider.getState();
	        if (state.state.type === 'active') {
	            let res = await provider.get('seqno', []);
	            return res.stack.readNumber();
	        }
	        else {
	            return 0;
	        }
	    }
	    /**
	     * Send signed transfer
	     */
	    async send(provider, message) {
	        await provider.external(message);
	    }
	    /**
	     * Sign and send transfer
	     */
	    async sendTransfer(provider, args) {
	        let transfer = this.createTransfer(args);
	        await this.send(provider, transfer);
	    }
	    /**
	     * Create signed transfer
	     */
	    createTransfer(args) {
	        let sendMode = core_1.SendMode.PAY_GAS_SEPARATELY;
	        if (args.sendMode !== null && args.sendMode !== undefined) {
	            sendMode = args.sendMode;
	        }
	        return (0, createWalletTransfer_1.createWalletTransferV2)({
	            seqno: args.seqno,
	            sendMode,
	            secretKey: args.secretKey,
	            messages: args.messages,
	            timeout: args.timeout
	        });
	    }
	    /**
	     * Create sender
	     */
	    sender(provider, secretKey) {
	        return {
	            send: async (args) => {
	                let seqno = await this.getSeqno(provider);
	                let transfer = this.createTransfer({
	                    seqno,
	                    secretKey,
	                    sendMode: args.sendMode,
	                    messages: [(0, core_1.internal)({
	                            to: args.to,
	                            value: args.value,
	                            extracurrency: args.extracurrency,
	                            init: args.init,
	                            body: args.body,
	                            bounce: args.bounce
	                        })]
	                });
	                await this.send(provider, transfer);
	            }
	        };
	    }
	};
	WalletContractV2R2.WalletContractV2R2 = WalletContractV2R2$1;
	return WalletContractV2R2;
}

var WalletContractV3R1 = {};

var hasRequiredWalletContractV3R1;

function requireWalletContractV3R1 () {
	if (hasRequiredWalletContractV3R1) return WalletContractV3R1;
	hasRequiredWalletContractV3R1 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(WalletContractV3R1, "__esModule", { value: true });
	WalletContractV3R1.WalletContractV3R1 = void 0;
	const core_1 = requireDist$2();
	const createWalletTransfer_1 = requireCreateWalletTransfer();
	let WalletContractV3R1$1 = class WalletContractV3R1 {
	    static create(args) {
	        return new WalletContractV3R1(args.workchain, args.publicKey, args.walletId);
	    }
	    constructor(workchain, publicKey, walletId) {
	        // Resolve parameters
	        this.workchain = workchain;
	        this.publicKey = publicKey;
	        if (walletId !== null && walletId !== undefined) {
	            this.walletId = walletId;
	        }
	        else {
	            this.walletId = 698983191 + workchain;
	        }
	        // Build initial code and data
	        let code = core_1.Cell.fromBoc(Buffer.from('te6cckEBAQEAYgAAwP8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVD++buA=', 'base64'))[0];
	        let data = (0, core_1.beginCell)()
	            .storeUint(0, 32) // Seqno
	            .storeUint(this.walletId, 32)
	            .storeBuffer(publicKey)
	            .endCell();
	        this.init = { code, data };
	        this.address = (0, core_1.contractAddress)(workchain, { code, data });
	    }
	    /**
	     * Get wallet balance
	     */
	    async getBalance(provider) {
	        let state = await provider.getState();
	        return state.balance;
	    }
	    /**
	     * Get Wallet Seqno
	     */
	    async getSeqno(provider) {
	        let state = await provider.getState();
	        if (state.state.type === 'active') {
	            let res = await provider.get('seqno', []);
	            return res.stack.readNumber();
	        }
	        else {
	            return 0;
	        }
	    }
	    /**
	     * Send signed transfer
	     */
	    async send(provider, message) {
	        await provider.external(message);
	    }
	    /**
	     * Sign and send transfer
	     */
	    async sendTransfer(provider, args) {
	        let transfer = this.createTransfer(args);
	        await this.send(provider, transfer);
	    }
	    /**
	     * Create transfer
	     */
	    createTransfer(args) {
	        return (0, createWalletTransfer_1.createWalletTransferV3)({
	            ...args,
	            sendMode: args.sendMode ?? core_1.SendMode.PAY_GAS_SEPARATELY,
	            walletId: this.walletId
	        });
	    }
	    /**
	     * Create sender
	     */
	    sender(provider, secretKey) {
	        return {
	            send: async (args) => {
	                let seqno = await this.getSeqno(provider);
	                let transfer = this.createTransfer({
	                    seqno,
	                    secretKey,
	                    sendMode: args.sendMode,
	                    messages: [(0, core_1.internal)({
	                            to: args.to,
	                            value: args.value,
	                            extracurrency: args.extracurrency,
	                            init: args.init,
	                            body: args.body,
	                            bounce: args.bounce
	                        })]
	                });
	                await this.send(provider, transfer);
	            }
	        };
	    }
	};
	WalletContractV3R1.WalletContractV3R1 = WalletContractV3R1$1;
	return WalletContractV3R1;
}

var WalletContractV3R2 = {};

var hasRequiredWalletContractV3R2;

function requireWalletContractV3R2 () {
	if (hasRequiredWalletContractV3R2) return WalletContractV3R2;
	hasRequiredWalletContractV3R2 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(WalletContractV3R2, "__esModule", { value: true });
	WalletContractV3R2.WalletContractV3R2 = void 0;
	const core_1 = requireDist$2();
	const createWalletTransfer_1 = requireCreateWalletTransfer();
	let WalletContractV3R2$1 = class WalletContractV3R2 {
	    static create(args) {
	        return new WalletContractV3R2(args.workchain, args.publicKey, args.walletId);
	    }
	    constructor(workchain, publicKey, walletId) {
	        // Resolve parameters
	        this.workchain = workchain;
	        this.publicKey = publicKey;
	        if (walletId !== null && walletId !== undefined) {
	            this.walletId = walletId;
	        }
	        else {
	            this.walletId = 698983191 + workchain;
	        }
	        // Build initial code and data
	        let code = core_1.Cell.fromBoc(Buffer.from('te6cckEBAQEAcQAA3v8AIN0gggFMl7ohggEznLqxn3Gw7UTQ0x/THzHXC//jBOCk8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVBC9ba0=', 'base64'))[0];
	        let data = (0, core_1.beginCell)()
	            .storeUint(0, 32) // Seqno
	            .storeUint(this.walletId, 32)
	            .storeBuffer(publicKey)
	            .endCell();
	        this.init = { code, data };
	        this.address = (0, core_1.contractAddress)(workchain, { code, data });
	    }
	    /**
	     * Get wallet balance
	     */
	    async getBalance(provider) {
	        let state = await provider.getState();
	        return state.balance;
	    }
	    /**
	     * Get Wallet Seqno
	     */
	    async getSeqno(provider) {
	        let state = await provider.getState();
	        if (state.state.type === 'active') {
	            let res = await provider.get('seqno', []);
	            return res.stack.readNumber();
	        }
	        else {
	            return 0;
	        }
	    }
	    /**
	     * Send signed transfer
	     */
	    async send(provider, message) {
	        await provider.external(message);
	    }
	    /**
	     * Sign and send transfer
	     */
	    async sendTransfer(provider, args) {
	        let transfer = this.createTransfer(args);
	        await this.send(provider, transfer);
	    }
	    /**
	     * Create transfer
	     */
	    createTransfer(args) {
	        return (0, createWalletTransfer_1.createWalletTransferV3)({
	            ...args,
	            sendMode: args.sendMode ?? core_1.SendMode.PAY_GAS_SEPARATELY,
	            walletId: this.walletId
	        });
	    }
	    /**
	     * Create sender
	     */
	    sender(provider, secretKey) {
	        return {
	            send: async (args) => {
	                let seqno = await this.getSeqno(provider);
	                let transfer = this.createTransfer({
	                    seqno,
	                    secretKey,
	                    sendMode: args.sendMode,
	                    messages: [(0, core_1.internal)({
	                            to: args.to,
	                            value: args.value,
	                            extracurrency: args.extracurrency,
	                            init: args.init,
	                            body: args.body,
	                            bounce: args.bounce
	                        })]
	                });
	                await this.send(provider, transfer);
	            }
	        };
	    }
	};
	WalletContractV3R2.WalletContractV3R2 = WalletContractV3R2$1;
	return WalletContractV3R2;
}

var WalletContractV4 = {};

var hasRequiredWalletContractV4;

function requireWalletContractV4 () {
	if (hasRequiredWalletContractV4) return WalletContractV4;
	hasRequiredWalletContractV4 = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(WalletContractV4, "__esModule", { value: true });
	WalletContractV4.WalletContractV4 = void 0;
	const core_1 = requireDist$2();
	const createWalletTransfer_1 = requireCreateWalletTransfer();
	let WalletContractV4$1 = class WalletContractV4 {
	    static create(args) {
	        return new WalletContractV4(args.workchain, args.publicKey, args.walletId);
	    }
	    constructor(workchain, publicKey, walletId) {
	        // Resolve parameters
	        this.workchain = workchain;
	        this.publicKey = publicKey;
	        if (walletId !== null && walletId !== undefined) {
	            this.walletId = walletId;
	        }
	        else {
	            this.walletId = 698983191 + workchain;
	        }
	        // Build initial code and data
	        let code = core_1.Cell.fromBoc(Buffer.from('te6ccgECFAEAAtQAART/APSkE/S88sgLAQIBIAIDAgFIBAUE+PKDCNcYINMf0x/THwL4I7vyZO1E0NMf0x/T//QE0VFDuvKhUVG68qIF+QFUEGT5EPKj+AAkpMjLH1JAyx9SMMv/UhD0AMntVPgPAdMHIcAAn2xRkyDXSpbTB9QC+wDoMOAhwAHjACHAAuMAAcADkTDjDQOkyMsfEssfy/8QERITAubQAdDTAyFxsJJfBOAi10nBIJJfBOAC0x8hghBwbHVnvSKCEGRzdHK9sJJfBeAD+kAwIPpEAcjKB8v/ydDtRNCBAUDXIfQEMFyBAQj0Cm+hMbOSXwfgBdM/yCWCEHBsdWe6kjgw4w0DghBkc3RyupJfBuMNBgcCASAICQB4AfoA9AQw+CdvIjBQCqEhvvLgUIIQcGx1Z4MesXCAGFAEywUmzxZY+gIZ9ADLaRfLH1Jgyz8gyYBA+wAGAIpQBIEBCPRZMO1E0IEBQNcgyAHPFvQAye1UAXKwjiOCEGRzdHKDHrFwgBhQBcsFUAPPFiP6AhPLassfyz/JgED7AJJfA+ICASAKCwBZvSQrb2omhAgKBrkPoCGEcNQICEekk30pkQzmkD6f+YN4EoAbeBAUiYcVnzGEAgFYDA0AEbjJftRNDXCx+AA9sp37UTQgQFA1yH0BDACyMoHy//J0AGBAQj0Cm+hMYAIBIA4PABmtznaiaEAga5Drhf/AABmvHfaiaEAQa5DrhY/AAG7SB/oA1NQi+QAFyMoHFcv/ydB3dIAYyMsFywIizxZQBfoCFMtrEszMyXP7AMhAFIEBCPRR8qcCAHCBAQjXGPoA0z/IVCBHgQEI9FHyp4IQbm90ZXB0gBjIywXLAlAGzxZQBPoCFMtqEssfyz/Jc/sAAgBsgQEI1xj6ANM/MFIkgQEI9Fnyp4IQZHN0cnB0gBjIywXLAlAFzxZQA/oCE8tqyx8Syz/Jc/sAAAr0AMntVA==', 'base64'))[0];
	        let data = (0, core_1.beginCell)()
	            .storeUint(0, 32) // Seqno
	            .storeUint(this.walletId, 32)
	            .storeBuffer(this.publicKey)
	            .storeBit(0) // Empty plugins dict
	            .endCell();
	        this.init = { code, data };
	        this.address = (0, core_1.contractAddress)(workchain, { code, data });
	    }
	    /**
	     * Get Wallet Balance
	     */
	    async getBalance(provider) {
	        let state = await provider.getState();
	        return state.balance;
	    }
	    /**
	     * Get Wallet Seqno
	     */
	    async getSeqno(provider) {
	        let state = await provider.getState();
	        if (state.state.type === 'active') {
	            let res = await provider.get('seqno', []);
	            return res.stack.readNumber();
	        }
	        else {
	            return 0;
	        }
	    }
	    /**
	     * Send signed transfer
	     */
	    async send(provider, message) {
	        await provider.external(message);
	    }
	    /**
	     * Sign and send transfer
	     */
	    async sendTransfer(provider, args) {
	        let transfer = this.createTransfer(args);
	        await this.send(provider, transfer);
	    }
	    /**
	     * Create signed transfer
	     */
	    createTransfer(args) {
	        return (0, createWalletTransfer_1.createWalletTransferV4)({
	            ...args,
	            sendMode: args.sendMode ?? core_1.SendMode.PAY_GAS_SEPARATELY,
	            walletId: this.walletId
	        });
	    }
	    /**
	     * Create sender
	     */
	    sender(provider, secretKey) {
	        return {
	            send: async (args) => {
	                let seqno = await this.getSeqno(provider);
	                let transfer = this.createTransfer({
	                    seqno,
	                    secretKey,
	                    sendMode: args.sendMode,
	                    messages: [(0, core_1.internal)({
	                            to: args.to,
	                            value: args.value,
	                            extracurrency: args.extracurrency,
	                            init: args.init,
	                            body: args.body,
	                            bounce: args.bounce
	                        })]
	                });
	                await this.send(provider, transfer);
	            }
	        };
	    }
	};
	WalletContractV4.WalletContractV4 = WalletContractV4$1;
	return WalletContractV4;
}

var WalletContractV5Beta = {};

var hasRequiredWalletContractV5Beta;

function requireWalletContractV5Beta () {
	if (hasRequiredWalletContractV5Beta) return WalletContractV5Beta;
	hasRequiredWalletContractV5Beta = 1;
	(function (exports) {
		var __createBinding = (WalletContractV5Beta && WalletContractV5Beta.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (WalletContractV5Beta && WalletContractV5Beta.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(requireWalletContractV5Beta$1(), exports);
		__exportStar(requireWalletV5BetaActions(), exports);
		__exportStar(requireWalletV5BetaWalletId(), exports); 
	} (WalletContractV5Beta));
	return WalletContractV5Beta;
}

var WalletContractV5R1 = {};

var hasRequiredWalletContractV5R1;

function requireWalletContractV5R1 () {
	if (hasRequiredWalletContractV5R1) return WalletContractV5R1;
	hasRequiredWalletContractV5R1 = 1;
	(function (exports) {
		var __createBinding = (WalletContractV5R1 && WalletContractV5R1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (WalletContractV5R1 && WalletContractV5R1.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(requireWalletContractV5R1$1(), exports);
		__exportStar(requireWalletV5R1Actions(), exports);
		__exportStar(requireWalletV5R1WalletId(), exports); 
	} (WalletContractV5R1));
	return WalletContractV5R1;
}

var JettonMaster = {};

var hasRequiredJettonMaster;

function requireJettonMaster () {
	if (hasRequiredJettonMaster) return JettonMaster;
	hasRequiredJettonMaster = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(JettonMaster, "__esModule", { value: true });
	JettonMaster.JettonMaster = void 0;
	const core_1 = requireDist$2();
	let JettonMaster$1 = class JettonMaster {
	    static create(address) {
	        return new JettonMaster(address);
	    }
	    constructor(address) {
	        this.address = address;
	    }
	    async getWalletAddress(provider, owner) {
	        let res = await provider.get('get_wallet_address', [{ type: 'slice', cell: (0, core_1.beginCell)().storeAddress(owner).endCell() }]);
	        return res.stack.readAddress();
	    }
	    async getJettonData(provider) {
	        let res = await provider.get('get_jetton_data', []);
	        let totalSupply = res.stack.readBigNumber();
	        let mintable = res.stack.readBoolean();
	        let adminAddress = res.stack.readAddress();
	        let content = res.stack.readCell();
	        let walletCode = res.stack.readCell();
	        return {
	            totalSupply,
	            mintable,
	            adminAddress,
	            content,
	            walletCode
	        };
	    }
	};
	JettonMaster.JettonMaster = JettonMaster$1;
	return JettonMaster;
}

var JettonWallet = {};

var hasRequiredJettonWallet;

function requireJettonWallet () {
	if (hasRequiredJettonWallet) return JettonWallet;
	hasRequiredJettonWallet = 1;
	/**
	 * Copyright (c) Whales Corp.
	 * All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	Object.defineProperty(JettonWallet, "__esModule", { value: true });
	JettonWallet.JettonWallet = void 0;
	let JettonWallet$1 = class JettonWallet {
	    static create(address) {
	        return new JettonWallet(address);
	    }
	    constructor(address) {
	        this.address = address;
	    }
	    async getBalance(provider) {
	        let state = await provider.getState();
	        if (state.state.type !== 'active') {
	            return 0n;
	        }
	        let res = await provider.get('get_wallet_data', []);
	        return res.stack.readBigNumber();
	    }
	};
	JettonWallet.JettonWallet = JettonWallet$1;
	return JettonWallet;
}

var MultisigOrder = {};

var hasRequiredMultisigOrder;

function requireMultisigOrder () {
	if (hasRequiredMultisigOrder) return MultisigOrder;
	hasRequiredMultisigOrder = 1;
	/* Made by @Gusarich and @Miandic */
	Object.defineProperty(MultisigOrder, "__esModule", { value: true });
	MultisigOrder.MultisigOrder = void 0;
	const crypto_1 = requireDist$3();
	const core_1 = requireDist$2();
	let MultisigOrder$1 = class MultisigOrder {
	    constructor(payload) {
	        this.signatures = {};
	        this.payload = payload;
	    }
	    static fromCell(cell) {
	        let s = cell.beginParse();
	        let signatures = s.loadMaybeRef()?.beginParse();
	        const messagesCell = s.asCell();
	        let order = new MultisigOrder(messagesCell);
	        if (signatures) {
	            while (signatures.remainingBits > 0) {
	                const signature = signatures.loadBuffer(64);
	                const ownerId = signatures.loadUint(8);
	                order.signatures[ownerId] = signature;
	                if (signatures.remainingRefs > 0) {
	                    signatures = signatures.loadRef().asSlice();
	                }
	                else {
	                    signatures.skip(1);
	                }
	            }
	            signatures.endParse();
	        }
	        return order;
	    }
	    static fromPayload(payload) {
	        return new MultisigOrder(payload);
	    }
	    addSignature(ownerId, signature, multisig) {
	        const signingHash = this.payload.hash();
	        if (!(0, crypto_1.signVerify)(signingHash, signature, multisig.owners.get(ownerId).slice(0, -1))) {
	            throw Error('invalid signature');
	        }
	        this.signatures[ownerId] = signature;
	    }
	    sign(ownerId, secretKey) {
	        const signingHash = this.payload.hash();
	        this.signatures[ownerId] = (0, crypto_1.sign)(signingHash, secretKey);
	        return signingHash;
	    }
	    unionSignatures(other) {
	        this.signatures = Object.assign({}, this.signatures, other.signatures);
	    }
	    clearSignatures() {
	        this.signatures = {};
	    }
	    toCell(ownerId) {
	        let b = (0, core_1.beginCell)().storeBit(0);
	        for (const ownerId in this.signatures) {
	            const signature = this.signatures[ownerId];
	            b = (0, core_1.beginCell)()
	                .storeBit(1)
	                .storeRef((0, core_1.beginCell)()
	                .storeBuffer(signature)
	                .storeUint(parseInt(ownerId), 8)
	                .storeBuilder(b)
	                .endCell());
	        }
	        return (0, core_1.beginCell)()
	            .storeUint(ownerId, 8)
	            .storeBuilder(b)
	            .storeBuilder(this.payload.asBuilder())
	            .endCell();
	    }
	};
	MultisigOrder.MultisigOrder = MultisigOrder$1;
	return MultisigOrder;
}

var MultisigOrderBuilder = {};

var hasRequiredMultisigOrderBuilder;

function requireMultisigOrderBuilder () {
	if (hasRequiredMultisigOrderBuilder) return MultisigOrderBuilder;
	hasRequiredMultisigOrderBuilder = 1;
	/* Made by @Gusarich and @Miandic */
	Object.defineProperty(MultisigOrderBuilder, "__esModule", { value: true });
	MultisigOrderBuilder.MultisigOrderBuilder = void 0;
	const core_1 = requireDist$2();
	const MultisigOrder_1 = requireMultisigOrder();
	let MultisigOrderBuilder$1 = class MultisigOrderBuilder {
	    constructor(walletId, offset) {
	        this.messages = (0, core_1.beginCell)();
	        this.queryId = 0n;
	        this.walletId = walletId;
	        this.queryOffset = offset || 7200;
	    }
	    addMessage(message, mode) {
	        if (this.messages.refs >= 4) {
	            throw Error('only 4 refs are allowed');
	        }
	        this.updateQueryId();
	        this.messages.storeUint(mode, 8);
	        this.messages.storeRef((0, core_1.beginCell)().store((0, core_1.storeMessageRelaxed)(message)).endCell());
	    }
	    clearMessages() {
	        this.messages = (0, core_1.beginCell)();
	    }
	    build() {
	        return MultisigOrder_1.MultisigOrder.fromPayload((0, core_1.beginCell)()
	            .storeUint(this.walletId, 32)
	            .storeUint(this.queryId, 64)
	            .storeBuilder(this.messages)
	            .endCell());
	    }
	    updateQueryId() {
	        const time = BigInt(Math.floor(Date.now() / 1000 + this.queryOffset));
	        this.queryId = time << 32n;
	    }
	};
	MultisigOrderBuilder.MultisigOrderBuilder = MultisigOrderBuilder$1;
	return MultisigOrderBuilder;
}

var MultisigWallet = {};

var hasRequiredMultisigWallet;

function requireMultisigWallet () {
	if (hasRequiredMultisigWallet) return MultisigWallet;
	hasRequiredMultisigWallet = 1;
	/* Made by @Gusarich and @Miandic */
	Object.defineProperty(MultisigWallet, "__esModule", { value: true });
	MultisigWallet.MultisigWallet = void 0;
	const crypto_1 = requireDist$3();
	const core_1 = requireDist$2();
	const MULTISIG_CODE = core_1.Cell.fromBase64('te6ccgECKwEABBgAART/APSkE/S88sgLAQIBIAIDAgFIBAUE2vIgxwCOgzDbPOCDCNcYIPkBAdMH2zwiwAAToVNxePQOb6Hyn9s8VBq6+RDyoAb0BCD5AQHTH1EYuvKq0z9wUwHwCgHCCAGDCryx8mhTFYBA9A5voSCYDqQgwgryZw7f+COqH1NAufJhVCOjU04gIyEiAgLMBgcCASAMDQIBIAgJAgFmCgsAA9GEAiPymAvHoHN9CYbZ5S7Z4BPHohwhJQAtAKkItdJEqCTItdKlwLUAdAT8ArobBKAATwhbpEx4CBukTDgAdAg10rDAJrUAvALyFjPFszJ4HHXI8gBzxb0AMmACASAODwIBIBQVARW77ZbVA0cFUg2zyCoCAUgQEQIBIBITAXOxHXQgwjXGCD5AQHTB4IB1MTtQ9hTIHj0Dm+h8p/XC/9eMfkQ8qCuAfQEIW6TW3Ey4PkBWNs8AaQBgJwA9rtqA6ADoAPoCAXoCEfyAgPyA3XlP+AXkegAA54tkwAAXrhlXP8EA1WZ2oexAAgEgFhcCASAYGQFRtyVbZ4YmRmpGEAgegc30McJNhFpAADMaYeYuAFrgJhwLb+4cC3d0bhAjAYm1WZtnhqvgb+2xxsoicAgej430pBHEoFpAADHDhBACGuQkuuBk9kUWE5kAOeLKhACQCB6IYFImHFImHFImXEA2YlzNijAjAgEgGhsAF7UGtc4QQDVZnah7EAIBIBwdAgOZOB4fARGsGm2eL4G2CUAjABWt+UEAzJV2oewYQAENqTbPBVfBYCMAFa3f3CCAarM7UPYgAiDbPALyZfgAUENxQxPbPO1UIyoACtP/0wcwBKDbPC+uUyCw8mISsQKkJbNTHLmwJYEA4aojoCi8sPJpggGGoPgBBZcCERACPj4wjo0REB/bPEDXePRDEL0F4lQWW1Rz51YQU9zbPFRxClR6vCQlKCYAIO1E0NMf0wfTB9M/9AT0BNEAXgGOGjDSAAHyo9MH0wdQA9cBIPkBBfkBFbrypFAD4GwhIddKqgIi10m68qtwVCATAAwByMv/ywcE1ts87VT4D3AlblOJvrGYEG4QLVDHXwePGzBUJANQTds8UFWgRlAQSRA6SwlTuds8UFQWf+L4AAeDJaGOLCaAQPSWb6UglDBTA7neII4WODk5CNIAAZfTBzAW8AcFkTDifwgHBZJsMeKz5jAGKicoKQBgcI4pA9CDCNcY0wf0BDBTFnj0Dm+h8qXXC/9URUT5EPKmrlIgsVIDvRShI27mbCIyAH5SML6OIF8D+ACTItdKmALTB9QC+wAC6DJwyMoAQBSAQPRDAvAHjhdxyMsAFMsHEssHWM8BWM8WQBOAQPRDAeIBII6KEEUQNEMA2zztVJJfBuIqABzIyx/LB8sHyz/0APQAyQ==');
	let MultisigWallet$1 = class MultisigWallet {
	    constructor(publicKeys, workchain, walletId, k, opts) {
	        this.provider = null;
	        this.owners = core_1.Dictionary.empty();
	        this.workchain = workchain;
	        this.walletId = walletId;
	        this.k = k;
	        for (let i = 0; i < publicKeys.length; i += 1) {
	            this.owners.set(i, Buffer.concat([publicKeys[i], Buffer.alloc(1)]));
	        }
	        this.init = {
	            code: MULTISIG_CODE,
	            data: (0, core_1.beginCell)()
	                .storeUint(this.walletId, 32)
	                .storeUint(this.owners.size, 8)
	                .storeUint(this.k, 8)
	                .storeUint(0, 64)
	                .storeDict(this.owners, core_1.Dictionary.Keys.Uint(8), core_1.Dictionary.Values.Buffer(33))
	                .storeBit(0)
	                .endCell(),
	        };
	        this.address = opts?.address || (0, core_1.contractAddress)(workchain, this.init);
	        if (opts?.provider) {
	            this.provider = opts.provider;
	        }
	        else if (opts?.client) {
	            this.provider = opts.client.provider(this.address, {
	                code: this.init.code,
	                data: this.init.data,
	            });
	        }
	    }
	    static async fromAddress(address, opts) {
	        let provider;
	        if (opts.provider) {
	            provider = opts.provider;
	        }
	        else {
	            if (!opts.client) {
	                throw Error('Either provider or client must be specified');
	            }
	            provider = opts.client.provider(address, {
	                code: null,
	                data: null,
	            });
	        }
	        const contractState = (await provider.getState()).state;
	        if (contractState.type !== 'active') {
	            throw Error('Contract must be active');
	        }
	        const data = core_1.Cell.fromBoc(contractState.data)[0].beginParse();
	        const walletId = data.loadUint(32);
	        data.skip(8);
	        const k = data.loadUint(8);
	        data.skip(64);
	        const owners = data.loadDict(core_1.Dictionary.Keys.Uint(8), core_1.Dictionary.Values.Buffer(33));
	        let publicKeys = [];
	        for (const [key, value] of owners) {
	            const publicKey = value.subarray(0, 32);
	            publicKeys.push(publicKey);
	        }
	        return new MultisigWallet(publicKeys, address.workChain, walletId, k, {
	            address,
	            provider,
	            client: opts.client,
	        });
	    }
	    async deployExternal(provider) {
	        if (!provider && !this.provider) {
	            throw Error('you must specify provider if there is no such property in MultisigWallet instance');
	        }
	        if (!provider) {
	            provider = this.provider;
	        }
	        await provider.external(core_1.Cell.EMPTY);
	    }
	    async deployInternal(sender, value = 1000000000n) {
	        await sender.send({
	            sendMode: core_1.SendMode.PAY_GAS_SEPARATELY + core_1.SendMode.IGNORE_ERRORS,
	            to: this.address,
	            value: value,
	            init: this.init,
	            body: core_1.Cell.EMPTY,
	            bounce: true,
	        });
	    }
	    async sendOrder(order, secretKey, provider) {
	        if (!provider && !this.provider) {
	            throw Error('you must specify provider if there is no such property in MultisigWallet instance');
	        }
	        if (!provider) {
	            provider = this.provider;
	        }
	        let publicKey = (0, crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
	        let ownerId = this.getOwnerIdByPubkey(publicKey);
	        let cell = order.toCell(ownerId);
	        let signature = (0, crypto_1.sign)(cell.hash(), secretKey);
	        cell = (0, core_1.beginCell)()
	            .storeBuffer(signature)
	            .storeSlice(cell.asSlice())
	            .endCell();
	        await provider.external(cell);
	    }
	    async sendOrderWithoutSecretKey(order, signature, ownerId, provider) {
	        if (!provider && !this.provider) {
	            throw Error('you must specify provider if there is no such property in MultisigWallet instance');
	        }
	        if (!provider) {
	            provider = this.provider;
	        }
	        let cell = order.toCell(ownerId);
	        cell = (0, core_1.beginCell)()
	            .storeBuffer(signature)
	            .storeSlice(cell.asSlice())
	            .endCell();
	        await provider.external(cell);
	    }
	    getOwnerIdByPubkey(publicKey) {
	        for (const [key, value] of this.owners) {
	            if (value.subarray(0, 32).equals(publicKey)) {
	                return key;
	            }
	        }
	        throw Error('public key is not an owner');
	    }
	};
	MultisigWallet.MultisigWallet = MultisigWallet$1;
	return MultisigWallet;
}

var ElectorContract = {};

var hasRequiredElectorContract;

function requireElectorContract () {
	if (hasRequiredElectorContract) return ElectorContract;
	hasRequiredElectorContract = 1;
	Object.defineProperty(ElectorContract, "__esModule", { value: true });
	ElectorContract.ElectorContract = void 0;
	const core_1 = requireDist$2();
	const FrozenDictValue = {
	    serialize(src, builder) {
	        throw Error("not implemented");
	    },
	    parse(src) {
	        const address = new core_1.Address(-1, src.loadBuffer(32));
	        const weight = src.loadUintBig(64);
	        const stake = src.loadCoins();
	        return { address, weight, stake };
	    }
	};
	const EntitiesDictValue = {
	    serialize(src, builder) {
	        throw Error("not implemented");
	    },
	    parse(src) {
	        const stake = src.loadCoins();
	        // skip time and maxFactor
	        src.skip(64);
	        const address = new core_1.Address(-1, src.loadBuffer(32));
	        const adnl = src.loadBuffer(32);
	        return { stake, address, adnl };
	    }
	};
	let ElectorContract$1 = class ElectorContract {
	    //readonly source: ContractSource = new UnknownContractSource('org.ton.elector', -1, 'Elector Contract');
	    static create() {
	        return new ElectorContract();
	    }
	    constructor() {
	        // Please note that we are NOT loading address from config to avoid mistake and send validator money to a wrong contract
	        this.address = core_1.Address.parseRaw('-1:3333333333333333333333333333333333333333333333333333333333333333');
	    }
	    async getReturnedStake(provider, address) {
	        if (address.workChain !== -1) {
	            throw Error('Only masterchain addresses could have stake');
	        }
	        const res = await provider.get('compute_returned_stake', [{ type: 'int', value: BigInt('0x' + address.hash.toString('hex')) }]);
	        return res.stack.readBigNumber();
	    }
	    async getPastElectionsList(provider) {
	        const res = await provider.get('past_elections_list', []);
	        const electionsListRaw = new core_1.TupleReader(res.stack.readLispList());
	        const elections = [];
	        while (electionsListRaw.remaining > 0) {
	            const electionsListEntry = electionsListRaw.readTuple();
	            const id = electionsListEntry.readNumber();
	            const unfreezeAt = electionsListEntry.readNumber();
	            electionsListEntry.pop(); // Ignore vset_hash
	            const stakeHeld = electionsListEntry.readNumber();
	            elections.push({ id, unfreezeAt, stakeHeld });
	        }
	        return elections;
	    }
	    async getPastElections(provider) {
	        const res = await provider.get('past_elections', []);
	        const electionsRaw = new core_1.TupleReader(res.stack.readLispList());
	        const elections = [];
	        while (electionsRaw.remaining > 0) {
	            const electionsEntry = electionsRaw.readTuple();
	            const id = electionsEntry.readNumber();
	            const unfreezeAt = electionsEntry.readNumber();
	            const stakeHeld = electionsEntry.readNumber();
	            electionsEntry.pop(); // Ignore vset_hash
	            const frozenDict = electionsEntry.readCell();
	            const totalStake = electionsEntry.readBigNumber();
	            const bonuses = electionsEntry.readBigNumber();
	            let frozen = new Map();
	            const frozenData = frozenDict.beginParse().loadDictDirect(core_1.Dictionary.Keys.Buffer(32), FrozenDictValue);
	            for (const [key, value] of frozenData) {
	                frozen.set(BigInt("0x" + key.toString("hex")).toString(10), { address: value["address"], weight: value["weight"], stake: value["stake"] });
	            }
	            elections.push({ id, unfreezeAt, stakeHeld, totalStake, bonuses, frozen });
	        }
	        return elections;
	    }
	    async getElectionEntities(provider) {
	        //
	        // NOTE: this method doesn't call get method since for some reason it doesn't work
	        //
	        const account = await provider.getState();
	        if (account.state.type !== 'active') {
	            throw Error('Unexpected error');
	        }
	        const cell = core_1.Cell.fromBoc(account.state.data)[0];
	        const cs = cell.beginParse();
	        if (!cs.loadBit()) {
	            return null;
	        }
	        // (es~load_uint(32), es~load_uint(32), es~load_grams(), es~load_grams(), es~load_dict(), es~load_int(1), es~load_int(1));
	        const sc = cs.loadRef().beginParse();
	        const startWorkTime = sc.loadUint(32);
	        const endElectionsTime = sc.loadUint(32);
	        const minStake = sc.loadCoins();
	        const allStakes = sc.loadCoins();
	        // var (stake, time, max_factor, addr, adnl_addr) = (cs~load_grams(), cs~load_uint(32), cs~load_uint(32), cs~load_uint(256), cs~load_uint(256));
	        const entitiesData = sc.loadDict(core_1.Dictionary.Keys.Buffer(32), EntitiesDictValue);
	        let entities = [];
	        // const failed = sc.loadBit();
	        // const finished = sc.loadBit();
	        if (entitiesData) {
	            for (const [key, value] of entitiesData) {
	                entities.push({ pubkey: key, stake: value["stake"], address: value["address"], adnl: value["adnl"] });
	            }
	        }
	        return { minStake, allStakes, endElectionsTime, startWorkTime, entities };
	    }
	    // possible code for fetching data via get method if it is possible to set gas limit by request
	    // async getElectionEntities(block: number) {
	    //     const res = await this.client.runMethod(block, this.address, 'participant_list_extended');
	    //     if (res.exitCode !== 0 && res.exitCode !== 1) {
	    //         throw Error('Exit code: ' + res.exitCode);
	    //     }
	    //     let tuple = new TupleReader(res.result);
	    //     const startWorkTime = tuple.readNumber();
	    //     const endElectionsTime = tuple.readNumber();
	    //     const minStake = tuple.readBigNumber();
	    //     const allStakes = tuple.readBigNumber();
	    //     let entriesTuple = tuple.readTuple();
	    //     const entriesRaw = new TupleReader(entriesTuple.readLispList());
	    //     let entities: { pubkey: Buffer, stake: bigint, address: Address, adnl: Buffer }[] = [];
	    //     while (entriesRaw.remaining > 0) {
	    //         const electionsEntry = entriesRaw.readTuple();
	    //         const pubkey = electionsEntry.readBuffer();
	    //         const stake = electionsEntry.readBigNumber();
	    //         const address = electionsEntry.readAddress();
	    //         const adnl = electionsEntry.readBuffer();
	    //         entities.push({ pubkey, stake, address, adnl });
	    //     }
	    //     return { minStake, allStakes, endElectionsTime, startWorkTime, entities };
	    // }
	    async getActiveElectionId(provider) {
	        const res = await provider.get('active_election_id', []);
	        const electionId = res.stack.readNumber();
	        return electionId > 0 ? electionId : null;
	    }
	    async getComplaints(provider, electionId) {
	        const b = new core_1.TupleBuilder();
	        b.writeNumber(electionId);
	        const res = await provider.get('list_complaints', b.build());
	        if (res.stack.peek().type === 'null') {
	            return [];
	        }
	        //let tuple = new TupleReader(res.result);
	        const complaintsRaw = new core_1.TupleReader(res.stack.readLispList());
	        const results = [];
	        while (complaintsRaw.remaining > 0) {
	            const complaintsEntry = complaintsRaw.readTuple();
	            const id = complaintsEntry.readBigNumber();
	            const completeUnpackedComplaint = complaintsEntry.readTuple();
	            const unpackedComplaints = completeUnpackedComplaint.readTuple();
	            const publicKey = Buffer.from(unpackedComplaints.readBigNumber().toString(16), 'hex');
	            // prod_info#34 utime:uint32 mc_blk_ref:ExtBlkRef state_proof:^(MERKLE_PROOF Block)
	            // prod_proof:^(MERKLE_PROOF ShardState) = ProducerInfo;
	            // no_blk_gen from_utime:uint32 prod_info:^ProducerInfo = ComplaintDescr;
	            // no_blk_gen_diff prod_info_old:^ProducerInfo prod_info_new:^ProducerInfo = ComplaintDescr;
	            unpackedComplaints.readCell();
	            const createdAt = unpackedComplaints.readNumber();
	            const severity = unpackedComplaints.readNumber();
	            const rewardAddress = new core_1.Address(-1, Buffer.from(unpackedComplaints.readBigNumber().toString(16), 'hex'));
	            const paid = unpackedComplaints.readBigNumber();
	            const suggestedFine = unpackedComplaints.readBigNumber();
	            const suggestedFinePart = unpackedComplaints.readBigNumber();
	            const votes = [];
	            const votersListRaw = new core_1.TupleReader(completeUnpackedComplaint.readLispList());
	            while (votersListRaw.remaining > 0) {
	                votes.push(votersListRaw.readNumber());
	            }
	            const vsetId = completeUnpackedComplaint.readBigNumber();
	            const remainingWeight = completeUnpackedComplaint.readBigNumber();
	            results.push({
	                id,
	                publicKey,
	                createdAt,
	                severity,
	                paid,
	                suggestedFine,
	                suggestedFinePart,
	                rewardAddress,
	                votes,
	                remainingWeight,
	                vsetId
	            });
	        }
	        return results;
	    }
	};
	ElectorContract.ElectorContract = ElectorContract$1;
	return ElectorContract;
}

var ConfigParser = {};

var hasRequiredConfigParser;

function requireConfigParser () {
	if (hasRequiredConfigParser) return ConfigParser;
	hasRequiredConfigParser = 1;
	Object.defineProperty(ConfigParser, "__esModule", { value: true });
	ConfigParser.configParseMasterAddress = configParseMasterAddress;
	ConfigParser.parseValidatorSet = parseValidatorSet;
	ConfigParser.parseBridge = parseBridge;
	ConfigParser.configParseMasterAddressRequired = configParseMasterAddressRequired;
	ConfigParser.configParse5 = configParse5;
	ConfigParser.configParse13 = configParse13;
	ConfigParser.configParse15 = configParse15;
	ConfigParser.configParse16 = configParse16;
	ConfigParser.configParse17 = configParse17;
	ConfigParser.configParse18 = configParse18;
	ConfigParser.configParse8 = configParse8;
	ConfigParser.configParse40 = configParse40;
	ConfigParser.configParseWorkchainDescriptor = configParseWorkchainDescriptor;
	ConfigParser.configParse12 = configParse12;
	ConfigParser.configParseValidatorSet = configParseValidatorSet;
	ConfigParser.configParseBridge = configParseBridge;
	ConfigParser.configParseGasLimitsPrices = configParseGasLimitsPrices;
	ConfigParser.configParseMsgPrices = configParseMsgPrices;
	ConfigParser.configParse28 = configParse28;
	ConfigParser.configParse29 = configParse29;
	ConfigParser.parseProposalSetup = parseProposalSetup;
	ConfigParser.parseVotingSetup = parseVotingSetup;
	ConfigParser.loadConfigParamById = loadConfigParamById;
	ConfigParser.loadConfigParamsAsSlice = loadConfigParamsAsSlice;
	ConfigParser.parseFullConfig = parseFullConfig;
	const core_1 = requireDist$2();
	function configParseMasterAddress(slice) {
	  if (slice) {
	    return new core_1.Address(-1, slice.loadBuffer(32));
	  } else {
	    return null;
	  }
	}
	function readPublicKey(slice) {
	  if (slice.loadUint(32) !== 2390828938) {
	    throw Error("Invalid config");
	  }
	  return slice.loadBuffer(32);
	}
	const ValidatorDescriptionDictValue = {
	  serialize(src, builder) {
	    throw Error("not implemented");
	  },
	  parse(src) {
	    const header = src.loadUint(8);
	    if (header === 83) {
	      return {
	        publicKey: readPublicKey(src),
	        weight: src.loadUintBig(64),
	        adnlAddress: null
	      };
	    } else if (header === 115) {
	      return {
	        publicKey: readPublicKey(src),
	        weight: src.loadUintBig(64),
	        adnlAddress: src.loadBuffer(32)
	      };
	    } else {
	      throw Error("Invalid config");
	    }
	  }
	};
	function parseValidatorSet(slice) {
	  const header = slice.loadUint(8);
	  if (header === 17) {
	    const timeSince = slice.loadUint(32);
	    const timeUntil = slice.loadUint(32);
	    const total = slice.loadUint(16);
	    const main = slice.loadUint(16);
	    const list = slice.loadDictDirect(core_1.Dictionary.Keys.Uint(16), ValidatorDescriptionDictValue);
	    return {
	      timeSince,
	      timeUntil,
	      total,
	      main,
	      totalWeight: null,
	      list
	    };
	  } else if (header === 18) {
	    const timeSince = slice.loadUint(32);
	    const timeUntil = slice.loadUint(32);
	    const total = slice.loadUint(16);
	    const main = slice.loadUint(16);
	    const totalWeight = slice.loadUintBig(64);
	    const list = slice.loadDict(core_1.Dictionary.Keys.Uint(16), ValidatorDescriptionDictValue);
	    return {
	      timeSince,
	      timeUntil,
	      total,
	      main,
	      totalWeight,
	      list
	    };
	  }
	}
	function parseBridge(slice) {
	  const bridgeAddress = new core_1.Address(-1, slice.loadBuffer(32));
	  const oracleMultisigAddress = new core_1.Address(-1, slice.loadBuffer(32));
	  const oraclesDict = slice.loadDict(core_1.Dictionary.Keys.Buffer(32), core_1.Dictionary.Values.Buffer(32));
	  const oracles = /* @__PURE__ */ new Map();
	  for (const [local, remote] of oraclesDict) {
	    oracles.set(new core_1.Address(-1, local).toString(), remote);
	  }
	  const externalChainAddress = slice.loadBuffer(32);
	  return {
	    bridgeAddress,
	    oracleMultisigAddress,
	    oracles,
	    externalChainAddress
	  };
	}
	function configParseMasterAddressRequired(slice) {
	  if (!slice) {
	    throw Error("Invalid config");
	  }
	  return configParseMasterAddress(slice);
	}
	function configParse5(slice) {
	  if (!slice) {
	    throw Error("Invalid config");
	  }
	  const magic = slice.loadUint(8);
	  if (magic === 1) {
	    const blackholeAddr = slice.loadBit() ? new core_1.Address(-1, slice.loadBuffer(32)) : null;
	    const feeBurnNominator = slice.loadUint(32);
	    const feeBurnDenominator = slice.loadUint(32);
	    return {
	      blackholeAddr,
	      feeBurnNominator,
	      feeBurnDenominator
	    };
	  }
	  throw new Error("Invalid config");
	}
	function configParse13(slice) {
	  if (!slice) {
	    throw Error("Invalid config");
	  }
	  const magic = slice.loadUint(8);
	  if (magic === 26) {
	    const deposit = slice.loadCoins();
	    const bitPrice = slice.loadCoins();
	    const cellPrice = slice.loadCoins();
	    return {
	      deposit,
	      bitPrice,
	      cellPrice
	    };
	  }
	  throw new Error("Invalid config");
	}
	function configParse15(slice) {
	  if (!slice) {
	    throw Error("Invalid config");
	  }
	  const validatorsElectedFor = slice.loadUint(32);
	  const electorsStartBefore = slice.loadUint(32);
	  const electorsEndBefore = slice.loadUint(32);
	  const stakeHeldFor = slice.loadUint(32);
	  return {
	    validatorsElectedFor,
	    electorsStartBefore,
	    electorsEndBefore,
	    stakeHeldFor
	  };
	}
	function configParse16(slice) {
	  if (!slice) {
	    throw Error("Invalid config");
	  }
	  const maxValidators = slice.loadUint(16);
	  const maxMainValidators = slice.loadUint(16);
	  const minValidators = slice.loadUint(16);
	  return {
	    maxValidators,
	    maxMainValidators,
	    minValidators
	  };
	}
	function configParse17(slice) {
	  if (!slice) {
	    throw Error("Invalid config");
	  }
	  const minStake = slice.loadCoins();
	  const maxStake = slice.loadCoins();
	  const minTotalStake = slice.loadCoins();
	  const maxStakeFactor = slice.loadUint(32);
	  return {
	    minStake,
	    maxStake,
	    minTotalStake,
	    maxStakeFactor
	  };
	}
	const StoragePricesDictValue = {
	  serialize(src, builder) {
	    throw Error("not implemented");
	  },
	  parse(src) {
	    const header = src.loadUint(8);
	    if (header !== 204) {
	      throw Error("Invalid config");
	    }
	    const utime_since = src.loadUint(32);
	    const bit_price_ps = src.loadUintBig(64);
	    const cell_price_ps = src.loadUintBig(64);
	    const mc_bit_price_ps = src.loadUintBig(64);
	    const mc_cell_price_ps = src.loadUintBig(64);
	    return {
	      utime_since,
	      bit_price_ps,
	      cell_price_ps,
	      mc_bit_price_ps,
	      mc_cell_price_ps
	    };
	  }
	};
	function configParse18(slice) {
	  if (!slice) {
	    throw Error("Invalid config");
	  }
	  return slice.loadDictDirect(core_1.Dictionary.Keys.Buffer(4), StoragePricesDictValue).values();
	}
	function configParse8(slice) {
	  if (!slice) {
	    return {
	      version: 0,
	      capabilities: 0n
	    };
	  }
	  const version = slice.loadUint(32);
	  const capabilities = slice.loadUintBig(64);
	  return {
	    version,
	    capabilities
	  };
	}
	function configParse40(slice) {
	  if (!slice) {
	    return null;
	  }
	  const header = slice.loadUint(8);
	  if (header !== 1) {
	    throw Error("Invalid config");
	  }
	  const defaultFlatFine = slice.loadCoins();
	  const defaultProportionaFine = slice.loadCoins();
	  const severityFlatMult = slice.loadUint(16);
	  const severityProportionalMult = slice.loadUint(16);
	  const unfunishableInterval = slice.loadUint(16);
	  const longInterval = slice.loadUint(16);
	  const longFlatMult = slice.loadUint(16);
	  const longProportionalMult = slice.loadUint(16);
	  const mediumInterval = slice.loadUint(16);
	  const mediumFlatMult = slice.loadUint(16);
	  const mediumProportionalMult = slice.loadUint(16);
	  return {
	    defaultFlatFine,
	    defaultProportionaFine,
	    severityFlatMult,
	    severityProportionalMult,
	    unfunishableInterval,
	    longInterval,
	    longFlatMult,
	    longProportionalMult,
	    mediumInterval,
	    mediumFlatMult,
	    mediumProportionalMult
	  };
	}
	function configParseWorkchainDescriptor(slice) {
	  const constructorTag = slice.loadUint(8);
	  if (!(constructorTag == 166 || constructorTag == 167)) {
	    throw Error("Invalid config");
	  }
	  const enabledSince = slice.loadUint(32);
	  const actialMinSplit = slice.loadUint(8);
	  const min_split = slice.loadUint(8);
	  const max_split = slice.loadUint(8);
	  const basic = slice.loadBit();
	  const active = slice.loadBit();
	  const accept_msgs = slice.loadBit();
	  const flags = slice.loadUint(13);
	  const zerostateRootHash = slice.loadBuffer(32);
	  const zerostateFileHash = slice.loadBuffer(32);
	  const version = slice.loadUint(32);
	  if (!slice.loadUint(4)) {
	    throw Error("Invalid config");
	  }
	  const vmVersion = slice.loadInt(32);
	  const vmMode = slice.loadUintBig(64);
	  let extension = void 0;
	  if (constructorTag == 167) {
	    const splitMergeTimings = parseWorkchainSplitMergeTimings(slice);
	    const stateSplitDepth = slice.loadUint(8);
	    if (stateSplitDepth > 63) {
	      throw RangeError(`Invalid persistent_state_split_depth: ${stateSplitDepth} expected <= 63`);
	    }
	    extension = {
	      split_merge_timings: splitMergeTimings,
	      persistent_state_split_depth: stateSplitDepth
	    };
	  }
	  return {
	    enabledSince,
	    actialMinSplit,
	    min_split,
	    max_split,
	    basic,
	    active,
	    accept_msgs,
	    flags,
	    zerostateRootHash,
	    zerostateFileHash,
	    version,
	    format: {
	      vmVersion,
	      vmMode
	    },
	    workchain_v2: extension
	  };
	}
	function parseWorkchainSplitMergeTimings(slice) {
	  if (slice.loadUint(4) !== 0) {
	    throw Error(`Invalid WcSplitMergeTimings tag expected 0!`);
	  }
	  return {
	    split_merge_delay: slice.loadUint(32),
	    split_merge_interval: slice.loadUint(32),
	    min_split_merge_interval: slice.loadUint(32),
	    max_split_merge_delay: slice.loadUint(32)
	  };
	}
	const WorkchainDescriptorDictValue = {
	  serialize(src, builder) {
	    throw Error("not implemented");
	  },
	  parse(src) {
	    return configParseWorkchainDescriptor(src);
	  }
	};
	function configParse12(slice) {
	  if (!slice) {
	    throw Error("Invalid config");
	  }
	  const wd = slice.loadDict(core_1.Dictionary.Keys.Uint(32), WorkchainDescriptorDictValue);
	  if (wd) {
	    return wd;
	  }
	  throw Error("No workchains exist");
	}
	function configParseValidatorSet(slice) {
	  if (!slice) {
	    return null;
	  }
	  return parseValidatorSet(slice);
	}
	function configParseBridge(slice) {
	  if (!slice) {
	    return null;
	  }
	  return parseBridge(slice);
	}
	function parseGasLimitsInternal(slice) {
	  const tag = slice.loadUint(8);
	  if (tag === 222) {
	    const gasPrice = slice.loadUintBig(64);
	    const gasLimit = slice.loadUintBig(64);
	    const specialGasLimit = slice.loadUintBig(64);
	    const gasCredit = slice.loadUintBig(64);
	    const blockGasLimit = slice.loadUintBig(64);
	    const freezeDueLimit = slice.loadUintBig(64);
	    const deleteDueLimit = slice.loadUintBig(64);
	    return {
	      gasPrice,
	      gasLimit,
	      specialGasLimit,
	      gasCredit,
	      blockGasLimit,
	      freezeDueLimit,
	      deleteDueLimit
	    };
	  } else if (tag === 221) {
	    const gasPrice = slice.loadUintBig(64);
	    const gasLimit = slice.loadUintBig(64);
	    const gasCredit = slice.loadUintBig(64);
	    const blockGasLimit = slice.loadUintBig(64);
	    const freezeDueLimit = slice.loadUintBig(64);
	    const deleteDueLimit = slice.loadUintBig(64);
	    return {
	      gasPrice,
	      gasLimit,
	      gasCredit,
	      blockGasLimit,
	      freezeDueLimit,
	      deleteDueLimit
	    };
	  } else {
	    throw Error("Invalid config");
	  }
	}
	function configParseGasLimitsPrices(slice) {
	  if (!slice) {
	    throw Error("Invalid config");
	  }
	  const tag = slice.loadUint(8);
	  if (tag === 209) {
	    const flatLimit = slice.loadUintBig(64);
	    const flatGasPrice = slice.loadUintBig(64);
	    const other = parseGasLimitsInternal(slice);
	    return {
	      flatLimit,
	      flatGasPrice,
	      other
	    };
	  } else {
	    throw Error("Invalid config");
	  }
	}
	function configParseMsgPrices(slice) {
	  if (!slice) {
	    throw new Error("Invalid config");
	  }
	  const magic = slice.loadUint(8);
	  if (magic !== 234) {
	    throw new Error("Invalid msg prices param");
	  }
	  return {
	    lumpPrice: slice.loadUintBig(64),
	    bitPrice: slice.loadUintBig(64),
	    cellPrice: slice.loadUintBig(64),
	    ihrPriceFactor: slice.loadUint(32),
	    firstFrac: slice.loadUint(16),
	    nextFrac: slice.loadUint(16)
	  };
	}
	function configParse28(slice) {
	  if (!slice) {
	    throw new Error("Invalid config");
	  }
	  const magic = slice.loadUint(8);
	  if (magic === 193) {
	    const masterCatchainLifetime = slice.loadUint(32);
	    const shardCatchainLifetime = slice.loadUint(32);
	    const shardValidatorsLifetime = slice.loadUint(32);
	    const shardValidatorsCount = slice.loadUint(32);
	    return {
	      masterCatchainLifetime,
	      shardCatchainLifetime,
	      shardValidatorsLifetime,
	      shardValidatorsCount
	    };
	  }
	  if (magic === 194) {
	    const flags = slice.loadUint(7);
	    const suffleMasterValidators = slice.loadBit();
	    const masterCatchainLifetime = slice.loadUint(32);
	    const shardCatchainLifetime = slice.loadUint(32);
	    const shardValidatorsLifetime = slice.loadUint(32);
	    const shardValidatorsCount = slice.loadUint(32);
	    return {
	      flags,
	      suffleMasterValidators,
	      masterCatchainLifetime,
	      shardCatchainLifetime,
	      shardValidatorsLifetime,
	      shardValidatorsCount
	    };
	  }
	  throw new Error("Invalid config");
	}
	function configParse29(slice) {
	  if (!slice) {
	    throw new Error("Invalid config");
	  }
	  const magic = slice.loadUint(8);
	  if (magic === 214) {
	    const roundCandidates = slice.loadUint(32);
	    const nextCandidateDelay = slice.loadUint(32);
	    const consensusTimeout = slice.loadUint(32);
	    const fastAttempts = slice.loadUint(32);
	    const attemptDuration = slice.loadUint(32);
	    const catchainMaxDeps = slice.loadUint(32);
	    const maxBlockBytes = slice.loadUint(32);
	    const maxColaltedBytes = slice.loadUint(32);
	    return {
	      roundCandidates,
	      nextCandidateDelay,
	      consensusTimeout,
	      fastAttempts,
	      attemptDuration,
	      catchainMaxDeps,
	      maxBlockBytes,
	      maxColaltedBytes
	    };
	  } else if (magic === 215) {
	    const flags = slice.loadUint(7);
	    const newCatchainIds = slice.loadBit();
	    const roundCandidates = slice.loadUint(8);
	    const nextCandidateDelay = slice.loadUint(32);
	    const consensusTimeout = slice.loadUint(32);
	    const fastAttempts = slice.loadUint(32);
	    const attemptDuration = slice.loadUint(32);
	    const catchainMaxDeps = slice.loadUint(32);
	    const maxBlockBytes = slice.loadUint(32);
	    const maxColaltedBytes = slice.loadUint(32);
	    return {
	      flags,
	      newCatchainIds,
	      roundCandidates,
	      nextCandidateDelay,
	      consensusTimeout,
	      fastAttempts,
	      attemptDuration,
	      catchainMaxDeps,
	      maxBlockBytes,
	      maxColaltedBytes
	    };
	  } else if (magic === 216) {
	    const flags = slice.loadUint(7);
	    const newCatchainIds = slice.loadBit();
	    const roundCandidates = slice.loadUint(8);
	    const nextCandidateDelay = slice.loadUint(32);
	    const consensusTimeout = slice.loadUint(32);
	    const fastAttempts = slice.loadUint(32);
	    const attemptDuration = slice.loadUint(32);
	    const catchainMaxDeps = slice.loadUint(32);
	    const maxBlockBytes = slice.loadUint(32);
	    const maxColaltedBytes = slice.loadUint(32);
	    const protoVersion = slice.loadUint(16);
	    return {
	      flags,
	      newCatchainIds,
	      roundCandidates,
	      nextCandidateDelay,
	      consensusTimeout,
	      fastAttempts,
	      attemptDuration,
	      catchainMaxDeps,
	      maxBlockBytes,
	      maxColaltedBytes,
	      protoVersion
	    };
	  } else if (magic === 217) {
	    const flags = slice.loadUint(7);
	    const newCatchainIds = slice.loadBit();
	    const roundCandidates = slice.loadUint(8);
	    const nextCandidateDelay = slice.loadUint(32);
	    const consensusTimeout = slice.loadUint(32);
	    const fastAttempts = slice.loadUint(32);
	    const attemptDuration = slice.loadUint(32);
	    const catchainMaxDeps = slice.loadUint(32);
	    const maxBlockBytes = slice.loadUint(32);
	    const maxColaltedBytes = slice.loadUint(32);
	    const protoVersion = slice.loadUint(16);
	    const catchainMaxBlocksCoeff = slice.loadUint(32);
	    return {
	      flags,
	      newCatchainIds,
	      roundCandidates,
	      nextCandidateDelay,
	      consensusTimeout,
	      fastAttempts,
	      attemptDuration,
	      catchainMaxDeps,
	      maxBlockBytes,
	      maxColaltedBytes,
	      protoVersion,
	      catchainMaxBlocksCoeff
	    };
	  }
	  throw new Error("Invalid config");
	}
	function parseProposalSetup(slice) {
	  const magic = slice.loadUint(8);
	  if (magic !== 54) {
	    throw new Error("Invalid config");
	  }
	  const minTotalRounds = slice.loadUint(8);
	  const maxTotalRounds = slice.loadUint(8);
	  const minWins = slice.loadUint(8);
	  const maxLoses = slice.loadUint(8);
	  const minStoreSec = slice.loadUint(32);
	  const maxStoreSec = slice.loadUint(32);
	  const bitPrice = slice.loadUint(32);
	  const cellPrice = slice.loadUint(32);
	  return { minTotalRounds, maxTotalRounds, minWins, maxLoses, minStoreSec, maxStoreSec, bitPrice, cellPrice };
	}
	function parseVotingSetup(slice) {
	  if (!slice) {
	    throw new Error("Invalid config");
	  }
	  const magic = slice.loadUint(8);
	  if (magic !== 145) {
	    throw new Error("Invalid config");
	  }
	  const normalParams = parseProposalSetup(slice.loadRef().beginParse());
	  const criticalParams = parseProposalSetup(slice.loadRef().beginParse());
	  return { normalParams, criticalParams };
	}
	function loadConfigParams(configBase64) {
	  const comfigMap = core_1.Cell.fromBase64(configBase64).beginParse().loadDictDirect(core_1.Dictionary.Keys.Int(32), core_1.Dictionary.Values.Cell());
	  return comfigMap;
	}
	function loadConfigParamById(configBase64, id) {
	  return loadConfigParams(configBase64).get(id);
	}
	function loadConfigParamsAsSlice(configBase64) {
	  const pramsAsCells = loadConfigParams(configBase64);
	  const params = /* @__PURE__ */ new Map();
	  for (const [key, value] of pramsAsCells) {
	    params.set(key, value.beginParse());
	  }
	  return params;
	}
	function parseFullConfig(configs) {
	  return {
	    configAddress: configParseMasterAddressRequired(configs.get(0)),
	    electorAddress: configParseMasterAddressRequired(configs.get(1)),
	    minterAddress: configParseMasterAddress(configs.get(2)),
	    feeCollectorAddress: configParseMasterAddress(configs.get(3)),
	    dnsRootAddress: configParseMasterAddress(configs.get(4)),
	    burningConfig: configParse5(configs.get(5)),
	    globalVersion: configParse8(configs.get(8)),
	    workchains: configParse12(configs.get(12)),
	    voting: parseVotingSetup(configs.get(11)),
	    validators: {
	      ...configParse15(configs.get(15)),
	      ...configParse16(configs.get(16)),
	      ...configParse17(configs.get(17))
	    },
	    storagePrices: configParse18(configs.get(18)),
	    gasPrices: {
	      masterchain: configParseGasLimitsPrices(configs.get(20)),
	      workchain: configParseGasLimitsPrices(configs.get(21))
	    },
	    msgPrices: {
	      masterchain: configParseMsgPrices(configs.get(24)),
	      workchain: configParseMsgPrices(configs.get(25))
	    },
	    validatorSets: {
	      prevValidators: configParseValidatorSet(configs.get(32)),
	      prevTempValidators: configParseValidatorSet(configs.get(33)),
	      currentValidators: configParseValidatorSet(configs.get(34)),
	      currentTempValidators: configParseValidatorSet(configs.get(35)),
	      nextValidators: configParseValidatorSet(configs.get(36)),
	      nextTempValidators: configParseValidatorSet(configs.get(37))
	    },
	    validatorsPunish: configParse40(configs.get(40)),
	    bridges: {
	      ethereum: configParseBridge(configs.get(71)),
	      binance: configParseBridge(configs.get(72)),
	      polygon: configParseBridge(configs.get(73))
	    },
	    catchain: configParse28(configs.get(28)),
	    consensus: configParse29(configs.get(29))
	    // TODO: mint_new_price:Grams mint_add_price:Grams = ConfigParam 6;
	    // TODO: to_mint:ExtraCurrencyCollection = ConfigParam 7
	    // TODO: mandatory_params:(Hashmap 32 True) = ConfigParam 9
	    // TODO: critical_params:(Hashmap 32 True) = ConfigParam 10
	    // TODO: BlockCreateFees = ConfigParam 14
	  };
	}
	return ConfigParser;
}

var fees = {};

var hasRequiredFees;

function requireFees () {
	if (hasRequiredFees) return fees;
	hasRequiredFees = 1;
	Object.defineProperty(fees, "__esModule", { value: true });
	fees.computeStorageFees = computeStorageFees;
	fees.computeFwdFees = computeFwdFees;
	fees.computeGasPrices = computeGasPrices;
	fees.computeExternalMessageFees = computeExternalMessageFees;
	fees.computeMessageForwardFees = computeMessageForwardFees;
	const core_1 = requireDist$2();
	//
	// Source: https://github.com/ton-foundation/ton/blob/ae5c0720143e231c32c3d2034cfe4e533a16d969/crypto/block/transaction.cpp#L425
	//
	function computeStorageFees(data) {
	    const { lastPaid, now, storagePrices, storageStat, special, masterchain } = data;
	    if (now <= lastPaid || storagePrices.length === 0 || now < storagePrices[0].utime_since || special) {
	        return BigInt(0);
	    }
	    let upto = Math.max(lastPaid, storagePrices[0].utime_since);
	    let total = BigInt(0);
	    for (let i = 0; i < storagePrices.length && upto < now; i++) {
	        let valid_until = (i < storagePrices.length - 1 ? Math.min(now, storagePrices[i + 1].utime_since) : now);
	        let payment = BigInt(0);
	        if (upto < valid_until) {
	            let delta = valid_until - upto;
	            payment += (BigInt(storageStat.cells) * (masterchain ? storagePrices[i].mc_cell_price_ps : storagePrices[i].cell_price_ps));
	            payment += (BigInt(storageStat.bits) * (masterchain ? storagePrices[i].mc_bit_price_ps : storagePrices[i].bit_price_ps));
	            payment = payment * BigInt(delta);
	        }
	        upto = valid_until;
	        total += payment;
	    }
	    return shr16ceil(total);
	}
	//
	// Source: https://github.com/ton-foundation/ton/blob/ae5c0720143e231c32c3d2034cfe4e533a16d969/crypto/block/transaction.cpp#L1218
	//
	function computeFwdFees(msgPrices, cells, bits) {
	    return msgPrices.lumpPrice + (shr16ceil(msgPrices.bitPrice * bits + (msgPrices.cellPrice * cells)));
	}
	//
	// Source: https://github.com/ton-foundation/ton/blob/ae5c0720143e231c32c3d2034cfe4e533a16d969/crypto/block/transaction.cpp#L761
	//
	function computeGasPrices(gasUsed, prices) {
	    if (gasUsed <= prices.flatLimit) {
	        return prices.flatPrice;
	    }
	    else {
	        //  td::rshift(gas_price256 * (gas_used - cfg.flat_gas_limit), 16, 1) + cfg.flat_gas_price
	        return prices.flatPrice + ((prices.price * (gasUsed - prices.flatLimit)) >> 16n);
	    }
	}
	//
	// Source: https://github.com/ton-foundation/ton/blob/ae5c0720143e231c32c3d2034cfe4e533a16d969/crypto/block/transaction.cpp#L530
	//
	function computeExternalMessageFees(msgPrices, cell) {
	    // Collect stats
	    let storageStats = collectCellStats(cell);
	    storageStats.bits -= cell.bits.length;
	    storageStats.cells -= 1;
	    return computeFwdFees(msgPrices, BigInt(storageStats.cells), BigInt(storageStats.bits));
	}
	function computeMessageForwardFees(msgPrices, cell) {
	    let msg = (0, core_1.loadMessageRelaxed)(cell.beginParse());
	    let storageStats = { bits: 0, cells: 0 };
	    // Init
	    if (msg.init) {
	        const rawBuilder = new core_1.Cell().asBuilder();
	        (0, core_1.storeStateInit)(msg.init)(rawBuilder);
	        const raw = rawBuilder.endCell();
	        let c = collectCellStats(raw);
	        c.bits -= raw.bits.length;
	        c.cells -= 1;
	        storageStats.bits += c.bits;
	        storageStats.cells += c.cells;
	    }
	    // Body
	    let bc = collectCellStats(msg.body);
	    bc.bits -= msg.body.bits.length;
	    bc.cells -= 1;
	    storageStats.bits += bc.bits;
	    storageStats.cells += bc.cells;
	    // NOTE: Extra currencies are ignored for now
	    let fees = computeFwdFees(msgPrices, BigInt(storageStats.cells), BigInt(storageStats.bits));
	    let res = (fees * BigInt(msgPrices.firstFrac)) >> 16n;
	    let remaining = fees - res;
	    return { fees: res, remaining };
	}
	function collectCellStats(cell) {
	    let bits = cell.bits.length;
	    let cells = 1;
	    for (let ref of cell.refs) {
	        let r = collectCellStats(ref);
	        cells += r.cells;
	        bits += r.bits;
	    }
	    return { bits, cells };
	}
	function shr16ceil(src) {
	    let rem = src % 65536n;
	    let res = src >> 16n;
	    if (rem !== 0n) {
	        res += 1n;
	    }
	    return res;
	}
	return fees;
}

var hasRequiredDist$1;

function requireDist$1 () {
	if (hasRequiredDist$1) return dist$3;
	hasRequiredDist$1 = 1;
	(function (exports) {
		/**
		 * Copyright (c) Whales Corp.
		 * All Rights Reserved.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 */
		var __createBinding = (dist$3 && dist$3.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (dist$3 && dist$3.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.computeStorageFees = exports.computeMessageForwardFees = exports.computeGasPrices = exports.computeFwdFees = exports.computeExternalMessageFees = exports.loadConfigParamsAsSlice = exports.loadConfigParamById = exports.parseFullConfig = exports.parseVotingSetup = exports.parseValidatorSet = exports.parseProposalSetup = exports.parseBridge = exports.configParseWorkchainDescriptor = exports.configParseValidatorSet = exports.configParseMsgPrices = exports.configParseMasterAddressRequired = exports.configParseMasterAddress = exports.configParseGasLimitsPrices = exports.configParseBridge = exports.configParse40 = exports.configParse29 = exports.configParse28 = exports.configParse18 = exports.configParse17 = exports.configParse16 = exports.configParse15 = exports.configParse13 = exports.configParse12 = exports.configParse8 = exports.configParse5 = exports.ElectorContract = exports.MultisigWallet = exports.MultisigOrderBuilder = exports.MultisigOrder = exports.JettonWallet = exports.JettonMaster = exports.WalletContractV5R1 = exports.WalletContractV5Beta = exports.WalletContractV4 = exports.WalletContractV3R2 = exports.WalletContractV3R1 = exports.WalletContractV2R2 = exports.WalletContractV2R1 = exports.WalletContractV1R3 = exports.WalletContractV1R2 = exports.WalletContractV1R1 = exports.TonClient4 = exports.TonClient = exports.HttpApi = void 0;
		__exportStar(requireDist$2(), exports);
		//
		// toncenter Client
		//
		var HttpApi_1 = requireHttpApi();
		Object.defineProperty(exports, "HttpApi", { enumerable: true, get: function () { return HttpApi_1.HttpApi; } });
		var TonClient_1 = requireTonClient();
		Object.defineProperty(exports, "TonClient", { enumerable: true, get: function () { return TonClient_1.TonClient; } });
		//
		// API V4 Client
		//
		var TonClient4_1 = requireTonClient4();
		Object.defineProperty(exports, "TonClient4", { enumerable: true, get: function () { return TonClient4_1.TonClient4; } });
		//
		// Wallets
		//
		var WalletContractV1R1_1 = requireWalletContractV1R1();
		Object.defineProperty(exports, "WalletContractV1R1", { enumerable: true, get: function () { return WalletContractV1R1_1.WalletContractV1R1; } });
		var WalletContractV1R2_1 = requireWalletContractV1R2();
		Object.defineProperty(exports, "WalletContractV1R2", { enumerable: true, get: function () { return WalletContractV1R2_1.WalletContractV1R2; } });
		var WalletContractV1R3_1 = requireWalletContractV1R3();
		Object.defineProperty(exports, "WalletContractV1R3", { enumerable: true, get: function () { return WalletContractV1R3_1.WalletContractV1R3; } });
		var WalletContractV2R1_1 = requireWalletContractV2R1();
		Object.defineProperty(exports, "WalletContractV2R1", { enumerable: true, get: function () { return WalletContractV2R1_1.WalletContractV2R1; } });
		var WalletContractV2R2_1 = requireWalletContractV2R2();
		Object.defineProperty(exports, "WalletContractV2R2", { enumerable: true, get: function () { return WalletContractV2R2_1.WalletContractV2R2; } });
		var WalletContractV3R1_1 = requireWalletContractV3R1();
		Object.defineProperty(exports, "WalletContractV3R1", { enumerable: true, get: function () { return WalletContractV3R1_1.WalletContractV3R1; } });
		var WalletContractV3R2_1 = requireWalletContractV3R2();
		Object.defineProperty(exports, "WalletContractV3R2", { enumerable: true, get: function () { return WalletContractV3R2_1.WalletContractV3R2; } });
		var WalletContractV4_1 = requireWalletContractV4();
		Object.defineProperty(exports, "WalletContractV4", { enumerable: true, get: function () { return WalletContractV4_1.WalletContractV4; } });
		var WalletContractV5Beta_1 = requireWalletContractV5Beta();
		Object.defineProperty(exports, "WalletContractV5Beta", { enumerable: true, get: function () { return WalletContractV5Beta_1.WalletContractV5Beta; } });
		var WalletContractV5R1_1 = requireWalletContractV5R1();
		Object.defineProperty(exports, "WalletContractV5R1", { enumerable: true, get: function () { return WalletContractV5R1_1.WalletContractV5R1; } });
		//
		// Jettons
		//
		var JettonMaster_1 = requireJettonMaster();
		Object.defineProperty(exports, "JettonMaster", { enumerable: true, get: function () { return JettonMaster_1.JettonMaster; } });
		var JettonWallet_1 = requireJettonWallet();
		Object.defineProperty(exports, "JettonWallet", { enumerable: true, get: function () { return JettonWallet_1.JettonWallet; } });
		//
		// Multisig
		//
		var MultisigOrder_1 = requireMultisigOrder();
		Object.defineProperty(exports, "MultisigOrder", { enumerable: true, get: function () { return MultisigOrder_1.MultisigOrder; } });
		var MultisigOrderBuilder_1 = requireMultisigOrderBuilder();
		Object.defineProperty(exports, "MultisigOrderBuilder", { enumerable: true, get: function () { return MultisigOrderBuilder_1.MultisigOrderBuilder; } });
		var MultisigWallet_1 = requireMultisigWallet();
		Object.defineProperty(exports, "MultisigWallet", { enumerable: true, get: function () { return MultisigWallet_1.MultisigWallet; } });
		//
		// Elector
		//
		var ElectorContract_1 = requireElectorContract();
		Object.defineProperty(exports, "ElectorContract", { enumerable: true, get: function () { return ElectorContract_1.ElectorContract; } });
		//
		// Config
		//
		var ConfigParser_1 = requireConfigParser();
		Object.defineProperty(exports, "configParse5", { enumerable: true, get: function () { return ConfigParser_1.configParse5; } });
		Object.defineProperty(exports, "configParse8", { enumerable: true, get: function () { return ConfigParser_1.configParse8; } });
		Object.defineProperty(exports, "configParse12", { enumerable: true, get: function () { return ConfigParser_1.configParse12; } });
		Object.defineProperty(exports, "configParse13", { enumerable: true, get: function () { return ConfigParser_1.configParse13; } });
		Object.defineProperty(exports, "configParse15", { enumerable: true, get: function () { return ConfigParser_1.configParse15; } });
		Object.defineProperty(exports, "configParse16", { enumerable: true, get: function () { return ConfigParser_1.configParse16; } });
		Object.defineProperty(exports, "configParse17", { enumerable: true, get: function () { return ConfigParser_1.configParse17; } });
		Object.defineProperty(exports, "configParse18", { enumerable: true, get: function () { return ConfigParser_1.configParse18; } });
		Object.defineProperty(exports, "configParse28", { enumerable: true, get: function () { return ConfigParser_1.configParse28; } });
		Object.defineProperty(exports, "configParse29", { enumerable: true, get: function () { return ConfigParser_1.configParse29; } });
		Object.defineProperty(exports, "configParse40", { enumerable: true, get: function () { return ConfigParser_1.configParse40; } });
		Object.defineProperty(exports, "configParseBridge", { enumerable: true, get: function () { return ConfigParser_1.configParseBridge; } });
		Object.defineProperty(exports, "configParseGasLimitsPrices", { enumerable: true, get: function () { return ConfigParser_1.configParseGasLimitsPrices; } });
		Object.defineProperty(exports, "configParseMasterAddress", { enumerable: true, get: function () { return ConfigParser_1.configParseMasterAddress; } });
		Object.defineProperty(exports, "configParseMasterAddressRequired", { enumerable: true, get: function () { return ConfigParser_1.configParseMasterAddressRequired; } });
		Object.defineProperty(exports, "configParseMsgPrices", { enumerable: true, get: function () { return ConfigParser_1.configParseMsgPrices; } });
		Object.defineProperty(exports, "configParseValidatorSet", { enumerable: true, get: function () { return ConfigParser_1.configParseValidatorSet; } });
		Object.defineProperty(exports, "configParseWorkchainDescriptor", { enumerable: true, get: function () { return ConfigParser_1.configParseWorkchainDescriptor; } });
		Object.defineProperty(exports, "parseBridge", { enumerable: true, get: function () { return ConfigParser_1.parseBridge; } });
		Object.defineProperty(exports, "parseProposalSetup", { enumerable: true, get: function () { return ConfigParser_1.parseProposalSetup; } });
		Object.defineProperty(exports, "parseValidatorSet", { enumerable: true, get: function () { return ConfigParser_1.parseValidatorSet; } });
		Object.defineProperty(exports, "parseVotingSetup", { enumerable: true, get: function () { return ConfigParser_1.parseVotingSetup; } });
		Object.defineProperty(exports, "parseFullConfig", { enumerable: true, get: function () { return ConfigParser_1.parseFullConfig; } });
		Object.defineProperty(exports, "loadConfigParamById", { enumerable: true, get: function () { return ConfigParser_1.loadConfigParamById; } });
		Object.defineProperty(exports, "loadConfigParamsAsSlice", { enumerable: true, get: function () { return ConfigParser_1.loadConfigParamsAsSlice; } });
		//
		// Fees
		//
		var fees_1 = requireFees();
		Object.defineProperty(exports, "computeExternalMessageFees", { enumerable: true, get: function () { return fees_1.computeExternalMessageFees; } });
		Object.defineProperty(exports, "computeFwdFees", { enumerable: true, get: function () { return fees_1.computeFwdFees; } });
		Object.defineProperty(exports, "computeGasPrices", { enumerable: true, get: function () { return fees_1.computeGasPrices; } });
		Object.defineProperty(exports, "computeMessageForwardFees", { enumerable: true, get: function () { return fees_1.computeMessageForwardFees; } });
		Object.defineProperty(exports, "computeStorageFees", { enumerable: true, get: function () { return fees_1.computeStorageFees; } }); 
	} (dist$3));
	return dist$3;
}

var distExports$3 = requireDist$1();

var naclUtil$1 = {exports: {}};

var naclUtil = naclUtil$1.exports;

var hasRequiredNaclUtil;

function requireNaclUtil () {
	if (hasRequiredNaclUtil) return naclUtil$1.exports;
	hasRequiredNaclUtil = 1;
	(function (module) {
		// Written in 2014-2016 by Dmitry Chestnykh and Devi Mandiri.
		// Public domain.
		(function(root, f) {
		  if (module.exports) module.exports = f();
		  else if (root.nacl) root.nacl.util = f();
		  else {
		    root.nacl = {};
		    root.nacl.util = f();
		  }
		}(naclUtil, function() {

		  var util = {};

		  function validateBase64(s) {
		    if (!(/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s))) {
		      throw new TypeError('invalid encoding');
		    }
		  }

		  util.decodeUTF8 = function(s) {
		    if (typeof s !== 'string') throw new TypeError('expected string');
		    var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);
		    for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
		    return b;
		  };

		  util.encodeUTF8 = function(arr) {
		    var i, s = [];
		    for (i = 0; i < arr.length; i++) s.push(String.fromCharCode(arr[i]));
		    return decodeURIComponent(escape(s.join('')));
		  };

		  if (typeof atob === 'undefined') {
		    // Node.js

		    if (typeof Buffer.from !== 'undefined') {
		       // Node v6 and later
		      util.encodeBase64 = function (arr) { // v6 and later
		          return Buffer.from(arr).toString('base64');
		      };

		      util.decodeBase64 = function (s) {
		        validateBase64(s);
		        return new Uint8Array(Array.prototype.slice.call(Buffer.from(s, 'base64'), 0));
		      };

		    } else {
		      // Node earlier than v6
		      util.encodeBase64 = function (arr) { // v6 and later
		        return (new Buffer(arr)).toString('base64');
		      };

		      util.decodeBase64 = function(s) {
		        validateBase64(s);
		        return new Uint8Array(Array.prototype.slice.call(new Buffer(s, 'base64'), 0));
		      };
		    }

		  } else {
		    // Browsers

		    util.encodeBase64 = function(arr) {
		      var i, s = [], len = arr.length;
		      for (i = 0; i < len; i++) s.push(String.fromCharCode(arr[i]));
		      return btoa(s.join(''));
		    };

		    util.decodeBase64 = function(s) {
		      validateBase64(s);
		      var i, d = atob(s), b = new Uint8Array(d.length);
		      for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
		      return b;
		    };

		  }

		  return util;

		})); 
	} (naclUtil$1));
	return naclUtil$1.exports;
}

var naclUtilExports = requireNaclUtil();
const nacl = /*@__PURE__*/getDefaultExportFromCjs(naclUtilExports);

var naclFastExports = requireNaclFast();
const nacl$1 = /*@__PURE__*/getDefaultExportFromCjs(naclFastExports);

var CONNECT_EVENT_ERROR_CODES;
(function (CONNECT_EVENT_ERROR_CODES) {
    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["MANIFEST_NOT_FOUND_ERROR"] = 2] = "MANIFEST_NOT_FOUND_ERROR";
    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["MANIFEST_CONTENT_ERROR"] = 3] = "MANIFEST_CONTENT_ERROR";
    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
    CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(CONNECT_EVENT_ERROR_CODES || (CONNECT_EVENT_ERROR_CODES = {}));
var CONNECT_ITEM_ERROR_CODES;
(function (CONNECT_ITEM_ERROR_CODES) {
    CONNECT_ITEM_ERROR_CODES[CONNECT_ITEM_ERROR_CODES["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
    CONNECT_ITEM_ERROR_CODES[CONNECT_ITEM_ERROR_CODES["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(CONNECT_ITEM_ERROR_CODES || (CONNECT_ITEM_ERROR_CODES = {}));

var SEND_TRANSACTION_ERROR_CODES;
(function (SEND_TRANSACTION_ERROR_CODES) {
    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
    SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(SEND_TRANSACTION_ERROR_CODES || (SEND_TRANSACTION_ERROR_CODES = {}));

var SIGN_DATA_ERROR_CODES;
(function (SIGN_DATA_ERROR_CODES) {
    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
    SIGN_DATA_ERROR_CODES[SIGN_DATA_ERROR_CODES["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(SIGN_DATA_ERROR_CODES || (SIGN_DATA_ERROR_CODES = {}));

var DISCONNECT_ERROR_CODES;
(function (DISCONNECT_ERROR_CODES) {
    DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
    DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
    DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
    DISCONNECT_ERROR_CODES[DISCONNECT_ERROR_CODES["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
})(DISCONNECT_ERROR_CODES || (DISCONNECT_ERROR_CODES = {}));

var CHAIN;
(function (CHAIN) {
    CHAIN["MAINNET"] = "-239";
    CHAIN["TESTNET"] = "-3";
})(CHAIN || (CHAIN = {}));

function encodeUint8Array(value, urlSafe) {
    const encoded = nacl.encodeBase64(value);
    if (!urlSafe) {
        return encoded;
    }
    return encodeURIComponent(encoded);
}
function decodeToUint8Array(value, urlSafe) {
    if (urlSafe) {
        value = decodeURIComponent(value);
    }
    return nacl.decodeBase64(value);
}
function encode(value, urlSafe = false) {
    let uint8Array;
    if (value instanceof Uint8Array) {
        uint8Array = value;
    }
    else {
        if (typeof value !== 'string') {
            value = JSON.stringify(value);
        }
        uint8Array = nacl.decodeUTF8(value);
    }
    return encodeUint8Array(uint8Array, urlSafe);
}
function decode(value, urlSafe = false) {
    const decodedUint8Array = decodeToUint8Array(value, urlSafe);
    return {
        toString() {
            return nacl.encodeUTF8(decodedUint8Array);
        },
        toObject() {
            try {
                return JSON.parse(nacl.encodeUTF8(decodedUint8Array));
            }
            catch (e) {
                return null;
            }
        },
        toUint8Array() {
            return decodedUint8Array;
        }
    };
}
const Base64 = {
    encode,
    decode
};

function concatUint8Arrays(buffer1, buffer2) {
    const mergedArray = new Uint8Array(buffer1.length + buffer2.length);
    mergedArray.set(buffer1);
    mergedArray.set(buffer2, buffer1.length);
    return mergedArray;
}
function splitToUint8Arrays(array, index) {
    if (index >= array.length) {
        throw new Error('Index is out of buffer');
    }
    const subArray1 = array.slice(0, index);
    const subArray2 = array.slice(index);
    return [subArray1, subArray2];
}
function toHexString(byteArray) {
    let hexString = '';
    byteArray.forEach(byte => {
        hexString += ('0' + (byte & 0xff).toString(16)).slice(-2);
    });
    return hexString;
}
function hexToByteArray(hexString) {
    if (hexString.length % 2 !== 0) {
        throw new Error(`Cannot convert ${hexString} to bytesArray`);
    }
    const result = new Uint8Array(hexString.length / 2);
    for (let i = 0; i < hexString.length; i += 2) {
        result[i / 2] = parseInt(hexString.slice(i, i + 2), 16);
    }
    return result;
}

class SessionCrypto {
    constructor(keyPair) {
        this.nonceLength = 24;
        this.keyPair = keyPair ? this.createKeypairFromString(keyPair) : this.createKeypair();
        this.sessionId = toHexString(this.keyPair.publicKey);
    }
    createKeypair() {
        return nacl$1.box.keyPair();
    }
    createKeypairFromString(keyPair) {
        return {
            publicKey: hexToByteArray(keyPair.publicKey),
            secretKey: hexToByteArray(keyPair.secretKey)
        };
    }
    createNonce() {
        return nacl$1.randomBytes(this.nonceLength);
    }
    encrypt(message, receiverPublicKey) {
        const encodedMessage = new TextEncoder().encode(message);
        const nonce = this.createNonce();
        const encrypted = nacl$1.box(encodedMessage, nonce, receiverPublicKey, this.keyPair.secretKey);
        return concatUint8Arrays(nonce, encrypted);
    }
    decrypt(message, senderPublicKey) {
        const [nonce, internalMessage] = splitToUint8Arrays(message, this.nonceLength);
        const decrypted = nacl$1.box.open(internalMessage, nonce, senderPublicKey, this.keyPair.secretKey);
        if (!decrypted) {
            throw new Error(`Decryption error: \n message: ${message.toString()} \n sender pubkey: ${senderPublicKey.toString()} \n keypair pubkey: ${this.keyPair.publicKey.toString()} \n keypair secretkey: ${this.keyPair.secretKey.toString()}`);
        }
        return new TextDecoder().decode(decrypted);
    }
    stringifyKeypair() {
        return {
            publicKey: toHexString(this.keyPair.publicKey),
            secretKey: toHexString(this.keyPair.secretKey)
        };
    }
}

// Wallet-related type definitions
class WalletInitConfigMnemonic {
    mnemonic;
    version;
    mnemonicType;
    walletId;
    network;
    constructor({ mnemonic, version = 'v5r1', mnemonicType = 'ton', walletId, network, }) {
        this.mnemonic = mnemonic;
        this.version = version ?? 'v5r1';
        this.mnemonicType = mnemonicType ?? 'ton';
        this.walletId = walletId;
        this.network = network ?? 'mainnet';
    }
}
class WalletInitConfigPrivateKey {
    privateKey; // private key in hex format
    version;
    walletId;
    network;
    constructor({ privateKey, version = 'v5r1', walletId, network, }) {
        this.privateKey = privateKey;
        this.version = version;
        this.walletId = walletId;
        this.network = network ?? 'mainnet';
    }
}

// Durable event system types
/**
 * Default configuration for durable events
 */
const DEFAULT_DURABLE_EVENTS_CONFIG = {
    recoveryIntervalMs: 10 * 1000, // 10 seconds
    processingTimeoutMs: 60 * 1000, // 1 minute
    cleanupIntervalMs: 60 * 1000, // 1 minute
    retentionMs: 60 * 10 * 1000, // 10 minutes
};

// Jettons API types based on JETTONS.md specification
// === Error Types ===
class JettonError extends Error {
    code;
    details;
    constructor(message, code, details) {
        super(message);
        this.code = code;
        this.details = details;
        this.name = 'JettonError';
    }
}
var JettonErrorCode;
(function (JettonErrorCode) {
    JettonErrorCode["INVALID_ADDRESS"] = "INVALID_ADDRESS";
    JettonErrorCode["JETTON_NOT_FOUND"] = "JETTON_NOT_FOUND";
    JettonErrorCode["INSUFFICIENT_BALANCE"] = "INSUFFICIENT_BALANCE";
    JettonErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
    JettonErrorCode["INVALID_AMOUNT"] = "INVALID_AMOUNT";
    JettonErrorCode["PREPARATION_FAILED"] = "PREPARATION_FAILED";
})(JettonErrorCode || (JettonErrorCode = {}));

var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  LogLevel2[LogLevel2["NONE"] = 4] = "NONE";
})(LogLevel || (LogLevel = {}));
class Logger {
  config;
  parent;
  static defaultConfig = {
    level: LogLevel.INFO,
    prefix: "TonWalletKit",
    enableTimestamp: true,
    enableStackTrace: false
  };
  constructor(config) {
    this.parent = config?.parent;
    this.config = { ...Logger.defaultConfig, ...config };
    if (this.parent) {
      this.config = {
        ...this.parent.config,
        ...config,
        // Build hierarchical prefix
        prefix: this.buildHierarchicalPrefix(config?.prefix)
      };
    }
  }
  /**
   * Update logger configuration
   */
  configure(config) {
    this.config = { ...this.config, ...config };
  }
  /**
   * Create a child logger with a prefix that inherits from this logger
   */
  createChild(prefix, config) {
    return new Logger({
      ...config,
      parent: this,
      prefix
    });
  }
  /**
   * Build hierarchical prefix by combining parent prefix with current prefix
   */
  buildHierarchicalPrefix(currentPrefix) {
    if (!this.parent || !currentPrefix) {
      return currentPrefix || this.parent?.config.prefix || "";
    }
    const parentPrefix = this.parent.config.prefix;
    if (!parentPrefix) {
      return currentPrefix;
    }
    return `${parentPrefix}:${currentPrefix}`;
  }
  /**
   * Get the full hierarchical prefix for this logger
   */
  getPrefix() {
    return this.config.prefix || "";
  }
  /**
   * Get the parent logger if it exists
   */
  getParent() {
    return this.parent;
  }
  /**
   * Log debug messages
   */
  debug(message, context) {
    if (this.config.level <= LogLevel.DEBUG) {
      this.log("DEBUG", message, context);
    }
  }
  /**
   * Log info messages
   */
  info(message, context) {
    if (this.config.level <= LogLevel.INFO) {
      this.log("INFO", message, context);
    }
  }
  /**
   * Log warning messages
   */
  warn(message, context) {
    if (this.config.level <= LogLevel.WARN) {
      this.log("WARN", message, context);
    }
  }
  /**
   * Log error messages
   */
  error(message, context) {
    if (this.config.level <= LogLevel.ERROR) {
      this.log("ERROR", message, context);
    }
  }
  /**
   * Internal logging method
   */
  log(level, message, context) {
    const timestamp = this.config.enableTimestamp ? (/* @__PURE__ */ new Date()).toISOString() : "";
    const prefix = this.config.prefix ? `[${this.config.prefix}]` : "";
    let logMessage = "";
    if (timestamp) {
      logMessage += `${timestamp} `;
    }
    if (prefix) {
      logMessage += `${prefix} `;
    }
    logMessage += `${level}: ${message}`;
    const logArgs = [logMessage];
    if (context && Object.keys(context).length > 0) {
      logArgs.push(context);
    }
    switch (level) {
      case "DEBUG":
        console.debug(...logArgs);
        break;
      case "INFO":
        console.info(...logArgs);
        break;
      case "WARN":
        console.warn(...logArgs);
        break;
      case "ERROR":
        console.error(...logArgs);
        if (this.config.enableStackTrace) {
          console.trace();
        }
        break;
    }
  }
}
const globalLogger = new Logger({
  level: LogLevel.DEBUG,
  enableStackTrace: true
});

const log$r = globalLogger.createChild("StorageAdapter");
class LocalStorageAdapter {
  prefix;
  maxRetries;
  retryDelay;
  constructor(config = {}) {
    this.prefix = config.prefix || "tonwallet:";
    this.maxRetries = config.maxRetries || 3;
    this.retryDelay = config.retryDelay || 100;
    this.validateEnvironment();
  }
  async get(key) {
    return this.withRetry(async () => {
      const fullKey = this.prefix + key;
      const item = localStorage.getItem(fullKey);
      return item ? JSON.parse(item) : null;
    });
  }
  async set(key, value) {
    return this.withRetry(async () => {
      const fullKey = this.prefix + key;
      localStorage.setItem(fullKey, JSON.stringify(value));
    });
  }
  async remove(key) {
    return this.withRetry(async () => {
      const fullKey = this.prefix + key;
      localStorage.removeItem(fullKey);
    });
  }
  async clear() {
    return this.withRetry(async () => {
      const keysToRemove = this.getPrefixedKeys();
      keysToRemove.forEach((key) => localStorage.removeItem(key));
    });
  }
  validateEnvironment() {
    if (typeof localStorage === "undefined") {
      throw new Error("localStorage is not available in this environment");
    }
  }
  getPrefixedKeys() {
    const keys = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith(this.prefix)) {
        keys.push(key);
      }
    }
    return keys;
  }
  async withRetry(operation) {
    let lastError = null;
    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {
      try {
        return operation();
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        if (attempt < this.maxRetries) {
          await this.delay(this.retryDelay * Math.pow(2, attempt));
        }
      }
    }
    throw lastError;
  }
  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}
class MemoryStorageAdapter {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  store = /* @__PURE__ */ new Map();
  prefix;
  constructor(config = {}) {
    this.prefix = config.prefix || "";
  }
  async get(key) {
    const fullKey = this.prefix + key;
    return this.store.get(fullKey) || null;
  }
  async set(key, value) {
    const fullKey = this.prefix + key;
    this.store.set(fullKey, value);
  }
  async remove(key) {
    const fullKey = this.prefix + key;
    this.store.delete(fullKey);
  }
  async clear() {
    if (this.prefix) {
      const keysToDelete = Array.from(this.store.keys()).filter((key) => key.startsWith(this.prefix));
      keysToDelete.forEach((key) => this.store.delete(key));
    } else {
      this.store.clear();
    }
  }
  /**
   * Get current store size (for testing/debugging)
   */
  getSize() {
    return this.store.size;
  }
  /**
   * Get all keys (for testing/debugging)
   */
  getKeys() {
    return Array.from(this.store.keys());
  }
}
function createStorageAdapter(config = {}) {
  if (typeof localStorage !== "undefined") {
    try {
      return new LocalStorageAdapter(config);
    } catch (error) {
      log$r.warn("Failed to create LocalStorageAdapter, falling back to memory", { error });
    }
  }
  log$r.warn("Using MemoryStorageAdapter - data will not persist across sessions");
  return new MemoryStorageAdapter(config);
}

// Wallet-specific validation logic
/**
 * Validate wallet interface implementation
 */
function validateWallet(_wallet, _context = {}) {
    const errors = [];
    const warnings = [];
    // // Required field validations
    // if (!wallet.publicKey || typeof wallet.publicKey !== 'string') {
    //     errors.push('publicKey must be a non-empty string');
    // } else if (wallet.publicKey.length < 32) {
    //     errors.push('publicKey appears too short (minimum 32 characters)');
    // }
    // if (!wallet.version || typeof wallet.version !== 'string') {
    //     errors.push('version must be a non-empty string');
    // } else if (!isValidWalletVersion(wallet.version)) {
    //     if (context.strict) {
    //         errors.push(`unsupported wallet version: ${wallet.version}`);
    //     } else {
    //         warnings.push(`unknown wallet version: ${wallet.version}`);
    //     }
    // }
    // // Required method validations
    // if (typeof wallet.sign !== 'function') {
    //     errors.push('sign must be a function');
    // }
    // if (typeof wallet.getAddress !== 'function') {
    //     errors.push('getAddress must be a function');
    // }
    // if (typeof wallet.getBalance !== 'function') {
    //     errors.push('getBalance must be a function');
    // }
    // // Optional method validations
    // if (wallet.getStateInit && typeof wallet.getStateInit !== 'function') {
    //     errors.push('getStateInit must be a function if provided');
    // }
    // // Additional context-based validations
    // if (context.strict) {
    //     // In strict mode, perform additional checks
    //     if (!wallet.getStateInit) {
    //         warnings.push('getStateInit method is recommended for new wallets');
    //     }
    // }
    return {
        isValid: errors.length === 0,
        errors,
        warnings: warnings.length > 0 ? warnings : undefined,
    };
}

// Bridge event validation logic
/**
 * Validate bridge event structure
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function validateBridgeEvent(event, context = {}) {
    const errors = [];
    if (!event || typeof event !== 'object') {
        errors.push('event must be an object');
        return { isValid: false, errors };
    }
    // Required fields
    if (!event.id || typeof event.id !== 'string') {
        errors.push('event.id must be a non-empty string');
    }
    if (!event.method || typeof event.method !== 'string') {
        errors.push('event.method must be a non-empty string');
    }
    else if (!isValidEventMethod(event.method)) {
        if (context.strict) {
            errors.push(`unsupported event method: ${event.method}`);
        }
    }
    // Optional but validated fields
    if (event.params && typeof event.params !== 'object') {
        errors.push('event.params must be an object if provided');
    }
    if (event.sessionId && typeof event.sessionId !== 'string') {
        errors.push('event.sessionId must be a string if provided');
    }
    if (event.timestamp && typeof event.timestamp !== 'number') {
        errors.push('event.timestamp must be a number if provided');
    }
    return {
        isValid: errors.length === 0,
        errors,
    };
}
/**
 * Check if event method is supported
 */
function isValidEventMethod(method) {
    const supportedMethods = [
        'connect',
        'sendTransaction',
        'signData',
        'disconnect',
        'tonconnect_connect',
        'tonconnect_sendTransaction',
        'tonconnect_signData',
        'tonconnect_disconnect',
        'wallet_connect',
        'wallet_disconnect',
        'personal_sign',
    ];
    return supportedMethods.includes(method);
}

var distExports$2 = requireDist$2();

function formatWalletAddress(address, isTestnet = false) {
    if (typeof address === 'string') {
        return distExports$2.Address.parse(address).toString({ bounceable: false, testOnly: isTestnet });
    }
    return address.toString({ bounceable: false, testOnly: isTestnet });
}
function isValidAddress(address) {
    if (typeof address !== 'string') {
        return false;
    }
    try {
        distExports$2.Address.parse(address);
    }
    catch (_) {
        return false;
    }
    return true;
}
function isFriendlyTonAddress(address) {
    try {
        distExports$2.Address.parseFriendly(address);
    }
    catch (_) {
        return false;
    }
    return true;
}

/**
 * Validate transaction messages array
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function validateTransactionMessages(messages) {
    const errors = [];
    if (!Array.isArray(messages)) {
        errors.push('messages must be an array');
        return { isValid: false, errors };
    }
    if (messages.length === 0) {
        errors.push('messages array cannot be empty');
        return { isValid: false, errors };
    }
    // Validate each message
    messages.forEach((msg, index) => {
        const msgErrors = validateTransactionMessage(msg).errors;
        msgErrors.forEach((error) => {
            errors.push(`message[${index}]: ${error}`);
        });
    });
    return {
        isValid: errors.length === 0,
        errors,
    };
}
/**
 * Validate individual transaction message
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function validateTransactionMessage(message) {
    const errors = [];
    if (typeof message !== 'object') {
        return { isValid: false, errors: ['Invalid message'] };
    }
    if (message === null || message === undefined) {
        return { isValid: false, errors: ['Invalid message'] };
    }
    // Object format - validate required fields
    const objErrors = validateMessageObject(message).errors;
    errors.push(...objErrors);
    return {
        isValid: errors.length === 0,
        errors,
    };
}
/**
 * Validate message object structure
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function validateMessageObject(message) {
    const errors = [];
    // Required fields
    if (!message.address || typeof message.address !== 'string') {
        errors.push('to address is required and must be a string');
    }
    else {
        if (!isFriendlyTonAddress(message.address)) {
            errors.push('to address must be a valid TON address');
        }
    }
    if (message.amount !== undefined) {
        if (!isValidNanotonAmount(message.amount)) {
            errors.push('value must be a valid nanonton amount (string of digits)');
        }
    }
    else {
        errors.push('value must be a valid nanonton amount (string of digits)');
    }
    // Optional fields validation
    if (message.payload && typeof message.payload !== 'string') {
        errors.push('payload must be a string if provided');
    }
    if (message.stateInit && typeof message.stateInit !== 'string') {
        errors.push('stateInit must be a string if provided');
    }
    return {
        isValid: errors.length === 0,
        errors,
    };
}
/**
 * Check if value is a valid nanonton amount
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isValidNanotonAmount(amount) {
    if (typeof amount !== 'string') {
        return false;
    }
    const amountStr = String(amount);
    // Check if it's a valid non-negative integer
    const parsed = BigInt(amountStr);
    return parsed >= 0 && parsed.toString() === amountStr;
}

// Input sanitization utilities
/**
 * Sanitize string input to prevent XSS and other attacks
 */
function sanitizeString(input) {
    if (typeof input !== 'string') {
        return '';
    }
    return input
        .replace(/[<>]/g, '') // Remove angle brackets
        .replace(/javascript:/gi, '') // Remove javascript: protocol
        .replace(/on\w+=/gi, '') // Remove event handlers like onclick=
        .trim()
        .slice(0, 1000); // Limit length
}

const log$q = globalLogger.createChild("WalletManager");
class WalletManager {
  wallets = /* @__PURE__ */ new Map();
  storageAdapter;
  // private storageKey = 'wallets';
  constructor(storageAdapter) {
    this.storageAdapter = storageAdapter;
  }
  /**
   * Initialize manager and load persisted wallets
   */
  async initialize() {
  }
  /**
   * Get all wallets as array
   */
  getWallets() {
    return Array.from(this.wallets.values());
  }
  /**
   * Get wallet by public key
   */
  getWallet(address) {
    return this.wallets.get(address) || void 0;
  }
  /**
   * Add a wallet with validation
   */
  async addWallet(wallet) {
    const validation = validateWallet();
    if (!validation.isValid) {
      throw new Error(`Invalid wallet: ${validation.errors.join(", ")}`);
    }
    if (this.wallets.has(wallet.getAddress())) {
      log$q.warn(`Wallet with address ${wallet.getAddress()} already exists`);
      return false;
    }
    this.wallets.set(wallet.getAddress(), wallet);
    return true;
  }
  /**
   * Remove wallet by public key
   */
  async removeWallet(addressOrWallet) {
    const address = typeof addressOrWallet === "string" ? addressOrWallet : addressOrWallet.getAddress();
    const removed = this.wallets.delete(address);
    return removed;
  }
  /**
   * Update existing wallet
   */
  async updateWallet(wallet) {
    if (!this.wallets.has(wallet.getAddress())) {
      throw new Error(`Wallet with address ${wallet.getAddress()} not found`);
    }
    const validation = validateWallet();
    if (!validation.isValid) {
      throw new Error(`Invalid wallet: ${validation.errors.join(", ")}`);
    }
    this.wallets.set(wallet.getAddress(), wallet);
  }
  /**
   * Clear all wallets
   */
  async clearWallets() {
    this.wallets.clear();
  }
  /**
   * Find wallet by address (async since getAddress is async)
   */
  async findWalletByAddress(address) {
    for (const wallet of this.wallets.values()) {
      try {
        const walletAddress = wallet.getAddress();
        if (walletAddress === address) {
          return wallet;
        }
      } catch (error) {
        log$q.warn("Failed to get address for wallet", { publicKey: wallet.publicKey, error });
      }
    }
    return null;
  }
  /**
   * Get wallet count
   */
  getWalletCount() {
    return this.wallets.size;
  }
  /**
   * Check if wallet exists
   */
  hasWallet(publicKey) {
    return this.wallets.has(publicKey);
  }
}

const log$p = globalLogger.createChild("SessionManager");
class SessionManager {
  sessions = /* @__PURE__ */ new Map();
  storageAdapter;
  walletManager;
  storageKey = "sessions";
  constructor(storageAdapter, walletManager) {
    this.storageAdapter = storageAdapter;
    this.walletManager = walletManager;
  }
  /**
   * Initialize manager and load persisted sessions
   */
  async initialize() {
    await this.loadSessions();
  }
  /**
   * Create new session
   */
  async createSession(sessionId, dAppName, domain, wallet) {
    const now = /* @__PURE__ */ new Date();
    const randomKeyPair = new SessionCrypto().stringifyKeypair();
    const sessionData = {
      sessionId,
      dAppName,
      domain,
      walletAddress: wallet.getAddress(),
      createdAt: now.toISOString(),
      lastActivityAt: now.toISOString(),
      privateKey: randomKeyPair.secretKey,
      publicKey: randomKeyPair.publicKey
    };
    this.sessions.set(sessionId, sessionData);
    await this.persistSessions();
    return await this.getSession(sessionId);
  }
  // async getSessionData(sessionId: string): Promise<SessionData | undefined> {}
  /**
   * Get session by ID
   */
  async getSession(sessionId) {
    const session = this.sessions.get(sessionId);
    if (session) {
      return {
        sessionId: session.sessionId,
        dAppName: session.dAppName,
        walletAddress: session.walletAddress,
        wallet: this.walletManager.getWallet(session.walletAddress),
        privateKey: session.privateKey,
        publicKey: session.publicKey,
        createdAt: new Date(session.createdAt),
        lastActivityAt: new Date(session.lastActivityAt),
        domain: session.domain
      };
    }
    return void 0;
  }
  /**
   * Get all sessions as array
   */
  getSessions() {
    return Array.from(this.sessions.values());
  }
  /**
   * Get sessions for specific wallet
   */
  getSessionsForWallet(wallet) {
    return this.getSessions().filter((session) => session.walletAddress === wallet.getAddress());
  }
  /**
   * Update session activity timestamp
   */
  async updateSessionActivity(sessionId) {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.lastActivityAt = (/* @__PURE__ */ new Date()).toISOString();
      await this.persistSessions();
    }
  }
  /**
   * Remove session by ID
   */
  async removeSession(sessionId) {
    const removed = this.sessions.delete(sessionId);
    if (removed) {
      await this.persistSessions();
    }
    return removed;
  }
  /**
   * Remove all sessions for a wallet
   */
  async removeSessionsForWallet(wallet) {
    const sessionsToRemove = this.getSessionsForWallet(wallet);
    let removedCount = 0;
    for (const session of sessionsToRemove) {
      if (this.sessions.delete(session.sessionId)) {
        removedCount++;
      }
    }
    if (removedCount > 0) {
      await this.persistSessions();
    }
    return removedCount;
  }
  /**
   * Clear all sessions
   */
  async clearSessions() {
    this.sessions.clear();
    await this.persistSessions();
  }
  /**
   * Get session count
   */
  getSessionCount() {
    return this.sessions.size;
  }
  /**
   * Check if session exists
   */
  hasSession(sessionId) {
    return this.sessions.has(sessionId);
  }
  /**
   * Clean up expired sessions (optional cleanup based on inactivity)
   */
  async cleanupInactiveSessions(maxInactiveHours = 24) {
    const cutoffTime = /* @__PURE__ */ new Date();
    cutoffTime.setHours(cutoffTime.getHours() - maxInactiveHours);
    const sessionsToRemove = [];
    for (const [sessionId, session] of this.sessions.entries()) {
      if (new Date(session.lastActivityAt) < cutoffTime) {
        sessionsToRemove.push(sessionId);
      }
    }
    for (const sessionId of sessionsToRemove) {
      this.sessions.delete(sessionId);
    }
    if (sessionsToRemove.length > 0) {
      await this.persistSessions();
    }
    return sessionsToRemove.length;
  }
  /**
   * Get sessions as the format expected by the main API
   */
  getSessionsForAPI() {
    return this.getSessions().map((session) => ({
      sessionId: session.sessionId,
      dAppName: session.dAppName,
      walletAddress: session.walletAddress
    }));
  }
  /**
   * Load sessions from storage
   */
  async loadSessions() {
    try {
      const sessionData = await this.storageAdapter.get(this.storageKey);
      if (sessionData && Array.isArray(sessionData)) {
        for (const session of sessionData) {
          this.sessions.set(session.sessionId, {
            ...session
            // wallet,
            // createdAt: session.createdAt,
            // lastActivityAt: session.lastActivityAt,
          });
        }
        log$p.debug("Loaded session metadata", { count: sessionData.length });
      }
    } catch (error) {
      log$p.warn("Failed to load sessions from storage", { error });
    }
  }
  /**
   * Persist session metadata to storage
   */
  async persistSessions() {
    try {
      const sessionMetadata = this.getSessions().map((session) => ({
        sessionId: session.sessionId,
        dAppName: session.dAppName,
        domain: session.domain,
        walletAddress: session.walletAddress,
        createdAt: session.createdAt,
        lastActivityAt: session.lastActivityAt,
        privateKey: session.privateKey,
        publicKey: session.publicKey
      }));
      await this.storageAdapter.set(this.storageKey, sessionMetadata);
    } catch (error) {
      log$p.warn("Failed to persist sessions to storage", { error });
    }
  }
}

var define_process_env_default$1 = {};
function E() {
  return typeof process < "u" && !!define_process_env_default$1;
}
function S$1(o4) {
  return define_process_env_default$1?.[o4];
}
var M$1 = E() && !S$1("TONBRIDGE_DEBUG"), i = (...o4) => {
  M$1 || console.debug("[TON_CONNECT_BRIDGE_SDK]", ...o4);
}, b$1 = (...o4) => {
  console.error("[TON_CONNECT_BRIDGE_SDK]", ...o4);
};
var s = class o extends Error {
  static prefix = "[BRIDGE_SDK_ERROR]";
  constructor(e, t) {
    super(e, t), this.message = `${o.prefix} ${e ? `
` + e : ""}`, i(this.message), Object.setPrototypeOf(this, o.prototype);
  }
};
function D(o4) {
  return o4.slice(-1) === "/" ? o4.slice(0, -1) : o4;
}
function h(o4, e) {
  return D(o4) + "/" + e;
}
function u(o4) {
  let e = new AbortController();
  return o4?.aborted ? e.abort() : o4?.addEventListener("abort", () => e.abort(), { once: true }), e;
}
function C$1(o4, e) {
  let t = null, n = null, r = null;
  return { create: async (a, ...p) => {
    if (r?.abort(), r = u(a), r.signal.aborted) throw new s("Resource creation was aborted");
    let g = o4(r.signal, ...p);
    n = g;
    let v = await g;
    if (n !== g && v !== t) throw await e(v), new s("Resource creation was aborted by a new resource creation");
    return t = v, t;
  }, current: () => t ?? null, dispose: async () => {
    try {
      let a = t;
      t = null;
      let p = n;
      n = null;
      try {
        r?.abort();
      } catch {
      }
      await Promise.allSettled([a ? e(a) : Promise.resolve(), p ? e(await p) : Promise.resolve()]);
    } catch {
    }
  } };
}
function P(o4, e) {
  let t = e?.timeout, n = e?.signal, r = u(n);
  return new Promise(async (d, l) => {
    if (n?.aborted) {
      l(new s("Timeout aborted before setTimeout"));
      return;
    }
    let c;
    typeof t < "u" && (c = setTimeout(() => {
      r.abort(), l(new s(`Timeout after ${t}ms`));
    }, t)), r.signal.addEventListener("abort", () => {
      c && (clearTimeout(c), c = void 0, l(new s("Timeout aborted after setTimeout")));
    }, { once: true }), await o4((...a) => {
      clearTimeout(c), c = void 0, d(...a);
    }, (a) => {
      clearTimeout(c), c = void 0, l(a);
    }, { timeout: t, signal: r.signal });
  });
}
var m$1 = class o2 {
  constructor(e, t, n, r, d, l) {
    this.bridgeUrl = e;
    this.sessionIds = t;
    this.listener = n;
    this.errorsListener = r;
    this.lastEventId = d;
    this.heartbeatFormat = l;
  }
  static ssePath = "events";
  static postPath = "message";
  static defaultTtl = 300;
  eventSource = C$1(async (e, t) => {
    let n = { bridgeUrl: this.bridgeUrl, ssePath: o2.ssePath, sessionIds: this.sessionIds, errorHandler: this.errorsHandler.bind(this), messageHandler: this.messagesHandler.bind(this), signal: e, connectingDeadlineMS: t, lastEventId: this.lastEventId, heartbeatFormat: this.heartbeatFormat };
    return await A$1(n);
  }, async (e) => {
    e.close();
  });
  get isReady() {
    return this.eventSource.current()?.readyState === EventSource.OPEN;
  }
  get isClosed() {
    return this.eventSource.current()?.readyState !== EventSource.OPEN;
  }
  get isConnecting() {
    return this.eventSource.current()?.readyState === EventSource.CONNECTING;
  }
  static async open(e) {
    let t = new o2(e.bridgeUrl, e.sessionIds, e.listener, e.errorsListener, e.lastEventId, e.heartbeatFormat);
    try {
      return await t.registerSession(e.options), t;
    } catch (n) {
      throw await t.close(), n;
    }
  }
  async registerSession(e) {
    await this.eventSource.create(e?.signal, e?.connectingDeadlineMS);
  }
  static async sendRequest(e, t, n, r, d) {
    let l = new URL(h(e, this.postPath));
    l.searchParams.append("client_id", n), l.searchParams.append("to", r), l.searchParams.append("ttl", (d?.ttl ?? o2.defaultTtl).toString()), d?.topic && l.searchParams.append("topic", d.topic);
    let c = Base64.encode(t), a = await this.post(l, c, d?.signal);
    if (!a.ok) throw new s(`Bridge send failed, status ${a.status}`);
  }
  async send(e, t, n, r) {
    return o2.sendRequest(this.bridgeUrl, e, t, n, r);
  }
  async close() {
    await this.eventSource.dispose().catch((e) => {
      b$1("[BridgeGateway] Failed to close connection:", e);
    });
  }
  setListener(e) {
    this.listener = e;
  }
  setErrorsListener(e) {
    this.errorsListener = e;
  }
  static async post(e, t, n) {
    let r = await fetch(e, { method: "post", body: t, signal: n });
    if (!r.ok) throw new s(`Bridge send failed, status ${r.status}`);
    return r;
  }
  async errorsHandler(e, t) {
    this.errorsListener(t);
  }
  async messagesHandler(e) {
    this.listener(e);
  }
};
async function A$1(o4) {
  let { lastEventId: e, heartbeatFormat: t } = o4;
  return await P(async (n, r, d) => {
    let { signal: l } = d;
    if (i("[BridgeGateway] Connecting to bridge SSE..."), l?.aborted) {
      r(new s("Bridge connection aborted before connection"));
      return;
    }
    let c = new URL(h(o4.bridgeUrl, o4.ssePath));
    if (c.searchParams.append("client_id", o4.sessionIds.join(",")), e && c.searchParams.append("last_event_id", e), t && c.searchParams.append("heartbeat", t), l?.aborted) {
      r(new s("Bridge connection aborted after building url"));
      return;
    }
    i("[BridgeGateway] Initializing EventSource instance...");
    let a = new EventSource(c.toString()), p = false;
    a.onerror = async (g) => {
      if (i("[BridgeGateway] EventSource error occurred:", JSON.stringify(g)), l?.aborted) {
        a.close(), r(new s("Bridge connection aborted on error callback"));
        return;
      }
      if (!p) {
        a.close(), r(new s("Bridge error before connecting"));
        return;
      }
      try {
        a.close(), await o4.errorHandler(a, g);
      } catch (v) {
        a.close(), r(v);
      }
    }, a.onopen = () => {
      if (l?.aborted) {
        a.close(), r(new s("Bridge connection aborted on open"));
        return;
      }
      p = true, i("[BridgeGateway] EventSource connection established."), n(a);
    }, a.onmessage = (g) => {
      if (l?.aborted) {
        a.close(), r(new s("Bridge connection aborted on message"));
        return;
      }
      e = g.lastEventId, o4.messageHandler(g);
    }, o4.signal?.addEventListener("abort", () => {
      a.close(), r(new s("Bridge connection aborted"));
    }, { once: true });
  }, { timeout: o4.connectingDeadlineMS, signal: o4.signal });
}
async function y(o4, e) {
  if (e?.signal?.aborted) throw new s("Delay aborted before setTimeout");
  return new Promise((t, n) => {
    let r = setTimeout(t, o4);
    e?.signal?.addEventListener("abort", () => {
      clearTimeout(r), n(new s("Delay aborted after setTimeout"));
    }, { once: true });
  });
}
async function f(o4, e) {
  let { signal: t, attempts: n = 10, delayMs: r = 100 } = e ?? {};
  if (typeof o4 != "function") throw new s(`Expected a function, got ${typeof o4}`);
  let d = 0, l;
  for (; d < n; ) {
    if (i(`[callForSuccess] Attempt: ${d}`), t?.aborted) throw new s(`Aborted after attempts ${d}`);
    try {
      return await o4({ signal: t });
    } catch (c) {
      i(`[callForSuccess], error after attempt ${d}, ${/* @__PURE__ */ new Date()}: ${JSON.stringify(c)}`, c), l = c, d++, d < n && (await y(r, { signal: t }), e?.exponential && (r = Math.min(r * 2, e.maxDelayMs ?? Number.MAX_SAFE_INTEGER)));
    }
  }
  throw l;
}
function B(o4) {
  return [...new Set(o4)];
}
var w$1 = class o3 {
  constructor(e, t = null, n = null, r = void 0) {
    this.bridgeUrl = e;
    this.listener = t;
    this.errorListener = n;
    this.heartbeatReconnectIntervalMs = r;
  }
  clients = [];
  lastEventId;
  abortController;
  gateway = null;
  onConnectingCallback;
  heartbeatMessage = "heartbeat";
  defaultConnectingDeadlineMS = 14e3;
  defaultRetryDelayMs = 1e3;
  defaultMaxExponentialDelayMS = 7e3;
  missedHeartbeatDelay = 100;
  lastHeartbeatAt = Date.now();
  heartbeatTimer = null;
  connectionOptions = {};
  static async open(e) {
    let t = new o3(e.bridgeUrl, e.listener, e.errorListener, e.options?.heartbeatReconnectIntervalMs);
    e.onConnecting && (t.onConnecting = e.onConnecting);
    try {
      return await t.restoreConnection(e.clients, e.options), t;
    } catch (n) {
      throw await t.close(), n;
    }
  }
  get isReady() {
    return this.gateway?.isReady || false;
  }
  get isConnecting() {
    return this.gateway?.isConnecting ?? false;
  }
  get isClosed() {
    return this.gateway?.isClosed ?? false;
  }
  startHeartbeatWatcher(e) {
    if (!this.heartbeatReconnectIntervalMs) return;
    this.stopHeartbeatWatcher();
    let t = u(e), { signal: n } = t;
    this.lastHeartbeatAt = Date.now();
    let r = (l) => {
      this.heartbeatTimer = setTimeout(d, l);
    }, d = async () => {
      if (n.aborted) {
        this.stopHeartbeatWatcher();
        return;
      }
      if (Date.now() - this.lastHeartbeatAt < this.heartbeatReconnectIntervalMs) {
        r(this.heartbeatReconnectIntervalMs / 2);
        return;
      }
      if (await y(this.missedHeartbeatDelay, { signal: n }), n.aborted) {
        this.stopHeartbeatWatcher();
        return;
      }
      let c = Date.now() - this.lastHeartbeatAt;
      if (c <= this.heartbeatReconnectIntervalMs) {
        r(this.heartbeatReconnectIntervalMs / 2);
        return;
      }
      this.stopHeartbeatWatcher(), i(`[BridgeProvider] No heartbeat for ${c}ms, reconnecting...`);
      try {
        await this.reconnect(n);
      } catch (a) {
        b$1("[BridgeProvider] Failed to reconnect after missed heartbeat:", a), this.errorListener?.(a);
      }
    };
    r(this.heartbeatReconnectIntervalMs);
  }
  stopHeartbeatWatcher() {
    this.heartbeatTimer && (clearTimeout(this.heartbeatTimer), this.heartbeatTimer = null);
  }
  async restoreConnection(e, t) {
    if (e.length === 0) {
      i("[BridgeProvider] No clients passed");
      return;
    }
    this.clients = e, this.lastEventId = t?.lastEventId, this.connectionOptions = t, i("[BridgeProvider] Restoring connection...");
    let n = u(t?.signal);
    this.abortController?.abort(), this.abortController = n;
    let r = n.signal;
    if (r.aborted) {
      i("[BridgeProvider] Restore aborted before start.");
      return;
    }
    if (await this.reconnect(r), n.signal.aborted) {
      i("[BridgeProvider] Restore aborted after connecting.");
      return;
    }
    this.startHeartbeatWatcher(t?.signal);
  }
  async reconnect(e) {
    try {
      await this.closeGateway();
    } catch (n) {
      i("[BridgeProvider] Error closing gateway:", JSON.stringify(n));
    }
    if (e.aborted) {
      i("[BridgeProvider] Reconnect aborted after closing gateway.");
      return;
    }
    let t = this.connectionOptions;
    await f(({ signal: n }) => this.openGateway(this.clients.map((r) => r.session), { lastEventId: this.lastEventId, connectingDeadlineMS: t?.connectingDeadlineMs ?? this.defaultConnectingDeadlineMS, signal: n }), { attempts: Number.MAX_SAFE_INTEGER, delayMs: t?.delayMs ?? this.defaultRetryDelayMs, signal: e, exponential: t?.exponential ?? true, maxDelayMs: t?.maxDelayMs ?? this.defaultMaxExponentialDelayMS });
  }
  async send(e, t, n, r) {
    if (r?.signal?.aborted) {
      i("[BridgeProvider] Send aborted before encryption.");
      return;
    }
    let d = t.encrypt(JSON.stringify(e), hexToByteArray(n));
    await f(async ({ signal: l }) => {
      await m$1.sendRequest(this.bridgeUrl, d, t.sessionId, n, { signal: l, ttl: r?.ttl });
    }, { attempts: r?.attempts ?? Number.MAX_SAFE_INTEGER, delayMs: r?.delayMs ?? this.defaultRetryDelayMs, signal: r?.signal, exponential: r?.exponential ?? true, maxDelayMs: r?.maxDelayMs ?? this.defaultMaxExponentialDelayMS });
  }
  async close() {
    i("[BridgeProvider] Closing provider and gateway..."), await this.closeGateway(), this.stopHeartbeatWatcher(), this.lastEventId = void 0, this.clients = [], i("[BridgeProvider] Closed.");
  }
  listen(e) {
    this.listener = e;
  }
  set onConnecting(e) {
    this.onConnectingCallback = () => {
      try {
        e();
      } catch (t) {
        b$1(`[BridgeProvider] Error during onConnecting callback: ${JSON.stringify(t)}`, t);
      }
    };
  }
  getCryptoSession(e) {
    let t = this.clients.find(({ clientId: n }) => n === e);
    if (!t) throw new s("Client session does not exist");
    return t.session;
  }
  async gatewayListener(e) {
    if (e.data === this.heartbeatMessage) {
      this.lastHeartbeatAt = Date.now();
      return;
    }
    i(`[BridgeProvider] Message received. Event ID: ${e.lastEventId}`);
    let t;
    try {
      t = JSON.parse(e.data);
    } catch {
      throw new s(`Failed to parse message: ${e.data}`);
    }
    let n = this.getCryptoSession(t.from), r = JSON.parse(n.decrypt(Base64.decode(t.message).toUint8Array(), hexToByteArray(t.from)));
    i("[BridgeProvider] Incoming message decrypted:", r), this.lastEventId = e.lastEventId, this.listener?.({ lastEventId: e.lastEventId, ...r, from: t.from });
  }
  async gatewayErrorsListener(e) {
    if (this.gateway?.isClosed || this.gateway?.isConnecting) {
      let n = u(this.abortController?.signal);
      try {
        return i("[BridgeProvider] Error in gatewayErrorsListener, trying to reconnect:", e), this.onConnectingCallback?.(), this.reconnect(n.signal);
      } catch (r) {
        n.abort(), i("[BridgeProvider] Error in gatewayErrorsListener after reconnect:", r);
      }
    }
    let t = new s(`Bridge error ${JSON.stringify(e)}`);
    b$1("[BridgeProvider] Gateway error:", t), this.errorListener?.(t);
  }
  async openGateway(e, t) {
    if (t?.signal?.aborted) {
      i("[BridgeProvider] Open gateway aborted before start.");
      return;
    }
    if (this.gateway && (i("[BridgeProvider] Existing gateway detected. Closing it..."), await this.closeGateway()), i("[BridgeProvider] Creating new BridgeGateway instance..."), t?.signal?.aborted) {
      i("[BridgeProvider] Open gateway aborted after close.");
      return;
    }
    this.gateway = new m$1(this.bridgeUrl, B(e.map(({ sessionId: n }) => n)), this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this), this.lastEventId, "message"), i("[BridgeProvider] BridgeGateway created. Connecting to bridge..."), this.onConnectingCallback?.(), await this.gateway.registerSession({ connectingDeadlineMS: t?.connectingDeadlineMS, signal: t?.signal }), i("[BridgeProvider] Connected to bridge successfully.");
  }
  async closeGateway() {
    this.gateway && (i("[BridgeProvider] Closing previous gateway..."), await this.gateway.close(), this.gateway = null, i("[BridgeProvider] Gateway closed."));
  }
};

const log$o = globalLogger.createChild("BridgeManager");
class BridgeManager {
  config;
  bridgeProvider;
  sessionManager;
  storageAdapter;
  isConnected = false;
  reconnectAttempts = 0;
  lastEventId;
  storageKey = "bridge_last_event_id";
  // Event processing queue and concurrency control
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  eventQueue = [];
  isProcessing = false;
  // Durable events support
  eventStore;
  eventEmitter;
  requestProcessingTimeoutId;
  constructor(config, sessionManager, storageAdapter, eventStore, eventEmitter) {
    this.config = {
      heartbeatInterval: 5e3,
      reconnectInterval: 15e3,
      maxReconnectAttempts: 5,
      ...config
    };
    this.sessionManager = sessionManager;
    this.storageAdapter = storageAdapter;
    this.eventStore = eventStore;
    this.eventEmitter = eventEmitter;
  }
  /**
   * Initialize bridge connection
   */
  async start() {
    if (this.bridgeProvider) {
      log$o.warn("Bridge already initialized");
      return;
    }
    try {
      await this.loadLastEventId();
      await this.connectToBridge();
    } catch (error) {
      log$o.error("Failed to start bridge", { error });
      throw error;
    }
    const requestProcessing = () => {
      this.processBridgeEvents();
      this.requestProcessingTimeoutId = setTimeout(requestProcessing, 1e3);
    };
    requestProcessing();
  }
  /**
   * Create new session for a dApp connection
   */
  async createSession(appSessionId) {
    log$o.info("[BRIDGE] Creating session", { appSessionId });
    const session = this.sessionManager.getSession(appSessionId);
    if (!session) {
      throw new Error(`Session ${appSessionId} not found`);
    }
    if (this.bridgeProvider && this.isConnected) {
      log$o.info("[BRIDGE] Updating clients");
      await this.updateClients();
    }
  }
  /**
   * Remove session
   */
  async removeSession(appSessionId) {
    if (this.bridgeProvider && this.isConnected) {
      await this.updateClients();
    }
    log$o.debug("Session removed", { appSessionId });
  }
  /**
   * Send response to dApp
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async sendResponse(sessionId, requestId, response) {
    if (!this.bridgeProvider) {
      throw new Error("Bridge not initialized");
    }
    const session = await this.sessionManager.getSession(sessionId);
    if (!session) {
      throw new Error(`Session ${sessionId} not found`);
    }
    try {
      const sessionCrypto = new SessionCrypto({
        publicKey: session.publicKey,
        secretKey: session.privateKey
      });
      await this.bridgeProvider.send(response, sessionCrypto, sessionId);
      log$o.debug("Response sent successfully", { sessionId, requestId });
    } catch (error) {
      log$o.error("Failed to send response through bridge", {
        sessionId,
        requestId,
        error
      });
      throw error;
    }
  }
  /**
   * Close bridge connection
   */
  async close() {
    if (this.bridgeProvider) {
      await this.bridgeProvider.close();
      this.bridgeProvider = void 0;
    }
    this.eventQueue = [];
    this.isProcessing = false;
    this.isConnected = false;
    this.reconnectAttempts = 0;
    if (this.requestProcessingTimeoutId) {
      clearTimeout(this.requestProcessingTimeoutId);
      this.requestProcessingTimeoutId = void 0;
    }
  }
  /**
   * Get connection status
   */
  isConnectedToBridge() {
    return this.isConnected;
  }
  /**
   * Get active session count
   */
  // getSessionCount(): number {
  //     return this.sessions.size;
  // }
  async getClients() {
    return this.sessionManager.getSessions().map((session) => ({
      session: new SessionCrypto({
        publicKey: session.publicKey,
        secretKey: session.privateKey.length > 64 ? session.privateKey.slice(0, 64) : session.privateKey
      }),
      clientId: session.sessionId
    }));
  }
  /**
   * Connect to TON Connect bridge
   */
  async connectToBridge() {
    try {
      const clients = await this.getClients();
      if (clients.length === 0) {
        clients.push({
          clientId: "0",
          session: new SessionCrypto()
        });
      }
      this.bridgeProvider = await w$1.open({
        bridgeUrl: this.config.bridgeUrl,
        clients,
        listener: this.queueBridgeEvent.bind(this),
        options: {
          lastEventId: this.lastEventId
          // heartbeatReconnectIntervalMs: this.config.reconnectInterval,
        }
      });
      this.isConnected = true;
      this.reconnectAttempts = 0;
      log$o.info("Bridge connected successfully");
    } catch (error) {
      log$o.error("Bridge connection failed", { error });
      if (this.reconnectAttempts < (this.config.maxReconnectAttempts || 5)) {
        this.reconnectAttempts++;
        log$o.info("Bridge reconnection attempt", { attempt: this.reconnectAttempts });
        setTimeout(() => {
          this.connectToBridge().catch((error2) => log$o.error("Bridge reconnection failed", { error: error2 }));
        }, this.config.reconnectInterval);
      }
      throw error;
    }
  }
  /**
   * Restart bridge connection in case of error, so we can receive events again
   */
  async restartConnection() {
    await this.close();
    await this.start();
  }
  /**
   * Add client to existing bridge connection
   */
  async updateClients() {
    log$o.debug("Updating clients");
    if (this.bridgeProvider) {
      const clients = await this.getClients();
      log$o.info("[BRIDGE] Restoring connection", { clients: clients.length });
      await this.bridgeProvider.restoreConnection(clients, {
        lastEventId: this.lastEventId
      });
    }
  }
  /**
   * Queue incoming bridge events for processing
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  queueBridgeEvent(event) {
    log$o.debug("Bridge event queued", { eventId: event?.id });
    this.eventQueue.push(event);
    this.processBridgeEvents().catch((error) => {
      log$o.error("Error in background event processing", { error });
    });
  }
  /**
   * Process events from the queue with concurrency control
   */
  async processBridgeEvents() {
    if (this.isProcessing) {
      log$o.debug("Event processing already in progress, skipping");
      return;
    }
    this.isProcessing = true;
    log$o.debug("Started event processing");
    try {
      while (this.eventQueue.length > 0) {
        const event = this.eventQueue.shift();
        if (event) {
          await this.handleBridgeEvent(event);
        }
      }
    } catch (error) {
      log$o.error("Error during event processing", { error });
      this.isProcessing = false;
      log$o.debug("Event processing completed");
      this.restartConnection();
      return;
    } finally {
      this.isProcessing = false;
      log$o.debug("Event processing completed");
    }
  }
  /**
   * Handle individual bridge event (original processing logic)
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async handleBridgeEvent(event) {
    try {
      log$o.info("Bridge event received", { event });
      const rawEvent = {
        id: event.id || crypto.randomUUID(),
        method: event.method || "unknown",
        params: event.params || event,
        // sessionId: event.from,
        timestamp: Date.now(),
        from: event?.from,
        domain: ""
      };
      if (rawEvent.from) {
        const session = await this.sessionManager.getSession(rawEvent.from);
        rawEvent.domain = session?.domain || "";
        if (session?.wallet) {
          rawEvent.wallet = session.wallet;
        }
      }
      if (!this.eventStore) {
        throw new Error("Event store is not initialized");
      }
      try {
        await this.eventStore.storeEvent(rawEvent);
        if (this.eventEmitter) {
          this.eventEmitter.emit("bridge-storage-updated");
        }
        log$o.info("Event stored durably", { eventId: rawEvent.id, method: rawEvent.method });
      } catch (error) {
        log$o.error("Failed to store event durably", {
          eventId: rawEvent.id,
          error: error.message
        });
        throw error;
      }
      log$o.info("Bridge event processed", { rawEvent });
      if (event?.lastEventId && event.lastEventId !== this.lastEventId) {
        this.lastEventId = event.lastEventId;
        await this.saveLastEventId();
      }
    } catch (error) {
      log$o.error("Error handling bridge event", { error });
    }
  }
  /**
   * Load last event ID from storage
   */
  async loadLastEventId() {
    try {
      const savedEventId = await this.storageAdapter.get(this.storageKey);
      if (savedEventId) {
        this.lastEventId = savedEventId;
        log$o.debug("Loaded last event ID from storage", { lastEventId: this.lastEventId });
      }
    } catch (error) {
      log$o.warn("Failed to load last event ID from storage", { error });
    }
  }
  /**
   * Save last event ID to storage
   */
  async saveLastEventId() {
    try {
      if (this.lastEventId) {
        await this.storageAdapter.set(this.storageKey, this.lastEventId);
        log$o.debug("Saved last event ID to storage", { lastEventId: this.lastEventId });
      }
    } catch (error) {
      log$o.warn("Failed to save last event ID to storage", { error });
    }
  }
}

class BasicHandler {
    _notifyHandler;
    constructor(notify) {
        this._notifyHandler = notify;
    }
    async notify(event) {
        if (this._notifyHandler) {
            return await this._notifyHandler(event);
        }
        return Promise.resolve();
    }
}

const log$n = globalLogger.createChild("ConnectHandler");
class ConnectHandler extends BasicHandler {
  canHandle(event) {
    return event.method === "startConnect";
  }
  async handle(event) {
    const manifestUrl = this.extractManifestUrl(event);
    let manifest = null;
    if (manifestUrl) {
      try {
        manifest = await this.fetchManifest(manifestUrl);
      } catch (error) {
        log$n.warn("Failed to fetch manifest", { error });
      }
    }
    const connectEvent = {
      id: event.id,
      dAppName: this.extractDAppName(event, manifest),
      dAppUrl: manifest?.url || "",
      manifestUrl,
      request: event.params?.items || [],
      preview: this.createPreview(event, manifest)
    };
    return connectEvent;
  }
  /**
   * Extract dApp name from bridge event or manifest
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  extractDAppName(event, manifest) {
    const name = manifest?.name || // eslint-disable-next-line @typescript-eslint/no-explicit-any
    event.params?.manifest?.name || // event.params?.dAppName ||
    // event.params?.name ||
    "Unknown dApp";
    return sanitizeString(name);
  }
  /**
   * Extract manifest URL from bridge event
   */
  extractManifestUrl(event) {
    const url = event.params?.manifest?.url || "";
    return sanitizeString(url);
  }
  /**
   * Create preview object for connect request
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  createPreview(event, fetchedManifest) {
    const eventManifest = event.params?.manifest;
    const manifest = fetchedManifest || eventManifest;
    const sanitizedManifest = manifest && {
      name: sanitizeString(manifest.name || ""),
      description: sanitizeString(manifest.description || ""),
      url: sanitizeString(manifest.url || ""),
      iconUrl: sanitizeString(manifest.iconUrl || "")
    };
    const requestedItems = event.params?.items || [];
    const permissions = [];
    const addrItem = requestedItems.find((item) => item.name === "ton_addr");
    if (addrItem) {
      permissions.push({
        name: "ton_addr",
        title: "TON Address",
        description: "Gives dApp information about your TON address"
      });
    }
    const proofItem = requestedItems.find((item) => item.name === "ton_proof");
    if (proofItem) {
      permissions.push({
        name: "ton_proof",
        title: "TON Proof",
        description: "Gives dApp signature, that can be used to verify your identity"
      });
    }
    return {
      manifest: manifest ? sanitizedManifest : null,
      requestedItems: event.params?.items || [],
      permissions
    };
  }
  /**
   * Fetch manifest from URL
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async fetchManifest(manifestUrl) {
    const response = await fetch(manifestUrl);
    if (!response.ok) {
      throw new Error(`Failed to fetch manifest: ${response.statusText}`);
    }
    return response.json();
  }
}

var define_process_env_default = {};
function ot(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var T = { exports: {} }, A, v;
function nt() {
  if (v) return A;
  v = 1;
  var t = 1e3, e = t * 60, o = e * 60, n = o * 24, a = n * 7, r = n * 365.25;
  A = function(u, s) {
    s = s || {};
    var p = typeof u;
    if (p === "string" && u.length > 0)
      return d(u);
    if (p === "number" && isFinite(u))
      return s.long ? l(u) : i(u);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(u)
    );
  };
  function d(u) {
    if (u = String(u), !(u.length > 100)) {
      var s = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        u
      );
      if (s) {
        var p = parseFloat(s[1]), _ = (s[2] || "ms").toLowerCase();
        switch (_) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return p * r;
          case "weeks":
          case "week":
          case "w":
            return p * a;
          case "days":
          case "day":
          case "d":
            return p * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return p * o;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return p * e;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return p * t;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return p;
          default:
            return;
        }
      }
    }
  }
  function i(u) {
    var s = Math.abs(u);
    return s >= n ? Math.round(u / n) + "d" : s >= o ? Math.round(u / o) + "h" : s >= e ? Math.round(u / e) + "m" : s >= t ? Math.round(u / t) + "s" : u + "ms";
  }
  function l(u) {
    var s = Math.abs(u);
    return s >= n ? f(u, s, n, "day") : s >= o ? f(u, s, o, "hour") : s >= e ? f(u, s, e, "minute") : s >= t ? f(u, s, t, "second") : u + " ms";
  }
  function f(u, s, p, _) {
    var U = s >= p * 1.5;
    return Math.round(u / p) + " " + _ + (U ? "s" : "");
  }
  return A;
}
function at(t) {
  o.debug = o, o.default = o, o.coerce = l, o.disable = d, o.enable = a, o.enabled = i, o.humanize = nt(), o.destroy = f, Object.keys(t).forEach((u) => {
    o[u] = t[u];
  }), o.names = [], o.skips = [], o.formatters = {};
  function e(u) {
    let s = 0;
    for (let p = 0; p < u.length; p++)
      s = (s << 5) - s + u.charCodeAt(p), s |= 0;
    return o.colors[Math.abs(s) % o.colors.length];
  }
  o.selectColor = e;
  function o(u) {
    let s, p = null, _, U;
    function y(...h) {
      if (!y.enabled)
        return;
      const c = y, B = Number(/* @__PURE__ */ new Date()), P = B - (s || B);
      c.diff = P, c.prev = s, c.curr = B, s = B, h[0] = o.coerce(h[0]), typeof h[0] != "string" && h.unshift("%O");
      let k = 0;
      h[0] = h[0].replace(/%([a-zA-Z%])/g, (E, tt) => {
        if (E === "%%")
          return "%";
        k++;
        const L = o.formatters[tt];
        if (typeof L == "function") {
          const et = h[k];
          E = L.call(c, et), h.splice(k, 1), k--;
        }
        return E;
      }), o.formatArgs.call(c, h), (c.log || o.log).apply(c, h);
    }
    return y.namespace = u, y.useColors = o.useColors(), y.color = o.selectColor(u), y.extend = n, y.destroy = o.destroy, Object.defineProperty(y, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => p !== null ? p : (_ !== o.namespaces && (_ = o.namespaces, U = o.enabled(u)), U),
      set: (h) => {
        p = h;
      }
    }), typeof o.init == "function" && o.init(y), y;
  }
  function n(u, s) {
    const p = o(this.namespace + (typeof s > "u" ? ":" : s) + u);
    return p.log = this.log, p;
  }
  function a(u) {
    o.save(u), o.namespaces = u, o.names = [], o.skips = [];
    const s = (typeof u == "string" ? u : "").trim().replace(" ", ",").split(",").filter(Boolean);
    for (const p of s)
      p[0] === "-" ? o.skips.push(p.slice(1)) : o.names.push(p);
  }
  function r(u, s) {
    let p = 0, _ = 0, U = -1, y = 0;
    for (; p < u.length; )
      if (_ < s.length && (s[_] === u[p] || s[_] === "*"))
        s[_] === "*" ? (U = _, y = p, _++) : (p++, _++);
      else if (U !== -1)
        _ = U + 1, y++, p = y;
      else
        return false;
    for (; _ < s.length && s[_] === "*"; )
      _++;
    return _ === s.length;
  }
  function d() {
    const u = [
      ...o.names,
      ...o.skips.map((s) => "-" + s)
    ].join(",");
    return o.enable(""), u;
  }
  function i(u) {
    for (const s of o.skips)
      if (r(u, s))
        return false;
    for (const s of o.names)
      if (r(u, s))
        return true;
    return false;
  }
  function l(u) {
    return u instanceof Error ? u.stack || u.message : u;
  }
  function f() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return o.enable(o.load()), o;
}
var rt = at;
(function(t, e) {
  e.formatArgs = n, e.save = a, e.load = r, e.useColors = o, e.storage = d(), e.destroy = /* @__PURE__ */ (() => {
    let l = false;
    return () => {
      l || (l = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), e.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function o() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return true;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return false;
    let l;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (l = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(l[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function n(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !this.useColors)
      return;
    const f = "color: " + this.color;
    l.splice(1, 0, f, "color: inherit");
    let u = 0, s = 0;
    l[0].replace(/%[a-zA-Z%]/g, (p) => {
      p !== "%%" && (u++, p === "%c" && (s = u));
    }), l.splice(s, 0, f);
  }
  e.log = console.debug || console.log || (() => {
  });
  function a(l) {
    try {
      l ? e.storage.setItem("debug", l) : e.storage.removeItem("debug");
    } catch {
    }
  }
  function r() {
    let l;
    try {
      l = e.storage.getItem("debug");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = define_process_env_default.DEBUG), l;
  }
  function d() {
    try {
      return localStorage;
    } catch {
    }
  }
  t.exports = rt(e);
  const { formatters: i } = t.exports;
  i.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (f) {
      return "[UnexpectedJSONParseError]: " + f.message;
    }
  };
})(T, T.exports);
var dt = T.exports;
const $ = /* @__PURE__ */ ot(dt);
function g(t) {
  return t.toString(2).length;
}
function C(t) {
  if (t.remainingBits >= 1)
    return {
      kind: "Bool",
      value: t.loadUint(1) == 1
    };
  throw new Error('Expected one of "BoolFalse" in loading "BoolFalse", but data does not satisfy any constructor');
}
function b(t) {
  let e = t.loadUint(8), o = Array.from(Array(e).keys()).map((n) => t.loadUint(8));
  return {
    kind: "FixedLengthText",
    n: e,
    value: o
  };
}
function m(t, e) {
  if (t.remainingBits >= 1 && t.preloadUint(1) == 0)
    return t.loadUint(1), {
      kind: "Maybe_nothing"
    };
  if (t.remainingBits >= 1 && t.preloadUint(1) == 1)
    return t.loadUint(1), {
      kind: "Maybe_just",
      value: e(t)
    };
  throw new Error('Expected one of "Maybe_nothing", "Maybe_just" in loading "Maybe", but data does not satisfy any constructor');
}
function S(t, e, o) {
  if (t.remainingBits >= 1 && t.preloadUint(1) == 0)
    return t.loadUint(1), {
      kind: "Either_left",
      value: e(t)
    };
  if (t.remainingBits >= 1 && t.preloadUint(1) == 1)
    return t.loadUint(1), {
      kind: "Either_right",
      value: o(t)
    };
  throw new Error('Expected one of "Either_left", "Either_right" in loading "Either", but data does not satisfy any constructor');
}
function w(t) {
  return {
    kind: "JettonPayload",
    data: t.asCell()
  };
}
function N(t) {
  return {
    kind: "NFTPayload",
    data: t.asCell()
  };
}
function H(t) {
  return {
    kind: "Bytes",
    data: t.asCell()
  };
}
function R(t) {
  return {
    kind: "Text"
  };
}
function it(t) {
  if (t.remainingBits >= 16 && t.preloadUint(16) == 18516)
    return t.loadUint(16), {
      kind: "Protocol"
    };
  throw new Error('Expected one of "Protocol" in loading "Protocol", but data does not satisfy any constructor');
}
function K(t) {
  if (t.remainingBits >= 1 && t.preloadUint(1) == 0)
    return t.loadUint(1), {
      kind: "ProtoList_proto_list_nil"
    };
  if (t.remainingBits >= 1 && t.preloadUint(1) == 1) {
    t.loadUint(1);
    let e = it(t), o = K(t);
    return {
      kind: "ProtoList_proto_list_next",
      head: e,
      tail: o
    };
  }
  throw new Error('Expected one of "ProtoList_proto_list_nil", "ProtoList_proto_list_next" in loading "ProtoList", but data does not satisfy any constructor');
}
function lt(t) {
  if (t.remainingBits >= 16 && t.preloadUint(16) == 8567)
    return t.loadUint(16), {
      kind: "SmcCapability"
    };
  throw new Error('Expected one of "SmcCapability" in loading "SmcCapability", but data does not satisfy any constructor');
}
function z(t) {
  if (t.remainingBits >= 1 && t.preloadUint(1) == 0)
    return t.loadUint(1), {
      kind: "SmcCapList_cap_list_nil"
    };
  if (t.remainingBits >= 1 && t.preloadUint(1) == 1) {
    t.loadUint(1);
    let e = lt(t), o = z(t);
    return {
      kind: "SmcCapList_cap_list_next",
      head: e,
      tail: o
    };
  }
  throw new Error('Expected one of "SmcCapList_cap_list_nil", "SmcCapList_cap_list_next" in loading "SmcCapList", but data does not satisfy any constructor');
}
function st(t) {
  if (t.remainingBits >= 16 && t.preloadUint(16) == 40915) {
    t.loadUint(16);
    let e = t.loadAddress(), o = t.loadUint(8), n = o & 1 ? z(t) : void 0;
    if (!(o <= 1))
      throw new Error('Condition (flags <= 1) is not satisfied while loading "DNSRecord_dns_smc_address" for type "DNSRecord"');
    return {
      kind: "DNSRecord_dns_smc_address",
      smc_addr: e,
      flags: o,
      cap_list: n
    };
  }
  if (t.remainingBits >= 16 && t.preloadUint(16) == 47763)
    return t.loadUint(16), {
      kind: "DNSRecord_dns_next_resolver",
      resolver: t.loadAddress()
    };
  if (t.remainingBits >= 16 && t.preloadUint(16) == 44289) {
    t.loadUint(16);
    let e = t.loadBuffer(256 / 8), o = t.loadUint(8), n = o & 1 ? K(t) : void 0;
    if (!(o <= 1))
      throw new Error('Condition (flags <= 1) is not satisfied while loading "DNSRecord_dns_adnl_address" for type "DNSRecord"');
    return {
      kind: "DNSRecord_dns_adnl_address",
      adnl_addr: e,
      flags: o,
      proto_list: n
    };
  }
  if (t.remainingBits >= 16 && t.preloadUint(16) == 29811)
    return t.loadUint(16), {
      kind: "DNSRecord_dns_storage_address",
      bag_id: t.loadBuffer(256 / 8)
    };
  throw new Error('Expected one of "DNSRecord_dns_smc_address", "DNSRecord_dns_next_resolver", "DNSRecord_dns_adnl_address", "DNSRecord_dns_storage_address" in loading "DNSRecord", but data does not satisfy any constructor');
}
function ut(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1112786133) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadVarUintBig(g(15)), n = m(t, (a) => a.loadRef().beginParse(true).asCell());
    return {
      kind: "BemoStake",
      query_id: e,
      forward_ton_amount: o,
      forward_payload: n
    };
  }
  throw new Error('Expected one of "BemoStake" in loading "BemoStake", but data does not satisfy any constructor');
}
function ft(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1227534771) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddressAny(), n = t.loadVarUintBig(g(15)), a = t.loadVarUintBig(g(15)), r = m(t, (d) => d.loadRef().beginParse(true).asCell());
    return {
      kind: "BemoUnstake",
      index: e,
      owner: o,
      ton_amount: n,
      jetton_amount: a,
      forward_payload: r
    };
  }
  throw new Error('Expected one of "BemoUnstake" in loading "BemoUnstake", but data does not satisfy any constructor');
}
function pt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 279039605) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddressAny(), n = t.loadVarUintBig(g(15)), a = t.loadVarUintBig(g(15)), r = m(t, (i) => i.loadRef().beginParse(true).asCell()), d = t.loadUint(32);
    return {
      kind: "BemoDeployUnstakeRequest",
      query_id: e,
      owner_address: o,
      withdraw_ton_amount: n,
      withdraw_jetton_amount: a,
      forward_payload: r,
      lockup_timestamp: d
    };
  }
  throw new Error('Expected one of "BemoDeployUnstakeRequest" in loading "BemoDeployUnstakeRequest", but data does not satisfy any constructor');
}
function mt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2429028871) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = m(t, (n) => n.loadRef().beginParse(true).asCell());
    return {
      kind: "BemoUnstakeNotification",
      query_id: e,
      forward_payload: o
    };
  }
  throw new Error('Expected one of "BemoUnstakeNotification" in loading "BemoUnstakeNotification", but data does not satisfy any constructor');
}
function gt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 946025784)
    return t.loadUint(32), {
      kind: "BemoReturnUnstakeRequest",
      lockup_timestamp: t.loadUint(32)
    };
  throw new Error('Expected one of "BemoReturnUnstakeRequest" in loading "BemoReturnUnstakeRequest", but data does not satisfy any constructor');
}
function _t(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1544662441)
    return t.loadUint(32), {
      kind: "DaolamaVaultSupply",
      amount: t.loadCoins()
    };
  throw new Error('Expected one of "DaolamaVaultSupply" in loading "DaolamaVaultSupply", but data does not satisfy any constructor');
}
function yt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2078119902) {
    t.loadUint(32);
    let e = t.loadCoins(), o = t.loadAddressAny();
    return {
      kind: "DaolamaVaultWithdraw",
      jetton_amount: e,
      user_address: o
    };
  }
  throw new Error('Expected one of "DaolamaVaultWithdraw" in loading "DaolamaVaultWithdraw", but data does not satisfy any constructor');
}
function V(t) {
  if (t.remainingBits >= 4 && t.preloadUint(4) == 0)
    return t.loadUint(4), {
      kind: "DedustAsset_native"
    };
  if (t.remainingBits >= 4 && t.preloadUint(4) == 1) {
    t.loadUint(4);
    let e = t.loadInt(8), o = t.loadBuffer(256 / 8);
    return {
      kind: "DedustAsset_jetton",
      workchain_id: e,
      address: o
    };
  }
  if (t.remainingBits >= 4 && t.preloadUint(4) == 2)
    return t.loadUint(4), {
      kind: "DedustAsset_extra_currency",
      currency_id: t.loadInt(32)
    };
  throw new Error('Expected one of "DedustAsset_native", "DedustAsset_jetton", "DedustAsset_extra_currency" in loading "DedustAsset", but data does not satisfy any constructor');
}
function Ut(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3043726744) {
    t.loadUint(32);
    let e = t.loadUintBig(64), n = t.loadRef().beginParse(true).asCell(), a = t.loadAddressAny(), r = t.loadVarUintBig(g(15)), d = t.loadRef().beginParse(true), i = V(d), l = d.loadVarUintBig(g(15)), f = V(d), u = d.loadVarUintBig(g(15)), s = m(t, (_) => _.loadRef().beginParse(true).asCell()), p = m(t, (_) => _.loadRef().beginParse(true).asCell());
    return {
      kind: "DedustDepositLiquidityAll",
      query_id: e,
      proof: n,
      owner_addr: a,
      min_lp_amount: r,
      asset0: i,
      asset0_amount: l,
      asset1: f,
      asset1_amount: u,
      fulfill_payload: s,
      reject_payload: p
    };
  }
  throw new Error('Expected one of "DedustDepositLiquidityAll" in loading "DedustDepositLiquidityAll", but data does not satisfy any constructor');
}
function ht(t) {
  let e = t.loadUint(32), o = t.loadAddressAny(), n = t.loadAddressAny(), a = m(t, (d) => d.loadRef().beginParse(true).asCell()), r = m(t, (d) => d.loadRef().beginParse(true).asCell());
  return {
    kind: "DedustSwapParams",
    deadline: e,
    recipient_addr: o,
    referral_addr: n,
    fulfill_payload: a,
    reject_payload: r
  };
}
function Q(t) {
  let e = C(t), o = t.loadVarUintBig(g(15)), n = m(t, (a) => {
    let r = a.loadRef().beginParse(true);
    return Ct(r);
  });
  return {
    kind: "DedustSwapStepParams",
    kind_out: e,
    limit: o,
    next: n
  };
}
function Ct(t) {
  let e = t.loadAddressAny(), o = Q(t);
  return {
    kind: "DedustSwapStep",
    pool_addr: e,
    params: o
  };
}
function ct(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1643009069) {
    t.loadUint(32);
    let e = t.loadUintBig(64), n = t.loadRef().beginParse(true).asCell(), a = t.loadVarUintBig(g(15)), r = t.loadAddressAny(), d = Q(t), i = t.loadRef().beginParse(true), l = ht(i);
    return {
      kind: "DedustSwapExternal",
      query_id: e,
      proof: n,
      amount: a,
      sender_addr: r,
      current: d,
      swap_params: l
    };
  }
  throw new Error('Expected one of "DedustSwapExternal" in loading "DedustSwapExternal", but data does not satisfy any constructor');
}
function wt(t) {
  if (t.remainingBits >= 4 && t.preloadUint(4) == 0)
    return t.loadUint(4), {
      kind: "DedustAsset_native"
    };
  if (t.remainingBits >= 4 && t.preloadUint(4) == 1) {
    t.loadUint(4);
    let e = t.loadInt(8), o = t.loadBuffer(256 / 8);
    return {
      kind: "DedustAsset_jetton",
      workchain_id: e,
      address: o
    };
  }
  if (t.remainingBits >= 4 && t.preloadUint(4) == 2)
    return t.loadUint(4), {
      kind: "DedustAsset_extra_currency",
      currency_id: t.loadInt(32)
    };
  throw new Error('Expected one of "DedustAsset_native", "DedustAsset_jetton", "DedustAsset_extra_currency" in loading "DedustAsset", but data does not satisfy any constructor');
}
function kt(t) {
  let e = t.loadUint(32), o = t.loadAddressAny(), n = t.loadAddressAny(), a = m(t, (d) => d.loadRef().beginParse(true).asCell()), r = m(t, (d) => d.loadRef().beginParse(true).asCell());
  return {
    kind: "DedustSwapParams",
    deadline: e,
    recipient_addr: o,
    referral_addr: n,
    fulfill_payload: a,
    reject_payload: r
  };
}
function Z(t) {
  let e = C(t), o = t.loadVarUintBig(g(15)), n = m(t, (a) => {
    let r = a.loadRef().beginParse(true);
    return St(r);
  });
  return {
    kind: "DedustSwapStepParams",
    kind_out: e,
    limit: o,
    next: n
  };
}
function St(t) {
  let e = t.loadAddressAny(), o = Z(t);
  return {
    kind: "DedustSwapStep",
    pool_addr: e,
    params: o
  };
}
function Bt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1923917994) {
    t.loadUint(32);
    let e = t.loadUintBig(64), n = t.loadRef().beginParse(true).asCell(), a = wt(t), r = t.loadVarUintBig(g(15)), d = t.loadAddressAny(), i = Z(t), l = t.loadRef().beginParse(true), f = kt(l);
    return {
      kind: "DedustSwapPeer",
      query_id: e,
      proof: n,
      asset: a,
      amount: r,
      sender_addr: d,
      current: i,
      swap_params: f
    };
  }
  throw new Error('Expected one of "DedustSwapPeer" in loading "DedustSwapPeer", but data does not satisfy any constructor');
}
function xt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2907617013) {
    t.loadUint(32);
    let e = t.loadUintBig(64), n = t.loadRef().beginParse(true).asCell(), a = t.loadVarUintBig(g(15)), r = t.loadAddressAny(), d = m(t, (i) => i.loadRef().beginParse(true).asCell());
    return {
      kind: "DedustPayoutFromPool",
      query_id: e,
      proof: n,
      amount: a,
      recipient_addr: r,
      payload: d
    };
  }
  throw new Error('Expected one of "DedustPayoutFromPool" in loading "DedustPayoutFromPool", but data does not satisfy any constructor');
}
function bt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1196394191) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = m(t, (n) => n.loadRef().beginParse(true).asCell());
    return {
      kind: "DedustPayout",
      query_id: e,
      payload: o
    };
  }
  throw new Error('Expected one of "DedustPayout" in loading "DedustPayout", but data does not satisfy any constructor');
}
function Nt(t) {
  let e = t.loadUint(32), o = t.loadAddressAny(), n = t.loadAddressAny(), a = m(t, (d) => d.loadRef().beginParse(true).asCell()), r = m(t, (d) => d.loadRef().beginParse(true).asCell());
  return {
    kind: "DedustSwapParams",
    deadline: e,
    recipient_addr: o,
    referral_addr: n,
    fulfill_payload: a,
    reject_payload: r
  };
}
function Pt(t) {
  let e = C(t), o = t.loadVarUintBig(g(15)), n = m(t, (a) => {
    let r = a.loadRef().beginParse(true);
    return X(r);
  });
  return {
    kind: "DedustSwapStepParams",
    kind_out: e,
    limit: o,
    next: n
  };
}
function X(t) {
  let e = t.loadAddressAny(), o = Pt(t);
  return {
    kind: "DedustSwapStep",
    pool_addr: e,
    params: o
  };
}
function Et(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3926267997) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadCoins(), n = X(t), a = t.loadRef().beginParse(true), r = Nt(a);
    return {
      kind: "DedustSwap",
      query_id: e,
      amount: o,
      step: n,
      swap_params: r
    };
  }
  throw new Error('Expected one of "DedustSwap" in loading "DedustSwap", but data does not satisfy any constructor');
}
function F(t) {
  if (t.remainingBits >= 4 && t.preloadUint(4) == 0)
    return t.loadUint(4), {
      kind: "DedustAsset_native"
    };
  if (t.remainingBits >= 4 && t.preloadUint(4) == 1) {
    t.loadUint(4);
    let e = t.loadInt(8), o = t.loadBuffer(256 / 8);
    return {
      kind: "DedustAsset_jetton",
      workchain_id: e,
      address: o
    };
  }
  if (t.remainingBits >= 4 && t.preloadUint(4) == 2)
    return t.loadUint(4), {
      kind: "DedustAsset_extra_currency",
      currency_id: t.loadInt(32)
    };
  throw new Error('Expected one of "DedustAsset_native", "DedustAsset_jetton", "DedustAsset_extra_currency" in loading "DedustAsset", but data does not satisfy any constructor');
}
function At(t) {
  if (t.remainingBits >= 1 && t.preloadUint(1) == 0)
    return t.loadUint(1), {
      kind: "DedustPoolType_volatile"
    };
  if (t.remainingBits >= 1 && t.preloadUint(1) == 1)
    return t.loadUint(1), {
      kind: "DedustPoolType_stable"
    };
  throw new Error('Expected one of "DedustPoolType_volatile", "DedustPoolType_stable" in loading "DedustPoolType", but data does not satisfy any constructor');
}
function Tt(t) {
  let e = At(t), o = F(t), n = F(t);
  return {
    kind: "DedustPoolParams",
    pool_type: e,
    asset0: o,
    asset1: n
  };
}
function Dt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3579725446) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadCoins(), n = Tt(t), a = t.loadRef().beginParse(true), r = a.loadCoins(), d = a.loadCoins(), i = a.loadCoins(), l = m(t, (u) => u.loadRef().beginParse(true).asCell()), f = m(t, (u) => u.loadRef().beginParse(true).asCell());
    return {
      kind: "DedustDepositLiquidity",
      query_id: e,
      amount: o,
      pool_params: n,
      min_lp_amount: r,
      asset0_target_balance: d,
      asset1_target_balance: i,
      fulfill_payload: l,
      reject_payload: f
    };
  }
  throw new Error('Expected one of "DedustDepositLiquidity" in loading "DedustDepositLiquidity", but data does not satisfy any constructor');
}
function Rt(t) {
  if (t.remainingBits >= 4 && t.preloadUint(4) == 0)
    return t.loadUint(4), {
      kind: "DedustAsset_native"
    };
  if (t.remainingBits >= 4 && t.preloadUint(4) == 1) {
    t.loadUint(4);
    let e = t.loadInt(8), o = t.loadBuffer(256 / 8);
    return {
      kind: "DedustAsset_jetton",
      workchain_id: e,
      address: o
    };
  }
  if (t.remainingBits >= 4 && t.preloadUint(4) == 2)
    return t.loadUint(4), {
      kind: "DedustAsset_extra_currency",
      currency_id: t.loadInt(32)
    };
  throw new Error('Expected one of "DedustAsset_native", "DedustAsset_jetton", "DedustAsset_extra_currency" in loading "DedustAsset", but data does not satisfy any constructor');
}
function qt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 567271467) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = Rt(t);
    return {
      kind: "DedustCreateVault",
      query_id: e,
      asset: o
    };
  }
  throw new Error('Expected one of "DedustCreateVault" in loading "DedustCreateVault", but data does not satisfy any constructor');
}
function W(t) {
  if (t.remainingBits >= 4 && t.preloadUint(4) == 0)
    return t.loadUint(4), {
      kind: "DedustAsset_native"
    };
  if (t.remainingBits >= 4 && t.preloadUint(4) == 1) {
    t.loadUint(4);
    let e = t.loadInt(8), o = t.loadBuffer(256 / 8);
    return {
      kind: "DedustAsset_jetton",
      workchain_id: e,
      address: o
    };
  }
  if (t.remainingBits >= 4 && t.preloadUint(4) == 2)
    return t.loadUint(4), {
      kind: "DedustAsset_extra_currency",
      currency_id: t.loadInt(32)
    };
  throw new Error('Expected one of "DedustAsset_native", "DedustAsset_jetton", "DedustAsset_extra_currency" in loading "DedustAsset", but data does not satisfy any constructor');
}
function Lt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2547326767) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = W(t), n = W(t);
    return {
      kind: "DedustCreateVolatilePool",
      query_id: e,
      asset0: o,
      asset1: n
    };
  }
  throw new Error('Expected one of "DedustCreateVolatilePool" in loading "DedustCreateVolatilePool", but data does not satisfy any constructor');
}
function vt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 376237550) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = m(t, (n) => n.loadRef().beginParse(true).asCell());
    return {
      kind: "DedustCancelDeposit",
      query_id: e,
      payload: o
    };
  }
  throw new Error('Expected one of "DedustCancelDeposit" in loading "DedustCancelDeposit", but data does not satisfy any constructor');
}
function Vt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1322339173)
    return t.loadUint(32), {
      kind: "DnsBalanceRelease",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "DnsBalanceRelease" in loading "DnsBalanceRelease", but data does not satisfy any constructor');
}
function Ft(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1320284409) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadBuffer(256 / 8);
    return {
      kind: "DeleteDnsRecord",
      query_id: e,
      key: o
    };
  }
  throw new Error('Expected one of "DeleteDnsRecord" in loading "DeleteDnsRecord", but data does not satisfy any constructor');
}
function Wt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1320284409) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadBuffer(256 / 8), n = t.loadRef().beginParse(true), a = st(n);
    return {
      kind: "ChangeDnsRecord",
      query_id: e,
      key: o,
      value: a
    };
  }
  throw new Error('Expected one of "ChangeDnsRecord" in loading "ChangeDnsRecord", but data does not satisfy any constructor');
}
function Jt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1153347137)
    return t.loadUint(32), {
      kind: "ProcessGovernanceDecision",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "ProcessGovernanceDecision" in loading "ProcessGovernanceDecision", but data does not satisfy any constructor');
}
function It(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 923790417)
    return t.loadUint(32), {
      kind: "AuctionFillUp",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "AuctionFillUp" in loading "AuctionFillUp", but data does not satisfy any constructor');
}
function Ot(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1434249760)
    return t.loadUint(32), {
      kind: "OutbidNotification",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "OutbidNotification" in loading "OutbidNotification", but data does not satisfy any constructor');
}
function Mt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1298755173) {
    t.loadUint(32);
    let e = t.loadUint(8), o = t.loadUint(32), n = t.loadBuffer(256 / 8), a = t.loadBuffer(256 / 8), r = t.loadUintBig(128), d = t.loadBuffer(256 / 8);
    return {
      kind: "GramSubmitProofOfWork",
      flags: e,
      expire: o,
      whom: n,
      rdata1: a,
      rseed: r,
      rdata2: d
    };
  }
  throw new Error('Expected one of "GramSubmitProofOfWork" in loading "GramSubmitProofOfWork", but data does not satisfy any constructor');
}
function jt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1027039654) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddressAny(), n = t.loadVarUintBig(g(15)), a = t.loadVarUintBig(g(15)), r = t.loadAddressAny();
    return {
      kind: "HipoFinanceDepositCoins",
      query_id: e,
      owner: o,
      coins: n,
      ownership_assigned_amount: a,
      referrer: r
    };
  }
  throw new Error('Expected one of "HipoFinanceDepositCoins" in loading "HipoFinanceDepositCoins", but data does not satisfy any constructor');
}
function Gt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1541764646) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadVarUintBig(g(15)), n = t.loadVarUintBig(g(15)), a = t.loadAddressAny(), r = t.loadUint(32);
    return {
      kind: "HipoFinanceProxyTokensMinted",
      query_id: e,
      tokens: o,
      coins: n,
      owner: a,
      round_since: r
    };
  }
  throw new Error('Expected one of "HipoFinanceProxyTokensMinted" in loading "HipoFinanceProxyTokensMinted", but data does not satisfy any constructor');
}
function $t(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1413869550) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadVarUintBig(g(15)), n = t.loadVarUintBig(g(15)), a = t.loadAddressAny(), r = t.loadUint(32);
    return {
      kind: "HipoFinanceTokensMinted",
      query_id: e,
      tokens: o,
      coins: n,
      owner: a,
      round_since: r
    };
  }
  throw new Error('Expected one of "HipoFinanceTokensMinted" in loading "HipoFinanceTokensMinted", but data does not satisfy any constructor');
}
function Ht(t) {
  if (t.remainingBits >= 8 && t.preloadUint(8) == 0)
    return t.loadUint(8), {
      kind: "PaymentProviderUrl_none"
    };
  if (t.remainingBits >= 8 && t.preloadUint(8) == 1)
    return t.loadUint(8), {
      kind: "PaymentProviderUrl_tonsite",
      address: t.loadBuffer(256 / 8)
    };
  throw new Error('Expected one of "PaymentProviderUrl_none", "PaymentProviderUrl_tonsite" in loading "PaymentProviderUrl", but data does not satisfy any constructor');
}
function Kt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2057453237) {
    t.loadUint(32);
    let e = t.loadBuffer(128 / 8), o = Ht(t);
    return {
      kind: "InvoicePayload",
      id: e,
      url: o
    };
  }
  throw new Error('Expected one of "InvoicePayload" in loading "InvoicePayload", but data does not satisfy any constructor');
}
function zt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 260734629) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadVarUintBig(g(15)), n = t.loadAddressAny(), a = t.loadAddressAny(), r = m(t, (l) => l.loadRef().beginParse(true).asCell()), d = t.loadVarUintBig(g(15)), i = S(t, w, (l) => {
      let f = l.loadRef().beginParse(true);
      return w(f);
    });
    return {
      kind: "JettonTransfer",
      query_id: e,
      amount: o,
      destination: n,
      response_destination: a,
      custom_payload: r,
      forward_ton_amount: d,
      forward_payload: i
    };
  }
  throw new Error('Expected one of "JettonTransfer" in loading "JettonTransfer", but data does not satisfy any constructor');
}
function Qt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 395134233) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadVarUintBig(g(15)), n = t.loadAddressAny(), a = t.loadAddressAny(), r = t.loadVarUintBig(g(15)), d = S(t, w, (i) => {
      let l = i.loadRef().beginParse(true);
      return w(l);
    });
    return {
      kind: "JettonInternalTransfer",
      query_id: e,
      amount: o,
      from: n,
      response_address: a,
      forward_ton_amount: r,
      forward_payload: d
    };
  }
  throw new Error('Expected one of "JettonInternalTransfer" in loading "JettonInternalTransfer", but data does not satisfy any constructor');
}
function Zt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1499400124) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadVarUintBig(g(15)), n = t.loadAddressAny(), a = m(t, (r) => {
      let d = r.loadRef().beginParse(true);
      return w(d);
    });
    return {
      kind: "JettonBurn",
      query_id: e,
      amount: o,
      response_destination: n,
      custom_payload: a
    };
  }
  throw new Error('Expected one of "JettonBurn" in loading "JettonBurn", but data does not satisfy any constructor');
}
function Xt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2078119902) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadVarUintBig(g(15)), n = t.loadAddressAny(), a = t.loadAddressAny();
    return {
      kind: "JettonBurnNotification",
      query_id: e,
      amount: o,
      sender: n,
      response_destination: a
    };
  }
  throw new Error('Expected one of "JettonBurnNotification" in loading "JettonBurnNotification", but data does not satisfy any constructor');
}
function Yt(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1935855772) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadVarUintBig(g(15)), n = t.loadAddressAny(), a = S(t, w, (r) => {
      let d = r.loadRef().beginParse(true);
      return w(d);
    });
    return {
      kind: "JettonNotify",
      query_id: e,
      amount: o,
      sender: n,
      forward_payload: a
    };
  }
  throw new Error('Expected one of "JettonNotify" in loading "JettonNotify", but data does not satisfy any constructor');
}
function te(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4006754003) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadUint(4);
    return {
      kind: "JettonSetStatus",
      query_id: e,
      status: o
    };
  }
  throw new Error('Expected one of "JettonSetStatus" in loading "JettonSetStatus", but data does not satisfy any constructor');
}
function ee(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1680571655) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddress(), n = t.loadCoins();
    return {
      kind: "JettonMint",
      query_id: e,
      to_address: o,
      ton_amount: n
    };
  }
  throw new Error('Expected one of "JettonMint" in loading "JettonMint", but data does not satisfy any constructor');
}
function oe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1694626644) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddressAny();
    return {
      kind: "JettonChangeAdmin",
      query_id: e,
      new_admin_address: o
    };
  }
  throw new Error('Expected one of "JettonChangeAdmin" in loading "JettonChangeAdmin", but data does not satisfy any constructor');
}
function ne(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4220051737)
    return t.loadUint(32), {
      kind: "JettonClaimAdmin",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "JettonClaimAdmin" in loading "JettonClaimAdmin", but data does not satisfy any constructor');
}
function ae(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4006754003) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadUint(4);
    return {
      kind: "JettonForceAction_set_status",
      query_id: e,
      status: o
    };
  }
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1499400124) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadVarUintBig(g(15)), n = t.loadAddressAny(), a = m(t, (r) => {
      let d = r.loadRef().beginParse(true);
      return w(d);
    });
    return {
      kind: "JettonForceAction_burn",
      query_id: e,
      amount: o,
      response_destination: n,
      custom_payload: a
    };
  }
  if (t.remainingBits >= 32 && t.preloadUint(32) == 260734629) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadVarUintBig(g(15)), n = t.loadAddressAny(), a = t.loadAddressAny(), r = m(t, (l) => l.loadRef().beginParse(true).asCell()), d = t.loadVarUintBig(g(15)), i = S(t, w, (l) => {
      let f = l.loadRef().beginParse(true);
      return w(f);
    });
    return {
      kind: "JettonForceAction_transfer",
      query_id: e,
      amount: o,
      destination: n,
      response_destination: a,
      custom_payload: r,
      forward_ton_amount: d,
      forward_payload: i
    };
  }
  throw new Error('Expected one of "JettonForceAction_set_status", "JettonForceAction_burn", "JettonForceAction_transfer" in loading "JettonForceAction", but data does not satisfy any constructor');
}
function re(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 593276754) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddress(), n = t.loadCoins(), a = t.loadRef().beginParse(true), r = ae(a);
    return {
      kind: "JettonCallTo",
      query_id: e,
      to_address: o,
      ton_amount: n,
      master_msg: r
    };
  }
  throw new Error('Expected one of "JettonCallTo" in loading "JettonCallTo", but data does not satisfy any constructor');
}
function de(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 621336170) {
    t.loadUint(32);
    let e = t.loadUintBig(64), n = t.loadRef().beginParse(true).asCell(), r = t.loadRef().beginParse(true).asCell();
    return {
      kind: "JettonUpgrade",
      query_id: e,
      new_data: n,
      new_code: r
    };
  }
  throw new Error('Expected one of "JettonUpgrade" in loading "JettonUpgrade", but data does not satisfy any constructor');
}
function ie(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3414567170) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.asCell();
    return {
      kind: "JettonChangeMetadata",
      query_id: e,
      metadata: o
    };
  }
  throw new Error('Expected one of "JettonChangeMetadata" in loading "JettonChangeMetadata", but data does not satisfy any constructor');
}
function le(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4294967295)
    return t.loadUint(32), {
      kind: "Bounce",
      payload: t.asCell()
    };
  throw new Error('Expected one of "Bounce" in loading "Bounce", but data does not satisfy any constructor');
}
function se(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 0)
    return t.loadUint(32), {
      kind: "TextComment",
      text: R()
    };
  throw new Error('Expected one of "TextComment" in loading "TextComment", but data does not satisfy any constructor');
}
function ue(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 560454219)
    return t.loadUint(32), {
      kind: "EncryptedTextComment",
      cipher_text: H(t)
    };
  throw new Error('Expected one of "EncryptedTextComment" in loading "EncryptedTextComment", but data does not satisfy any constructor');
}
function fe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3576854235)
    return t.loadUint(32), {
      kind: "Excess",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "Excess" in loading "Excess", but data does not satisfy any constructor');
}
function pe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3547469196)
    return t.loadUint(32), {
      kind: "TopUp",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TopUp" in loading "TopUp", but data does not satisfy any constructor');
}
function me(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 378586628) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadCoins();
    return {
      kind: "Credit",
      query_id: e,
      amount: o
    };
  }
  throw new Error('Expected one of "Credit" in loading "Credit", but data does not satisfy any constructor');
}
function ge(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2068529894)
    return t.loadUint(32), {
      kind: "Approve",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "Approve" in loading "Approve", but data does not satisfy any constructor');
}
function _e(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3902843902)
    return t.loadUint(32), {
      kind: "Disapprove",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "Disapprove" in loading "Disapprove", but data does not satisfy any constructor');
}
function ye(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1316189259) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadBuffer(256 / 8), n = t.loadUint(32), a = t.loadUint(32), r = t.loadBuffer(256 / 8), i = t.loadRef().beginParse(true).loadBuffer(512 / 8);
    return {
      kind: "ElectorNewStake",
      query_id: e,
      validator_pubkey: o,
      stake_at: n,
      max_factor: a,
      adnl_addr: r,
      signature: i
    };
  }
  throw new Error('Expected one of "ElectorNewStake" in loading "ElectorNewStake", but data does not satisfy any constructor');
}
function Ue(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4084484172)
    return t.loadUint(32), {
      kind: "ElectorNewStakeConfirmation",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "ElectorNewStakeConfirmation" in loading "ElectorNewStakeConfirmation", but data does not satisfy any constructor');
}
function he(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1197831204)
    return t.loadUint(32), {
      kind: "ElectorRecoverStakeRequest",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "ElectorRecoverStakeRequest" in loading "ElectorRecoverStakeRequest", but data does not satisfy any constructor');
}
function Ce(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4184830756)
    return t.loadUint(32), {
      kind: "ElectorRecoverStakeResponse",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "ElectorRecoverStakeResponse" in loading "ElectorRecoverStakeResponse", but data does not satisfy any constructor');
}
function ce(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3946265093)
    return t.loadUint(32), {
      kind: "TonstakeControllerRecoverStake",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeControllerRecoverStake" in loading "TonstakeControllerRecoverStake", but data does not satisfy any constructor');
}
function we(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4043121232)
    return t.loadUint(32), {
      kind: "TonstakeControllerUpdateValidatorHash",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeControllerUpdateValidatorHash" in loading "TonstakeControllerUpdateValidatorHash", but data does not satisfy any constructor');
}
function ke(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2399065977) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadCoins();
    return {
      kind: "TonstakeControllerWithdrawValidator",
      query_id: e,
      value: o
    };
  }
  throw new Error('Expected one of "TonstakeControllerWithdrawValidator" in loading "TonstakeControllerWithdrawValidator", but data does not satisfy any constructor');
}
function Se(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 805462823) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadCoins();
    return {
      kind: "TonstakeControllerValidatorWithdrawal",
      query_id: e,
      amount: o
    };
  }
  throw new Error('Expected one of "TonstakeControllerValidatorWithdrawal" in loading "TonstakeControllerValidatorWithdrawal", but data does not satisfy any constructor');
}
function Be(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3763363086) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadCoins(), n = t.loadUintBig(256), a = t.loadUint(32), r = t.loadUint(32), d = t.loadUintBig(256), l = t.loadRef().beginParse(true).loadBuffer(512 / 8);
    return {
      kind: "TonstakeControllerNewStake",
      query_id: e,
      value: o,
      validator_pubkey: n,
      stake_at: a,
      max_factor: r,
      adnl_addr: d,
      signature: l
    };
  }
  throw new Error('Expected one of "TonstakeControllerNewStake" in loading "TonstakeControllerNewStake", but data does not satisfy any constructor');
}
function xe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1664463130) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadCoins(), n = t.loadCoins(), a = t.loadUint(24);
    return {
      kind: "TonstakeControllerSendRequestLoan",
      query_id: e,
      min_loan: o,
      max_loan: n,
      max_interst: a
    };
  }
  throw new Error('Expected one of "TonstakeControllerSendRequestLoan" in loading "TonstakeControllerSendRequestLoan", but data does not satisfy any constructor');
}
function be(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3983767718)
    return t.loadUint(32), {
      kind: "TonstakeControllerReturnUnusedLoan",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeControllerReturnUnusedLoan" in loading "TonstakeControllerReturnUnusedLoan", but data does not satisfy any constructor');
}
function Ne(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1438805205)
    return t.loadUint(32), {
      kind: "TonstakeControllerReturnAvailableFunds",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeControllerReturnAvailableFunds" in loading "TonstakeControllerReturnAvailableFunds", but data does not satisfy any constructor');
}
function Pe(t) {
  let e = t.loadUint(32), o = t.loadAddressAny(), n = t.loadAddressAny(), a = t.loadAddressAny(), r = t.loadRef().beginParse(true), d = r.loadAddressAny(), i = r.loadAddressAny();
  return {
    kind: "TonstakersControllerData",
    controller_id: e,
    validator: o,
    pool: n,
    governor: a,
    approver: d,
    halter: i
  };
}
function Ee(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3863136613) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadCoins(), n = t.loadCoins(), a = t.loadUint(24), r = t.loadRef().beginParse(true), d = Pe(r);
    return {
      kind: "TonstakePoolRequestLoan",
      query_id: e,
      min_loan: o,
      max_loan: n,
      max_interest: a,
      controller_data: d
    };
  }
  throw new Error('Expected one of "TonstakePoolRequestLoan" in loading "TonstakePoolRequestLoan", but data does not satisfy any constructor');
}
function Ae(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3755778683)
    return t.loadUint(32), {
      kind: "TonstakePoolLoanRepayment",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakePoolLoanRepayment" in loading "TonstakePoolLoanRepayment", but data does not satisfy any constructor');
}
function Te$1(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1205158801) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.asCell();
    return {
      kind: "TonstakePoolDeposit",
      query_id: e,
      referral: o
    };
  }
  throw new Error('Expected one of "TonstakePoolDeposit" in loading "TonstakePoolDeposit", but data does not satisfy any constructor');
}
function De(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1271382751)
    return t.loadUint(32), {
      kind: "TonstakePoolTouch",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakePoolTouch" in loading "TonstakePoolTouch", but data does not satisfy any constructor');
}
function Re(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 715822752) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadUint(16);
    return {
      kind: "TonstakePoolSetGovernanceFee",
      query_id: e,
      governance_fee: o
    };
  }
  throw new Error('Expected one of "TonstakePoolSetGovernanceFee" in loading "TonstakePoolSetGovernanceFee", but data does not satisfy any constructor');
}
function qe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 832244956) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadCoins(), n = t.loadAddressAny(), a = t.loadAddressAny();
    return {
      kind: "TonstakePoolWithdraw",
      query_id: e,
      jetton_amount: o,
      from_address: n,
      response_address: a
    };
  }
  throw new Error('Expected one of "TonstakePoolWithdraw" in loading "TonstakePoolWithdraw", but data does not satisfy any constructor');
}
function Le(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 175592284)
    return t.loadUint(32), {
      kind: "TonstakePoolWithdrawal",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakePoolWithdrawal" in loading "TonstakePoolWithdrawal", but data does not satisfy any constructor');
}
function ve(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1582399286) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = m(t, (r) => r.loadAddressAny()), n = m(t, (r) => r.loadAddressAny()), a = m(t, (r) => r.loadAddressAny());
    return {
      kind: "TonstakePoolSetRoles",
      query_id: e,
      governor: o,
      interest_manager: n,
      halter: a
    };
  }
  throw new Error('Expected one of "TonstakePoolSetRoles" in loading "TonstakePoolSetRoles", but data does not satisfy any constructor');
}
function Ve(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2616546844) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = C(t), n = C(t);
    return {
      kind: "TonstakePoolSetDepositSettings",
      query_id: e,
      optimistic_deposit_withdrawals: o,
      deposits_open: n
    };
  }
  throw new Error('Expected one of "TonstakePoolSetDepositSettings" in loading "TonstakePoolSetDepositSettings", but data does not satisfy any constructor');
}
function Fe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2994658477) {
    t.loadUint(32);
    let e = t.loadUint(32), o = t.loadUintBig(64);
    return {
      kind: "TonstakePoolDeployController",
      controller_id: e,
      query_id: o
    };
  }
  throw new Error('Expected one of "TonstakePoolDeployController" in loading "TonstakePoolDeployController", but data does not satisfy any constructor');
}
function We(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2574354460) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadUintBig(48);
    return {
      kind: "TonstakePoolPrepareGovernanceMigration",
      query_id: e,
      governor_update_after: o
    };
  }
  throw new Error('Expected one of "TonstakePoolPrepareGovernanceMigration" in loading "TonstakePoolPrepareGovernanceMigration", but data does not satisfy any constructor');
}
function Je(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 654743035) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadUint(8), a = t.loadRef().beginParse(true).asCell();
    return {
      kind: "TonstakeControllerPoolSendMessage",
      query_id: e,
      mode: o,
      msg: a
    };
  }
  throw new Error('Expected one of "TonstakeControllerPoolSendMessage" in loading "TonstakeControllerPoolSendMessage", but data does not satisfy any constructor');
}
function Ie(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2531783976) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = m(t, (r) => r.loadRef().beginParse(true).asCell()), n = m(t, (r) => r.loadRef().beginParse(true).asCell()), a = m(t, (r) => r.loadRef().beginParse(true).asCell());
    return {
      kind: "TonstakeControllerPoolUpgrade",
      query_id: e,
      data: o,
      code: n,
      after_upgrade: a
    };
  }
  throw new Error('Expected one of "TonstakeControllerPoolUpgrade" in loading "TonstakeControllerPoolUpgrade", but data does not satisfy any constructor');
}
function Oe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2045231126) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddressAny();
    return {
      kind: "TonstakeControllerPoolSetSudoer",
      query_id: e,
      sudoer: o
    };
  }
  throw new Error('Expected one of "TonstakeControllerPoolSetSudoer" in loading "TonstakeControllerPoolSetSudoer", but data does not satisfy any constructor');
}
function Me(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1917314981)
    return t.loadUint(32), {
      kind: "TonstakeControllerPoolUnhalt",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeControllerPoolUnhalt" in loading "TonstakeControllerPoolUnhalt", but data does not satisfy any constructor');
}
function je(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 328866638)
    return t.loadUint(32), {
      kind: "TonstakeControllerPoolHalt",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeControllerPoolHalt" in loading "TonstakeControllerPoolHalt", but data does not satisfy any constructor');
}
function Ge(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3387966597) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadUint(16);
    return {
      kind: "TonstakeImanagerSetInterest",
      query_id: e,
      interest_rate: o
    };
  }
  throw new Error('Expected one of "TonstakeImanagerSetInterest" in loading "TonstakeImanagerSetInterest", but data does not satisfy any constructor');
}
function $e(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1423144071)
    return t.loadUint(32), {
      kind: "TonstakeImanagerOperationFee",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeImanagerOperationFee" in loading "TonstakeImanagerOperationFee", but data does not satisfy any constructor');
}
function He(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2985012742) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadCoins(), n = t.loadCoins(), a = t.loadUint(16);
    return {
      kind: "TonstakeImanagerRequestNotification",
      query_id: e,
      min_loan: o,
      max_loan: n,
      max_interest: a
    };
  }
  throw new Error('Expected one of "TonstakeImanagerRequestNotification" in loading "TonstakeImanagerRequestNotification", but data does not satisfy any constructor');
}
function Ke(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3241429248) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadCoins(), n = t.loadCoins(), a = t.loadCoins(), r = t.loadInt(1), d = t.loadCoins(), i = t.loadCoins();
    return {
      kind: "TonstakeImanagerStats",
      query_id: e,
      borrowed: o,
      expected: n,
      returned: a,
      profit_sign: r,
      profit: d,
      total_balance: i
    };
  }
  throw new Error('Expected one of "TonstakeImanagerStats" in loading "TonstakeImanagerStats", but data does not satisfy any constructor');
}
function ze(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4045930062)
    return t.loadUint(32), {
      kind: "TonstakeNftBurn",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeNftBurn" in loading "TonstakeNftBurn", but data does not satisfy any constructor');
}
function Qe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3982012594) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadCoins(), n = t.loadAddressAny(), a = t.loadUintBig(64);
    return {
      kind: "TonstakeNftBurnNotification",
      query_id: e,
      amount: o,
      owner: n,
      index: a
    };
  }
  throw new Error('Expected one of "TonstakeNftBurnNotification" in loading "TonstakeNftBurnNotification", but data does not satisfy any constructor');
}
function Ze(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 321886789) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddressAny(), n = t.loadCoins(), a = t.loadAddressAny(), r = t.loadAddressAny();
    return {
      kind: "TonstakeNftInit",
      query_id: e,
      owner: o,
      amount: n,
      prev: a,
      next: r
    };
  }
  throw new Error('Expected one of "TonstakeNftInit" in loading "TonstakeNftInit", but data does not satisfy any constructor');
}
function Xe(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3678112445)
    return t.loadUint(32), {
      kind: "TonstakeNftPayout",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "TonstakeNftPayout" in loading "TonstakeNftPayout", but data does not satisfy any constructor');
}
function Ye(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 376746144) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddressAny(), n = t.loadCoins(), a = t.loadCoins(), r = t.loadCoins();
    return {
      kind: "TonstakePayoutMintJettons",
      query_id: e,
      destination: o,
      amount: n,
      notification: a,
      forward: r
    };
  }
  throw new Error('Expected one of "TonstakePayoutMintJettons" in loading "TonstakePayoutMintJettons", but data does not satisfy any constructor');
}
function to(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2007184673) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadCoins();
    return {
      kind: "MegatonWtonMint",
      query_id: e,
      amount: o
    };
  }
  throw new Error('Expected one of "MegatonWtonMint" in loading "MegatonWtonMint", but data does not satisfy any constructor');
}
function eo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1607220500) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddressAny(), n = t.loadAddressAny(), a = m(t, (i) => i.loadRef().beginParse(true).asCell()), r = t.loadVarUintBig(g(15)), d = S(t, N, (i) => {
      let l = i.loadRef().beginParse(true);
      return N(l);
    });
    return {
      kind: "NftTransfer",
      query_id: e,
      new_owner: o,
      response_destination: n,
      custom_payload: a,
      forward_amount: r,
      forward_payload: d
    };
  }
  throw new Error('Expected one of "NftTransfer" in loading "NftTransfer", but data does not satisfy any constructor');
}
function oo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 85167505) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddressAny(), n = S(t, N, (a) => {
      let r = a.loadRef().beginParse(true);
      return N(r);
    });
    return {
      kind: "NftOwnershipAssigned",
      query_id: e,
      prev_owner: o,
      forward_payload: n
    };
  }
  throw new Error('Expected one of "NftOwnershipAssigned" in loading "NftOwnershipAssigned", but data does not satisfy any constructor');
}
function no(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 801842850)
    return t.loadUint(32), {
      kind: "GetStaticData",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "GetStaticData" in loading "GetStaticData", but data does not satisfy any constructor');
}
function ao(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2339837749) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadUintBig(256), n = t.loadAddressAny();
    return {
      kind: "ReportStaticData",
      query_id: e,
      index: o,
      collection: n
    };
  }
  throw new Error('Expected one of "ReportStaticData" in loading "ReportStaticData", but data does not satisfy any constructor');
}
function ro(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1765620048)
    return t.loadUint(32), {
      kind: "GetRoyaltyParams",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "GetRoyaltyParams" in loading "GetRoyaltyParams", but data does not satisfy any constructor');
}
function io(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2831876269) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadUint(16), n = t.loadUint(16), a = t.loadAddressAny();
    return {
      kind: "ReportRoyaltyParams",
      query_id: e,
      numerator: o,
      denominator: n,
      destination: a
    };
  }
  throw new Error('Expected one of "ReportRoyaltyParams" in loading "ReportRoyaltyParams", but data does not satisfy any constructor');
}
function lo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 81711432) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddressAny(), a = t.loadRef().beginParse(true).asCell(), r = C(t);
    return {
      kind: "ProveOwnership",
      query_id: e,
      dest: o,
      forward_payload: a,
      with_content: r
    };
  }
  throw new Error('Expected one of "ProveOwnership" in loading "ProveOwnership", but data does not satisfy any constructor');
}
function so(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 86296494) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadUintBig(256), n = t.loadAddressAny(), r = t.loadRef().beginParse(true).asCell(), d = t.loadUintBig(64), i = m(t, (l) => l.loadRef().beginParse(true).asCell());
    return {
      kind: "OwnershipProof",
      query_id: e,
      item_id: o,
      owner: n,
      data: r,
      revoked_at: d,
      content: i
    };
  }
  throw new Error('Expected one of "OwnershipProof" in loading "OwnershipProof", but data does not satisfy any constructor');
}
function uo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3502489578) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddressAny(), a = t.loadRef().beginParse(true).asCell(), r = C(t);
    return {
      kind: "SbtRequestOwner",
      query_id: e,
      dest: o,
      forward_payload: a,
      with_content: r
    };
  }
  throw new Error('Expected one of "SbtRequestOwner" in loading "SbtRequestOwner", but data does not satisfy any constructor');
}
function fo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 232130531) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadUintBig(256), n = t.loadAddressAny(), a = t.loadAddressAny(), d = t.loadRef().beginParse(true).asCell(), i = t.loadUintBig(64), l = m(t, (f) => f.loadRef().beginParse(true).asCell());
    return {
      kind: "SbtOwnerInfo",
      query_id: e,
      item_id: o,
      initiator: n,
      owner: a,
      data: d,
      revoked_at: i,
      content: l
    };
  }
  throw new Error('Expected one of "SbtOwnerInfo" in loading "SbtOwnerInfo", but data does not satisfy any constructor');
}
function po(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 520377210)
    return t.loadUint(32), {
      kind: "SbtDestroy",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "SbtDestroy" in loading "SbtDestroy", but data does not satisfy any constructor');
}
function mo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1871312355)
    return t.loadUint(32), {
      kind: "SbtRevoke",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "SbtRevoke" in loading "SbtRevoke", but data does not satisfy any constructor');
}
function go(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1741148801) {
    t.loadUint(32);
    let e = t.loadCoins(), o = t.loadCoins();
    return {
      kind: "TopUpChannelBalance",
      add_A: e,
      add_B: o
    };
  }
  throw new Error('Expected one of "TopUpChannelBalance" in loading "TopUpChannelBalance", but data does not satisfy any constructor');
}
function _o(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 235282626) {
    t.loadUint(32);
    let e = C(t), o = t.loadBuffer(512 / 8), n = t.loadUint(32), a = t.loadUintBig(128), r = t.loadCoins(), d = t.loadCoins();
    return {
      kind: "InitPaymentChannel",
      is_A: e,
      signature: o,
      tag: n,
      channel_id: a,
      balance_A: r,
      balance_B: d
    };
  }
  throw new Error('Expected one of "InitPaymentChannel" in loading "InitPaymentChannel", but data does not satisfy any constructor');
}
function yo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1433884798) {
    t.loadUint(32);
    let o = t.loadRef().beginParse(true).loadBuffer(512 / 8), a = t.loadRef().beginParse(true).loadBuffer(512 / 8), r = t.loadUint(32), d = t.loadUintBig(128), i = t.loadCoins(), l = t.loadCoins(), f = t.loadUintBig(64), u = t.loadUintBig(64);
    return {
      kind: "ChannelCooperativeClose",
      sig_A: o,
      sig_B: a,
      tag: r,
      channel_id: d,
      balance_A: i,
      balance_B: l,
      seqno_A: f,
      seqno_B: u
    };
  }
  throw new Error('Expected one of "ChannelCooperativeClose" in loading "ChannelCooperativeClose", but data does not satisfy any constructor');
}
function Uo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2040604399) {
    t.loadUint(32);
    let o = t.loadRef().beginParse(true).loadBuffer(512 / 8), a = t.loadRef().beginParse(true).loadBuffer(512 / 8), r = t.loadUint(32), d = t.loadUintBig(128), i = t.loadUintBig(64), l = t.loadUintBig(64);
    return {
      kind: "ChannelCooperativeCommit",
      sig_A: o,
      sig_B: a,
      tag: r,
      channel_id: d,
      seqno_A: i,
      seqno_B: l
    };
  }
  throw new Error('Expected one of "ChannelCooperativeCommit" in loading "ChannelCooperativeCommit", but data does not satisfy any constructor');
}
function ho(t) {
  let e = t.loadCoins(), o = t.asCell();
  return {
    kind: "ConditionalPayment",
    amount: e,
    condition: o
  };
}
function J(t) {
  let e = t.loadUintBig(64), o = t.loadCoins(), n = distExports$2.Dictionary.load(distExports$2.Dictionary.Keys.Uint(32), {
    serialize: () => {
      throw new Error("Not implemented");
    },
    parse: ho
  }, t);
  return {
    kind: "SemiChannelBody",
    seqno: e,
    sent: o,
    conditionals: n
  };
}
function Co(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1130910580) {
    t.loadUint(32);
    let e = t.loadUintBig(128), o = J(t), n = m(t, (a) => {
      let r = a.loadRef().beginParse(true);
      return J(r);
    });
    return {
      kind: "SemiChannel",
      channel_id: e,
      data: o,
      counterparty_data: n
    };
  }
  throw new Error('Expected one of "SemiChannel" in loading "SemiChannel", but data does not satisfy any constructor');
}
function I(t) {
  let e = t.loadBuffer(64), o = Co(t);
  return {
    kind: "SignedSemiChannel",
    signature: e,
    state: o
  };
}
function co(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 521476815) {
    t.loadUint(32);
    let e = C(t), o = t.loadBuffer(512 / 8), n = t.loadUint(32), a = t.loadUintBig(128), r = t.loadRef().beginParse(true), d = I(r), i = t.loadRef().beginParse(true), l = I(i);
    return {
      kind: "StartUncooperativeChannelClose",
      signed_by_A: e,
      signature: o,
      tag: n,
      channel_id: a,
      sch_A: d,
      sch_B: l
    };
  }
  throw new Error('Expected one of "StartUncooperativeChannelClose" in loading "StartUncooperativeChannelClose", but data does not satisfy any constructor');
}
function wo(t) {
  let e = t.loadCoins(), o = t.asCell();
  return {
    kind: "ConditionalPayment",
    amount: e,
    condition: o
  };
}
function O(t) {
  let e = t.loadUintBig(64), o = t.loadCoins(), n = distExports$2.Dictionary.load(distExports$2.Dictionary.Keys.Uint(32), {
    serialize: () => {
      throw new Error("Not implemented");
    },
    parse: wo
  }, t);
  return {
    kind: "SemiChannelBody",
    seqno: e,
    sent: o,
    conditionals: n
  };
}
function ko(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1130910580) {
    t.loadUint(32);
    let e = t.loadUintBig(128), o = O(t), n = m(t, (a) => {
      let r = a.loadRef().beginParse(true);
      return O(r);
    });
    return {
      kind: "SemiChannel",
      channel_id: e,
      data: o,
      counterparty_data: n
    };
  }
  throw new Error('Expected one of "SemiChannel" in loading "SemiChannel", but data does not satisfy any constructor');
}
function M(t) {
  let e = t.loadBuffer(64), o = ko(t);
  return {
    kind: "SignedSemiChannel",
    signature: e,
    state: o
  };
}
function So(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 143567410) {
    t.loadUint(32);
    let e = C(t), o = t.loadBuffer(512 / 8), n = t.loadUint(32), a = t.loadUintBig(128), r = t.loadRef().beginParse(true), d = M(r), i = t.loadRef().beginParse(true), l = M(i);
    return {
      kind: "ChallengeQuarantinedChannelState",
      challenged_by_A: e,
      signature: o,
      tag: n,
      channel_id: a,
      sch_A: d,
      sch_B: l
    };
  }
  throw new Error('Expected one of "ChallengeQuarantinedChannelState" in loading "ChallengeQuarantinedChannelState", but data does not satisfy any constructor');
}
function Bo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1727459433) {
    t.loadUint(32);
    let e = C(t), o = t.loadBuffer(512 / 8), n = t.loadUint(32), a = t.loadUintBig(128), r = distExports$2.Dictionary.load(distExports$2.Dictionary.Keys.Uint(32), {
      serialize: () => {
        throw new Error("Not implemented");
      },
      parse: (d) => d.asCell()
    }, t);
    return {
      kind: "SettleChannelConditionals",
      from_A: e,
      signature: o,
      tag: n,
      channel_id: a,
      conditionals_to_settle: r
    };
  }
  throw new Error('Expected one of "SettleChannelConditionals" in loading "SettleChannelConditionals", but data does not satisfy any constructor');
}
function xo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 625158801)
    return t.loadUint(32), {
      kind: "FinishUncooperativeChannelClose"
    };
  throw new Error('Expected one of "FinishUncooperativeChannelClose" in loading "FinishUncooperativeChannelClose", but data does not satisfy any constructor');
}
function bo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3722217658)
    return t.loadUint(32), {
      kind: "ChannelClosed",
      channel_id: t.loadUintBig(128)
    };
  throw new Error('Expected one of "ChannelClosed" in loading "ChannelClosed", but data does not satisfy any constructor');
}
function No(t) {
  return {
    kind: "StonfiSwapAddrs",
    from_user: t.loadAddressAny()
  };
}
function Po(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 630424929) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddressAny(), n = t.loadAddressAny(), a = t.loadVarUintBig(g(15)), r = t.loadVarUintBig(g(15)), d = C(t), i = t.loadRef().beginParse(true), l = No(i);
    return {
      kind: "StonfiSwap",
      query_id: e,
      to_address: o,
      sender_address: n,
      jetton_amount: a,
      min_out: r,
      has_ref_address: d,
      addrs: l
    };
  }
  throw new Error('Expected one of "StonfiSwap" in loading "StonfiSwap", but data does not satisfy any constructor');
}
function j(t) {
  let e = t.loadVarUintBig(g(15)), o = t.loadAddressAny(), n = t.loadVarUintBig(g(15)), a = t.loadAddressAny();
  return {
    kind: "StonfiPayToParams",
    amount0_out: e,
    token0_address: o,
    amount1_out: n,
    token1_address: a
  };
}
function Eo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4181439551) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddressAny(), n = t.loadUint(32), a = S(t, j, (r) => {
      let d = r.loadRef().beginParse(true);
      return j(d);
    });
    return {
      kind: "StonfiPaymentRequest",
      query_id: e,
      owner: o,
      exit_code: n,
      params: a
    };
  }
  throw new Error('Expected one of "StonfiPaymentRequest" in loading "StonfiPaymentRequest", but data does not satisfy any constructor');
}
function Ao(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 32736093) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadCoins(), n = t.loadAddressAny(), a = S(t, (r) => r.asCell(), (r) => r.loadRef().beginParse(true).asCell());
    return {
      kind: "PtonTonTransfer",
      query_id: e,
      ton_amount: o,
      refund_address: n,
      forward_payload: a
    };
  }
  throw new Error('Expected one of "PtonTonTransfer" in loading "PtonTonTransfer", but data does not satisfy any constructor');
}
function To(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2921715614)
    return t.loadUint(32), {
      kind: "PtonTonRefund",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "PtonTonRefund" in loading "PtonTonRefund", but data does not satisfy any constructor');
}
function Do(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 701638965)
    return t.loadUint(32), {
      kind: "PtonResetGas",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "PtonResetGas" in loading "PtonResetGas", but data does not satisfy any constructor');
}
function Ro(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1331643155) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddressAny(), n = t.loadAddressAny();
    return {
      kind: "PtonDeployWallet",
      query_id: e,
      owner_address: o,
      excesses_address: n
    };
  }
  throw new Error('Expected one of "PtonDeployWallet" in loading "PtonDeployWallet", but data does not satisfy any constructor');
}
function qo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1698746245) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddressAny();
    return {
      kind: "PtonInternalDeploy",
      query_id: e,
      excesses_address: o
    };
  }
  throw new Error('Expected one of "PtonInternalDeploy" in loading "PtonInternalDeploy", but data does not satisfy any constructor');
}
function Lo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 116184359) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadVarUintBig(g(15)), n = t.loadVarUintBig(g(15)), a = t.loadAddressAny(), r = t.loadVarUintBig(g(15)), d = t.loadCoins(), i = m(t, (p) => p.loadRef().beginParse(true).asCell()), l = t.loadRef().beginParse(true), f = l.loadAddressAny(), u = l.loadAddressAny(), s = l.loadAddressAny();
    return {
      kind: "StonfiCbAddLiquidityV2",
      query_id: e,
      tot_am0: o,
      tot_am1: n,
      user_address: a,
      min_lp_out: r,
      fwd_amount: d,
      custom_payload_cs: i,
      to_user_address: f,
      refund_address: u,
      excess_address: s
    };
  }
  throw new Error('Expected one of "StonfiCbAddLiquidityV2" in loading "StonfiCbAddLiquidityV2", but data does not satisfy any constructor');
}
function vo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 935368415) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddressAny(), n = t.loadVarUintBig(g(15)), a = t.loadVarUintBig(g(15)), r = t.loadRef().beginParse(true), d = r.loadUint(32), i = r.loadAddressAny(), l = r.loadAddressAny(), f = r.loadAddressAny(), u = r.loadUintBig(64), s = r.loadRef().beginParse(true), p = s.loadVarUintBig(g(15)), _ = s.loadAddressAny(), U = s.loadUint(1), y = s.loadCoins(), h = m(s, (c) => c.loadRef().beginParse(true).asCell());
    return {
      kind: "StonfiProvideLpV2",
      query_id: e,
      from_user: o,
      left_amount: n,
      right_amount: a,
      transferred_op: d,
      token_wallet1: i,
      refund_address: l,
      excesses_address: f,
      tx_deadline: u,
      min_lp_out: p,
      to_address: _,
      both_positive: U,
      fwd_amount: y,
      custom_payload: h
    };
  }
  throw new Error('Expected one of "StonfiProvideLpV2" in loading "StonfiProvideLpV2", but data does not satisfy any constructor');
}
function Vo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1355195988) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadVarUintBig(g(15)), n = t.loadVarUintBig(g(15)), a = t.loadVarUintBig(g(15)), r = t.loadCoins(), d = t.loadUint(1), i = t.loadAddressAny(), l = m(t, (p) => p.loadRef().beginParse(true).asCell()), f = t.loadRef().beginParse(true), u = f.loadAddressAny(), s = f.loadAddressAny();
    return {
      kind: "StonfiAddLiquidityV2",
      query_id: e,
      new_amount0: o,
      new_amount1: n,
      min_lp_out: a,
      fwd_amount: r,
      both_positive: d,
      to_user: i,
      custom_payload_cs: l,
      refund_address: u,
      excess_address: s
    };
  }
  throw new Error('Expected one of "StonfiAddLiquidityV2" in loading "StonfiAddLiquidityV2", but data does not satisfy any constructor');
}
function Fo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1702581493) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddressAny(), n = t.loadAddressAny(), a = t.loadAddressAny(), r = t.loadUint(32), d = m(t, (_) => _.loadRef().beginParse(true).asCell()), i = t.loadRef().beginParse(true), l = i.loadCoins(), f = i.loadVarUintBig(g(15)), u = i.loadAddressAny(), s = i.loadVarUintBig(g(15)), p = i.loadAddressAny();
    return {
      kind: "StonfiPayToV2",
      query_id: e,
      to_address: o,
      excesses_address: n,
      original_caller: a,
      exit_code: r,
      custom_payload: d,
      fwd_ton_amount: l,
      amount0_out: f,
      token0_address: u,
      amount1_out: s,
      token1_address: p
    };
  }
  throw new Error('Expected one of "StonfiPayToV2" in loading "StonfiPayToV2", but data does not satisfy any constructor');
}
function Wo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1717886506) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddressAny(), n = t.loadVarUintBig(g(15)), a = t.loadVarUintBig(g(15)), r = t.loadRef().beginParse(true), d = r.loadUint(32), i = r.loadAddressAny(), l = r.loadAddressAny(), f = r.loadAddressAny(), u = r.loadUintBig(64), s = r.loadRef().beginParse(true), p = s.loadVarUintBig(g(15)), _ = s.loadAddressAny(), U = s.loadCoins(), y = m(s, (k) => k.loadRef().beginParse(true).asCell()), h = s.loadCoins(), c = m(s, (k) => k.loadRef().beginParse(true).asCell()), B = s.loadUint(16), P = s.loadAddressAny();
    return {
      kind: "StonfiSwapV2",
      query_id: e,
      from_user: o,
      left_amount: n,
      right_amount: a,
      transferred_op: d,
      token_wallet1: i,
      refund_address: l,
      excesses_address: f,
      tx_deadline: u,
      min_out: p,
      receiver: _,
      fwd_gas: U,
      custom_payload: y,
      refund_fwd_gas: h,
      refund_payload: c,
      ref_fee: B,
      ref_address: P
    };
  }
  throw new Error('Expected one of "StonfiSwapV2" in loading "StonfiSwapV2", but data does not satisfy any constructor');
}
function Jo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 894160372)
    return t.loadUint(32), {
      kind: "StonfiWithdrawFeeV2",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "StonfiWithdrawFeeV2" in loading "StonfiWithdrawFeeV2", but data does not satisfy any constructor');
}
function Io(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 76607643) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadVarUintBig(g(15)), n = t.loadAddressAny();
    return {
      kind: "StonfiDepositRefFeeV2",
      query_id: e,
      jetton_amount: o,
      excesses_address: n
    };
  }
  throw new Error('Expected one of "StonfiDepositRefFeeV2" in loading "StonfiDepositRefFeeV2", but data does not satisfy any constructor');
}
function Oo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 553699618) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadVarUintBig(g(15)), n = t.loadAddressAny(), a = t.loadAddressAny();
    return {
      kind: "StonfiVaultPayToV2",
      query_id: e,
      amount_out: o,
      token_address: n,
      to_address: a
    };
  }
  throw new Error('Expected one of "StonfiVaultPayToV2" in loading "StonfiVaultPayToV2", but data does not satisfy any constructor');
}
function Mo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1664620082) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadAddressAny(), n = t.loadAddressAny(), a = t.loadRef().beginParse(true), r = a.loadVarUintBig(g(15)), d = a.loadAddressAny(), i = a.loadVarUintBig(g(15)), l = a.loadAddressAny();
    return {
      kind: "StonfiPayVaultV2",
      query_id: e,
      owner: o,
      excesses_address: n,
      amount0_out: r,
      token0_address: d,
      amount1_out: i,
      token1_address: l
    };
  }
  throw new Error('Expected one of "StonfiPayVaultV2" in loading "StonfiPayVaultV2", but data does not satisfy any constructor');
}
function jo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 695482319) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadVarUintBig(g(15)), n = t.loadAddressAny(), a = t.loadAddressAny(), r = m(t, (d) => d.loadRef().beginParse(true).asCell());
    return {
      kind: "StonfiBurnNotificationExtV2",
      query_id: e,
      jetton_amount: o,
      from_address: n,
      response_address: a,
      maybe_custom_payload: r
    };
  }
  throw new Error('Expected one of "StonfiBurnNotificationExtV2" in loading "StonfiBurnNotificationExtV2", but data does not satisfy any constructor');
}
function Go(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 5358900) {
    t.loadUint(32);
    let e = t.loadUint(32), o = t.loadUintBig(64), n = t.loadUintBig(256), a = t.loadUintBig(64), r = t.loadUintBig(256), d = m(t, (l) => l.loadUintBig(256)), i = R();
    return {
      kind: "TorrentInfo",
      piece_size: e,
      file_size: o,
      root_hash: n,
      header_size: a,
      header_hash: r,
      microchunk_hash: d,
      description: i
    };
  }
  throw new Error('Expected one of "TorrentInfo" in loading "TorrentInfo", but data does not satisfy any constructor');
}
function $o(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3832843761) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadRef().beginParse(true), n = Go(o), a = t.loadBuffer(256 / 8), r = t.loadCoins(), d = t.loadUint(32);
    return {
      kind: "DeployStorageContract",
      query_id: e,
      info: n,
      merkle_hash: a,
      expected_rate: r,
      expected_max_span: d
    };
  }
  throw new Error('Expected one of "DeployStorageContract" in loading "DeployStorageContract", but data does not satisfy any constructor');
}
function Ho(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1408453846) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadBuffer(256 / 8);
    return {
      kind: "UpdatePubkey",
      query_id: e,
      new_pubkey: o
    };
  }
  throw new Error('Expected one of "UpdatePubkey" in loading "UpdatePubkey", but data does not satisfy any constructor');
}
function Ko(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1422651803) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = C(t), n = t.loadCoins(), a = t.loadUint(32), r = t.loadUintBig(64), d = t.loadUintBig(64);
    return {
      kind: "UpdateStorageParams",
      query_id: e,
      accept_new_contracts: o,
      rate_per_mb_day: n,
      max_span: a,
      minimal_file_size: r,
      maximal_file_size: d
    };
  }
  throw new Error('Expected one of "UpdateStorageParams" in loading "UpdateStorageParams", but data does not satisfy any constructor');
}
function zo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 276580847)
    return t.loadUint(32), {
      kind: "OfferStorageContract",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "OfferStorageContract" in loading "OfferStorageContract", but data does not satisfy any constructor');
}
function Qo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2050365064)
    return t.loadUint(32), {
      kind: "AcceptStorageContract",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "AcceptStorageContract" in loading "AcceptStorageContract", but data does not satisfy any constructor');
}
function Zo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3570068941) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadBuffer(256 / 8);
    return {
      kind: "StorageContractConfirmed",
      cur_lt: e,
      torrent_hash: o
    };
  }
  throw new Error('Expected one of "StorageContractConfirmed" in loading "StorageContractConfirmed", but data does not satisfy any constructor');
}
function Xo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2046375914)
    return t.loadUint(32), {
      kind: "CloseStorageContract",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "CloseStorageContract" in loading "CloseStorageContract", but data does not satisfy any constructor');
}
function Yo(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3055775075) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadBuffer(256 / 8);
    return {
      kind: "StorageContractTerminated",
      cur_lt: e,
      torrent_hash: o
    };
  }
  throw new Error('Expected one of "StorageContractTerminated" in loading "StorageContractTerminated", but data does not satisfy any constructor');
}
function tn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1189949076)
    return t.loadUint(32), {
      kind: "StorageWithdraw",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "StorageWithdraw" in loading "StorageWithdraw", but data does not satisfy any constructor');
}
function en(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2837163862)
    return t.loadUint(32), {
      kind: "StorageRewardWithdrawal",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "StorageRewardWithdrawal" in loading "StorageRewardWithdrawal", but data does not satisfy any constructor');
}
function on(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1100832077) {
    t.loadUint(32);
    let e = t.loadUintBig(64), n = t.loadRef().beginParse(true).asCell();
    return {
      kind: "ProofStorage",
      query_id: e,
      file_dict_proof: n
    };
  }
  throw new Error('Expected one of "ProofStorage" in loading "ProofStorage", but data does not satisfy any constructor');
}
function nn(t) {
  let e = t.loadUint(32), o = t.loadUint(32), n = t.loadUint(32), a = t.loadUint(32), r = t.loadUint(32), d = t.loadUint(32), i = t.loadUint(32), l = t.loadUint(32), f = t.loadUint(32), u = t.loadUint(32), s = t.loadUint(32), p = t.loadUint(32), _ = t.loadUint(2), U = t.loadCoins(), y = t.loadUint(32);
  return {
    kind: "AmmSettings",
    fee: e,
    rollover_fee: o,
    funding_period: n,
    init_margin_ratio: a,
    maintenance_margin_ratio: r,
    liquidation_fee_ratio: d,
    partial_liquidation_ratio: i,
    spread_limit: l,
    max_price_impact: f,
    max_price_spread: u,
    max_open_notional: s,
    fee_to_stakers_percent: p,
    funding_mode: _,
    min_partial_liquidation_notional: U,
    min_leverage: y
  };
}
function an(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3989649062) {
    t.loadUint(32);
    let e = t.loadAddressAny(), o = t.loadRef().beginParse(true), n = nn(o);
    return {
      kind: "StormChangeSettings",
      redirect_addr: e,
      settings: n
    };
  }
  throw new Error('Expected one of "StormChangeSettings" in loading "StormChangeSettings", but data does not satisfy any constructor');
}
function rn(t) {
  let e = t.loadCoins(), o = t.loadCoins(), n = t.loadUint(32), a = t.loadUint(16);
  return {
    kind: "UpdateMsg",
    price: e,
    spread: o,
    timestamp: n,
    asset_index: a
  };
}
function dn(t) {
  let e = t.loadRef().beginParse(true), o = rn(e), a = t.loadRef().beginParse(true).asCell();
  return {
    kind: "OracleData",
    update_msg: o,
    signatures: a
  };
}
function ln(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3058877505) {
    t.loadUint(32);
    let e = t.loadRef().beginParse(true);
    return {
      kind: "StormPayFunding",
      oracle_ref: dn(e)
    };
  }
  throw new Error('Expected one of "StormPayFunding" in loading "StormPayFunding", but data does not satisfy any constructor');
}
function sn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 700515025) {
    t.loadUint(32);
    let e = t.loadAddressAny(), n = t.loadRef().beginParse(true).asCell(), r = t.loadRef().beginParse(true).asCell();
    return {
      kind: "StormVammInit",
      redirect_addr: e,
      code: n,
      data: r
    };
  }
  throw new Error('Expected one of "StormVammInit" in loading "StormVammInit", but data does not satisfy any constructor');
}
function un(t) {
  let e = t.loadUint(32), o = t.loadUint(32);
  return {
    kind: "Parameters",
    discount: e,
    rebate: o
  };
}
function fn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3410877500) {
    t.loadUint(32);
    let e = t.loadAddressAny(), o = t.loadUint(2), n = t.loadAddressAny(), a = t.loadRef().beginParse(true), r = un(a), i = t.loadRef().beginParse(true).asCell();
    return {
      kind: "StormMintReferral",
      nft_owner: e,
      ref_type: o,
      redirect_address: n,
      parameters: r,
      balances_dict: i
    };
  }
  throw new Error('Expected one of "StormMintReferral" in loading "StormMintReferral", but data does not satisfy any constructor');
}
function pn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2229071226) {
    t.loadUint(32);
    let e = t.loadCoins(), o = t.loadAddressAny();
    return {
      kind: "StormAddReferralAmount",
      referral_amount: e,
      origin_addr: o
    };
  }
  throw new Error('Expected one of "StormAddReferralAmount" in loading "StormAddReferralAmount", but data does not satisfy any constructor');
}
function mn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4124371794) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadCoins(), n = t.loadAddressAny();
    return {
      kind: "StormWithdrawReferralAmount",
      index: e,
      referral_amount: o,
      owner_addr: n
    };
  }
  throw new Error('Expected one of "StormWithdrawReferralAmount" in loading "StormWithdrawReferralAmount", but data does not satisfy any constructor');
}
function gn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1329122024) {
    t.loadUint(32);
    let e = t.loadAddressAny(), o = t.loadAddressAny(), a = t.loadRef().beginParse(true).asCell();
    return {
      kind: "StormMintExecutor",
      nft_owner: e,
      redirect_address: o,
      balances_dict: a
    };
  }
  throw new Error('Expected one of "StormMintExecutor" in loading "StormMintExecutor", but data does not satisfy any constructor');
}
function _n(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1574331769) {
    t.loadUint(32);
    let e = t.loadCoins(), o = t.loadAddressAny();
    return {
      kind: "StormAddExecutorAmount",
      referral_amount: e,
      origin_addr: o
    };
  }
  throw new Error('Expected one of "StormAddExecutorAmount" in loading "StormAddExecutorAmount", but data does not satisfy any constructor');
}
function yn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 752771921) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadCoins(), n = t.loadAddressAny();
    return {
      kind: "StormWithdrawExecutorAmount",
      index: e,
      executor_amount: o,
      owner_addr: n
    };
  }
  throw new Error('Expected one of "StormWithdrawExecutorAmount" in loading "StormWithdrawExecutorAmount", but data does not satisfy any constructor');
}
function Un(t) {
  let e = t.loadCoins(), o = t.loadUint(32);
  return {
    kind: "ReferralData",
    amount: e,
    index: o
  };
}
function hn(t) {
  let e = t.loadUint(8), o = t.loadCoins(), n = t.loadUint(32);
  return {
    kind: "ExecutorData",
    split_executor_rewards: e,
    amount: o,
    index: n
  };
}
function Cn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 880147922) {
    t.loadUint(32);
    let e = t.loadUint(16), o = t.loadUint(16), n = t.loadIntBig(64), a = t.loadIntBig(64), r = t.loadIntBig(64), d = t.loadIntBig(64), i = t.loadIntBig(64), l = t.loadAddressAny(), f = m(t, (s) => {
      let p = s.loadRef().beginParse(true);
      return Un(p);
    }), u = m(t, (s) => {
      let p = s.loadRef().beginParse(true);
      return hn(p);
    });
    return {
      kind: "StormVaultTradeNotification",
      amm_index: e,
      free_amount: o,
      locked_amount: n,
      exchange_amount: a,
      withdraw_locked_amount: r,
      fee_to_stakers: d,
      withdraw_amount: i,
      trader_addr: l,
      referral_params: f,
      executor_params: u
    };
  }
  throw new Error('Expected one of "StormVaultTradeNotification" in loading "StormVaultTradeNotification", but data does not satisfy any constructor');
}
function cn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3365551844)
    return t.loadUint(32), {
      kind: "StormVaultStake",
      amount: t.loadCoins()
    };
  throw new Error('Expected one of "StormVaultStake" in loading "StormVaultStake", but data does not satisfy any constructor');
}
function wn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3585468845) {
    t.loadUint(32);
    let e = t.loadCoins(), o = t.loadAddressAny();
    return {
      kind: "StormVaultUnstake",
      jetton_amount: e,
      user_address: o
    };
  }
  throw new Error('Expected one of "StormVaultUnstake" in loading "StormVaultUnstake", but data does not satisfy any constructor');
}
function kn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 700515025)
    return t.loadUint(32), {
      kind: "StormVaultInit",
      jetton_address: t.loadAddressAny()
    };
  throw new Error('Expected one of "StormVaultInit" in loading "StormVaultInit", but data does not satisfy any constructor');
}
function Sn(t) {
  let e = t.loadUint(32), o = t.loadUint(32);
  return {
    kind: "Parameters",
    discount: e,
    rebate: o
  };
}
function Bn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 316235805) {
    t.loadUint(32);
    let e = t.loadRef().beginParse(true);
    return {
      kind: "StormTakeReferralFees",
      referral_fees: Sn(e)
    };
  }
  throw new Error('Expected one of "StormTakeReferralFees" in loading "StormTakeReferralFees", but data does not satisfy any constructor');
}
function xn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1729316393) {
    t.loadUint(32);
    let e = t.loadUint(4), o = t.loadUint(3), n = t.loadUint(1), a = t.loadAddressAny();
    return {
      kind: "StormCancelOrder",
      order_type: e,
      order_index: o,
      direction: n,
      gas_to_address: a
    };
  }
  throw new Error('Expected one of "StormCancelOrder" in loading "StormCancelOrder", but data does not satisfy any constructor');
}
function bn(t) {
  let e = t.loadUint(4), o = t.loadUint(3), n = t.loadUint(1);
  return {
    kind: "OrderPayload",
    order_type: e,
    order_index: o,
    direction: n
  };
}
function Nn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2744665076) {
    t.loadUint(32);
    let e = t.loadRef().beginParse(true);
    return {
      kind: "StormCreateOrder",
      order_payload: bn(e)
    };
  }
  throw new Error('Expected one of "StormCreateOrder" in loading "StormCreateOrder", but data does not satisfy any constructor');
}
function Pn(t) {
  let e = t.loadUintBig(128), o = t.loadUint(1), n = t.loadCoins(), a = t.loadCoins(), r = t.loadUintBig(64), d = t.loadUint(32), i = t.loadUint(32), l = t.loadUint(32), f = t.loadUint(32);
  return {
    kind: "PositionChange",
    size: e,
    direction: o,
    margin: n,
    open_notional: a,
    last_updated_cumulative_premium: r,
    fee: d,
    discount: i,
    rebate: l,
    last_updated_timestamp: f
  };
}
function En(t) {
  let e = t.loadCoins(), o = t.loadCoins(), n = t.loadCoins(), a = t.loadCoins(), r = t.loadCoins(), d = t.loadCoins(), i = t.loadCoins();
  return {
    kind: "AmmChange",
    quote_asset_reserve: e,
    quote_asset_reserve_weight: o,
    base_asset_reserve: n,
    total_long_position_size: a,
    total_short_position_size: r,
    open_interest_long: d,
    open_interest_short: i
  };
}
function An(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3482375704) {
    t.loadUint(32);
    let e = t.loadUint(4), o = t.loadUint(3), n = t.loadUint(1), a = t.loadUint(32), r = t.loadCoins(), d = m(t, (s) => s.loadCoins()), i = t.loadRef().beginParse(true), l = Pn(i), f = t.loadRef().beginParse(true), u = En(f);
    return {
      kind: "StormCompleteOrder",
      order_type: e,
      order_index: o,
      direction: n,
      origin_opcode: a,
      index_price: r,
      settlement_oracle_price: d,
      position: l,
      amm: u
    };
  }
  throw new Error('Expected one of "StormCompleteOrder" in loading "StormCompleteOrder", but data does not satisfy any constructor');
}
function Tn(t) {
  let e = t.loadUint(4), o = t.loadUint(3), n = t.loadUint(1);
  return {
    kind: "OrderPayload",
    order_type: e,
    order_index: o,
    direction: n
  };
}
function Dn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2637088320) {
    t.loadUint(32);
    let e = t.loadUint(3), o = t.loadRef().beginParse(true), n = Tn(o);
    return {
      kind: "StormActivateOrder",
      order_index: e,
      activated_order: n
    };
  }
  throw new Error('Expected one of "StormActivateOrder" in loading "StormActivateOrder", but data does not satisfy any constructor');
}
function Rn(t) {
  let e = t.loadUintBig(128), o = t.loadUint(1), n = t.loadCoins(), a = t.loadCoins(), r = t.loadUintBig(64), d = t.loadUint(32), i = t.loadUint(32), l = t.loadUint(32), f = t.loadUint(32);
  return {
    kind: "PositionChange",
    size: e,
    direction: o,
    margin: n,
    open_notional: a,
    last_updated_cumulative_premium: r,
    fee: d,
    discount: i,
    rebate: l,
    last_updated_timestamp: f
  };
}
function qn(t) {
  let e = t.loadCoins(), o = t.loadCoins(), n = t.loadCoins(), a = t.loadCoins(), r = t.loadCoins(), d = t.loadCoins(), i = t.loadCoins();
  return {
    kind: "AmmChange",
    quote_asset_reserve: e,
    quote_asset_reserve_weight: o,
    base_asset_reserve: n,
    total_long_position_size: a,
    total_short_position_size: r,
    open_interest_long: d,
    open_interest_short: i
  };
}
function Ln(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1625278071) {
    t.loadUint(32);
    let e = t.loadUint(1), o = t.loadUint(32), n = t.loadCoins(), a = m(t, (f) => f.loadCoins()), r = t.loadRef().beginParse(true), d = Rn(r), i = t.loadRef().beginParse(true), l = qn(i);
    return {
      kind: "StormUpdatePosition",
      direction: e,
      origin_opcode: o,
      index_price: n,
      settlement_oracle_price: a,
      position: d,
      amm: l
    };
  }
  throw new Error('Expected one of "StormUpdatePosition" in loading "StormUpdatePosition", but data does not satisfy any constructor');
}
function vn(t) {
  let e = t.loadUintBig(128), o = t.loadUint(1), n = t.loadCoins(), a = t.loadCoins(), r = t.loadUintBig(64), d = t.loadUint(32), i = t.loadUint(32), l = t.loadUint(32), f = t.loadUint(32);
  return {
    kind: "PositionChange",
    size: e,
    direction: o,
    margin: n,
    open_notional: a,
    last_updated_cumulative_premium: r,
    fee: d,
    discount: i,
    rebate: l,
    last_updated_timestamp: f
  };
}
function Vn(t) {
  let e = t.loadCoins(), o = t.loadCoins(), n = t.loadCoins(), a = t.loadCoins(), r = t.loadCoins(), d = t.loadCoins(), i = t.loadCoins();
  return {
    kind: "AmmChange",
    quote_asset_reserve: e,
    quote_asset_reserve_weight: o,
    base_asset_reserve: n,
    total_long_position_size: a,
    total_short_position_size: r,
    open_interest_long: d,
    open_interest_short: i
  };
}
function Fn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1562056632) {
    t.loadUint(32);
    let e = t.loadUint(1), o = t.loadCoins(), n = t.loadCoins(), a = t.loadUint(32), r = t.loadCoins(), d = m(t, (s) => s.loadCoins()), i = t.loadRef().beginParse(true), l = vn(i), f = t.loadRef().beginParse(true), u = Vn(f);
    return {
      kind: "StormUpdatePositionWithStopLoss",
      direction: e,
      stop_trigger_price: o,
      take_trigger_price: n,
      origin_opcode: a,
      index_price: r,
      settlement_oracle_price: d,
      position: l,
      amm: u
    };
  }
  throw new Error('Expected one of "StormUpdatePositionWithStopLoss" in loading "StormUpdatePositionWithStopLoss", but data does not satisfy any constructor');
}
function Wn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 982793446)
    return t.loadUint(32), {
      kind: "StormOrderCreated"
    };
  throw new Error('Expected one of "StormOrderCreated" in loading "StormOrderCreated", but data does not satisfy any constructor');
}
function Jn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1775273593)
    return t.loadUint(32), {
      kind: "StormOrderCanceled"
    };
  throw new Error('Expected one of "StormOrderCanceled" in loading "StormOrderCanceled", but data does not satisfy any constructor');
}
function In(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 36101990) {
    t.loadUint(32);
    let e = t.loadAddressAny(), o = t.loadAddressAny(), n = t.loadCoins(), a = t.loadAddressAny(), r = t.loadUint(32);
    return {
      kind: "StormVaultRequestWithdrawPosition",
      trader_addr: e,
      vamm_addr: o,
      amount: n,
      gas_to_addr: a,
      withdraw_reason: r
    };
  }
  throw new Error('Expected one of "StormVaultRequestWithdrawPosition" in loading "StormVaultRequestWithdrawPosition", but data does not satisfy any constructor');
}
function On(t) {
  return {
    kind: "Signatures",
    data: t.asCell()
  };
}
function Mn(t) {
  let e = t.loadCoins(), o = t.loadCoins(), n = t.loadUint(32), a = t.loadUint(16);
  return {
    kind: "OraclePriceData",
    price: e,
    spread: o,
    another_spread: n,
    asset_id: a
  };
}
function jn(t) {
  let e = t.loadRef().beginParse(true), o = Mn(e), n = t.loadRef().beginParse(true), a = On(n);
  return {
    kind: "OraclePayload",
    price_data: o,
    signatures: a
  };
}
function Gn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2288366594) {
    t.loadUint(32);
    let e = t.loadUint(4), o = t.loadUint(3), n = t.loadUint(1), a = t.loadUint(32), r = t.loadRef().beginParse(true), d = jn(r);
    return {
      kind: "StormProvidePosition",
      order_type: e,
      order_index: o,
      direction: n,
      executor_index: a,
      oracle_payload: d
    };
  }
  throw new Error('Expected one of "StormProvidePosition" in loading "StormProvidePosition", but data does not satisfy any constructor');
}
function $n(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4145513419) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadUint(32), n = t.loadCoins(), a = t.loadUint(32), r = t.loadUint(32), d = t.loadCoins(), l = t.loadRef().beginParse(true).asCell();
    return {
      kind: "SubscriptionV2Deploy",
      query_id: e,
      first_charging_date: o,
      payment_per_period: n,
      period: a,
      grace_period: r,
      caller_fee: d,
      metadata: l
    };
  }
  throw new Error('Expected one of "SubscriptionV2Deploy" in loading "SubscriptionV2Deploy", but data does not satisfy any constructor');
}
function Hn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1685288050)
    return t.loadUint(32), {
      kind: "SubscriptionV2Destruct",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "SubscriptionV2Destruct" in loading "SubscriptionV2Destruct", but data does not satisfy any constructor');
}
function Kn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1350711532) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadCoins();
    return {
      kind: "SubscriptionV2ReducePayment",
      query_id: e,
      new_payment: o
    };
  }
  throw new Error('Expected one of "SubscriptionV2ReducePayment" in loading "SubscriptionV2ReducePayment", but data does not satisfy any constructor');
}
function zn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4033639783)
    return t.loadUint(32), {
      kind: "SubscriptionV2PaymentConfirmed"
    };
  throw new Error('Expected one of "SubscriptionV2PaymentConfirmed" in loading "SubscriptionV2PaymentConfirmed", but data does not satisfy any constructor');
}
function Qn(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 4166133070)
    return t.loadUint(32), {
      kind: "SubscriptionV2WithdrawToBeneficiary",
      subscription_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "SubscriptionV2WithdrawToBeneficiary" in loading "SubscriptionV2WithdrawToBeneficiary", but data does not satisfy any constructor');
}
function Zn(t) {
  let e = t.loadUint(16), o = t.loadUint(16), n = t.loadAddressAny();
  return {
    kind: "NftRoyaltyParams",
    numerator: e,
    denominator: o,
    destination: n
  };
}
function Xn(t) {
  let e = t.loadAddressAny(), o = t.loadCoins(), n = t.loadCoins(), a = t.loadUint(8), r = t.loadUint(32), d = t.loadUint(32);
  return {
    kind: "TeleitemAuctionConfig",
    beneficiar_address: e,
    initial_min_bid: o,
    max_bid: n,
    min_bid_step: a,
    min_extend_time: r,
    duration: d
  };
}
function Yn(t) {
  let e = t.loadUint(32), o = t.loadUint(32), n = t.loadUint(32), a = b(t), d = t.loadRef().beginParse(true).asCell(), i = t.loadRef().beginParse(true), l = Xn(i), f = m(t, (u) => {
    let s = u.loadRef().beginParse(true);
    return Zn(s);
  });
  return {
    kind: "TelemintUnsignedDeploy",
    subwallet_id: e,
    valid_since: o,
    valid_till: n,
    username: a,
    content: d,
    auction_config: l,
    royalty_params: f
  };
}
function ta(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1178019994) {
    t.loadUint(32);
    let e = t.loadBuffer(512 / 8), o = Yn(t);
    return {
      kind: "TelemintDeploy",
      sig: e,
      msg: o
    };
  }
  throw new Error('Expected one of "TelemintDeploy" in loading "TelemintDeploy", but data does not satisfy any constructor');
}
function ea(t) {
  let e = t.loadUint(16), o = t.loadUint(16), n = t.loadAddressAny();
  return {
    kind: "NftRoyaltyParams",
    numerator: e,
    denominator: o,
    destination: n
  };
}
function oa(t) {
  let e = t.loadAddressAny(), o = t.loadCoins(), n = t.loadCoins(), a = t.loadUint(8), r = t.loadUint(32), d = t.loadUint(32);
  return {
    kind: "TeleitemAuctionConfig",
    beneficiar_address: e,
    initial_min_bid: o,
    max_bid: n,
    min_bid_step: a,
    min_extend_time: r,
    duration: d
  };
}
function na(t) {
  let e = m(t, (n) => n.loadAddressAny()), o = m(t, (n) => n.loadAddressAny());
  return {
    kind: "TelemintRestrictions",
    force_sender_address: e,
    rewrite_sender_address: o
  };
}
function aa(t) {
  let e = t.loadUint(32), o = t.loadUint(32), n = t.loadUint(32), a = b(t), d = t.loadRef().beginParse(true).asCell(), i = t.loadRef().beginParse(true), l = oa(i), f = m(t, (s) => {
    let p = s.loadRef().beginParse(true);
    return ea(p);
  }), u = m(t, (s) => {
    let p = s.loadRef().beginParse(true);
    return na(p);
  });
  return {
    kind: "TelemintUnsignedDeployV2",
    subwallet_id: e,
    valid_since: o,
    valid_till: n,
    token_name: a,
    content: d,
    auction_config: l,
    royalty_params: f,
    restrictions: u
  };
}
function ra(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1178019995) {
    t.loadUint(32);
    let e = t.loadBuffer(512 / 8), o = aa(t);
    return {
      kind: "TelemintDeployV2",
      sig: e,
      msg: o
    };
  }
  throw new Error('Expected one of "TelemintDeployV2" in loading "TelemintDeployV2", but data does not satisfy any constructor');
}
function da(t) {
  let e = t.loadUint(16), o = t.loadUint(16), n = t.loadAddressAny();
  return {
    kind: "NftRoyaltyParams",
    numerator: e,
    denominator: o,
    destination: n
  };
}
function ia(t) {
  let e = t.loadAddressAny(), o = t.loadCoins(), n = t.loadCoins(), a = t.loadUint(8), r = t.loadUint(32), d = t.loadUint(32);
  return {
    kind: "TeleitemAuctionConfig",
    beneficiar_address: e,
    initial_min_bid: o,
    max_bid: n,
    min_bid_step: a,
    min_extend_time: r,
    duration: d
  };
}
function la(t) {
  let e = b(t), o = b(t);
  return {
    kind: "TelemintTokenInfo",
    name: e,
    domain: o
  };
}
function sa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 697974293) {
    t.loadUint(32);
    let e = t.loadAddressAny(), o = t.loadCoins(), n = t.loadRef().beginParse(true), a = la(n), d = t.loadRef().beginParse(true).asCell(), i = t.loadRef().beginParse(true), l = ia(i), f = t.loadRef().beginParse(true), u = da(f);
    return {
      kind: "TeleitemDeploy",
      sender_address: e,
      bid: o,
      token_info: a,
      nft_content: d,
      auction_config: l,
      royalty_params: u
    };
  }
  throw new Error('Expected one of "TeleitemDeploy" in loading "TeleitemDeploy", but data does not satisfy any constructor');
}
function ua(t) {
  let e = t.loadAddressAny(), o = t.loadCoins(), n = t.loadCoins(), a = t.loadUint(8), r = t.loadUint(32), d = t.loadUint(32);
  return {
    kind: "TeleitemAuctionConfig",
    beneficiar_address: e,
    initial_min_bid: o,
    max_bid: n,
    min_bid_step: a,
    min_extend_time: r,
    duration: d
  };
}
function fa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1215991425) {
    t.loadUint(32);
    let e = t.loadIntBig(64), o = t.loadRef().beginParse(true), n = ua(o);
    return {
      kind: "TeleitemStartAuction",
      query_id: e,
      auction_config: n
    };
  }
  throw new Error('Expected one of "TeleitemStartAuction" in loading "TeleitemStartAuction", but data does not satisfy any constructor');
}
function pa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 924203182)
    return t.loadUint(32), {
      kind: "TeleitemCancelAuction",
      query_id: t.loadIntBig(64)
    };
  throw new Error('Expected one of "TeleitemCancelAuction" in loading "TeleitemCancelAuction", but data does not satisfy any constructor');
}
function ma(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2742684035)
    return t.loadUint(32), {
      kind: "TeleitemOk",
      query_id: t.loadIntBig(64)
    };
  throw new Error('Expected one of "TeleitemOk" in loading "TeleitemOk", but data does not satisfy any constructor');
}
function ga(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2754750433)
    return t.loadUint(32), {
      kind: "TeleitemReturnBid",
      cur_lt: t.loadIntBig(64)
    };
  throw new Error('Expected one of "TeleitemReturnBid" in loading "TeleitemReturnBid", but data does not satisfy any constructor');
}
function _a(t) {
  let e = t.loadUintBig(64), o = t.loadBuffer(256 / 8);
  return {
    kind: "CertificateData2Fa",
    valid_until: e,
    pubkey: o
  };
}
function ya(t) {
  let e = _a(t), o = t.loadBuffer(512 / 8);
  return {
    kind: "Certificate2Fa",
    data: e,
    signature: o
  };
}
function Ua(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2975804556) {
    t.loadUint(32);
    let e = t.loadUint(32), o = t.loadUintBig(64), a = t.loadRef().beginParse(true).asCell(), r = t.loadUint(8);
    return {
      kind: "Payload2Fa_send_actions",
      seqno: e,
      valid_until: o,
      msg: a,
      mode: r
    };
  }
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2642445526) {
    t.loadUint(32);
    let e = t.loadUint(32), o = t.loadUintBig(64);
    return {
      kind: "Payload2Fa_remove_extension",
      seqno: e,
      valid_until: o
    };
  }
  if (t.remainingBits >= 32 && t.preloadUint(32) == 601473372) {
    t.loadUint(32);
    let e = t.loadUint(32), o = t.loadUintBig(64), a = t.loadRef().beginParse(true).asCell(), r = t.loadCoins();
    return {
      kind: "Payload2Fa_delegation",
      seqno: e,
      valid_until: o,
      new_state_init: a,
      forward_amount: r
    };
  }
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3733107969) {
    t.loadUint(32);
    let e = t.loadUint(32), o = t.loadUintBig(64);
    return {
      kind: "Payload2Fa_cancel_delegation",
      seqno: e,
      valid_until: o
    };
  }
  throw new Error('Expected one of "Payload2Fa_send_actions", "Payload2Fa_remove_extension", "Payload2Fa_delegation", "Payload2Fa_cancel_delegation" in loading "Payload2Fa", but data does not satisfy any constructor');
}
function ha(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1399341111) {
    t.loadUint(32);
    let e = t.loadRef().beginParse(true), o = ya(e), a = t.loadRef().beginParse(true).loadBuffer(512 / 8), r = Ua(t), d = t.loadBuffer(512 / 8);
    return {
      kind: "Tonkeeper2faSigned",
      ref_with_certificate: o,
      seed_signature: a,
      payload: r,
      certificate_signature: d
    };
  }
  throw new Error('Expected one of "Tonkeeper2faSigned" in loading "Tonkeeper2faSigned", but data does not satisfy any constructor');
}
function Ca(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 3665837821) {
    t.loadUint(32);
    let e = t.loadIntBig(64), o = t.loadCoins(), n = t.loadCoins();
    return {
      kind: "WhalesNominatorsWithdraw",
      query_id: e,
      gas: o,
      amount: n
    };
  }
  throw new Error('Expected one of "WhalesNominatorsWithdraw" in loading "WhalesNominatorsWithdraw", but data does not satisfy any constructor');
}
function ca(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2077040623) {
    t.loadUint(32);
    let e = t.loadIntBig(64), o = t.loadCoins();
    return {
      kind: "WhalesNominatorsDeposit",
      query_id: e,
      gas: o
    };
  }
  throw new Error('Expected one of "WhalesNominatorsDeposit" in loading "WhalesNominatorsDeposit", but data does not satisfy any constructor');
}
function wa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 362189324)
    return t.loadUint(32), {
      kind: "WhalesNominatorsForceKick",
      query_id: t.loadIntBig(64)
    };
  throw new Error('Expected one of "WhalesNominatorsForceKick" in loading "WhalesNominatorsForceKick", but data does not satisfy any constructor');
}
function ka(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 1958425639)
    return t.loadUint(32), {
      kind: "WhalesNominatorsStakeWithdrawDelayed",
      query_id: t.loadIntBig(64)
    };
  throw new Error('Expected one of "WhalesNominatorsStakeWithdrawDelayed" in loading "WhalesNominatorsStakeWithdrawDelayed", but data does not satisfy any constructor');
}
function Sa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 601104865)
    return t.loadUint(32), {
      kind: "WhalesNominatorsStakeWithdrawCompleted",
      query_id: t.loadIntBig(64)
    };
  throw new Error('Expected one of "WhalesNominatorsStakeWithdrawCompleted" in loading "WhalesNominatorsStakeWithdrawCompleted", but data does not satisfy any constructor');
}
function Ba(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2718326572) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadCoins(), n = t.loadCoins(), a = t.loadBuffer(256 / 8), r = t.loadUint(32), d = t.loadUint(32), i = t.loadBuffer(256 / 8), f = t.loadRef().beginParse(true).loadBuffer(512 / 8);
    return {
      kind: "WhalesNominatorsSendStake",
      query_id: e,
      gas_limit: o,
      stake: n,
      validator_pubkey: a,
      stake_at: r,
      max_factor: d,
      adnl_addr: i,
      signature: f
    };
  }
  throw new Error('Expected one of "WhalesNominatorsSendStake" in loading "WhalesNominatorsSendStake", but data does not satisfy any constructor');
}
function xa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 622684824) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.loadCoins();
    return {
      kind: "WhalesNominatorsWithdrawUnowned",
      query_id: e,
      gas_limit: o
    };
  }
  throw new Error('Expected one of "WhalesNominatorsWithdrawUnowned" in loading "WhalesNominatorsWithdrawUnowned", but data does not satisfy any constructor');
}
function ba(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 488052159)
    return t.loadUint(32), {
      kind: "WhalesNominatorsWithdrawUnownedResponse",
      query_id: t.loadUintBig(64)
    };
  throw new Error('Expected one of "WhalesNominatorsWithdrawUnownedResponse" in loading "WhalesNominatorsWithdrawUnownedResponse", but data does not satisfy any constructor');
}
function Na(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2577928699) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.asCell();
    return {
      kind: "WhalesNominatorsAcceptStake",
      query_id: e,
      members: o
    };
  }
  throw new Error('Expected one of "WhalesNominatorsAcceptStake" in loading "WhalesNominatorsAcceptStake", but data does not satisfy any constructor');
}
function Pa(t) {
  if (t.remainingBits >= 32 && t.preloadUint(32) == 2711607604) {
    t.loadUint(32);
    let e = t.loadUintBig(64), o = t.asCell();
    return {
      kind: "WhalesNominatorsAcceptWithdraws",
      query_id: e,
      members: o
    };
  }
  throw new Error('Expected one of "WhalesNominatorsAcceptWithdraws" in loading "WhalesNominatorsAcceptWithdraws", but data does not satisfy any constructor');
}
const Ga = [
  {
    opCode: 1112786133,
    parse: ut,
    fixedLength: false,
    folderName: "bemo",
    internalName: "bemo_stake"
  },
  {
    opCode: 1227534771,
    parse: ft,
    fixedLength: false,
    folderName: "bemo",
    internalName: "bemo_unstake"
  },
  {
    opCode: 279039605,
    parse: pt,
    fixedLength: false,
    folderName: "bemo",
    internalName: "bemo_deploy_unstake_request"
  },
  {
    opCode: 2429028871,
    parse: mt,
    fixedLength: false,
    folderName: "bemo",
    internalName: "bemo_unstake_notification"
  },
  {
    opCode: 946025784,
    parse: gt,
    fixedLength: false,
    folderName: "bemo",
    internalName: "bemo_return_unstake_request"
  },
  {
    opCode: 1544662441,
    parse: _t,
    fixedLength: false,
    folderName: "daolama",
    internalName: "daolama_vault_supply"
  },
  {
    opCode: 2078119902,
    parse: yt,
    fixedLength: false,
    folderName: "daolama",
    internalName: "daolama_vault_withdraw"
  },
  {
    opCode: 3043726744,
    parse: Ut,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_deposit_liquidity_all"
  },
  {
    opCode: 1643009069,
    parse: ct,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_swap_external"
  },
  {
    opCode: 1923917994,
    parse: Bt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_swap_peer"
  },
  {
    opCode: 2907617013,
    parse: xt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_payout_from_pool"
  },
  {
    opCode: 1196394191,
    parse: bt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_payout"
  },
  {
    opCode: 3926267997,
    parse: Et,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_swap"
  },
  {
    opCode: 3579725446,
    parse: Dt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_deposit_liquidity"
  },
  {
    opCode: 567271467,
    parse: qt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_create_vault"
  },
  {
    opCode: 2547326767,
    parse: Lt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_create_volatile_pool"
  },
  {
    opCode: 376237550,
    parse: vt,
    fixedLength: false,
    folderName: "dedust",
    internalName: "dedust_cancel_deposit"
  },
  {
    opCode: 1322339173,
    parse: Vt,
    fixedLength: false,
    folderName: "dns",
    internalName: "dns_balance_release"
  },
  {
    opCode: 1320284409,
    parse: Ft,
    fixedLength: true,
    folderName: "dns",
    internalName: "delete_dns_record"
  },
  {
    opCode: 1320284409,
    parse: Wt,
    fixedLength: false,
    folderName: "dns",
    internalName: "change_dns_record"
  },
  {
    opCode: 1153347137,
    parse: Jt,
    fixedLength: false,
    folderName: "dns",
    internalName: "process_governance_decision"
  },
  {
    opCode: 923790417,
    parse: It,
    fixedLength: false,
    folderName: "dns",
    internalName: "auction_fill_up"
  },
  {
    opCode: 1434249760,
    parse: Ot,
    fixedLength: false,
    folderName: "dns",
    internalName: "outbid_notification"
  },
  {
    opCode: 1298755173,
    parse: Mt,
    fixedLength: false,
    folderName: "gram",
    internalName: "gram_submit_proof_of_work"
  },
  {
    opCode: 1027039654,
    parse: jt,
    fixedLength: false,
    folderName: "hipo_finance",
    internalName: "hipo_finance_deposit_coins"
  },
  {
    opCode: 1541764646,
    parse: Gt,
    fixedLength: false,
    folderName: "hipo_finance",
    internalName: "hipo_finance_proxy_tokens_minted"
  },
  {
    opCode: 1413869550,
    parse: $t,
    fixedLength: false,
    folderName: "hipo_finance",
    internalName: "hipo_finance_tokens_minted"
  },
  {
    opCode: 2057453237,
    parse: Kt,
    fixedLength: false,
    folderName: "invoices",
    internalName: "invoice_payload"
  },
  {
    opCode: 260734629,
    parse: zt,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_transfer"
  },
  {
    opCode: 395134233,
    parse: Qt,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_internal_transfer"
  },
  {
    opCode: 1499400124,
    parse: Zt,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_burn"
  },
  {
    opCode: 2078119902,
    parse: Xt,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_burn_notification"
  },
  {
    opCode: 1935855772,
    parse: Yt,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_notify"
  },
  {
    opCode: 4006754003,
    parse: te,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_set_status"
  },
  {
    opCode: 1680571655,
    parse: ee,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_mint"
  },
  {
    opCode: 1694626644,
    parse: oe,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_change_admin"
  },
  {
    opCode: 4220051737,
    parse: ne,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_claim_admin"
  },
  {
    opCode: 593276754,
    parse: re,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_call_to"
  },
  {
    opCode: 621336170,
    parse: de,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_upgrade"
  },
  {
    opCode: 3414567170,
    parse: ie,
    fixedLength: false,
    folderName: "jettons",
    internalName: "jetton_change_metadata"
  },
  {
    opCode: 4294967295,
    parse: le,
    fixedLength: false,
    folderName: "known",
    internalName: "bounce"
  },
  {
    opCode: 0,
    parse: se,
    fixedLength: false,
    folderName: "known",
    internalName: "text_comment"
  },
  {
    opCode: 560454219,
    parse: ue,
    fixedLength: false,
    folderName: "known",
    internalName: "encrypted_text_comment"
  },
  {
    opCode: 3576854235,
    parse: fe,
    fixedLength: false,
    folderName: "known",
    internalName: "excess"
  },
  {
    opCode: 3547469196,
    parse: pe,
    fixedLength: true,
    folderName: "known",
    internalName: "top_up"
  },
  {
    opCode: 378586628,
    parse: me,
    fixedLength: true,
    folderName: "known",
    internalName: "credit"
  },
  {
    opCode: 2068529894,
    parse: ge,
    fixedLength: true,
    folderName: "known",
    internalName: "approve"
  },
  {
    opCode: 3902843902,
    parse: _e,
    fixedLength: true,
    folderName: "known",
    internalName: "disapprove"
  },
  {
    opCode: 1316189259,
    parse: ye,
    fixedLength: false,
    folderName: "known",
    internalName: "elector_new_stake"
  },
  {
    opCode: 4084484172,
    parse: Ue,
    fixedLength: false,
    folderName: "known",
    internalName: "elector_new_stake_confirmation"
  },
  {
    opCode: 1197831204,
    parse: he,
    fixedLength: false,
    folderName: "known",
    internalName: "elector_recover_stake_request"
  },
  {
    opCode: 4184830756,
    parse: Ce,
    fixedLength: false,
    folderName: "known",
    internalName: "elector_recover_stake_response"
  },
  {
    opCode: 3946265093,
    parse: ce,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_recover_stake"
  },
  {
    opCode: 4043121232,
    parse: we,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_update_validator_hash"
  },
  {
    opCode: 2399065977,
    parse: ke,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_withdraw_validator"
  },
  {
    opCode: 805462823,
    parse: Se,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_validator_withdrawal"
  },
  {
    opCode: 3763363086,
    parse: Be,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_new_stake"
  },
  {
    opCode: 1664463130,
    parse: xe,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_send_request_loan"
  },
  {
    opCode: 3983767718,
    parse: be,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_return_unused_loan"
  },
  {
    opCode: 1438805205,
    parse: Ne,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_return_available_funds"
  },
  {
    opCode: 3863136613,
    parse: Ee,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_request_loan"
  },
  {
    opCode: 3755778683,
    parse: Ae,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_loan_repayment"
  },
  {
    opCode: 1205158801,
    parse: Te$1,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_deposit"
  },
  {
    opCode: 1271382751,
    parse: De,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_touch"
  },
  {
    opCode: 715822752,
    parse: Re,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_set_governance_fee"
  },
  {
    opCode: 832244956,
    parse: qe,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_withdraw"
  },
  {
    opCode: 175592284,
    parse: Le,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_withdrawal"
  },
  {
    opCode: 1582399286,
    parse: ve,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_set_roles"
  },
  {
    opCode: 2616546844,
    parse: Ve,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_set_deposit_settings"
  },
  {
    opCode: 2994658477,
    parse: Fe,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_deploy_controller"
  },
  {
    opCode: 2574354460,
    parse: We,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_pool_prepare_governance_migration"
  },
  {
    opCode: 654743035,
    parse: Je,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_pool_send_message"
  },
  {
    opCode: 2531783976,
    parse: Ie,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_pool_upgrade"
  },
  {
    opCode: 2045231126,
    parse: Oe,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_pool_set_sudoer"
  },
  {
    opCode: 1917314981,
    parse: Me,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_pool_unhalt"
  },
  {
    opCode: 328866638,
    parse: je,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_controller_pool_halt"
  },
  {
    opCode: 3387966597,
    parse: Ge,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_imanager_set_interest"
  },
  {
    opCode: 1423144071,
    parse: $e,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_imanager_operation_fee"
  },
  {
    opCode: 2985012742,
    parse: He,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_imanager_request_notification"
  },
  {
    opCode: 3241429248,
    parse: Ke,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_imanager_stats"
  },
  {
    opCode: 4045930062,
    parse: ze,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_nft_burn"
  },
  {
    opCode: 3982012594,
    parse: Qe,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_nft_burn_notification"
  },
  {
    opCode: 321886789,
    parse: Ze,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_nft_init"
  },
  {
    opCode: 3678112445,
    parse: Xe,
    fixedLength: true,
    folderName: "liquid_stacking",
    internalName: "tonstake_nft_payout"
  },
  {
    opCode: 376746144,
    parse: Ye,
    fixedLength: false,
    folderName: "liquid_stacking",
    internalName: "tonstake_payout_mint_jettons"
  },
  {
    opCode: 2007184673,
    parse: to,
    fixedLength: false,
    folderName: "megaton_fi",
    internalName: "megaton_wton_mint"
  },
  {
    opCode: 1607220500,
    parse: eo,
    fixedLength: false,
    folderName: "nfts",
    internalName: "nft_transfer"
  },
  {
    opCode: 85167505,
    parse: oo,
    fixedLength: false,
    folderName: "nfts",
    internalName: "nft_ownership_assigned"
  },
  {
    opCode: 801842850,
    parse: no,
    fixedLength: false,
    folderName: "nfts",
    internalName: "get_static_data"
  },
  {
    opCode: 2339837749,
    parse: ao,
    fixedLength: false,
    folderName: "nfts",
    internalName: "report_static_data"
  },
  {
    opCode: 1765620048,
    parse: ro,
    fixedLength: false,
    folderName: "nfts",
    internalName: "get_royalty_params"
  },
  {
    opCode: 2831876269,
    parse: io,
    fixedLength: false,
    folderName: "nfts",
    internalName: "report_royalty_params"
  },
  {
    opCode: 81711432,
    parse: lo,
    fixedLength: false,
    folderName: "nfts",
    internalName: "prove_ownership"
  },
  {
    opCode: 86296494,
    parse: so,
    fixedLength: false,
    folderName: "nfts",
    internalName: "ownership_proof"
  },
  {
    opCode: 3502489578,
    parse: uo,
    fixedLength: false,
    folderName: "nfts",
    internalName: "sbt_request_owner"
  },
  {
    opCode: 232130531,
    parse: fo,
    fixedLength: false,
    folderName: "nfts",
    internalName: "sbt_owner_info"
  },
  {
    opCode: 520377210,
    parse: po,
    fixedLength: false,
    folderName: "nfts",
    internalName: "sbt_destroy"
  },
  {
    opCode: 1871312355,
    parse: mo,
    fixedLength: false,
    folderName: "nfts",
    internalName: "sbt_revoke"
  },
  {
    opCode: 1741148801,
    parse: go,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "top_up_channel_balance"
  },
  {
    opCode: 235282626,
    parse: _o,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "init_payment_channel"
  },
  {
    opCode: 1433884798,
    parse: yo,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "channel_cooperative_close"
  },
  {
    opCode: 2040604399,
    parse: Uo,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "channel_cooperative_commit"
  },
  {
    opCode: 521476815,
    parse: co,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "start_uncooperative_channel_close"
  },
  {
    opCode: 143567410,
    parse: So,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "challenge_quarantined_channel_state"
  },
  {
    opCode: 1727459433,
    parse: Bo,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "settle_channel_conditionals"
  },
  {
    opCode: 625158801,
    parse: xo,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "finish_uncooperative_channel_close"
  },
  {
    opCode: 3722217658,
    parse: bo,
    fixedLength: false,
    folderName: "payment_channels",
    internalName: "channel_closed"
  },
  {
    opCode: 630424929,
    parse: Po,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_swap"
  },
  {
    opCode: 4181439551,
    parse: Eo,
    fixedLength: true,
    folderName: "ston_fi",
    internalName: "stonfi_payment_request"
  },
  {
    opCode: 32736093,
    parse: Ao,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "pton_ton_transfer"
  },
  {
    opCode: 2921715614,
    parse: To,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "pton_ton_refund"
  },
  {
    opCode: 701638965,
    parse: Do,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "pton_reset_gas"
  },
  {
    opCode: 1331643155,
    parse: Ro,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "pton_deploy_wallet"
  },
  {
    opCode: 1698746245,
    parse: qo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "pton_internal_deploy"
  },
  {
    opCode: 116184359,
    parse: Lo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_cb_add_liquidity_v2"
  },
  {
    opCode: 935368415,
    parse: vo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_provide_lp_v2"
  },
  {
    opCode: 1355195988,
    parse: Vo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_add_liquidity_v2"
  },
  {
    opCode: 1702581493,
    parse: Fo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_pay_to_v2"
  },
  {
    opCode: 1717886506,
    parse: Wo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_swap_v2"
  },
  {
    opCode: 894160372,
    parse: Jo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_withdraw_fee_v2"
  },
  {
    opCode: 76607643,
    parse: Io,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_deposit_ref_fee_v2"
  },
  {
    opCode: 553699618,
    parse: Oo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_vault_pay_to_v2"
  },
  {
    opCode: 1664620082,
    parse: Mo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_pay_vault_v2"
  },
  {
    opCode: 695482319,
    parse: jo,
    fixedLength: false,
    folderName: "ston_fi",
    internalName: "stonfi_burn_notification_ext_v2"
  },
  {
    opCode: 3832843761,
    parse: $o,
    fixedLength: false,
    folderName: "storages",
    internalName: "deploy_storage_contract"
  },
  {
    opCode: 1408453846,
    parse: Ho,
    fixedLength: false,
    folderName: "storages",
    internalName: "update_pubkey"
  },
  {
    opCode: 1422651803,
    parse: Ko,
    fixedLength: false,
    folderName: "storages",
    internalName: "update_storage_params"
  },
  {
    opCode: 276580847,
    parse: zo,
    fixedLength: false,
    folderName: "storages",
    internalName: "offer_storage_contract"
  },
  {
    opCode: 2050365064,
    parse: Qo,
    fixedLength: false,
    folderName: "storages",
    internalName: "accept_storage_contract"
  },
  {
    opCode: 3570068941,
    parse: Zo,
    fixedLength: false,
    folderName: "storages",
    internalName: "storage_contract_confirmed"
  },
  {
    opCode: 2046375914,
    parse: Xo,
    fixedLength: false,
    folderName: "storages",
    internalName: "close_storage_contract"
  },
  {
    opCode: 3055775075,
    parse: Yo,
    fixedLength: false,
    folderName: "storages",
    internalName: "storage_contract_terminated"
  },
  {
    opCode: 1189949076,
    parse: tn,
    fixedLength: false,
    folderName: "storages",
    internalName: "storage_withdraw"
  },
  {
    opCode: 2837163862,
    parse: en,
    fixedLength: false,
    folderName: "storages",
    internalName: "storage_reward_withdrawal"
  },
  {
    opCode: 1100832077,
    parse: on,
    fixedLength: false,
    folderName: "storages",
    internalName: "proof_storage"
  },
  {
    opCode: 3989649062,
    parse: an,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_change_settings"
  },
  {
    opCode: 3058877505,
    parse: ln,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_pay_funding"
  },
  {
    opCode: 700515025,
    parse: sn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_vamm_init"
  },
  {
    opCode: 3410877500,
    parse: fn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_mint_referral"
  },
  {
    opCode: 2229071226,
    parse: pn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_add_referral_amount"
  },
  {
    opCode: 4124371794,
    parse: mn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_withdraw_referral_amount"
  },
  {
    opCode: 1329122024,
    parse: gn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_mint_executor"
  },
  {
    opCode: 1574331769,
    parse: _n,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_add_executor_amount"
  },
  {
    opCode: 752771921,
    parse: yn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_withdraw_executor_amount"
  },
  {
    opCode: 880147922,
    parse: Cn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_vault_trade_notification"
  },
  {
    opCode: 3365551844,
    parse: cn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_vault_stake"
  },
  {
    opCode: 3585468845,
    parse: wn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_vault_unstake"
  },
  {
    opCode: 700515025,
    parse: kn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_vault_init"
  },
  {
    opCode: 316235805,
    parse: Bn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_take_referral_fees"
  },
  {
    opCode: 1729316393,
    parse: xn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_cancel_order"
  },
  {
    opCode: 2744665076,
    parse: Nn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_create_order"
  },
  {
    opCode: 3482375704,
    parse: An,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_complete_order"
  },
  {
    opCode: 2637088320,
    parse: Dn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_activate_order"
  },
  {
    opCode: 1625278071,
    parse: Ln,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_update_position"
  },
  {
    opCode: 1562056632,
    parse: Fn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_update_position_with_stop_loss"
  },
  {
    opCode: 982793446,
    parse: Wn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_order_created"
  },
  {
    opCode: 1775273593,
    parse: Jn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_order_canceled"
  },
  {
    opCode: 36101990,
    parse: In,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_vault_request_withdraw_position"
  },
  {
    opCode: 2288366594,
    parse: Gn,
    fixedLength: false,
    folderName: "storm",
    internalName: "storm_provide_position"
  },
  {
    opCode: 4145513419,
    parse: $n,
    fixedLength: false,
    folderName: "subscriptions_v2",
    internalName: "subscription_v2_deploy"
  },
  {
    opCode: 1685288050,
    parse: Hn,
    fixedLength: false,
    folderName: "subscriptions_v2",
    internalName: "subscription_v2_destruct"
  },
  {
    opCode: 1350711532,
    parse: Kn,
    fixedLength: false,
    folderName: "subscriptions_v2",
    internalName: "subscription_v2_reduce_payment"
  },
  {
    opCode: 4033639783,
    parse: zn,
    fixedLength: false,
    folderName: "subscriptions_v2",
    internalName: "subscription_v2_payment_confirmed"
  },
  {
    opCode: 4166133070,
    parse: Qn,
    fixedLength: false,
    folderName: "subscriptions_v2",
    internalName: "subscription_v2_withdraw_to_beneficiary"
  },
  {
    opCode: 1178019994,
    parse: ta,
    fixedLength: false,
    folderName: "telegram",
    internalName: "telemint_deploy"
  },
  {
    opCode: 1178019995,
    parse: ra,
    fixedLength: false,
    folderName: "telegram",
    internalName: "telemint_deploy_v2"
  },
  {
    opCode: 697974293,
    parse: sa,
    fixedLength: false,
    folderName: "telegram",
    internalName: "teleitem_deploy"
  },
  {
    opCode: 1215991425,
    parse: fa,
    fixedLength: false,
    folderName: "telegram",
    internalName: "teleitem_start_auction"
  },
  {
    opCode: 924203182,
    parse: pa,
    fixedLength: false,
    folderName: "telegram",
    internalName: "teleitem_cancel_auction"
  },
  {
    opCode: 2742684035,
    parse: ma,
    fixedLength: false,
    folderName: "telegram",
    internalName: "teleitem_ok"
  },
  {
    opCode: 2754750433,
    parse: ga,
    fixedLength: false,
    folderName: "telegram",
    internalName: "teleitem_return_bid"
  },
  {
    opCode: 1399341111,
    parse: ha,
    fixedLength: false,
    folderName: "tonkeeper_2fa",
    internalName: "tonkeeper_2fa_signed"
  },
  {
    opCode: 3665837821,
    parse: Ca,
    fixedLength: false,
    folderName: "whales",
    internalName: "whales_nominators_withdraw"
  },
  {
    opCode: 2077040623,
    parse: ca,
    fixedLength: false,
    folderName: "whales",
    internalName: "whales_nominators_deposit"
  },
  {
    opCode: 362189324,
    parse: wa,
    fixedLength: false,
    folderName: "whales",
    internalName: "whales_nominators_force_kick"
  },
  {
    opCode: 1958425639,
    parse: ka,
    fixedLength: true,
    folderName: "whales",
    internalName: "whales_nominators_stake_withdraw_delayed"
  },
  {
    opCode: 601104865,
    parse: Sa,
    fixedLength: true,
    folderName: "whales",
    internalName: "whales_nominators_stake_withdraw_completed"
  },
  {
    opCode: 2718326572,
    parse: Ba,
    fixedLength: true,
    folderName: "whales",
    internalName: "whales_nominators_send_stake"
  },
  {
    opCode: 622684824,
    parse: xa,
    fixedLength: true,
    folderName: "whales",
    internalName: "whales_nominators_withdraw_unowned"
  },
  {
    opCode: 488052159,
    parse: ba,
    fixedLength: false,
    folderName: "whales",
    internalName: "whales_nominators_withdraw_unowned_response"
  },
  {
    opCode: 2577928699,
    parse: Na,
    fixedLength: false,
    folderName: "whales",
    internalName: "whales_nominators_accept_stake"
  },
  {
    opCode: 2711607604,
    parse: Pa,
    fixedLength: false,
    folderName: "whales",
    internalName: "whales_nominators_accept_withdraws"
  }
], Ha = $("tlb-abi:internal"); $("tlb-abi:jetton"); const za = {
  1112786133: [0],
  1227534771: [1],
  279039605: [2],
  2429028871: [3],
  946025784: [4],
  1544662441: [5],
  2078119902: [6, 31],
  3043726744: [7],
  1643009069: [8],
  1923917994: [9],
  2907617013: [10],
  1196394191: [11],
  3926267997: [12],
  3579725446: [13],
  567271467: [14],
  2547326767: [15],
  376237550: [16],
  1322339173: [17],
  1320284409: [18, 19],
  1153347137: [20],
  923790417: [21],
  1434249760: [22],
  1298755173: [23],
  1027039654: [24],
  1541764646: [25],
  1413869550: [26],
  2057453237: [27],
  260734629: [28],
  395134233: [29],
  1499400124: [30],
  1935855772: [32],
  4006754003: [33],
  1680571655: [34],
  1694626644: [35],
  4220051737: [36],
  593276754: [37],
  621336170: [38],
  3414567170: [39],
  4294967295: [40],
  0: [41],
  560454219: [42],
  3576854235: [43],
  3547469196: [44],
  378586628: [45],
  2068529894: [46],
  3902843902: [47],
  1316189259: [48],
  4084484172: [49],
  1197831204: [50],
  4184830756: [51],
  3946265093: [52],
  4043121232: [53],
  2399065977: [54],
  805462823: [55],
  3763363086: [56],
  1664463130: [57],
  3983767718: [58],
  1438805205: [59],
  3863136613: [60],
  3755778683: [61],
  1205158801: [62],
  1271382751: [63],
  715822752: [64],
  832244956: [65],
  175592284: [66],
  1582399286: [67],
  2616546844: [68],
  2994658477: [69],
  2574354460: [70],
  654743035: [71],
  2531783976: [72],
  2045231126: [73],
  1917314981: [74],
  328866638: [75],
  3387966597: [76],
  1423144071: [77],
  2985012742: [78],
  3241429248: [79],
  4045930062: [80],
  3982012594: [81],
  321886789: [82],
  3678112445: [83],
  376746144: [84],
  2007184673: [85],
  1607220500: [86],
  85167505: [87],
  801842850: [88],
  2339837749: [89],
  1765620048: [90],
  2831876269: [91],
  81711432: [92],
  86296494: [93],
  3502489578: [94],
  232130531: [95],
  520377210: [96],
  1871312355: [97],
  1741148801: [98],
  235282626: [99],
  1433884798: [100],
  2040604399: [101],
  521476815: [102],
  143567410: [103],
  1727459433: [104],
  625158801: [105],
  3722217658: [106],
  630424929: [107],
  4181439551: [108],
  32736093: [109],
  2921715614: [110],
  701638965: [111],
  1331643155: [112],
  1698746245: [113],
  116184359: [114],
  935368415: [115],
  1355195988: [116],
  1702581493: [117],
  1717886506: [118],
  894160372: [119],
  76607643: [120],
  553699618: [121],
  1664620082: [122],
  695482319: [123],
  3832843761: [124],
  1408453846: [125],
  1422651803: [126],
  276580847: [127],
  2050365064: [128],
  3570068941: [129],
  2046375914: [130],
  3055775075: [131],
  1189949076: [132],
  2837163862: [133],
  1100832077: [134],
  3989649062: [135],
  3058877505: [136],
  700515025: [137, 147],
  3410877500: [138],
  2229071226: [139],
  4124371794: [140],
  1329122024: [141],
  1574331769: [142],
  752771921: [143],
  880147922: [144],
  3365551844: [145],
  3585468845: [146],
  316235805: [148],
  1729316393: [149],
  2744665076: [150],
  3482375704: [151],
  2637088320: [152],
  1625278071: [153],
  1562056632: [154],
  982793446: [155],
  1775273593: [156],
  36101990: [157],
  2288366594: [158],
  4145513419: [159],
  1685288050: [160],
  1350711532: [161],
  4033639783: [162],
  4166133070: [163],
  1178019994: [164],
  1178019995: [165],
  697974293: [166],
  1215991425: [167],
  924203182: [168],
  2742684035: [169],
  2754750433: [170],
  1399341111: [171],
  3665837821: [172],
  2077040623: [173],
  362189324: [174],
  1958425639: [175],
  601104865: [176],
  2718326572: [177],
  622684824: [178],
  488052159: [179],
  2577928699: [180],
  2711607604: [181]
};
function Za(t) {
  if (t.remainingBits < 32)
    return;
  const e = t.preloadUint(32), o = za[e];
  if (o)
    for (const n of o) {
      const a = Ga[n];
      try {
        const r = t.asCell().toBoc(), d = a.parse(t);
        if (a.fixedLength && (t.remainingBits !== 0 || t.remainingRefs !== 0))
          throw new Error("Invalid data length");
        return {
          opCode: a.opCode,
          schema: a.folderName,
          internal: a.internalName,
          boc: r,
          data: d
        };
      } catch (r) {
        Ha("Failed to parse internal: %s", r);
      }
    }
}

/**
 * Creates a toncenter message payload for emulation
 */
function createToncenterMessage(walletAddress, messages) {
    return {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            from: walletAddress,
            valid_until: Math.floor(Date.now() / 1000) + 60,
            include_code_data: true,
            include_address_book: true,
            include_metadata: true,
            with_actions: true,
            messages: messages,
        }),
    };
}
/**
 * Fetches toncenter emulation result
 */
async function fetchToncenterEmulation(message) {
    const response = await fetch('https://toncenter.com/api/emulate/v1/emulateTonConnect', message);
    if (!response.ok) {
        throw new Error('Failed to fetch toncenter emulation result');
    }
    const result = (await response.json());
    return { result };
}
/**
 * Processes toncenter emulation result to extract money flow
 */
function processToncenterMoneyFlow(emulation) {
    if (!emulation || !emulation.result) {
        return {
            outputs: 0n,
            inputs: 0n,
            jettonTransfers: [],
            ourAddress: null,
        };
    }
    const firstTx = emulation.result.transactions[emulation.result.trace.tx_hash];
    // Get all transactions for our account
    const ourTxes = Object.values(emulation.result.transactions).filter((t) => t.account === firstTx.account);
    const messagesFrom = ourTxes.flatMap((t) => t.out_msgs);
    const messagesTo = ourTxes.flatMap((t) => t.in_msg).filter((m) => m !== null);
    // Calculate TON outputs
    const outputs = messagesFrom.reduce((acc, m) => {
        if (m.value) {
            return acc + BigInt(m.value);
        }
        return acc + 0n;
    }, 0n);
    // Calculate TON inputs
    const inputs = messagesTo.reduce((acc, m) => {
        if (m.value) {
            return acc + BigInt(m.value);
        }
        return acc + 0n;
    }, 0n);
    // Process jetton transfers
    const jettonTransfers = [];
    for (const t of Object.values(emulation.result.transactions)) {
        if (!t.in_msg?.source) {
            continue;
        }
        const parsed = Za(distExports$3.Cell.fromBase64(t.in_msg.message_content.body).beginParse());
        if (parsed?.internal !== 'jetton_transfer') {
            continue;
        }
        const from = distExports$3.Address.parse(t.in_msg.source);
        const to = parsed.data.destination instanceof distExports$3.Address ? parsed.data.destination : null;
        if (!to) {
            continue;
        }
        const jettonAmount = parsed.data.amount;
        const metadata = emulation.result.metadata[t.account];
        if (!metadata || !metadata?.token_info) {
            continue;
        }
        const tokenInfo = metadata.token_info.find((t) => t.valid && t.type === 'jetton_wallets');
        if (!tokenInfo) {
            continue;
        }
        const jettonAddress = distExports$3.Address.parse(tokenInfo.extra.jetton);
        jettonTransfers.push({
            from,
            to,
            jetton: jettonAddress,
            amount: jettonAmount,
        });
    }
    return {
        outputs,
        inputs,
        jettonTransfers,
        ourAddress: distExports$3.Address.parse(firstTx.account),
    };
}

function delay(ms) {
    return new Promise((resolve) => setTimeout(() => {
        resolve();
    }, ms));
}

// Function to call ton api untill we get response.
// Because testnet is pretty unstable we need to make sure response is final
// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function CallForSuccess(toCall, attempts = 20, delayMs = 100) {
    if (typeof toCall !== 'function') {
        throw new Error('unknown input');
    }
    let i = 0;
    let lastError;
    while (i < attempts) {
        try {
            const res = await toCall();
            return res;
        }
        catch (err) {
            lastError = err;
            i++;
            await delay(delayMs);
        }
    }
    throw lastError;
}

const log$m = globalLogger.createChild("TransactionHandler");
class TransactionHandler extends BasicHandler {
  eventEmitter;
  constructor(notify, eventEmitter) {
    super(notify);
    this.eventEmitter = eventEmitter;
  }
  canHandle(event) {
    return event.method === "sendTransaction";
  }
  async handle(event) {
    if (!event.wallet) {
      log$m.error("Wallet not found", { event });
      throw new Error("Wallet not found");
    }
    const request = this.parseTransactionRequest(event);
    if (!request) {
      log$m.error("Failed to parse transaction request", { event });
      throw new Error("Failed to parse transaction request");
    }
    const preview = await CallForSuccess(() => this.createTransactionPreview(request, event.wallet));
    const txEvent = {
      ...event,
      request,
      preview,
      wallet: event.wallet
    };
    return txEvent;
  }
  /**
   * Parse raw transaction request from bridge event
   */
  parseTransactionRequest(event) {
    try {
      if (event.params.length !== 1) {
        throw new Error("Invalid transaction request");
      }
      const params = JSON.parse(event.params[0]);
      const validUntilValidation = this.validateValidUntil(params.valid_until);
      if (!validUntilValidation.isValid) {
        throw new Error(`Invalid validUntil timestamp: ${validUntilValidation.errors.join(", ")}`);
      }
      const networkValidation = this.validateNetwork(params.network);
      if (!networkValidation.isValid) {
        throw new Error(`Invalid network: ${networkValidation.errors.join(", ")}`);
      }
      const fromValidation = this.validateFrom(params.from);
      if (!fromValidation.isValid) {
        throw new Error(`Invalid from address: ${fromValidation.errors.join(", ")}`);
      }
      const messagesValidation = validateTransactionMessages(params.messages);
      if (!messagesValidation.isValid) {
        throw new Error(`Invalid transaction messages: ${messagesValidation.errors.join(", ")}`);
      }
      return params;
    } catch (error) {
      log$m.error("Failed to parse transaction request", { error });
      return void 0;
    }
  }
  /**
   * Parse network from various possible formats
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  validateNetwork(network) {
    if (typeof network === "string") {
      if (network === "-3" || network === "-239") {
        return { isValid: true, errors: [] };
      }
    }
    return { isValid: false, errors: ["Invalid network"] };
  }
  validateFrom(from) {
    if (typeof from !== "string") {
      return { isValid: false, errors: ["Invalid from address"] };
    }
    if (isValidAddress(from)) {
      return { isValid: true, errors: [] };
    }
    return { isValid: false, errors: ["Invalid from address"] };
  }
  /**
   * Parse validUntil timestamp
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  validateValidUntil(validUntil) {
    if (typeof validUntil === "number" && !isNaN(validUntil)) {
      return { isValid: true, errors: [] };
    }
    return { isValid: false, errors: ["Invalid validUntil timestamp"] };
  }
  /**
   * Create human-readable transaction preview
   */
  async createTransactionPreview(request, wallet) {
    const emulationResult = await this.emulateTransaction(request, wallet);
    log$m.info("Emulation result", { emulationResult });
    return {
      // messages: [],
      moneyFlow: emulationResult.moneyFlow,
      emulationResult: emulationResult.emulationResult
      // messages: humanReadableMessages,
      // totalFees: emulationResult.totalFees,
      // willBounce: emulationResult.willBounce,
      // balanceBefore: emulationResult.balanceBefore,
      // balanceAfter: emulationResult.balanceAfter,
    };
  }
  /**
   * Parse BOC message to human-readable format
   */
  async parseMessageToHumanReadable(message, index) {
    try {
      const parsed = {
        to: message.address,
        valueTON: distExports$2.fromNano(message.amount).toString(),
        // comment: 'Comment from BOC data',
        type: "ton",
        extra: {
          // originalBoc: messageBoc,
          index
        }
      };
      return parsed;
    } catch (error) {
      log$m.warn("Failed to parse message", { index, error });
      return {
        to: "Unknown (parsing failed)",
        valueTON: "0",
        type: "raw",
        extra: {
          // originalBoc: message,
          error: error instanceof Error ? error.message : "Unknown error"
        }
      };
    }
  }
  /**
   * Emulate transaction to get fees and balance changes
   */
  async emulateTransaction(request, wallet) {
    const message = createToncenterMessage(wallet?.getAddress(), request.messages);
    const emulationResult = await CallForSuccess(() => fetchToncenterEmulation(message));
    const moneyFlow = processToncenterMoneyFlow(emulationResult);
    if (emulationResult.result) {
      try {
        this.eventEmitter.emit("emulation:result", emulationResult.result);
      } catch (error) {
        log$m.warn("Error emitting emulation result event", { error });
      }
    }
    return {
      emulationResult: emulationResult.result,
      moneyFlow
    };
  }
}

const BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
const BOC_PREFIX = 'te6cc';
function isValidObject(data) {
    return typeof data === 'object' && data !== null;
}
function isValidString(data) {
    return typeof data === 'string';
}
function hasExtraProperties(data, allowedKeys) {
    return typeof data === 'object' && data !== null && Object.keys(data).some((key) => !allowedKeys.includes(key));
}
function isValidBoc(value) {
    return typeof value === 'string' && BASE64_REGEX.test(value) && value.startsWith(BOC_PREFIX);
}
function validateSignDataPayload(data) {
    if (!isValidObject(data)) {
        return 'Payload must be an object';
    }
    if (!isValidString(data.type)) {
        return "'type' is required";
    }
    switch (data.type) {
        case 'text':
            return validateSignDataPayloadText(data);
        case 'binary':
            return validateSignDataPayloadBinary(data);
        case 'cell':
            return validateSignDataPayloadCell(data);
        default:
            return "Invalid 'type' value";
    }
}
function validateSignDataPayloadText(data) {
    const allowedKeys = ['type', 'text', 'network', 'from'];
    if (hasExtraProperties(data, allowedKeys)) {
        return 'Text payload contains extra properties';
    }
    if (!isValidString(data.text)) {
        return "'text' is required";
    }
    if (data.network !== undefined) {
        if (!isValidString(data.network) || !/^-?\d+$/.test(data.network)) {
            return "Invalid 'network' format";
        }
    }
    if (data.from !== undefined && !isValidString(data.from)) {
        return "Invalid 'from'";
    }
    return null;
}
function validateSignDataPayloadBinary(data) {
    const allowedKeys = ['type', 'bytes', 'network', 'from'];
    if (hasExtraProperties(data, allowedKeys)) {
        return 'Binary payload contains extra properties';
    }
    if (!isValidString(data.bytes)) {
        return "'bytes' is required";
    }
    if (data.network !== undefined) {
        if (!isValidString(data.network) || !/^-?\d+$/.test(data.network)) {
            return "Invalid 'network' format";
        }
    }
    if (data.from !== undefined && !isValidString(data.from)) {
        return "Invalid 'from'";
    }
    return null;
}
function validateSignDataPayloadCell(data) {
    const allowedKeys = ['type', 'schema', 'cell', 'network', 'from'];
    if (hasExtraProperties(data, allowedKeys)) {
        return 'Cell payload contains extra properties';
    }
    if (!isValidString(data.schema)) {
        return "'schema' is required";
    }
    if (!isValidString(data.cell)) {
        return "'cell' is required";
    }
    if (!isValidBoc(data.cell)) {
        return "Invalid 'cell' format (must be valid base64)";
    }
    if (data.network !== undefined) {
        if (!isValidString(data.network) || !/^-?\d+$/.test(data.network)) {
            return "Invalid 'network' format";
        }
    }
    if (data.from !== undefined && !isValidString(data.from)) {
        return "Invalid 'from'";
    }
    return null;
}

var dist = {};

var intermediate = {};

var main$1 = { exports: {} };
function isValidType(type) {
  return type === "description" || type === "string" || type === "code";
}
function Failure$2(pexpr, text, type) {
  if (!isValidType(type)) {
    throw new Error("invalid Failure type: " + type);
  }
  this.pexpr = pexpr;
  this.text = text;
  this.type = type;
  this.fluffy = false;
}
Failure$2.prototype.getPExpr = function() {
  return this.pexpr;
};
Failure$2.prototype.getText = function() {
  return this.text;
};
Failure$2.prototype.getType = function() {
  return this.type;
};
Failure$2.prototype.isDescription = function() {
  return this.type === "description";
};
Failure$2.prototype.isStringTerminal = function() {
  return this.type === "string";
};
Failure$2.prototype.isCode = function() {
  return this.type === "code";
};
Failure$2.prototype.isFluffy = function() {
  return this.fluffy;
};
Failure$2.prototype.makeFluffy = function() {
  this.fluffy = true;
};
Failure$2.prototype.clearFluffy = function() {
  this.fluffy = false;
};
Failure$2.prototype.subsumes = function(that) {
  return this.getText() === that.getText() && this.type === that.type && (!this.isFluffy() || this.isFluffy() && that.isFluffy());
};
Failure$2.prototype.toString = function() {
  return this.type === "string" ? JSON.stringify(this.getText()) : this.getText();
};
Failure$2.prototype.clone = function() {
  const failure = new Failure$2(this.pexpr, this.text, this.type);
  if (this.isFluffy()) {
    failure.makeFluffy();
  }
  return failure;
};
Failure$2.prototype.toKey = function() {
  return this.toString() + "#" + this.type;
};
var Failure_1 = Failure$2;
var common$l = {};
(function(exports) {
  exports.abstract = function(optMethodName) {
    const methodName = optMethodName || "";
    return function() {
      throw new Error(
        "this method " + methodName + " is abstract! (it has no implementation in class " + this.constructor.name + ")"
      );
    };
  };
  exports.assert = function(cond, message) {
    if (!cond) {
      throw new Error(message || "Assertion failed");
    }
  };
  exports.defineLazyProperty = function(obj, propName, getterFn) {
    let memo;
    Object.defineProperty(obj, propName, {
      get() {
        if (!memo) {
          memo = getterFn.call(this);
        }
        return memo;
      }
    });
  };
  exports.clone = function(obj) {
    if (obj) {
      return Object.assign({}, obj);
    }
    return obj;
  };
  exports.repeatFn = function(fn, n) {
    const arr = [];
    while (n-- > 0) {
      arr.push(fn());
    }
    return arr;
  };
  exports.repeatStr = function(str, n) {
    return new Array(n + 1).join(str);
  };
  exports.repeat = function(x, n) {
    return exports.repeatFn(() => x, n);
  };
  exports.getDuplicates = function(array) {
    const duplicates = [];
    for (let idx = 0; idx < array.length; idx++) {
      const x = array[idx];
      if (array.lastIndexOf(x) !== idx && duplicates.indexOf(x) < 0) {
        duplicates.push(x);
      }
    }
    return duplicates;
  };
  exports.copyWithoutDuplicates = function(array) {
    const noDuplicates = [];
    array.forEach((entry) => {
      if (noDuplicates.indexOf(entry) < 0) {
        noDuplicates.push(entry);
      }
    });
    return noDuplicates;
  };
  exports.isSyntactic = function(ruleName) {
    const firstChar = ruleName[0];
    return firstChar === firstChar.toUpperCase();
  };
  exports.isLexical = function(ruleName) {
    return !exports.isSyntactic(ruleName);
  };
  exports.padLeft = function(str, len, optChar) {
    const ch = optChar || " ";
    if (str.length < len) {
      return exports.repeatStr(ch, len - str.length) + str;
    }
    return str;
  };
  exports.StringBuffer = function() {
    this.strings = [];
  };
  exports.StringBuffer.prototype.append = function(str) {
    this.strings.push(str);
  };
  exports.StringBuffer.prototype.contents = function() {
    return this.strings.join("");
  };
  const escapeUnicode = (str) => String.fromCodePoint(parseInt(str, 16));
  exports.unescapeCodePoint = function(s) {
    if (s.charAt(0) === "\\") {
      switch (s.charAt(1)) {
        case "b":
          return "\b";
        case "f":
          return "\f";
        case "n":
          return "\n";
        case "r":
          return "\r";
        case "t":
          return "	";
        case "v":
          return "\v";
        case "x":
          return escapeUnicode(s.slice(2, 4));
        case "u":
          return s.charAt(2) === "{" ? escapeUnicode(s.slice(3, -1)) : escapeUnicode(s.slice(2, 6));
        default:
          return s.charAt(1);
      }
    } else {
      return s;
    }
  };
  exports.unexpectedObjToString = function(obj) {
    if (obj == null) {
      return String(obj);
    }
    const baseToString = Object.prototype.toString.call(obj);
    try {
      let typeName;
      if (obj.constructor && obj.constructor.name) {
        typeName = obj.constructor.name;
      } else if (baseToString.indexOf("[object ") === 0) {
        typeName = baseToString.slice(8, -1);
      } else {
        typeName = typeof obj;
      }
      return typeName + ": " + JSON.stringify(String(obj));
    } catch (e) {
      return baseToString;
    }
  };
})(common$l);
const common$k = common$l;
class Node {
  constructor(matchLength) {
    this.matchLength = matchLength;
  }
  get ctorName() {
    throw new Error("subclass responsibility");
  }
  numChildren() {
    return this.children ? this.children.length : 0;
  }
  childAt(idx) {
    if (this.children) {
      return this.children[idx];
    }
  }
  indexOfChild(arg) {
    return this.children.indexOf(arg);
  }
  hasChildren() {
    return this.numChildren() > 0;
  }
  hasNoChildren() {
    return !this.hasChildren();
  }
  onlyChild() {
    if (this.numChildren() !== 1) {
      throw new Error(
        "cannot get only child of a node of type " + this.ctorName + " (it has " + this.numChildren() + " children)"
      );
    } else {
      return this.firstChild();
    }
  }
  firstChild() {
    if (this.hasNoChildren()) {
      throw new Error(
        "cannot get first child of a " + this.ctorName + " node, which has no children"
      );
    } else {
      return this.childAt(0);
    }
  }
  lastChild() {
    if (this.hasNoChildren()) {
      throw new Error(
        "cannot get last child of a " + this.ctorName + " node, which has no children"
      );
    } else {
      return this.childAt(this.numChildren() - 1);
    }
  }
  childBefore(child) {
    const childIdx = this.indexOfChild(child);
    if (childIdx < 0) {
      throw new Error("Node.childBefore() called w/ an argument that is not a child");
    } else if (childIdx === 0) {
      throw new Error("cannot get child before first child");
    } else {
      return this.childAt(childIdx - 1);
    }
  }
  childAfter(child) {
    const childIdx = this.indexOfChild(child);
    if (childIdx < 0) {
      throw new Error("Node.childAfter() called w/ an argument that is not a child");
    } else if (childIdx === this.numChildren() - 1) {
      throw new Error("cannot get child after last child");
    } else {
      return this.childAt(childIdx + 1);
    }
  }
  isTerminal() {
    return false;
  }
  isNonterminal() {
    return false;
  }
  isIteration() {
    return false;
  }
  isOptional() {
    return false;
  }
}
class TerminalNode$2 extends Node {
  get ctorName() {
    return "_terminal";
  }
  isTerminal() {
    return true;
  }
  get primitiveValue() {
    throw new Error("The `primitiveValue` property was removed in Ohm v17.");
  }
}
class NonterminalNode$1 extends Node {
  constructor(ruleName, children, childOffsets, matchLength) {
    super(matchLength);
    this.ruleName = ruleName;
    this.children = children;
    this.childOffsets = childOffsets;
  }
  get ctorName() {
    return this.ruleName;
  }
  isNonterminal() {
    return true;
  }
  isLexical() {
    return common$k.isLexical(this.ctorName);
  }
  isSyntactic() {
    return common$k.isSyntactic(this.ctorName);
  }
}
class IterationNode$2 extends Node {
  constructor(children, childOffsets, matchLength, isOptional) {
    super(matchLength);
    this.children = children;
    this.childOffsets = childOffsets;
    this.optional = isOptional;
  }
  get ctorName() {
    return "_iter";
  }
  isIteration() {
    return true;
  }
  isOptional() {
    return this.optional;
  }
}
var nodes$1 = {
  TerminalNode: TerminalNode$2,
  NonterminalNode: NonterminalNode$1,
  IterationNode: IterationNode$2
};
var pexprsMain = {};
var UnicodeCategories$1 = {
  // Letters
  Lu: /[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A]|\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]/,
  Ll: /[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]/,
  Lt: /[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]/,
  Lm: /[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]/,
  Lo: /[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
  // Numbers
  Nl: /[\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF]|\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]|\uD809[\uDC00-\uDC6E]/,
  Nd: /[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD801[\uDCA0-\uDCA9]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|[\uD805\uD807][\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDD50-\uDD59]/,
  // Marks
  Mn: /[\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D01\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDCA-\uDDCC\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]/,
  Mc: /[\u0903-\u0903]|[\u093E-\u0940]|[\u0949-\u094C]|[\u0982-\u0983]|[\u09BE-\u09C0]|[\u09C7-\u09C8]|[\u09CB-\u09CC]|[\u09D7-\u09D7]|[\u0A3E-\u0A40]|[\u0A83-\u0A83]|[\u0ABE-\u0AC0]|[\u0AC9-\u0AC9]|[\u0ACB-\u0ACC]|[\u0B02-\u0B03]|[\u0B3E-\u0B3E]|[\u0B40-\u0B40]|[\u0B47-\u0B48]|[\u0B4B-\u0B4C]|[\u0B57-\u0B57]|[\u0B83-\u0B83]|[\u0BBE-\u0BBF]|[\u0BC1-\u0BC2]|[\u0BC6-\u0BC8]|[\u0BCA-\u0BCC]|[\u0BD7-\u0BD7]|[\u0C01-\u0C03]|[\u0C41-\u0C44]|[\u0C82-\u0C83]|[\u0CBE-\u0CBE]|[\u0CC0-\u0CC4]|[\u0CC7-\u0CC8]|[\u0CCA-\u0CCB]|[\u0CD5-\u0CD6]|[\u0D02-\u0D03]|[\u0D3E-\u0D40]|[\u0D46-\u0D48]|[\u0D4A-\u0D4C]|[\u0D57-\u0D57]|[\u0F3E-\u0F3F]|[\u0F7F-\u0F7F]/,
  // Punctuation, Connector
  Pc: /[_\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F]/,
  // Separator, Space
  Zs: /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/,
  // These two are not real Unicode categories, but our useful for Ohm.
  // L is a combination of all the letter categories.
  // Ltmo is a combination of Lt, Lm, and Lo.
  L: /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
  Ltmo: /[\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC]|[\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F]|\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0]|[\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/
};
const UnicodeCategories = UnicodeCategories$1;
const common$j = common$l;
class PExpr$1 {
  constructor() {
    if (this.constructor === PExpr$1) {
      throw new Error("PExpr cannot be instantiated -- it's abstract");
    }
  }
  // Set the `source` property to the interval containing the source for this expression.
  withSource(interval) {
    if (interval) {
      this.source = interval.trimmed();
    }
    return this;
  }
}
const any = Object.create(PExpr$1.prototype);
const end = Object.create(PExpr$1.prototype);
class Terminal$1 extends PExpr$1 {
  constructor(obj) {
    super();
    this.obj = obj;
  }
}
class Range extends PExpr$1 {
  constructor(from, to) {
    super();
    this.from = from;
    this.to = to;
    this.matchCodePoint = from.length > 1 || to.length > 1;
  }
}
class Param extends PExpr$1 {
  constructor(index) {
    super();
    this.index = index;
  }
}
class Alt extends PExpr$1 {
  constructor(terms) {
    super();
    this.terms = terms;
  }
}
class Extend extends Alt {
  constructor(superGrammar, name2, body) {
    const origBody = superGrammar.rules[name2].body;
    super([body, origBody]);
    this.superGrammar = superGrammar;
    this.name = name2;
    this.body = body;
  }
}
class Splice extends Alt {
  constructor(superGrammar, ruleName, beforeTerms, afterTerms) {
    const origBody = superGrammar.rules[ruleName].body;
    super([...beforeTerms, origBody, ...afterTerms]);
    this.superGrammar = superGrammar;
    this.ruleName = ruleName;
    this.expansionPos = beforeTerms.length;
  }
}
class Seq extends PExpr$1 {
  constructor(factors) {
    super();
    this.factors = factors;
  }
}
class Iter extends PExpr$1 {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}
class Star extends Iter {
}
class Plus extends Iter {
}
class Opt extends Iter {
}
Star.prototype.operator = "*";
Plus.prototype.operator = "+";
Opt.prototype.operator = "?";
Star.prototype.minNumMatches = 0;
Plus.prototype.minNumMatches = 1;
Opt.prototype.minNumMatches = 0;
Star.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
Plus.prototype.maxNumMatches = Number.POSITIVE_INFINITY;
Opt.prototype.maxNumMatches = 1;
class Not extends PExpr$1 {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}
class Lookahead extends PExpr$1 {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}
class Lex extends PExpr$1 {
  constructor(expr) {
    super();
    this.expr = expr;
  }
}
class Apply extends PExpr$1 {
  constructor(ruleName, args = []) {
    super();
    this.ruleName = ruleName;
    this.args = args;
  }
  isSyntactic() {
    return common$j.isSyntactic(this.ruleName);
  }
  // This method just caches the result of `this.toString()` in a non-enumerable property.
  toMemoKey() {
    if (!this._memoKey) {
      Object.defineProperty(this, "_memoKey", { value: this.toString() });
    }
    return this._memoKey;
  }
}
class UnicodeChar extends PExpr$1 {
  constructor(category) {
    super();
    this.category = category;
    this.pattern = UnicodeCategories[category];
  }
}
pexprsMain.PExpr = PExpr$1;
pexprsMain.any = any;
pexprsMain.end = end;
pexprsMain.Terminal = Terminal$1;
pexprsMain.Range = Range;
pexprsMain.Param = Param;
pexprsMain.Alt = Alt;
pexprsMain.Extend = Extend;
pexprsMain.Splice = Splice;
pexprsMain.Seq = Seq;
pexprsMain.Iter = Iter;
pexprsMain.Star = Star;
pexprsMain.Plus = Plus;
pexprsMain.Opt = Opt;
pexprsMain.Not = Not;
pexprsMain.Lookahead = Lookahead;
pexprsMain.Lex = Lex;
pexprsMain.Apply = Apply;
pexprsMain.UnicodeChar = UnicodeChar;
const common$i = common$l;
const pexprs$l = pexprsMain;
pexprs$l.PExpr.prototype.allowsSkippingPrecedingSpace = common$i.abstract(
  "allowsSkippingPrecedingSpace"
);
pexprs$l.any.allowsSkippingPrecedingSpace = pexprs$l.end.allowsSkippingPrecedingSpace = pexprs$l.Apply.prototype.allowsSkippingPrecedingSpace = pexprs$l.Terminal.prototype.allowsSkippingPrecedingSpace = pexprs$l.Range.prototype.allowsSkippingPrecedingSpace = pexprs$l.UnicodeChar.prototype.allowsSkippingPrecedingSpace = function() {
  return true;
};
pexprs$l.Alt.prototype.allowsSkippingPrecedingSpace = pexprs$l.Iter.prototype.allowsSkippingPrecedingSpace = pexprs$l.Lex.prototype.allowsSkippingPrecedingSpace = pexprs$l.Lookahead.prototype.allowsSkippingPrecedingSpace = pexprs$l.Not.prototype.allowsSkippingPrecedingSpace = pexprs$l.Param.prototype.allowsSkippingPrecedingSpace = pexprs$l.Seq.prototype.allowsSkippingPrecedingSpace = function() {
  return false;
};
function Namespace$2() {
}
Namespace$2.prototype = /* @__PURE__ */ Object.create(null);
Namespace$2.asNamespace = function(objOrNamespace) {
  if (objOrNamespace instanceof Namespace$2) {
    return objOrNamespace;
  }
  return Namespace$2.createNamespace(objOrNamespace);
};
Namespace$2.createNamespace = function(optProps) {
  return Namespace$2.extend(Namespace$2.prototype, optProps);
};
Namespace$2.extend = function(namespace, optProps) {
  if (namespace !== Namespace$2.prototype && !(namespace instanceof Namespace$2)) {
    throw new TypeError("not a Namespace object: " + namespace);
  }
  const ns = Object.create(namespace, {
    constructor: {
      value: Namespace$2,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  return Object.assign(ns, optProps);
};
Namespace$2.toString = function(ns) {
  return Object.prototype.toString.call(ns);
};
var Namespace_1 = Namespace$2;
const { assert: assert$3 } = common$l;
const Namespace$1 = Namespace_1;
const pexprs$k = pexprsMain;
function createError(message, optInterval) {
  let e;
  if (optInterval) {
    e = new Error(optInterval.getLineAndColumnMessage() + message);
    e.shortMessage = message;
    e.interval = optInterval;
  } else {
    e = new Error(message);
  }
  return e;
}
function intervalSourcesDontMatch() {
  return createError("Interval sources don't match");
}
function grammarSyntaxError(matchFailure) {
  const e = new Error();
  Object.defineProperty(e, "message", {
    enumerable: true,
    get() {
      return matchFailure.message;
    }
  });
  Object.defineProperty(e, "shortMessage", {
    enumerable: true,
    get() {
      return "Expected " + matchFailure.getExpectedText();
    }
  });
  e.interval = matchFailure.getInterval();
  return e;
}
function undeclaredGrammar(grammarName, namespace, interval) {
  const message = namespace ? "Grammar " + grammarName + " is not declared in namespace " + Namespace$1.toString(namespace) : "Undeclared grammar " + grammarName;
  return createError(message, interval);
}
function duplicateGrammarDeclaration(grammar2, namespace) {
  return createError("Grammar " + grammar2.name + " is already declared in this namespace");
}
function undeclaredRule(ruleName, grammarName, optInterval) {
  return createError(
    "Rule " + ruleName + " is not declared in grammar " + grammarName,
    optInterval
  );
}
function cannotOverrideUndeclaredRule(ruleName, grammarName, optSource) {
  return createError(
    "Cannot override rule " + ruleName + " because it is not declared in " + grammarName,
    optSource
  );
}
function cannotExtendUndeclaredRule(ruleName, grammarName, optSource) {
  return createError(
    "Cannot extend rule " + ruleName + " because it is not declared in " + grammarName,
    optSource
  );
}
function duplicateRuleDeclaration(ruleName, grammarName, declGrammarName, optSource) {
  let message = "Duplicate declaration for rule '" + ruleName + "' in grammar '" + grammarName + "'";
  if (grammarName !== declGrammarName) {
    message += " (originally declared in '" + declGrammarName + "')";
  }
  return createError(message, optSource);
}
function wrongNumberOfParameters(ruleName, expected, actual, source) {
  return createError(
    "Wrong number of parameters for rule " + ruleName + " (expected " + expected + ", got " + actual + ")",
    source
  );
}
function wrongNumberOfArguments(ruleName, expected, actual, expr) {
  return createError(
    "Wrong number of arguments for rule " + ruleName + " (expected " + expected + ", got " + actual + ")",
    expr
  );
}
function duplicateParameterNames(ruleName, duplicates, source) {
  return createError(
    "Duplicate parameter names in rule " + ruleName + ": " + duplicates.join(", "),
    source
  );
}
function invalidParameter(ruleName, expr) {
  return createError(
    "Invalid parameter to rule " + ruleName + ": " + expr + " has arity " + expr.getArity() + ", but parameter expressions must have arity 1",
    expr.source
  );
}
const syntacticVsLexicalNote = "NOTE: A _syntactic rule_ is a rule whose name begins with a capital letter. See https://ohmjs.org/d/svl for more details.";
function applicationOfSyntacticRuleFromLexicalContext(ruleName, applyExpr) {
  return createError(
    "Cannot apply syntactic rule " + ruleName + " from here (inside a lexical context)",
    applyExpr.source
  );
}
function applySyntacticWithLexicalRuleApplication(applyExpr) {
  const { ruleName } = applyExpr;
  return createError(
    `applySyntactic is for syntactic rules, but '${ruleName}' is a lexical rule. ` + syntacticVsLexicalNote,
    applyExpr.source
  );
}
function unnecessaryExperimentalApplySyntactic(applyExpr) {
  return createError(
    "applySyntactic is not required here (in a syntactic context)",
    applyExpr.source
  );
}
function incorrectArgumentType(expectedType, expr) {
  return createError("Incorrect argument type: expected " + expectedType, expr.source);
}
function multipleSuperSplices(expr) {
  return createError("'...' can appear at most once in a rule body", expr.source);
}
function invalidCodePoint(applyWrapper) {
  const node = applyWrapper._node;
  assert$3(node && node.isNonterminal() && node.ctorName === "escapeChar_unicodeCodePoint");
  const digitIntervals = applyWrapper.children.slice(1, -1).map((d) => d.source);
  const fullInterval = digitIntervals[0].coverageWith(...digitIntervals.slice(1));
  return createError(
    `U+${fullInterval.contents} is not a valid Unicode code point`,
    fullInterval
  );
}
function kleeneExprHasNullableOperand(kleeneExpr, applicationStack) {
  const actuals = applicationStack.length > 0 ? applicationStack[applicationStack.length - 1].args : [];
  const expr = kleeneExpr.expr.substituteParams(actuals);
  let message = "Nullable expression " + expr + " is not allowed inside '" + kleeneExpr.operator + "' (possible infinite loop)";
  if (applicationStack.length > 0) {
    const stackTrace = applicationStack.map((app) => new pexprs$k.Apply(app.ruleName, app.args)).join("\n");
    message += "\nApplication stack (most recent application last):\n" + stackTrace;
  }
  return createError(message, kleeneExpr.expr.source);
}
function inconsistentArity(ruleName, expected, actual, expr) {
  return createError(
    "Rule " + ruleName + " involves an alternation which has inconsistent arity (expected " + expected + ", got " + actual + ")",
    expr.source
  );
}
function duplicatePropertyNames(duplicates) {
  return createError("Object pattern has duplicate property names: " + duplicates.join(", "));
}
function invalidConstructorCall(grammar2, ctorName, children) {
  return createError(
    "Attempt to invoke constructor " + ctorName + " with invalid or unexpected arguments"
  );
}
function multipleErrors(errors2) {
  const messages = errors2.map((e) => e.message);
  return createError(["Errors:"].concat(messages).join("\n- "), errors2[0].interval);
}
function missingSemanticAction(ctorName, name2, type, stack) {
  let stackTrace = stack.slice(0, -1).map((info) => {
    const ans = "  " + info[0].name + " > " + info[1];
    return info.length === 3 ? ans + " for '" + info[2] + "'" : ans;
  }).join("\n");
  stackTrace += "\n  " + name2 + " > " + ctorName;
  let moreInfo = "";
  if (ctorName === "_iter") {
    moreInfo = [
      "\nNOTE: as of Ohm v16, there is no default action for iteration nodes  see ",
      "  https://ohmjs.org/d/dsa for details."
    ].join("\n");
  }
  const message = [
    `Missing semantic action for '${ctorName}' in ${type} '${name2}'.${moreInfo}`,
    "Action stack (most recent call last):",
    stackTrace
  ].join("\n");
  const e = createError(message);
  e.name = "missingSemanticAction";
  return e;
}
var errors$9 = {
  applicationOfSyntacticRuleFromLexicalContext,
  applySyntacticWithLexicalRuleApplication,
  cannotExtendUndeclaredRule,
  cannotOverrideUndeclaredRule,
  duplicateGrammarDeclaration,
  duplicateParameterNames,
  duplicatePropertyNames,
  duplicateRuleDeclaration,
  inconsistentArity,
  incorrectArgumentType,
  intervalSourcesDontMatch,
  invalidCodePoint,
  invalidConstructorCall,
  invalidParameter,
  grammarSyntaxError,
  kleeneExprHasNullableOperand,
  missingSemanticAction,
  multipleSuperSplices,
  undeclaredGrammar,
  undeclaredRule,
  unnecessaryExperimentalApplySyntactic,
  wrongNumberOfArguments,
  wrongNumberOfParameters,
  throwErrors(errors2) {
    if (errors2.length === 1) {
      throw errors2[0];
    }
    if (errors2.length > 1) {
      throw multipleErrors(errors2);
    }
  }
};
var util$7 = {};
(function(exports) {
  const common2 = common$l;
  function padNumbersToEqualLength(arr) {
    let maxLen = 0;
    const strings = arr.map((n) => {
      const str = n.toString();
      maxLen = Math.max(maxLen, str.length);
      return str;
    });
    return strings.map((s) => common2.padLeft(s, maxLen));
  }
  function strcpy(dest, src, offset) {
    const origDestLen = dest.length;
    const start = dest.slice(0, offset);
    const end2 = dest.slice(offset + src.length);
    return (start + src + end2).substr(0, origDestLen);
  }
  function lineAndColumnToMessage(...ranges) {
    const lineAndCol = this;
    const { offset } = lineAndCol;
    const { repeatStr } = common2;
    const sb = new common2.StringBuffer();
    sb.append("Line " + lineAndCol.lineNum + ", col " + lineAndCol.colNum + ":\n");
    const lineNumbers = padNumbersToEqualLength([
      lineAndCol.prevLine == null ? 0 : lineAndCol.lineNum - 1,
      lineAndCol.lineNum,
      lineAndCol.nextLine == null ? 0 : lineAndCol.lineNum + 1
    ]);
    const appendLine = (num, content, prefix) => {
      sb.append(prefix + lineNumbers[num] + " | " + content + "\n");
    };
    if (lineAndCol.prevLine != null) {
      appendLine(0, lineAndCol.prevLine, "  ");
    }
    appendLine(1, lineAndCol.line, "> ");
    const lineLen = lineAndCol.line.length;
    let indicationLine = repeatStr(" ", lineLen + 1);
    for (let i = 0; i < ranges.length; ++i) {
      let startIdx = ranges[i][0];
      let endIdx = ranges[i][1];
      common2.assert(startIdx >= 0 && startIdx <= endIdx, "range start must be >= 0 and <= end");
      const lineStartOffset = offset - lineAndCol.colNum + 1;
      startIdx = Math.max(0, startIdx - lineStartOffset);
      endIdx = Math.min(endIdx - lineStartOffset, lineLen);
      indicationLine = strcpy(indicationLine, repeatStr("~", endIdx - startIdx), startIdx);
    }
    const gutterWidth = 2 + lineNumbers[1].length + 3;
    sb.append(repeatStr(" ", gutterWidth));
    indicationLine = strcpy(indicationLine, "^", lineAndCol.colNum - 1);
    sb.append(indicationLine.replace(/ +$/, "") + "\n");
    if (lineAndCol.nextLine != null) {
      appendLine(2, lineAndCol.nextLine, "  ");
    }
    return sb.contents();
  }
  let builtInRulesCallbacks = [];
  exports.awaitBuiltInRules = (cb) => {
    builtInRulesCallbacks.push(cb);
  };
  exports.announceBuiltInRules = (grammar2) => {
    builtInRulesCallbacks.forEach((cb) => {
      cb(grammar2);
    });
    builtInRulesCallbacks = null;
  };
  exports.getLineAndColumn = (str, offset) => {
    let lineNum = 1;
    let colNum = 1;
    let currOffset = 0;
    let lineStartOffset = 0;
    let nextLine = null;
    let prevLine = null;
    let prevLineStartOffset = -1;
    while (currOffset < offset) {
      const c = str.charAt(currOffset++);
      if (c === "\n") {
        lineNum++;
        colNum = 1;
        prevLineStartOffset = lineStartOffset;
        lineStartOffset = currOffset;
      } else if (c !== "\r") {
        colNum++;
      }
    }
    let lineEndOffset = str.indexOf("\n", lineStartOffset);
    if (lineEndOffset === -1) {
      lineEndOffset = str.length;
    } else {
      const nextLineEndOffset = str.indexOf("\n", lineEndOffset + 1);
      nextLine = nextLineEndOffset === -1 ? str.slice(lineEndOffset) : str.slice(lineEndOffset, nextLineEndOffset);
      nextLine = nextLine.replace(/^\r?\n/, "").replace(/\r$/, "");
    }
    if (prevLineStartOffset >= 0) {
      prevLine = str.slice(prevLineStartOffset, lineStartOffset).replace(/\r?\n$/, "");
    }
    const line = str.slice(lineStartOffset, lineEndOffset).replace(/\r$/, "");
    return {
      offset,
      lineNum,
      colNum,
      line,
      prevLine,
      nextLine,
      toString: lineAndColumnToMessage
    };
  };
  exports.getLineAndColumnMessage = function(str, offset, ...ranges) {
    return exports.getLineAndColumn(str, offset).toString(...ranges);
  };
  exports.uniqueId = /* @__PURE__ */ (() => {
    let idCounter = 0;
    return (prefix) => "" + prefix + idCounter++;
  })();
})(util$7);
const { abstract, isSyntactic } = common$l;
const errors$8 = errors$9;
const pexprs$j = pexprsMain;
const util$6 = util$7;
let BuiltInRules;
util$6.awaitBuiltInRules((g) => {
  BuiltInRules = g;
});
let lexifyCount;
pexprs$j.PExpr.prototype.assertAllApplicationsAreValid = function(ruleName, grammar2) {
  lexifyCount = 0;
  this._assertAllApplicationsAreValid(ruleName, grammar2);
};
pexprs$j.PExpr.prototype._assertAllApplicationsAreValid = abstract(
  "_assertAllApplicationsAreValid"
);
pexprs$j.any._assertAllApplicationsAreValid = pexprs$j.end._assertAllApplicationsAreValid = pexprs$j.Terminal.prototype._assertAllApplicationsAreValid = pexprs$j.Range.prototype._assertAllApplicationsAreValid = pexprs$j.Param.prototype._assertAllApplicationsAreValid = pexprs$j.UnicodeChar.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
};
pexprs$j.Lex.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
  lexifyCount++;
  this.expr._assertAllApplicationsAreValid(ruleName, grammar2);
  lexifyCount--;
};
pexprs$j.Alt.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    this.terms[idx]._assertAllApplicationsAreValid(ruleName, grammar2);
  }
};
pexprs$j.Seq.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx]._assertAllApplicationsAreValid(ruleName, grammar2);
  }
};
pexprs$j.Iter.prototype._assertAllApplicationsAreValid = pexprs$j.Not.prototype._assertAllApplicationsAreValid = pexprs$j.Lookahead.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2) {
  this.expr._assertAllApplicationsAreValid(ruleName, grammar2);
};
pexprs$j.Apply.prototype._assertAllApplicationsAreValid = function(ruleName, grammar2, skipSyntacticCheck = false) {
  const ruleInfo = grammar2.rules[this.ruleName];
  const isContextSyntactic = isSyntactic(ruleName) && lexifyCount === 0;
  if (!ruleInfo) {
    throw errors$8.undeclaredRule(this.ruleName, grammar2.name, this.source);
  }
  if (!skipSyntacticCheck && isSyntactic(this.ruleName) && !isContextSyntactic) {
    throw errors$8.applicationOfSyntacticRuleFromLexicalContext(this.ruleName, this);
  }
  const actual = this.args.length;
  const expected = ruleInfo.formals.length;
  if (actual !== expected) {
    throw errors$8.wrongNumberOfArguments(this.ruleName, expected, actual, this.source);
  }
  const isBuiltInApplySyntactic = BuiltInRules && ruleInfo === BuiltInRules.rules.applySyntactic;
  const isBuiltInCaseInsensitive = BuiltInRules && ruleInfo === BuiltInRules.rules.caseInsensitive;
  if (isBuiltInCaseInsensitive) {
    if (!(this.args[0] instanceof pexprs$j.Terminal)) {
      throw errors$8.incorrectArgumentType('a Terminal (e.g. "abc")', this.args[0]);
    }
  }
  if (isBuiltInApplySyntactic) {
    const arg = this.args[0];
    if (!(arg instanceof pexprs$j.Apply)) {
      throw errors$8.incorrectArgumentType("a syntactic rule application", arg);
    }
    if (!isSyntactic(arg.ruleName)) {
      throw errors$8.applySyntacticWithLexicalRuleApplication(arg);
    }
    if (isContextSyntactic) {
      throw errors$8.unnecessaryExperimentalApplySyntactic(this);
    }
  }
  this.args.forEach((arg) => {
    arg._assertAllApplicationsAreValid(ruleName, grammar2, isBuiltInApplySyntactic);
    if (arg.getArity() !== 1) {
      throw errors$8.invalidParameter(this.ruleName, arg);
    }
  });
};
const common$h = common$l;
const errors$7 = errors$9;
const pexprs$i = pexprsMain;
pexprs$i.PExpr.prototype.assertChoicesHaveUniformArity = common$h.abstract(
  "assertChoicesHaveUniformArity"
);
pexprs$i.any.assertChoicesHaveUniformArity = pexprs$i.end.assertChoicesHaveUniformArity = pexprs$i.Terminal.prototype.assertChoicesHaveUniformArity = pexprs$i.Range.prototype.assertChoicesHaveUniformArity = pexprs$i.Param.prototype.assertChoicesHaveUniformArity = pexprs$i.Lex.prototype.assertChoicesHaveUniformArity = pexprs$i.UnicodeChar.prototype.assertChoicesHaveUniformArity = function(ruleName) {
};
pexprs$i.Alt.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  if (this.terms.length === 0) {
    return;
  }
  const arity = this.terms[0].getArity();
  for (let idx = 0; idx < this.terms.length; idx++) {
    const term = this.terms[idx];
    term.assertChoicesHaveUniformArity();
    const otherArity = term.getArity();
    if (arity !== otherArity) {
      throw errors$7.inconsistentArity(ruleName, arity, otherArity, term);
    }
  }
};
pexprs$i.Extend.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  const actualArity = this.terms[0].getArity();
  const expectedArity = this.terms[1].getArity();
  if (actualArity !== expectedArity) {
    throw errors$7.inconsistentArity(ruleName, expectedArity, actualArity, this.terms[0]);
  }
};
pexprs$i.Seq.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx].assertChoicesHaveUniformArity(ruleName);
  }
};
pexprs$i.Iter.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  this.expr.assertChoicesHaveUniformArity(ruleName);
};
pexprs$i.Not.prototype.assertChoicesHaveUniformArity = function(ruleName) {
};
pexprs$i.Lookahead.prototype.assertChoicesHaveUniformArity = function(ruleName) {
  this.expr.assertChoicesHaveUniformArity(ruleName);
};
pexprs$i.Apply.prototype.assertChoicesHaveUniformArity = function(ruleName) {
};
const common$g = common$l;
const errors$6 = errors$9;
const pexprs$h = pexprsMain;
pexprs$h.PExpr.prototype.assertIteratedExprsAreNotNullable = common$g.abstract(
  "assertIteratedExprsAreNotNullable"
);
pexprs$h.any.assertIteratedExprsAreNotNullable = pexprs$h.end.assertIteratedExprsAreNotNullable = pexprs$h.Terminal.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Range.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Param.prototype.assertIteratedExprsAreNotNullable = pexprs$h.UnicodeChar.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
};
pexprs$h.Alt.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    this.terms[idx].assertIteratedExprsAreNotNullable(grammar2);
  }
};
pexprs$h.Seq.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    this.factors[idx].assertIteratedExprsAreNotNullable(grammar2);
  }
};
pexprs$h.Iter.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  this.expr.assertIteratedExprsAreNotNullable(grammar2);
  if (this.expr.isNullable(grammar2)) {
    throw errors$6.kleeneExprHasNullableOperand(this, []);
  }
};
pexprs$h.Opt.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Not.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Lookahead.prototype.assertIteratedExprsAreNotNullable = pexprs$h.Lex.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  this.expr.assertIteratedExprsAreNotNullable(grammar2);
};
pexprs$h.Apply.prototype.assertIteratedExprsAreNotNullable = function(grammar2) {
  this.args.forEach((arg) => {
    arg.assertIteratedExprsAreNotNullable(grammar2);
  });
};
const { assert: assert$2 } = common$l;
const errors$5 = errors$9;
const util$5 = util$7;
function Interval$3(sourceString, startIdx, endIdx) {
  this.sourceString = sourceString;
  this.startIdx = startIdx;
  this.endIdx = endIdx;
}
Interval$3.coverage = function(firstInterval, ...intervals) {
  let { startIdx, endIdx } = firstInterval;
  for (const interval of intervals) {
    if (interval.sourceString !== firstInterval.sourceString) {
      throw errors$5.intervalSourcesDontMatch();
    } else {
      startIdx = Math.min(startIdx, interval.startIdx);
      endIdx = Math.max(endIdx, interval.endIdx);
    }
  }
  return new Interval$3(firstInterval.sourceString, startIdx, endIdx);
};
Interval$3.prototype = {
  coverageWith(...intervals) {
    return Interval$3.coverage(...intervals, this);
  },
  collapsedLeft() {
    return new Interval$3(this.sourceString, this.startIdx, this.startIdx);
  },
  collapsedRight() {
    return new Interval$3(this.sourceString, this.endIdx, this.endIdx);
  },
  getLineAndColumn() {
    return util$5.getLineAndColumn(this.sourceString, this.startIdx);
  },
  getLineAndColumnMessage() {
    const range = [this.startIdx, this.endIdx];
    return util$5.getLineAndColumnMessage(this.sourceString, this.startIdx, range);
  },
  // Returns an array of 0, 1, or 2 intervals that represents the result of the
  // interval difference operation.
  minus(that) {
    if (this.sourceString !== that.sourceString) {
      throw errors$5.intervalSourcesDontMatch();
    } else if (this.startIdx === that.startIdx && this.endIdx === that.endIdx) {
      return [];
    } else if (this.startIdx < that.startIdx && that.endIdx < this.endIdx) {
      return [
        new Interval$3(this.sourceString, this.startIdx, that.startIdx),
        new Interval$3(this.sourceString, that.endIdx, this.endIdx)
      ];
    } else if (this.startIdx < that.endIdx && that.endIdx < this.endIdx) {
      return [new Interval$3(this.sourceString, that.endIdx, this.endIdx)];
    } else if (this.startIdx < that.startIdx && that.startIdx < this.endIdx) {
      return [new Interval$3(this.sourceString, this.startIdx, that.startIdx)];
    } else {
      return [this];
    }
  },
  // Returns a new Interval that has the same extent as this one, but which is relative
  // to `that`, an Interval that fully covers this one.
  relativeTo(that) {
    if (this.sourceString !== that.sourceString) {
      throw errors$5.intervalSourcesDontMatch();
    }
    assert$2(
      this.startIdx >= that.startIdx && this.endIdx <= that.endIdx,
      "other interval does not cover this one"
    );
    return new Interval$3(
      this.sourceString,
      this.startIdx - that.startIdx,
      this.endIdx - that.startIdx
    );
  },
  // Returns a new Interval which contains the same contents as this one,
  // but with whitespace trimmed from both ends.
  trimmed() {
    const { contents } = this;
    const startIdx = this.startIdx + contents.match(/^\s*/)[0].length;
    const endIdx = this.endIdx - contents.match(/\s*$/)[0].length;
    return new Interval$3(this.sourceString, startIdx, endIdx);
  },
  subInterval(offset, len) {
    const newStartIdx = this.startIdx + offset;
    return new Interval$3(this.sourceString, newStartIdx, newStartIdx + len);
  }
};
Object.defineProperties(Interval$3.prototype, {
  contents: {
    get() {
      if (this._contents === void 0) {
        this._contents = this.sourceString.slice(this.startIdx, this.endIdx);
      }
      return this._contents;
    },
    enumerable: true
  },
  length: {
    get() {
      return this.endIdx - this.startIdx;
    },
    enumerable: true
  }
});
var Interval_1 = Interval$3;
const Interval$2 = Interval_1;
const common$f = common$l;
const BALLOT_X = "";
const CHECK_MARK = "";
const DOT_OPERATOR = "";
const RIGHTWARDS_DOUBLE_ARROW = "";
const SYMBOL_FOR_HORIZONTAL_TABULATION = "";
const SYMBOL_FOR_LINE_FEED = "";
const SYMBOL_FOR_CARRIAGE_RETURN = "";
const Flags = {
  succeeded: 1 << 0,
  isRootNode: 1 << 1,
  isImplicitSpaces: 1 << 2,
  isMemoized: 1 << 3,
  isHeadOfLeftRecursion: 1 << 4,
  terminatesLR: 1 << 5
};
function spaces(n) {
  return common$f.repeat(" ", n).join("");
}
function getInputExcerpt(input, pos, len) {
  const excerpt = asEscapedString(input.slice(pos, pos + len));
  if (excerpt.length < len) {
    return excerpt + common$f.repeat(" ", len - excerpt.length).join("");
  }
  return excerpt;
}
function asEscapedString(obj) {
  if (typeof obj === "string") {
    return obj.replace(/ /g, DOT_OPERATOR).replace(/\t/g, SYMBOL_FOR_HORIZONTAL_TABULATION).replace(/\n/g, SYMBOL_FOR_LINE_FEED).replace(/\r/g, SYMBOL_FOR_CARRIAGE_RETURN);
  }
  return String(obj);
}
function Trace$2(input, pos1, pos2, expr, succeeded, bindings, optChildren) {
  this.input = input;
  this.pos = this.pos1 = pos1;
  this.pos2 = pos2;
  this.source = new Interval$2(input, pos1, pos2);
  this.expr = expr;
  this.bindings = bindings;
  this.children = optChildren || [];
  this.terminatingLREntry = null;
  this._flags = succeeded ? Flags.succeeded : 0;
}
Trace$2.prototype.SKIP = {};
Object.defineProperty(Trace$2.prototype, "displayString", {
  get() {
    return this.expr.toDisplayString();
  }
});
Object.keys(Flags).forEach((name2) => {
  const mask = Flags[name2];
  Object.defineProperty(Trace$2.prototype, name2, {
    get() {
      return (this._flags & mask) !== 0;
    },
    set(val) {
      if (val) {
        this._flags |= mask;
      } else {
        this._flags &= ~mask;
      }
    }
  });
});
Trace$2.prototype.clone = function() {
  return this.cloneWithExpr(this.expr);
};
Trace$2.prototype.cloneWithExpr = function(expr) {
  const ans = new Trace$2(
    this.input,
    this.pos,
    this.pos2,
    expr,
    this.succeeded,
    this.bindings,
    this.children
  );
  ans.isHeadOfLeftRecursion = this.isHeadOfLeftRecursion;
  ans.isImplicitSpaces = this.isImplicitSpaces;
  ans.isMemoized = this.isMemoized;
  ans.isRootNode = this.isRootNode;
  ans.terminatesLR = this.terminatesLR;
  ans.terminatingLREntry = this.terminatingLREntry;
  return ans;
};
Trace$2.prototype.recordLRTermination = function(ruleBodyTrace, value) {
  this.terminatingLREntry = new Trace$2(
    this.input,
    this.pos,
    this.pos2,
    this.expr,
    false,
    [value],
    [ruleBodyTrace]
  );
  this.terminatingLREntry.terminatesLR = true;
};
Trace$2.prototype.walk = function(visitorObjOrFn, optThisArg) {
  let visitor = visitorObjOrFn;
  if (typeof visitor === "function") {
    visitor = { enter: visitor };
  }
  function _walk(node, parent, depth) {
    let recurse = true;
    if (visitor.enter) {
      if (visitor.enter.call(optThisArg, node, parent, depth) === Trace$2.prototype.SKIP) {
        recurse = false;
      }
    }
    if (recurse) {
      node.children.forEach((child) => {
        _walk(child, node, depth + 1);
      });
      if (visitor.exit) {
        visitor.exit.call(optThisArg, node, parent, depth);
      }
    }
  }
  if (this.isRootNode) {
    this.children.forEach((c) => {
      _walk(c, null, 0);
    });
  } else {
    _walk(this, null, 0);
  }
};
Trace$2.prototype.toString = function() {
  const sb = new common$f.StringBuffer();
  this.walk((node, parent, depth) => {
    if (!node) {
      return this.SKIP;
    }
    const ctorName = node.expr.constructor.name;
    if (ctorName === "Alt") {
      return;
    }
    sb.append(getInputExcerpt(node.input, node.pos, 10) + spaces(depth * 2 + 1));
    sb.append((node.succeeded ? CHECK_MARK : BALLOT_X) + " " + node.displayString);
    if (node.isHeadOfLeftRecursion) {
      sb.append(" (LR)");
    }
    if (node.succeeded) {
      const contents = asEscapedString(node.source.contents);
      sb.append(" " + RIGHTWARDS_DOUBLE_ARROW + "  ");
      sb.append(typeof contents === "string" ? '"' + contents + '"' : contents);
    }
    sb.append("\n");
  });
  return sb.contents();
};
var Trace_1 = Trace$2;
const Trace$1 = Trace_1;
const common$e = common$l;
const errors$4 = errors$9;
const nodes$2 = nodes$1;
const pexprs$g = pexprsMain;
const { TerminalNode: TerminalNode$1 } = nodes$2;
const { NonterminalNode } = nodes$2;
const { IterationNode: IterationNode$1 } = nodes$2;
pexprs$g.PExpr.prototype.eval = common$e.abstract("eval");
pexprs$g.any.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch) {
    state.pushBinding(new TerminalNode$1(ch.length), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};
pexprs$g.end.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  if (inputStream.atEnd()) {
    state.pushBinding(new TerminalNode$1(0), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};
pexprs$g.Terminal.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  if (!inputStream.matchString(this.obj)) {
    state.processFailure(origPos, this);
    return false;
  } else {
    state.pushBinding(new TerminalNode$1(this.obj.length), origPos);
    return true;
  }
};
pexprs$g.Range.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const cp = this.matchCodePoint ? inputStream.nextCodePoint() : inputStream.nextCharCode();
  if (cp !== void 0 && this.from.codePointAt(0) <= cp && cp <= this.to.codePointAt(0)) {
    state.pushBinding(new TerminalNode$1(String.fromCodePoint(cp).length), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};
pexprs$g.Param.prototype.eval = function(state) {
  return state.eval(state.currentApplication().args[this.index]);
};
pexprs$g.Lex.prototype.eval = function(state) {
  state.enterLexifiedContext();
  const ans = state.eval(this.expr);
  state.exitLexifiedContext();
  return ans;
};
pexprs$g.Alt.prototype.eval = function(state) {
  for (let idx = 0; idx < this.terms.length; idx++) {
    if (state.eval(this.terms[idx])) {
      return true;
    }
  }
  return false;
};
pexprs$g.Seq.prototype.eval = function(state) {
  for (let idx = 0; idx < this.factors.length; idx++) {
    const factor = this.factors[idx];
    if (!state.eval(factor)) {
      return false;
    }
  }
  return true;
};
pexprs$g.Iter.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const arity = this.getArity();
  const cols = [];
  const colOffsets = [];
  while (cols.length < arity) {
    cols.push([]);
    colOffsets.push([]);
  }
  let numMatches = 0;
  let prevPos = origPos;
  let idx;
  while (numMatches < this.maxNumMatches && state.eval(this.expr)) {
    if (inputStream.pos === prevPos) {
      throw errors$4.kleeneExprHasNullableOperand(this, state._applicationStack);
    }
    prevPos = inputStream.pos;
    numMatches++;
    const row = state._bindings.splice(state._bindings.length - arity, arity);
    const rowOffsets = state._bindingOffsets.splice(
      state._bindingOffsets.length - arity,
      arity
    );
    for (idx = 0; idx < row.length; idx++) {
      cols[idx].push(row[idx]);
      colOffsets[idx].push(rowOffsets[idx]);
    }
  }
  if (numMatches < this.minNumMatches) {
    return false;
  }
  let offset = state.posToOffset(origPos);
  let matchLength = 0;
  if (numMatches > 0) {
    const lastCol = cols[arity - 1];
    const lastColOffsets = colOffsets[arity - 1];
    const endOffset = lastColOffsets[lastColOffsets.length - 1] + lastCol[lastCol.length - 1].matchLength;
    offset = colOffsets[0][0];
    matchLength = endOffset - offset;
  }
  const isOptional = this instanceof pexprs$g.Opt;
  for (idx = 0; idx < cols.length; idx++) {
    state._bindings.push(
      new IterationNode$1(cols[idx], colOffsets[idx], matchLength, isOptional)
    );
    state._bindingOffsets.push(offset);
  }
  return true;
};
pexprs$g.Not.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  state.pushFailuresInfo();
  const ans = state.eval(this.expr);
  state.popFailuresInfo();
  if (ans) {
    state.processFailure(origPos, this);
    return false;
  }
  inputStream.pos = origPos;
  return true;
};
pexprs$g.Lookahead.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  if (state.eval(this.expr)) {
    inputStream.pos = origPos;
    return true;
  } else {
    return false;
  }
};
pexprs$g.Apply.prototype.eval = function(state) {
  const caller = state.currentApplication();
  const actuals = caller ? caller.args : [];
  const app = this.substituteParams(actuals);
  const posInfo = state.getCurrentPosInfo();
  if (posInfo.isActive(app)) {
    return app.handleCycle(state);
  }
  const memoKey = app.toMemoKey();
  const memoRec = posInfo.memo[memoKey];
  if (memoRec && posInfo.shouldUseMemoizedResult(memoRec)) {
    if (state.hasNecessaryInfo(memoRec)) {
      return state.useMemoizedResult(state.inputStream.pos, memoRec);
    }
    delete posInfo.memo[memoKey];
  }
  return app.reallyEval(state);
};
pexprs$g.Apply.prototype.handleCycle = function(state) {
  const posInfo = state.getCurrentPosInfo();
  const { currentLeftRecursion } = posInfo;
  const memoKey = this.toMemoKey();
  let memoRec = posInfo.memo[memoKey];
  if (currentLeftRecursion && currentLeftRecursion.headApplication.toMemoKey() === memoKey) {
    memoRec.updateInvolvedApplicationMemoKeys();
  } else if (!memoRec) {
    memoRec = posInfo.memoize(memoKey, {
      matchLength: 0,
      examinedLength: 0,
      value: false,
      rightmostFailureOffset: -1
    });
    posInfo.startLeftRecursion(this, memoRec);
  }
  return state.useMemoizedResult(state.inputStream.pos, memoRec);
};
pexprs$g.Apply.prototype.reallyEval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const origPosInfo = state.getCurrentPosInfo();
  const ruleInfo = state.grammar.rules[this.ruleName];
  const { body } = ruleInfo;
  const { description: description2 } = ruleInfo;
  state.enterApplication(origPosInfo, this);
  if (description2) {
    state.pushFailuresInfo();
  }
  const origInputStreamExaminedLength = inputStream.examinedLength;
  inputStream.examinedLength = 0;
  let value = this.evalOnce(body, state);
  const currentLR = origPosInfo.currentLeftRecursion;
  const memoKey = this.toMemoKey();
  const isHeadOfLeftRecursion = currentLR && currentLR.headApplication.toMemoKey() === memoKey;
  let memoRec;
  if (isHeadOfLeftRecursion) {
    value = this.growSeedResult(body, state, origPos, currentLR, value);
    origPosInfo.endLeftRecursion();
    memoRec = currentLR;
    memoRec.examinedLength = inputStream.examinedLength - origPos;
    memoRec.rightmostFailureOffset = state._getRightmostFailureOffset();
    origPosInfo.memoize(memoKey, memoRec);
  } else if (!currentLR || !currentLR.isInvolved(memoKey)) {
    memoRec = origPosInfo.memoize(memoKey, {
      matchLength: inputStream.pos - origPos,
      examinedLength: inputStream.examinedLength - origPos,
      value,
      failuresAtRightmostPosition: state.cloneRecordedFailures(),
      rightmostFailureOffset: state._getRightmostFailureOffset()
    });
  }
  const succeeded = !!value;
  if (description2) {
    state.popFailuresInfo();
    if (!succeeded) {
      state.processFailure(origPos, this);
    }
    if (memoRec) {
      memoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();
    }
  }
  if (state.isTracing() && memoRec) {
    const entry = state.getTraceEntry(origPos, this, succeeded, succeeded ? [value] : []);
    if (isHeadOfLeftRecursion) {
      common$e.assert(entry.terminatingLREntry != null || !succeeded);
      entry.isHeadOfLeftRecursion = true;
    }
    memoRec.traceEntry = entry;
  }
  inputStream.examinedLength = Math.max(
    inputStream.examinedLength,
    origInputStreamExaminedLength
  );
  state.exitApplication(origPosInfo, value);
  return succeeded;
};
pexprs$g.Apply.prototype.evalOnce = function(expr, state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  if (state.eval(expr)) {
    const arity = expr.getArity();
    const bindings = state._bindings.splice(state._bindings.length - arity, arity);
    const offsets = state._bindingOffsets.splice(state._bindingOffsets.length - arity, arity);
    const matchLength = inputStream.pos - origPos;
    return new NonterminalNode(this.ruleName, bindings, offsets, matchLength);
  } else {
    return false;
  }
};
pexprs$g.Apply.prototype.growSeedResult = function(body, state, origPos, lrMemoRec, newValue) {
  if (!newValue) {
    return false;
  }
  const { inputStream } = state;
  while (true) {
    lrMemoRec.matchLength = inputStream.pos - origPos;
    lrMemoRec.value = newValue;
    lrMemoRec.failuresAtRightmostPosition = state.cloneRecordedFailures();
    if (state.isTracing()) {
      const seedTrace = state.trace[state.trace.length - 1];
      lrMemoRec.traceEntry = new Trace$1(
        state.input,
        origPos,
        inputStream.pos,
        this,
        true,
        [newValue],
        [seedTrace.clone()]
      );
    }
    inputStream.pos = origPos;
    newValue = this.evalOnce(body, state);
    if (inputStream.pos - origPos <= lrMemoRec.matchLength) {
      break;
    }
    if (state.isTracing()) {
      state.trace.splice(-2, 1);
    }
  }
  if (state.isTracing()) {
    lrMemoRec.traceEntry.recordLRTermination(state.trace.pop(), newValue);
  }
  inputStream.pos = origPos + lrMemoRec.matchLength;
  return lrMemoRec.value;
};
pexprs$g.UnicodeChar.prototype.eval = function(state) {
  const { inputStream } = state;
  const origPos = inputStream.pos;
  const ch = inputStream.next();
  if (ch && this.pattern.test(ch)) {
    state.pushBinding(new TerminalNode$1(ch.length), origPos);
    return true;
  } else {
    state.processFailure(origPos, this);
    return false;
  }
};
const common$d = common$l;
const pexprs$f = pexprsMain;
pexprs$f.PExpr.prototype.getArity = common$d.abstract("getArity");
pexprs$f.any.getArity = pexprs$f.end.getArity = pexprs$f.Terminal.prototype.getArity = pexprs$f.Range.prototype.getArity = pexprs$f.Param.prototype.getArity = pexprs$f.Apply.prototype.getArity = pexprs$f.UnicodeChar.prototype.getArity = function() {
  return 1;
};
pexprs$f.Alt.prototype.getArity = function() {
  return this.terms.length === 0 ? 0 : this.terms[0].getArity();
};
pexprs$f.Seq.prototype.getArity = function() {
  let arity = 0;
  for (let idx = 0; idx < this.factors.length; idx++) {
    arity += this.factors[idx].getArity();
  }
  return arity;
};
pexprs$f.Iter.prototype.getArity = function() {
  return this.expr.getArity();
};
pexprs$f.Not.prototype.getArity = function() {
  return 0;
};
pexprs$f.Lookahead.prototype.getArity = pexprs$f.Lex.prototype.getArity = function() {
  return this.expr.getArity();
};
const common$c = common$l;
const pexprs$e = pexprsMain;
function getMetaInfo(expr, grammarInterval) {
  const metaInfo = {};
  if (expr.source && grammarInterval) {
    const adjusted = expr.source.relativeTo(grammarInterval);
    metaInfo.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
  }
  return metaInfo;
}
pexprs$e.PExpr.prototype.outputRecipe = common$c.abstract("outputRecipe");
pexprs$e.any.outputRecipe = function(formals, grammarInterval) {
  return ["any", getMetaInfo(this, grammarInterval)];
};
pexprs$e.end.outputRecipe = function(formals, grammarInterval) {
  return ["end", getMetaInfo(this, grammarInterval)];
};
pexprs$e.Terminal.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["terminal", getMetaInfo(this, grammarInterval), this.obj];
};
pexprs$e.Range.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["range", getMetaInfo(this, grammarInterval), this.from, this.to];
};
pexprs$e.Param.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["param", getMetaInfo(this, grammarInterval), this.index];
};
pexprs$e.Alt.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["alt", getMetaInfo(this, grammarInterval)].concat(
    this.terms.map((term) => term.outputRecipe(formals, grammarInterval))
  );
};
pexprs$e.Extend.prototype.outputRecipe = function(formals, grammarInterval) {
  const extension = this.terms[0];
  return extension.outputRecipe(formals, grammarInterval);
};
pexprs$e.Splice.prototype.outputRecipe = function(formals, grammarInterval) {
  const beforeTerms = this.terms.slice(0, this.expansionPos);
  const afterTerms = this.terms.slice(this.expansionPos + 1);
  return [
    "splice",
    getMetaInfo(this, grammarInterval),
    beforeTerms.map((term) => term.outputRecipe(formals, grammarInterval)),
    afterTerms.map((term) => term.outputRecipe(formals, grammarInterval))
  ];
};
pexprs$e.Seq.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["seq", getMetaInfo(this, grammarInterval)].concat(
    this.factors.map((factor) => factor.outputRecipe(formals, grammarInterval))
  );
};
pexprs$e.Star.prototype.outputRecipe = pexprs$e.Plus.prototype.outputRecipe = pexprs$e.Opt.prototype.outputRecipe = pexprs$e.Not.prototype.outputRecipe = pexprs$e.Lookahead.prototype.outputRecipe = pexprs$e.Lex.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    this.constructor.name.toLowerCase(),
    getMetaInfo(this, grammarInterval),
    this.expr.outputRecipe(formals, grammarInterval)
  ];
};
pexprs$e.Apply.prototype.outputRecipe = function(formals, grammarInterval) {
  return [
    "app",
    getMetaInfo(this, grammarInterval),
    this.ruleName,
    this.args.map((arg) => arg.outputRecipe(formals, grammarInterval))
  ];
};
pexprs$e.UnicodeChar.prototype.outputRecipe = function(formals, grammarInterval) {
  return ["unicodeChar", getMetaInfo(this, grammarInterval), this.category];
};
const common$b = common$l;
const pexprs$d = pexprsMain;
pexprs$d.PExpr.prototype.introduceParams = common$b.abstract("introduceParams");
pexprs$d.any.introduceParams = pexprs$d.end.introduceParams = pexprs$d.Terminal.prototype.introduceParams = pexprs$d.Range.prototype.introduceParams = pexprs$d.Param.prototype.introduceParams = pexprs$d.UnicodeChar.prototype.introduceParams = function(formals) {
  return this;
};
pexprs$d.Alt.prototype.introduceParams = function(formals) {
  this.terms.forEach((term, idx, terms) => {
    terms[idx] = term.introduceParams(formals);
  });
  return this;
};
pexprs$d.Seq.prototype.introduceParams = function(formals) {
  this.factors.forEach((factor, idx, factors) => {
    factors[idx] = factor.introduceParams(formals);
  });
  return this;
};
pexprs$d.Iter.prototype.introduceParams = pexprs$d.Not.prototype.introduceParams = pexprs$d.Lookahead.prototype.introduceParams = pexprs$d.Lex.prototype.introduceParams = function(formals) {
  this.expr = this.expr.introduceParams(formals);
  return this;
};
pexprs$d.Apply.prototype.introduceParams = function(formals) {
  const index = formals.indexOf(this.ruleName);
  if (index >= 0) {
    if (this.args.length > 0) {
      throw new Error("Parameterized rules cannot be passed as arguments to another rule.");
    }
    return new pexprs$d.Param(index).withSource(this.source);
  } else {
    this.args.forEach((arg, idx, args) => {
      args[idx] = arg.introduceParams(formals);
    });
    return this;
  }
};
const common$a = common$l;
const pexprs$c = pexprsMain;
pexprs$c.PExpr.prototype.isNullable = function(grammar2) {
  return this._isNullable(grammar2, /* @__PURE__ */ Object.create(null));
};
pexprs$c.PExpr.prototype._isNullable = common$a.abstract("_isNullable");
pexprs$c.any._isNullable = pexprs$c.Range.prototype._isNullable = pexprs$c.Param.prototype._isNullable = pexprs$c.Plus.prototype._isNullable = pexprs$c.UnicodeChar.prototype._isNullable = function(grammar2, memo) {
  return false;
};
pexprs$c.end._isNullable = function(grammar2, memo) {
  return true;
};
pexprs$c.Terminal.prototype._isNullable = function(grammar2, memo) {
  if (typeof this.obj === "string") {
    return this.obj === "";
  } else {
    return false;
  }
};
pexprs$c.Alt.prototype._isNullable = function(grammar2, memo) {
  return this.terms.length === 0 || this.terms.some((term) => term._isNullable(grammar2, memo));
};
pexprs$c.Seq.prototype._isNullable = function(grammar2, memo) {
  return this.factors.every((factor) => factor._isNullable(grammar2, memo));
};
pexprs$c.Star.prototype._isNullable = pexprs$c.Opt.prototype._isNullable = pexprs$c.Not.prototype._isNullable = pexprs$c.Lookahead.prototype._isNullable = function(grammar2, memo) {
  return true;
};
pexprs$c.Lex.prototype._isNullable = function(grammar2, memo) {
  return this.expr._isNullable(grammar2, memo);
};
pexprs$c.Apply.prototype._isNullable = function(grammar2, memo) {
  const key = this.toMemoKey();
  if (!Object.prototype.hasOwnProperty.call(memo, key)) {
    const { body } = grammar2.rules[this.ruleName];
    const inlined = body.substituteParams(this.args);
    memo[key] = false;
    memo[key] = inlined._isNullable(grammar2, memo);
  }
  return memo[key];
};
const common$9 = common$l;
const pexprs$b = pexprsMain;
pexprs$b.PExpr.prototype.substituteParams = common$9.abstract("substituteParams");
pexprs$b.any.substituteParams = pexprs$b.end.substituteParams = pexprs$b.Terminal.prototype.substituteParams = pexprs$b.Range.prototype.substituteParams = pexprs$b.UnicodeChar.prototype.substituteParams = function(actuals) {
  return this;
};
pexprs$b.Param.prototype.substituteParams = function(actuals) {
  return actuals[this.index];
};
pexprs$b.Alt.prototype.substituteParams = function(actuals) {
  return new pexprs$b.Alt(this.terms.map((term) => term.substituteParams(actuals)));
};
pexprs$b.Seq.prototype.substituteParams = function(actuals) {
  return new pexprs$b.Seq(this.factors.map((factor) => factor.substituteParams(actuals)));
};
pexprs$b.Iter.prototype.substituteParams = pexprs$b.Not.prototype.substituteParams = pexprs$b.Lookahead.prototype.substituteParams = pexprs$b.Lex.prototype.substituteParams = function(actuals) {
  return new this.constructor(this.expr.substituteParams(actuals));
};
pexprs$b.Apply.prototype.substituteParams = function(actuals) {
  if (this.args.length === 0) {
    return this;
  } else {
    const args = this.args.map((arg) => arg.substituteParams(actuals));
    return new pexprs$b.Apply(this.ruleName, args);
  }
};
const common$8 = common$l;
const pexprs$a = pexprsMain;
const { copyWithoutDuplicates } = common$8;
function isRestrictedJSIdentifier(str) {
  return /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(str);
}
function resolveDuplicatedNames(argumentNameList) {
  const count = /* @__PURE__ */ Object.create(null);
  argumentNameList.forEach((argName) => {
    count[argName] = (count[argName] || 0) + 1;
  });
  Object.keys(count).forEach((dupArgName) => {
    if (count[dupArgName] <= 1) {
      return;
    }
    let subscript = 1;
    argumentNameList.forEach((argName, idx) => {
      if (argName === dupArgName) {
        argumentNameList[idx] = argName + "_" + subscript++;
      }
    });
  });
}
pexprs$a.PExpr.prototype.toArgumentNameList = common$8.abstract("toArgumentNameList");
pexprs$a.any.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ["any"];
};
pexprs$a.end.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ["end"];
};
pexprs$a.Terminal.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  if (typeof this.obj === "string" && /^[_a-zA-Z0-9]+$/.test(this.obj)) {
    return ["_" + this.obj];
  } else {
    return ["$" + firstArgIndex];
  }
};
pexprs$a.Range.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  let argName = this.from + "_to_" + this.to;
  if (!isRestrictedJSIdentifier(argName)) {
    argName = "_" + argName;
  }
  if (!isRestrictedJSIdentifier(argName)) {
    argName = "$" + firstArgIndex;
  }
  return [argName];
};
pexprs$a.Alt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  const termArgNameLists = this.terms.map(
    (term) => term.toArgumentNameList(firstArgIndex, true)
  );
  const argumentNameList = [];
  const numArgs = termArgNameLists[0].length;
  for (let colIdx = 0; colIdx < numArgs; colIdx++) {
    const col = [];
    for (let rowIdx = 0; rowIdx < this.terms.length; rowIdx++) {
      col.push(termArgNameLists[rowIdx][colIdx]);
    }
    const uniqueNames = copyWithoutDuplicates(col);
    argumentNameList.push(uniqueNames.join("_or_"));
  }
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};
pexprs$a.Seq.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  let argumentNameList = [];
  this.factors.forEach((factor) => {
    const factorArgumentNameList = factor.toArgumentNameList(firstArgIndex, true);
    argumentNameList = argumentNameList.concat(factorArgumentNameList);
    firstArgIndex += factorArgumentNameList.length;
  });
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};
pexprs$a.Iter.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  const argumentNameList = this.expr.toArgumentNameList(firstArgIndex, noDupCheck).map(
    (exprArgumentString) => exprArgumentString[exprArgumentString.length - 1] === "s" ? exprArgumentString + "es" : exprArgumentString + "s"
  );
  if (!noDupCheck) {
    resolveDuplicatedNames(argumentNameList);
  }
  return argumentNameList;
};
pexprs$a.Opt.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return this.expr.toArgumentNameList(firstArgIndex, noDupCheck).map((argName) => {
    return "opt" + argName[0].toUpperCase() + argName.slice(1);
  });
};
pexprs$a.Not.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return [];
};
pexprs$a.Lookahead.prototype.toArgumentNameList = pexprs$a.Lex.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return this.expr.toArgumentNameList(firstArgIndex, noDupCheck);
};
pexprs$a.Apply.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return [this.ruleName];
};
pexprs$a.UnicodeChar.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ["$" + firstArgIndex];
};
pexprs$a.Param.prototype.toArgumentNameList = function(firstArgIndex, noDupCheck) {
  return ["param" + this.index];
};
const common$7 = common$l;
const pexprs$9 = pexprsMain;
pexprs$9.PExpr.prototype.toDisplayString = common$7.abstract("toDisplayString");
pexprs$9.Alt.prototype.toDisplayString = pexprs$9.Seq.prototype.toDisplayString = function() {
  if (this.source) {
    return this.source.trimmed().contents;
  }
  return "[" + this.constructor.name + "]";
};
pexprs$9.any.toDisplayString = pexprs$9.end.toDisplayString = pexprs$9.Iter.prototype.toDisplayString = pexprs$9.Not.prototype.toDisplayString = pexprs$9.Lookahead.prototype.toDisplayString = pexprs$9.Lex.prototype.toDisplayString = pexprs$9.Terminal.prototype.toDisplayString = pexprs$9.Range.prototype.toDisplayString = pexprs$9.Param.prototype.toDisplayString = function() {
  return this.toString();
};
pexprs$9.Apply.prototype.toDisplayString = function() {
  if (this.args.length > 0) {
    const ps = this.args.map((arg) => arg.toDisplayString());
    return this.ruleName + "<" + ps.join(",") + ">";
  } else {
    return this.ruleName;
  }
};
pexprs$9.UnicodeChar.prototype.toDisplayString = function() {
  return "Unicode [" + this.category + "] character";
};
const Failure$1 = Failure_1;
const common$6 = common$l;
const pexprs$8 = pexprsMain;
pexprs$8.PExpr.prototype.toFailure = common$6.abstract("toFailure");
pexprs$8.any.toFailure = function(grammar2) {
  return new Failure$1(this, "any object", "description");
};
pexprs$8.end.toFailure = function(grammar2) {
  return new Failure$1(this, "end of input", "description");
};
pexprs$8.Terminal.prototype.toFailure = function(grammar2) {
  return new Failure$1(this, this.obj, "string");
};
pexprs$8.Range.prototype.toFailure = function(grammar2) {
  return new Failure$1(this, JSON.stringify(this.from) + ".." + JSON.stringify(this.to), "code");
};
pexprs$8.Not.prototype.toFailure = function(grammar2) {
  const description2 = this.expr === pexprs$8.any ? "nothing" : "not " + this.expr.toFailure(grammar2);
  return new Failure$1(this, description2, "description");
};
pexprs$8.Lookahead.prototype.toFailure = function(grammar2) {
  return this.expr.toFailure(grammar2);
};
pexprs$8.Apply.prototype.toFailure = function(grammar2) {
  let { description: description2 } = grammar2.rules[this.ruleName];
  if (!description2) {
    const article = /^[aeiouAEIOU]/.test(this.ruleName) ? "an" : "a";
    description2 = article + " " + this.ruleName;
  }
  return new Failure$1(this, description2, "description");
};
pexprs$8.UnicodeChar.prototype.toFailure = function(grammar2) {
  return new Failure$1(this, "a Unicode [" + this.category + "] character", "description");
};
pexprs$8.Alt.prototype.toFailure = function(grammar2) {
  const fs = this.terms.map((t) => t.toFailure(grammar2));
  const description2 = "(" + fs.join(" or ") + ")";
  return new Failure$1(this, description2, "description");
};
pexprs$8.Seq.prototype.toFailure = function(grammar2) {
  const fs = this.factors.map((f) => f.toFailure(grammar2));
  const description2 = "(" + fs.join(" ") + ")";
  return new Failure$1(this, description2, "description");
};
pexprs$8.Iter.prototype.toFailure = function(grammar2) {
  const description2 = "(" + this.expr.toFailure(grammar2) + this.operator + ")";
  return new Failure$1(this, description2, "description");
};
const common$5 = common$l;
const pexprs$7 = pexprsMain;
pexprs$7.PExpr.prototype.toString = common$5.abstract("toString");
pexprs$7.any.toString = function() {
  return "any";
};
pexprs$7.end.toString = function() {
  return "end";
};
pexprs$7.Terminal.prototype.toString = function() {
  return JSON.stringify(this.obj);
};
pexprs$7.Range.prototype.toString = function() {
  return JSON.stringify(this.from) + ".." + JSON.stringify(this.to);
};
pexprs$7.Param.prototype.toString = function() {
  return "$" + this.index;
};
pexprs$7.Lex.prototype.toString = function() {
  return "#(" + this.expr.toString() + ")";
};
pexprs$7.Alt.prototype.toString = function() {
  return this.terms.length === 1 ? this.terms[0].toString() : "(" + this.terms.map((term) => term.toString()).join(" | ") + ")";
};
pexprs$7.Seq.prototype.toString = function() {
  return this.factors.length === 1 ? this.factors[0].toString() : "(" + this.factors.map((factor) => factor.toString()).join(" ") + ")";
};
pexprs$7.Iter.prototype.toString = function() {
  return this.expr + this.operator;
};
pexprs$7.Not.prototype.toString = function() {
  return "~" + this.expr;
};
pexprs$7.Lookahead.prototype.toString = function() {
  return "&" + this.expr;
};
pexprs$7.Apply.prototype.toString = function() {
  if (this.args.length > 0) {
    const ps = this.args.map((arg) => arg.toString());
    return this.ruleName + "<" + ps.join(",") + ">";
  } else {
    return this.ruleName;
  }
};
pexprs$7.UnicodeChar.prototype.toString = function() {
  return "\\p{" + this.category + "}";
};
var pexprs$6 = pexprsMain;
const Failure = Failure_1;
const { TerminalNode } = nodes$1;
const { assert: assert$1 } = common$l;
const { PExpr, Terminal } = pexprs$6;
class CaseInsensitiveTerminal$1 extends PExpr {
  constructor(param) {
    super();
    this.obj = param;
  }
  _getString(state) {
    const terminal = state.currentApplication().args[this.obj.index];
    assert$1(terminal instanceof Terminal, "expected a Terminal expression");
    return terminal.obj;
  }
  // Implementation of the PExpr API
  allowsSkippingPrecedingSpace() {
    return true;
  }
  eval(state) {
    const { inputStream } = state;
    const origPos = inputStream.pos;
    const matchStr = this._getString(state);
    if (!inputStream.matchString(matchStr, true)) {
      state.processFailure(origPos, this);
      return false;
    } else {
      state.pushBinding(new TerminalNode(matchStr.length), origPos);
      return true;
    }
  }
  getArity() {
    return 1;
  }
  substituteParams(actuals) {
    return new CaseInsensitiveTerminal$1(this.obj.substituteParams(actuals));
  }
  toDisplayString() {
    return this.obj.toDisplayString() + " (case-insensitive)";
  }
  toFailure(grammar2) {
    return new Failure(
      this,
      this.obj.toFailure(grammar2) + " (case-insensitive)",
      "description"
    );
  }
  _isNullable(grammar2, memo) {
    return this.obj._isNullable(grammar2, memo);
  }
}
var CaseInsensitiveTerminal_1 = CaseInsensitiveTerminal$1;
const Interval$1 = Interval_1;
function InputStream$3(source) {
  this.source = source;
  this.pos = 0;
  this.examinedLength = 0;
}
InputStream$3.prototype = {
  atEnd() {
    const ans = this.pos === this.source.length;
    this.examinedLength = Math.max(this.examinedLength, this.pos + 1);
    return ans;
  },
  next() {
    const ans = this.source[this.pos++];
    this.examinedLength = Math.max(this.examinedLength, this.pos);
    return ans;
  },
  nextCharCode() {
    const nextChar = this.next();
    return nextChar && nextChar.charCodeAt(0);
  },
  nextCodePoint() {
    const cp = this.source.slice(this.pos++).codePointAt(0);
    if (cp > 65535) {
      this.pos += 1;
    }
    this.examinedLength = Math.max(this.examinedLength, this.pos);
    return cp;
  },
  matchString(s, optIgnoreCase) {
    let idx;
    if (optIgnoreCase) {
      for (idx = 0; idx < s.length; idx++) {
        const actual = this.next();
        const expected = s[idx];
        if (actual == null || actual.toUpperCase() !== expected.toUpperCase()) {
          return false;
        }
      }
      return true;
    }
    for (idx = 0; idx < s.length; idx++) {
      if (this.next() !== s[idx]) {
        return false;
      }
    }
    return true;
  },
  sourceSlice(startIdx, endIdx) {
    return this.source.slice(startIdx, endIdx);
  },
  interval(startIdx, optEndIdx) {
    return new Interval$1(this.source, startIdx, optEndIdx ? optEndIdx : this.pos);
  }
};
var InputStream_1 = InputStream$3;
const common$4 = common$l;
const util$4 = util$7;
const Interval = Interval_1;
function MatchResult$2(matcher, input, startExpr, cst, cstOffset, rightmostFailurePosition, optRecordedFailures) {
  this.matcher = matcher;
  this.input = input;
  this.startExpr = startExpr;
  this._cst = cst;
  this._cstOffset = cstOffset;
  this._rightmostFailurePosition = rightmostFailurePosition;
  this._rightmostFailures = optRecordedFailures;
  if (this.failed()) {
    common$4.defineLazyProperty(this, "message", function() {
      const detail = "Expected " + this.getExpectedText();
      return util$4.getLineAndColumnMessage(this.input, this.getRightmostFailurePosition()) + detail;
    });
    common$4.defineLazyProperty(this, "shortMessage", function() {
      const detail = "expected " + this.getExpectedText();
      const errorInfo = util$4.getLineAndColumn(this.input, this.getRightmostFailurePosition());
      return "Line " + errorInfo.lineNum + ", col " + errorInfo.colNum + ": " + detail;
    });
  }
}
MatchResult$2.prototype.succeeded = function() {
  return !!this._cst;
};
MatchResult$2.prototype.failed = function() {
  return !this.succeeded();
};
MatchResult$2.prototype.getRightmostFailurePosition = function() {
  return this._rightmostFailurePosition;
};
MatchResult$2.prototype.getRightmostFailures = function() {
  if (!this._rightmostFailures) {
    this.matcher.setInput(this.input);
    const matchResultWithFailures = this.matcher._match(
      this.startExpr,
      false,
      this.getRightmostFailurePosition()
    );
    this._rightmostFailures = matchResultWithFailures.getRightmostFailures();
  }
  return this._rightmostFailures;
};
MatchResult$2.prototype.toString = function() {
  return this.succeeded() ? "[match succeeded]" : "[match failed at position " + this.getRightmostFailurePosition() + "]";
};
MatchResult$2.prototype.getExpectedText = function() {
  if (this.succeeded()) {
    throw new Error("cannot get expected text of a successful MatchResult");
  }
  const sb = new common$4.StringBuffer();
  let failures = this.getRightmostFailures();
  failures = failures.filter((failure) => !failure.isFluffy());
  for (let idx = 0; idx < failures.length; idx++) {
    if (idx > 0) {
      if (idx === failures.length - 1) {
        sb.append(failures.length > 2 ? ", or " : " or ");
      } else {
        sb.append(", ");
      }
    }
    sb.append(failures[idx].toString());
  }
  return sb.contents();
};
MatchResult$2.prototype.getInterval = function() {
  const pos = this.getRightmostFailurePosition();
  return new Interval(this.input, pos, pos);
};
var MatchResult_1 = MatchResult$2;
function PosInfo$1() {
  this.applicationMemoKeyStack = [];
  this.memo = {};
  this.maxExaminedLength = 0;
  this.maxRightmostFailureOffset = -1;
  this.currentLeftRecursion = void 0;
}
PosInfo$1.prototype = {
  isActive(application) {
    return this.applicationMemoKeyStack.indexOf(application.toMemoKey()) >= 0;
  },
  enter(application) {
    this.applicationMemoKeyStack.push(application.toMemoKey());
  },
  exit() {
    this.applicationMemoKeyStack.pop();
  },
  startLeftRecursion(headApplication, memoRec) {
    memoRec.isLeftRecursion = true;
    memoRec.headApplication = headApplication;
    memoRec.nextLeftRecursion = this.currentLeftRecursion;
    this.currentLeftRecursion = memoRec;
    const { applicationMemoKeyStack } = this;
    const indexOfFirstInvolvedRule = applicationMemoKeyStack.indexOf(headApplication.toMemoKey()) + 1;
    const involvedApplicationMemoKeys = applicationMemoKeyStack.slice(
      indexOfFirstInvolvedRule
    );
    memoRec.isInvolved = function(applicationMemoKey) {
      return involvedApplicationMemoKeys.indexOf(applicationMemoKey) >= 0;
    };
    memoRec.updateInvolvedApplicationMemoKeys = function() {
      for (let idx = indexOfFirstInvolvedRule; idx < applicationMemoKeyStack.length; idx++) {
        const applicationMemoKey = applicationMemoKeyStack[idx];
        if (!this.isInvolved(applicationMemoKey)) {
          involvedApplicationMemoKeys.push(applicationMemoKey);
        }
      }
    };
  },
  endLeftRecursion() {
    this.currentLeftRecursion = this.currentLeftRecursion.nextLeftRecursion;
  },
  // Note: this method doesn't get called for the "head" of a left recursion -- for LR heads,
  // the memoized result (which starts out being a failure) is always used.
  shouldUseMemoizedResult(memoRec) {
    if (!memoRec.isLeftRecursion) {
      return true;
    }
    const { applicationMemoKeyStack } = this;
    for (let idx = 0; idx < applicationMemoKeyStack.length; idx++) {
      const applicationMemoKey = applicationMemoKeyStack[idx];
      if (memoRec.isInvolved(applicationMemoKey)) {
        return false;
      }
    }
    return true;
  },
  memoize(memoKey, memoRec) {
    this.memo[memoKey] = memoRec;
    this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);
    this.maxRightmostFailureOffset = Math.max(
      this.maxRightmostFailureOffset,
      memoRec.rightmostFailureOffset
    );
    return memoRec;
  },
  clearObsoleteEntries(pos, invalidatedIdx) {
    if (pos + this.maxExaminedLength <= invalidatedIdx) {
      return;
    }
    const { memo } = this;
    this.maxExaminedLength = 0;
    this.maxRightmostFailureOffset = -1;
    Object.keys(memo).forEach((k) => {
      const memoRec = memo[k];
      if (pos + memoRec.examinedLength > invalidatedIdx) {
        delete memo[k];
      } else {
        this.maxExaminedLength = Math.max(this.maxExaminedLength, memoRec.examinedLength);
        this.maxRightmostFailureOffset = Math.max(
          this.maxRightmostFailureOffset,
          memoRec.rightmostFailureOffset
        );
      }
    });
  }
};
var PosInfo_1 = PosInfo$1;
const InputStream$2 = InputStream_1;
const MatchResult$1 = MatchResult_1;
const PosInfo = PosInfo_1;
const Trace = Trace_1;
const pexprs$5 = pexprs$6;
const util$3 = util$7;
let builtInApplySyntacticBody;
util$3.awaitBuiltInRules((builtInRules2) => {
  builtInApplySyntacticBody = builtInRules2.rules.applySyntactic.body;
});
const applySpaces = new pexprs$5.Apply("spaces");
function MatchState$1(matcher, startExpr, optPositionToRecordFailures) {
  this.matcher = matcher;
  this.startExpr = startExpr;
  this.grammar = matcher.grammar;
  this.input = matcher.input;
  this.inputStream = new InputStream$2(matcher.input);
  this.memoTable = matcher.memoTable;
  this._bindings = [];
  this._bindingOffsets = [];
  this._applicationStack = [];
  this._posStack = [0];
  this.inLexifiedContextStack = [false];
  this.rightmostFailurePosition = -1;
  this._rightmostFailurePositionStack = [];
  this._recordedFailuresStack = [];
  if (optPositionToRecordFailures !== void 0) {
    this.positionToRecordFailures = optPositionToRecordFailures;
    this.recordedFailures = /* @__PURE__ */ Object.create(null);
  }
}
MatchState$1.prototype = {
  posToOffset(pos) {
    return pos - this._posStack[this._posStack.length - 1];
  },
  enterApplication(posInfo, app) {
    this._posStack.push(this.inputStream.pos);
    this._applicationStack.push(app);
    this.inLexifiedContextStack.push(false);
    posInfo.enter(app);
    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
    this.rightmostFailurePosition = -1;
  },
  exitApplication(posInfo, optNode) {
    const origPos = this._posStack.pop();
    this._applicationStack.pop();
    this.inLexifiedContextStack.pop();
    posInfo.exit();
    this.rightmostFailurePosition = Math.max(
      this.rightmostFailurePosition,
      this._rightmostFailurePositionStack.pop()
    );
    if (optNode) {
      this.pushBinding(optNode, origPos);
    }
  },
  enterLexifiedContext() {
    this.inLexifiedContextStack.push(true);
  },
  exitLexifiedContext() {
    this.inLexifiedContextStack.pop();
  },
  currentApplication() {
    return this._applicationStack[this._applicationStack.length - 1];
  },
  inSyntacticContext() {
    const currentApplication = this.currentApplication();
    if (currentApplication) {
      return currentApplication.isSyntactic() && !this.inLexifiedContext();
    } else {
      return this.startExpr.factors[0].isSyntactic();
    }
  },
  inLexifiedContext() {
    return this.inLexifiedContextStack[this.inLexifiedContextStack.length - 1];
  },
  skipSpaces() {
    this.pushFailuresInfo();
    this.eval(applySpaces);
    this.popBinding();
    this.popFailuresInfo();
    return this.inputStream.pos;
  },
  skipSpacesIfInSyntacticContext() {
    return this.inSyntacticContext() ? this.skipSpaces() : this.inputStream.pos;
  },
  maybeSkipSpacesBefore(expr) {
    if (expr.allowsSkippingPrecedingSpace() && expr !== applySpaces) {
      return this.skipSpacesIfInSyntacticContext();
    } else {
      return this.inputStream.pos;
    }
  },
  pushBinding(node, origPos) {
    this._bindings.push(node);
    this._bindingOffsets.push(this.posToOffset(origPos));
  },
  popBinding() {
    this._bindings.pop();
    this._bindingOffsets.pop();
  },
  numBindings() {
    return this._bindings.length;
  },
  truncateBindings(newLength) {
    while (this._bindings.length > newLength) {
      this.popBinding();
    }
  },
  getCurrentPosInfo() {
    return this.getPosInfo(this.inputStream.pos);
  },
  getPosInfo(pos) {
    let posInfo = this.memoTable[pos];
    if (!posInfo) {
      posInfo = this.memoTable[pos] = new PosInfo();
    }
    return posInfo;
  },
  processFailure(pos, expr) {
    this.rightmostFailurePosition = Math.max(this.rightmostFailurePosition, pos);
    if (this.recordedFailures && pos === this.positionToRecordFailures) {
      const app = this.currentApplication();
      if (app) {
        expr = expr.substituteParams(app.args);
      }
      this.recordFailure(expr.toFailure(this.grammar), false);
    }
  },
  recordFailure(failure, shouldCloneIfNew) {
    const key = failure.toKey();
    if (!this.recordedFailures[key]) {
      this.recordedFailures[key] = shouldCloneIfNew ? failure.clone() : failure;
    } else if (this.recordedFailures[key].isFluffy() && !failure.isFluffy()) {
      this.recordedFailures[key].clearFluffy();
    }
  },
  recordFailures(failures, shouldCloneIfNew) {
    Object.keys(failures).forEach((key) => {
      this.recordFailure(failures[key], shouldCloneIfNew);
    });
  },
  cloneRecordedFailures() {
    if (!this.recordedFailures) {
      return void 0;
    }
    const ans = /* @__PURE__ */ Object.create(null);
    Object.keys(this.recordedFailures).forEach((key) => {
      ans[key] = this.recordedFailures[key].clone();
    });
    return ans;
  },
  getRightmostFailurePosition() {
    return this.rightmostFailurePosition;
  },
  _getRightmostFailureOffset() {
    return this.rightmostFailurePosition >= 0 ? this.posToOffset(this.rightmostFailurePosition) : -1;
  },
  // Returns the memoized trace entry for `expr` at `pos`, if one exists, `null` otherwise.
  getMemoizedTraceEntry(pos, expr) {
    const posInfo = this.memoTable[pos];
    if (posInfo && expr instanceof pexprs$5.Apply) {
      const memoRec = posInfo.memo[expr.toMemoKey()];
      if (memoRec && memoRec.traceEntry) {
        const entry = memoRec.traceEntry.cloneWithExpr(expr);
        entry.isMemoized = true;
        return entry;
      }
    }
    return null;
  },
  // Returns a new trace entry, with the currently active trace array as its children.
  getTraceEntry(pos, expr, succeeded, bindings) {
    if (expr instanceof pexprs$5.Apply) {
      const app = this.currentApplication();
      const actuals = app ? app.args : [];
      expr = expr.substituteParams(actuals);
    }
    return this.getMemoizedTraceEntry(pos, expr) || new Trace(this.input, pos, this.inputStream.pos, expr, succeeded, bindings, this.trace);
  },
  isTracing() {
    return !!this.trace;
  },
  hasNecessaryInfo(memoRec) {
    if (this.trace && !memoRec.traceEntry) {
      return false;
    }
    if (this.recordedFailures && this.inputStream.pos + memoRec.rightmostFailureOffset === this.positionToRecordFailures) {
      return !!memoRec.failuresAtRightmostPosition;
    }
    return true;
  },
  useMemoizedResult(origPos, memoRec) {
    if (this.trace) {
      this.trace.push(memoRec.traceEntry);
    }
    const memoRecRightmostFailurePosition = this.inputStream.pos + memoRec.rightmostFailureOffset;
    this.rightmostFailurePosition = Math.max(
      this.rightmostFailurePosition,
      memoRecRightmostFailurePosition
    );
    if (this.recordedFailures && this.positionToRecordFailures === memoRecRightmostFailurePosition && memoRec.failuresAtRightmostPosition) {
      this.recordFailures(memoRec.failuresAtRightmostPosition, true);
    }
    this.inputStream.examinedLength = Math.max(
      this.inputStream.examinedLength,
      memoRec.examinedLength + origPos
    );
    if (memoRec.value) {
      this.inputStream.pos += memoRec.matchLength;
      this.pushBinding(memoRec.value, origPos);
      return true;
    }
    return false;
  },
  // Evaluate `expr` and return `true` if it succeeded, `false` otherwise. On success, `bindings`
  // will have `expr.getArity()` more elements than before, and the input stream's position may
  // have increased. On failure, `bindings` and position will be unchanged.
  eval(expr) {
    const { inputStream } = this;
    const origNumBindings = this._bindings.length;
    let origRecordedFailures;
    if (this.recordedFailures) {
      origRecordedFailures = this.recordedFailures;
      this.recordedFailures = /* @__PURE__ */ Object.create(null);
    }
    const origPos = inputStream.pos;
    const memoPos = this.maybeSkipSpacesBefore(expr);
    let origTrace;
    if (this.trace) {
      origTrace = this.trace;
      this.trace = [];
    }
    const ans = expr.eval(this);
    if (this.trace) {
      const bindings = this._bindings.slice(origNumBindings);
      const traceEntry = this.getTraceEntry(memoPos, expr, ans, bindings);
      traceEntry.isImplicitSpaces = expr === applySpaces;
      traceEntry.isRootNode = expr === this.startExpr;
      origTrace.push(traceEntry);
      this.trace = origTrace;
    }
    if (ans) {
      if (this.recordedFailures && inputStream.pos === this.positionToRecordFailures) {
        Object.keys(this.recordedFailures).forEach((key) => {
          this.recordedFailures[key].makeFluffy();
        });
      }
    } else {
      inputStream.pos = origPos;
      this.truncateBindings(origNumBindings);
    }
    if (this.recordedFailures) {
      this.recordFailures(origRecordedFailures, false);
    }
    if (expr === builtInApplySyntacticBody) {
      this.skipSpaces();
    }
    return ans;
  },
  getMatchResult() {
    this.eval(this.startExpr);
    let rightmostFailures;
    if (this.recordedFailures) {
      rightmostFailures = Object.keys(this.recordedFailures).map(
        (key) => this.recordedFailures[key]
      );
    }
    const cst = this._bindings[0];
    if (cst) {
      cst.grammar = this.grammar;
    }
    return new MatchResult$1(
      this.matcher,
      this.input,
      this.startExpr,
      cst,
      this._bindingOffsets[0],
      this.rightmostFailurePosition,
      rightmostFailures
    );
  },
  getTrace() {
    this.trace = [];
    const matchResult = this.getMatchResult();
    const rootTrace = this.trace[this.trace.length - 1];
    rootTrace.result = matchResult;
    return rootTrace;
  },
  pushFailuresInfo() {
    this._rightmostFailurePositionStack.push(this.rightmostFailurePosition);
    this._recordedFailuresStack.push(this.recordedFailures);
  },
  popFailuresInfo() {
    this.rightmostFailurePosition = this._rightmostFailurePositionStack.pop();
    this.recordedFailures = this._recordedFailuresStack.pop();
  }
};
var MatchState_1 = MatchState$1;
const MatchState = MatchState_1;
const pexprs$4 = pexprs$6;
function Matcher$1(grammar2) {
  this.grammar = grammar2;
  this.memoTable = [];
  this.input = "";
}
Matcher$1.prototype.getInput = function() {
  return this.input;
};
Matcher$1.prototype.setInput = function(str) {
  if (this.input !== str) {
    this.replaceInputRange(0, this.input.length, str);
  }
  return this;
};
Matcher$1.prototype.replaceInputRange = function(startIdx, endIdx, str) {
  const currentInput = this.input;
  if (startIdx < 0 || startIdx > currentInput.length || endIdx < 0 || endIdx > currentInput.length || startIdx > endIdx) {
    throw new Error("Invalid indices: " + startIdx + " and " + endIdx);
  }
  this.input = currentInput.slice(0, startIdx) + str + currentInput.slice(endIdx);
  const restOfMemoTable = this.memoTable.slice(endIdx);
  this.memoTable.length = startIdx;
  for (let idx = 0; idx < str.length; idx++) {
    this.memoTable.push(void 0);
  }
  restOfMemoTable.forEach(function(posInfo) {
    this.memoTable.push(posInfo);
  }, this);
  for (let pos = 0; pos < startIdx; pos++) {
    const posInfo = this.memoTable[pos];
    if (posInfo) {
      posInfo.clearObsoleteEntries(pos, startIdx);
    }
  }
  return this;
};
Matcher$1.prototype.match = function(optStartApplicationStr) {
  return this._match(this._getStartExpr(optStartApplicationStr), false);
};
Matcher$1.prototype.trace = function(optStartApplicationStr) {
  return this._match(this._getStartExpr(optStartApplicationStr), true);
};
Matcher$1.prototype._match = function(startExpr, tracing, optPositionToRecordFailures) {
  const state = new MatchState(this, startExpr, optPositionToRecordFailures);
  return tracing ? state.getTrace() : state.getMatchResult();
};
Matcher$1.prototype._getStartExpr = function(optStartApplicationStr) {
  const applicationStr = optStartApplicationStr || this.grammar.defaultStartRule;
  if (!applicationStr) {
    throw new Error("Missing start rule argument -- the grammar has no default start rule.");
  }
  const startApp = this.grammar.parseApplication(applicationStr);
  return new pexprs$4.Seq([startApp, pexprs$4.end]);
};
var Matcher_1 = Matcher$1;
const InputStream$1 = InputStream_1;
const { IterationNode } = nodes$1;
const MatchResult = MatchResult_1;
const common$3 = common$l;
const errors$3 = errors$9;
const util$2 = util$7;
const globalActionStack = [];
const hasOwnProperty = (x, prop) => Object.prototype.hasOwnProperty.call(x, prop);
class Wrapper {
  constructor(node, sourceInterval, baseInterval) {
    this._node = node;
    this.source = sourceInterval;
    this._baseInterval = baseInterval;
    if (node.isNonterminal()) {
      common$3.assert(sourceInterval === baseInterval);
    }
    this._childWrappers = [];
  }
  toString() {
    return "[semantics wrapper for " + this._node.grammar.name + "]";
  }
  _forgetMemoizedResultFor(attributeName) {
    delete this._node[this._semantics.attributeKeys[attributeName]];
    this.children.forEach((child) => {
      child._forgetMemoizedResultFor(attributeName);
    });
  }
  // Returns the wrapper of the specified child node. Child wrappers are created lazily and
  // cached in the parent wrapper's `_childWrappers` instance variable.
  child(idx) {
    if (!(0 <= idx && idx < this._node.numChildren())) {
      return void 0;
    }
    let childWrapper = this._childWrappers[idx];
    if (!childWrapper) {
      const childNode = this._node.childAt(idx);
      const offset = this._node.childOffsets[idx];
      const source = this._baseInterval.subInterval(offset, childNode.matchLength);
      const base = childNode.isNonterminal() ? source : this._baseInterval;
      childWrapper = this._childWrappers[idx] = this._semantics.wrap(childNode, source, base);
    }
    return childWrapper;
  }
  // Returns an array containing the wrappers of all of the children of the node associated
  // with this wrapper.
  _children() {
    for (let idx = 0; idx < this._node.numChildren(); idx++) {
      this.child(idx);
    }
    return this._childWrappers;
  }
  // Returns `true` if the CST node associated with this wrapper corresponds to an iteration
  // expression, i.e., a Kleene-*, Kleene-+, or an optional. Returns `false` otherwise.
  isIteration() {
    return this._node.isIteration();
  }
  // Returns `true` if the CST node associated with this wrapper is a terminal node, `false`
  // otherwise.
  isTerminal() {
    return this._node.isTerminal();
  }
  // Returns `true` if the CST node associated with this wrapper is a nonterminal node, `false`
  // otherwise.
  isNonterminal() {
    return this._node.isNonterminal();
  }
  // Returns `true` if the CST node associated with this wrapper is a nonterminal node
  // corresponding to a syntactic rule, `false` otherwise.
  isSyntactic() {
    return this.isNonterminal() && this._node.isSyntactic();
  }
  // Returns `true` if the CST node associated with this wrapper is a nonterminal node
  // corresponding to a lexical rule, `false` otherwise.
  isLexical() {
    return this.isNonterminal() && this._node.isLexical();
  }
  // Returns `true` if the CST node associated with this wrapper is an iterator node
  // having either one or no child (? operator), `false` otherwise.
  // Otherwise, throws an exception.
  isOptional() {
    return this._node.isOptional();
  }
  // Create a new _iter wrapper in the same semantics as this wrapper.
  iteration(optChildWrappers) {
    const childWrappers = optChildWrappers || [];
    const childNodes = childWrappers.map((c) => c._node);
    const iter = new IterationNode(childNodes, [], -1, false);
    const wrapper = this._semantics.wrap(iter, null, null);
    wrapper._childWrappers = childWrappers;
    return wrapper;
  }
  // Returns an array containing the children of this CST node.
  get children() {
    return this._children();
  }
  // Returns the name of grammar rule that created this CST node.
  get ctorName() {
    return this._node.ctorName;
  }
  // TODO: Remove this eventually (deprecated in v0.12).
  get interval() {
    throw new Error("The `interval` property is deprecated -- use `source` instead");
  }
  // Returns the number of children of this CST node.
  get numChildren() {
    return this._node.numChildren();
  }
  // Returns the contents of the input stream consumed by this CST node.
  get sourceString() {
    return this.source.contents;
  }
}
function Semantics$2(grammar2, superSemantics) {
  const self = this;
  this.grammar = grammar2;
  this.checkedActionDicts = false;
  this.Wrapper = class extends (superSemantics ? superSemantics.Wrapper : Wrapper) {
    constructor(node, sourceInterval, baseInterval) {
      super(node, sourceInterval, baseInterval);
      self.checkActionDictsIfHaventAlready();
      this._semantics = self;
    }
  };
  this.super = superSemantics;
  if (superSemantics) {
    if (!(grammar2.equals(this.super.grammar) || grammar2._inheritsFrom(this.super.grammar))) {
      throw new Error(
        "Cannot extend a semantics for grammar '" + this.super.grammar.name + "' for use with grammar '" + grammar2.name + "' (not a sub-grammar)"
      );
    }
    this.operations = Object.create(this.super.operations);
    this.attributes = Object.create(this.super.attributes);
    this.attributeKeys = /* @__PURE__ */ Object.create(null);
    for (const attributeName in this.attributes) {
      Object.defineProperty(this.attributeKeys, attributeName, {
        value: util$2.uniqueId(attributeName)
      });
    }
  } else {
    this.operations = /* @__PURE__ */ Object.create(null);
    this.attributes = /* @__PURE__ */ Object.create(null);
    this.attributeKeys = /* @__PURE__ */ Object.create(null);
  }
}
Semantics$2.prototype.toString = function() {
  return "[semantics for " + this.grammar.name + "]";
};
Semantics$2.prototype.checkActionDictsIfHaventAlready = function() {
  if (!this.checkedActionDicts) {
    this.checkActionDicts();
    this.checkedActionDicts = true;
  }
};
Semantics$2.prototype.checkActionDicts = function() {
  let name2;
  for (name2 in this.operations) {
    this.operations[name2].checkActionDict(this.grammar);
  }
  for (name2 in this.attributes) {
    this.attributes[name2].checkActionDict(this.grammar);
  }
};
Semantics$2.prototype.toRecipe = function(semanticsOnly) {
  function hasSuperSemantics(s) {
    return s.super !== Semantics$2.BuiltInSemantics._getSemantics();
  }
  let str = "(function(g) {\n";
  if (hasSuperSemantics(this)) {
    str += "  var semantics = " + this.super.toRecipe(true) + "(g";
    const superSemanticsGrammar = this.super.grammar;
    let relatedGrammar = this.grammar;
    while (relatedGrammar !== superSemanticsGrammar) {
      str += ".superGrammar";
      relatedGrammar = relatedGrammar.superGrammar;
    }
    str += ");\n";
    str += "  return g.extendSemantics(semantics)";
  } else {
    str += "  return g.createSemantics()";
  }
  ["Operation", "Attribute"].forEach((type) => {
    const semanticOperations = this[type.toLowerCase() + "s"];
    Object.keys(semanticOperations).forEach((name2) => {
      const { actionDict, formals, builtInDefault } = semanticOperations[name2];
      let signature = name2;
      if (formals.length > 0) {
        signature += "(" + formals.join(", ") + ")";
      }
      let method;
      if (hasSuperSemantics(this) && this.super[type.toLowerCase() + "s"][name2]) {
        method = "extend" + type;
      } else {
        method = "add" + type;
      }
      str += "\n    ." + method + "(" + JSON.stringify(signature) + ", {";
      const srcArray = [];
      Object.keys(actionDict).forEach((actionName) => {
        if (actionDict[actionName] !== builtInDefault) {
          let source = actionDict[actionName].toString().trim();
          source = source.replace(/^.*\(/, "function(");
          srcArray.push("\n      " + JSON.stringify(actionName) + ": " + source);
        }
      });
      str += srcArray.join(",") + "\n    })";
    });
  });
  str += ";\n  })";
  if (!semanticsOnly) {
    str = "(function() {\n  var grammar = this.fromRecipe(" + this.grammar.toRecipe() + ");\n  var semantics = " + str + "(grammar);\n  return semantics;\n});\n";
  }
  return str;
};
function parseSignature$1(signature, type) {
  if (!Semantics$2.prototypeGrammar) {
    common$3.assert(signature.indexOf("(") === -1);
    return {
      name: signature,
      formals: []
    };
  }
  const r = Semantics$2.prototypeGrammar.match(
    signature,
    type === "operation" ? "OperationSignature" : "AttributeSignature"
  );
  if (r.failed()) {
    throw new Error(r.message);
  }
  return Semantics$2.prototypeGrammarSemantics(r).parse();
}
function newDefaultAction(type, name2, doIt) {
  return function(...children) {
    const thisThing = this._semantics.operations[name2] || this._semantics.attributes[name2];
    const args = thisThing.formals.map((formal) => this.args[formal]);
    if (!this.isIteration() && children.length === 1) {
      return doIt.apply(children[0], args);
    } else {
      throw errors$3.missingSemanticAction(this.ctorName, name2, type, globalActionStack);
    }
  };
}
Semantics$2.prototype.addOperationOrAttribute = function(type, signature, actionDict) {
  const typePlural = type + "s";
  const parsedNameAndFormalArgs = parseSignature$1(signature, type);
  const { name: name2 } = parsedNameAndFormalArgs;
  const { formals } = parsedNameAndFormalArgs;
  this.assertNewName(name2, type);
  const builtInDefault = newDefaultAction(type, name2, doIt);
  const realActionDict = { _default: builtInDefault };
  Object.keys(actionDict).forEach((name3) => {
    realActionDict[name3] = actionDict[name3];
  });
  const entry = type === "operation" ? new Operation(name2, formals, realActionDict, builtInDefault) : new Attribute(name2, realActionDict, builtInDefault);
  entry.checkActionDict(this.grammar);
  this[typePlural][name2] = entry;
  function doIt(...args) {
    const thisThing = this._semantics[typePlural][name2];
    if (arguments.length !== thisThing.formals.length) {
      throw new Error(
        "Invalid number of arguments passed to " + name2 + " " + type + " (expected " + thisThing.formals.length + ", got " + arguments.length + ")"
      );
    }
    const argsObj = /* @__PURE__ */ Object.create(null);
    for (const [idx, val] of Object.entries(args)) {
      const formal = thisThing.formals[idx];
      argsObj[formal] = val;
    }
    const oldArgs = this.args;
    this.args = argsObj;
    const ans = thisThing.execute(this._semantics, this);
    this.args = oldArgs;
    return ans;
  }
  if (type === "operation") {
    this.Wrapper.prototype[name2] = doIt;
    this.Wrapper.prototype[name2].toString = function() {
      return "[" + name2 + " operation]";
    };
  } else {
    Object.defineProperty(this.Wrapper.prototype, name2, {
      get: doIt,
      configurable: true
      // So the property can be deleted.
    });
    Object.defineProperty(this.attributeKeys, name2, {
      value: util$2.uniqueId(name2)
    });
  }
};
Semantics$2.prototype.extendOperationOrAttribute = function(type, name2, actionDict) {
  const typePlural = type + "s";
  parseSignature$1(name2, "attribute");
  if (!(this.super && name2 in this.super[typePlural])) {
    throw new Error(
      "Cannot extend " + type + " '" + name2 + "': did not inherit an " + type + " with that name"
    );
  }
  if (hasOwnProperty(this[typePlural], name2)) {
    throw new Error("Cannot extend " + type + " '" + name2 + "' again");
  }
  const inheritedFormals = this[typePlural][name2].formals;
  const inheritedActionDict = this[typePlural][name2].actionDict;
  const newActionDict = Object.create(inheritedActionDict);
  Object.keys(actionDict).forEach((name3) => {
    newActionDict[name3] = actionDict[name3];
  });
  this[typePlural][name2] = type === "operation" ? new Operation(name2, inheritedFormals, newActionDict) : new Attribute(name2, newActionDict);
  this[typePlural][name2].checkActionDict(this.grammar);
};
Semantics$2.prototype.assertNewName = function(name2, type) {
  if (hasOwnProperty(Wrapper.prototype, name2)) {
    throw new Error("Cannot add " + type + " '" + name2 + "': that's a reserved name");
  }
  if (name2 in this.operations) {
    throw new Error(
      "Cannot add " + type + " '" + name2 + "': an operation with that name already exists"
    );
  }
  if (name2 in this.attributes) {
    throw new Error(
      "Cannot add " + type + " '" + name2 + "': an attribute with that name already exists"
    );
  }
};
Semantics$2.prototype.wrap = function(node, source, optBaseInterval) {
  const baseInterval = optBaseInterval || source;
  return node instanceof this.Wrapper ? node : new this.Wrapper(node, source, baseInterval);
};
Semantics$2.createSemantics = function(grammar2, optSuperSemantics) {
  const s = new Semantics$2(
    grammar2,
    optSuperSemantics !== void 0 ? optSuperSemantics : Semantics$2.BuiltInSemantics._getSemantics()
  );
  const proxy = function ASemantics(matchResult) {
    if (!(matchResult instanceof MatchResult)) {
      throw new TypeError(
        "Semantics expected a MatchResult, but got " + common$3.unexpectedObjToString(matchResult)
      );
    }
    if (matchResult.failed()) {
      throw new TypeError("cannot apply Semantics to " + matchResult.toString());
    }
    const cst = matchResult._cst;
    if (cst.grammar !== grammar2) {
      throw new Error(
        "Cannot use a MatchResult from grammar '" + cst.grammar.name + "' with a semantics for '" + grammar2.name + "'"
      );
    }
    const inputStream = new InputStream$1(matchResult.input);
    return s.wrap(cst, inputStream.interval(matchResult._cstOffset, matchResult.input.length));
  };
  proxy.addOperation = function(signature, actionDict) {
    s.addOperationOrAttribute("operation", signature, actionDict);
    return proxy;
  };
  proxy.extendOperation = function(name2, actionDict) {
    s.extendOperationOrAttribute("operation", name2, actionDict);
    return proxy;
  };
  proxy.addAttribute = function(name2, actionDict) {
    s.addOperationOrAttribute("attribute", name2, actionDict);
    return proxy;
  };
  proxy.extendAttribute = function(name2, actionDict) {
    s.extendOperationOrAttribute("attribute", name2, actionDict);
    return proxy;
  };
  proxy._getActionDict = function(operationOrAttributeName) {
    const action = s.operations[operationOrAttributeName] || s.attributes[operationOrAttributeName];
    if (!action) {
      throw new Error(
        '"' + operationOrAttributeName + '" is not a valid operation or attribute name in this semantics for "' + grammar2.name + '"'
      );
    }
    return action.actionDict;
  };
  proxy._remove = function(operationOrAttributeName) {
    let semantic;
    if (operationOrAttributeName in s.operations) {
      semantic = s.operations[operationOrAttributeName];
      delete s.operations[operationOrAttributeName];
    } else if (operationOrAttributeName in s.attributes) {
      semantic = s.attributes[operationOrAttributeName];
      delete s.attributes[operationOrAttributeName];
    }
    delete s.Wrapper.prototype[operationOrAttributeName];
    return semantic;
  };
  proxy.getOperationNames = function() {
    return Object.keys(s.operations);
  };
  proxy.getAttributeNames = function() {
    return Object.keys(s.attributes);
  };
  proxy.getGrammar = function() {
    return s.grammar;
  };
  proxy.toRecipe = function(semanticsOnly) {
    return s.toRecipe(semanticsOnly);
  };
  proxy.toString = s.toString.bind(s);
  proxy._getSemantics = function() {
    return s;
  };
  return proxy;
};
class Operation {
  constructor(name2, formals, actionDict, builtInDefault) {
    this.name = name2;
    this.formals = formals;
    this.actionDict = actionDict;
    this.builtInDefault = builtInDefault;
  }
  checkActionDict(grammar2) {
    grammar2._checkTopDownActionDict(this.typeName, this.name, this.actionDict);
  }
  // Execute this operation on the CST node associated with `nodeWrapper` in the context of the
  // given Semantics instance.
  execute(semantics, nodeWrapper) {
    try {
      const { ctorName } = nodeWrapper._node;
      let actionFn = this.actionDict[ctorName];
      if (actionFn) {
        globalActionStack.push([this, ctorName]);
        return actionFn.apply(nodeWrapper, nodeWrapper._children());
      }
      if (nodeWrapper.isNonterminal()) {
        actionFn = this.actionDict._nonterminal;
        if (actionFn) {
          globalActionStack.push([this, "_nonterminal", ctorName]);
          return actionFn.apply(nodeWrapper, nodeWrapper._children());
        }
      }
      globalActionStack.push([this, "default action", ctorName]);
      return this.actionDict._default.apply(nodeWrapper, nodeWrapper._children());
    } finally {
      globalActionStack.pop();
    }
  }
}
Operation.prototype.typeName = "operation";
class Attribute extends Operation {
  constructor(name2, actionDict, builtInDefault) {
    super(name2, [], actionDict, builtInDefault);
  }
  execute(semantics, nodeWrapper) {
    const node = nodeWrapper._node;
    const key = semantics.attributeKeys[this.name];
    if (!hasOwnProperty(node, key)) {
      node[key] = Operation.prototype.execute.call(this, semantics, nodeWrapper);
    }
    return node[key];
  }
}
Attribute.prototype.typeName = "attribute";
var Semantics_1 = Semantics$2;
const CaseInsensitiveTerminal = CaseInsensitiveTerminal_1;
const Matcher = Matcher_1;
const Semantics$1 = Semantics_1;
const common$2 = common$l;
const errors$2 = errors$9;
const pexprs$3 = pexprs$6;
const SPECIAL_ACTION_NAMES = ["_iter", "_terminal", "_nonterminal", "_default"];
function getSortedRuleValues(grammar2) {
  return Object.keys(grammar2.rules).sort().map((name2) => grammar2.rules[name2]);
}
const jsonToJS = (str) => str.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
function Grammar$4(name2, superGrammar, rules, optDefaultStartRule) {
  this.name = name2;
  this.superGrammar = superGrammar;
  this.rules = rules;
  if (optDefaultStartRule) {
    if (!(optDefaultStartRule in rules)) {
      throw new Error(
        "Invalid start rule: '" + optDefaultStartRule + "' is not a rule in grammar '" + name2 + "'"
      );
    }
    this.defaultStartRule = optDefaultStartRule;
  }
}
let ohmGrammar$2;
let buildGrammar$1;
Grammar$4.initApplicationParser = function(grammar2, builderFn) {
  ohmGrammar$2 = grammar2;
  buildGrammar$1 = builderFn;
};
Grammar$4.prototype = {
  matcher() {
    return new Matcher(this);
  },
  // Return true if the grammar is a built-in grammar, otherwise false.
  // NOTE: This might give an unexpected result if called before BuiltInRules is defined!
  isBuiltIn() {
    return this === Grammar$4.ProtoBuiltInRules || this === Grammar$4.BuiltInRules;
  },
  equals(g) {
    if (this === g) {
      return true;
    }
    if (g == null || this.name !== g.name || this.defaultStartRule !== g.defaultStartRule || !(this.superGrammar === g.superGrammar || this.superGrammar.equals(g.superGrammar))) {
      return false;
    }
    const myRules = getSortedRuleValues(this);
    const otherRules = getSortedRuleValues(g);
    return myRules.length === otherRules.length && myRules.every((rule, i) => {
      return rule.description === otherRules[i].description && rule.formals.join(",") === otherRules[i].formals.join(",") && rule.body.toString() === otherRules[i].body.toString();
    });
  },
  match(input, optStartApplication) {
    const m = this.matcher();
    m.replaceInputRange(0, 0, input);
    return m.match(optStartApplication);
  },
  trace(input, optStartApplication) {
    const m = this.matcher();
    m.replaceInputRange(0, 0, input);
    return m.trace(optStartApplication);
  },
  createSemantics() {
    return Semantics$1.createSemantics(this);
  },
  extendSemantics(superSemantics) {
    return Semantics$1.createSemantics(this, superSemantics._getSemantics());
  },
  // Check that every key in `actionDict` corresponds to a semantic action, and that it maps to
  // a function of the correct arity. If not, throw an exception.
  _checkTopDownActionDict(what, name2, actionDict) {
    const problems = [];
    for (const k in actionDict) {
      const v = actionDict[k];
      const isSpecialAction = SPECIAL_ACTION_NAMES.includes(k);
      if (!isSpecialAction && !(k in this.rules)) {
        problems.push(`'${k}' is not a valid semantic action for '${this.name}'`);
        continue;
      }
      if (typeof v !== "function") {
        problems.push(`'${k}' must be a function in an action dictionary for '${this.name}'`);
        continue;
      }
      const actual = v.length;
      const expected = this._topDownActionArity(k);
      if (actual !== expected) {
        let details;
        if (k === "_iter" || k === "_nonterminal") {
          details = `it should use a rest parameter, e.g. \`${k}(...children) {}\`. NOTE: this is new in Ohm v16  see https://ohmjs.org/d/ati for details.`;
        } else {
          details = `expected ${expected}, got ${actual}`;
        }
        problems.push(`Semantic action '${k}' has the wrong arity: ${details}`);
      }
    }
    if (problems.length > 0) {
      const prettyProblems = problems.map((problem) => "- " + problem);
      const error = new Error(
        [
          `Found errors in the action dictionary of the '${name2}' ${what}:`,
          ...prettyProblems
        ].join("\n")
      );
      error.problems = problems;
      throw error;
    }
  },
  // Return the expected arity for a semantic action named `actionName`, which
  // is either a rule name or a special action name like '_nonterminal'.
  _topDownActionArity(actionName) {
    return SPECIAL_ACTION_NAMES.includes(actionName) ? 0 : this.rules[actionName].body.getArity();
  },
  _inheritsFrom(grammar2) {
    let g = this.superGrammar;
    while (g) {
      if (g.equals(grammar2, true)) {
        return true;
      }
      g = g.superGrammar;
    }
    return false;
  },
  toRecipe(superGrammarExpr = void 0) {
    const metaInfo = {};
    if (this.source) {
      metaInfo.source = this.source.contents;
    }
    let startRule = null;
    if (this.defaultStartRule) {
      startRule = this.defaultStartRule;
    }
    const rules = {};
    Object.keys(this.rules).forEach((ruleName) => {
      const ruleInfo = this.rules[ruleName];
      const { body } = ruleInfo;
      const isDefinition = !this.superGrammar || !this.superGrammar.rules[ruleName];
      let operation;
      if (isDefinition) {
        operation = "define";
      } else {
        operation = body instanceof pexprs$3.Extend ? "extend" : "override";
      }
      const metaInfo2 = {};
      if (ruleInfo.source && this.source) {
        const adjusted = ruleInfo.source.relativeTo(this.source);
        metaInfo2.sourceInterval = [adjusted.startIdx, adjusted.endIdx];
      }
      const description2 = isDefinition ? ruleInfo.description : null;
      const bodyRecipe = body.outputRecipe(ruleInfo.formals, this.source);
      rules[ruleName] = [
        operation,
        // "define"/"extend"/"override"
        metaInfo2,
        description2,
        ruleInfo.formals,
        bodyRecipe
      ];
    });
    let superGrammarOutput = "null";
    if (superGrammarExpr) {
      superGrammarOutput = superGrammarExpr;
    } else if (this.superGrammar && !this.superGrammar.isBuiltIn()) {
      superGrammarOutput = this.superGrammar.toRecipe();
    }
    const recipeElements = [
      ...["grammar", metaInfo, this.name].map(JSON.stringify),
      superGrammarOutput,
      ...[startRule, rules].map(JSON.stringify)
    ];
    return jsonToJS(`[${recipeElements.join(",")}]`);
  },
  // TODO: Come up with better names for these methods.
  // TODO: Write the analog of these methods for inherited attributes.
  toOperationActionDictionaryTemplate() {
    return this._toOperationOrAttributeActionDictionaryTemplate();
  },
  toAttributeActionDictionaryTemplate() {
    return this._toOperationOrAttributeActionDictionaryTemplate();
  },
  _toOperationOrAttributeActionDictionaryTemplate() {
    const sb = new common$2.StringBuffer();
    sb.append("{");
    let first = true;
    for (const ruleName in this.rules) {
      const { body } = this.rules[ruleName];
      if (first) {
        first = false;
      } else {
        sb.append(",");
      }
      sb.append("\n");
      sb.append("  ");
      this.addSemanticActionTemplate(ruleName, body, sb);
    }
    sb.append("\n}");
    return sb.contents();
  },
  addSemanticActionTemplate(ruleName, body, sb) {
    sb.append(ruleName);
    sb.append(": function(");
    const arity = this._topDownActionArity(ruleName);
    sb.append(common$2.repeat("_", arity).join(", "));
    sb.append(") {\n");
    sb.append("  }");
  },
  // Parse a string which expresses a rule application in this grammar, and return the
  // resulting Apply node.
  parseApplication(str) {
    let app;
    if (str.indexOf("<") === -1) {
      app = new pexprs$3.Apply(str);
    } else {
      const cst = ohmGrammar$2.match(str, "Base_application");
      app = buildGrammar$1(cst, {});
    }
    if (!(app.ruleName in this.rules)) {
      throw errors$2.undeclaredRule(app.ruleName, this.name);
    }
    const { formals } = this.rules[app.ruleName];
    if (formals.length !== app.args.length) {
      const { source } = this.rules[app.ruleName];
      throw errors$2.wrongNumberOfParameters(
        app.ruleName,
        formals.length,
        app.args.length,
        source
      );
    }
    return app;
  }
};
Grammar$4.ProtoBuiltInRules = new Grammar$4(
  "ProtoBuiltInRules",
  // name
  void 0,
  // supergrammar
  {
    any: {
      body: pexprs$3.any,
      formals: [],
      description: "any character",
      primitive: true
    },
    end: {
      body: pexprs$3.end,
      formals: [],
      description: "end of input",
      primitive: true
    },
    caseInsensitive: {
      body: new CaseInsensitiveTerminal(new pexprs$3.Param(0)),
      formals: ["str"],
      primitive: true
    },
    lower: {
      body: new pexprs$3.UnicodeChar("Ll"),
      formals: [],
      description: "a lowercase letter",
      primitive: true
    },
    upper: {
      body: new pexprs$3.UnicodeChar("Lu"),
      formals: [],
      description: "an uppercase letter",
      primitive: true
    },
    // Union of Lt (titlecase), Lm (modifier), and Lo (other), i.e. any letter not in Ll or Lu.
    unicodeLtmo: {
      body: new pexprs$3.UnicodeChar("Ltmo"),
      formals: [],
      description: "a Unicode character in Lt, Lm, or Lo",
      primitive: true
    },
    // These rules are not truly primitive (they could be written in userland) but are defined
    // here for bootstrapping purposes.
    spaces: {
      body: new pexprs$3.Star(new pexprs$3.Apply("space")),
      formals: []
    },
    space: {
      body: new pexprs$3.Range("\0", " "),
      formals: [],
      description: "a space"
    }
  }
);
var Grammar_1 = Grammar$4;
const Grammar$3 = Grammar_1;
const InputStream = InputStream_1;
const common$1 = common$l;
const errors$1 = errors$9;
const pexprs$2 = pexprs$6;
function GrammarDecl$1(name2) {
  this.name = name2;
}
GrammarDecl$1.prototype.sourceInterval = function(startIdx, endIdx) {
  return this.source.subInterval(startIdx, endIdx - startIdx);
};
GrammarDecl$1.prototype.ensureSuperGrammar = function() {
  if (!this.superGrammar) {
    this.withSuperGrammar(
      // TODO: The conditional expression below is an ugly hack. It's kind of ok because
      // I doubt anyone will ever try to declare a grammar called `BuiltInRules`. Still,
      // we should try to find a better way to do this.
      this.name === "BuiltInRules" ? Grammar$3.ProtoBuiltInRules : Grammar$3.BuiltInRules
    );
  }
  return this.superGrammar;
};
GrammarDecl$1.prototype.ensureSuperGrammarRuleForOverriding = function(name2, source) {
  const ruleInfo = this.ensureSuperGrammar().rules[name2];
  if (!ruleInfo) {
    throw errors$1.cannotOverrideUndeclaredRule(name2, this.superGrammar.name, source);
  }
  return ruleInfo;
};
GrammarDecl$1.prototype.installOverriddenOrExtendedRule = function(name2, formals, body, source) {
  const duplicateParameterNames2 = common$1.getDuplicates(formals);
  if (duplicateParameterNames2.length > 0) {
    throw errors$1.duplicateParameterNames(name2, duplicateParameterNames2, source);
  }
  const ruleInfo = this.ensureSuperGrammar().rules[name2];
  const expectedFormals = ruleInfo.formals;
  const expectedNumFormals = expectedFormals ? expectedFormals.length : 0;
  if (formals.length !== expectedNumFormals) {
    throw errors$1.wrongNumberOfParameters(name2, expectedNumFormals, formals.length, source);
  }
  return this.install(name2, formals, body, ruleInfo.description, source);
};
GrammarDecl$1.prototype.install = function(name2, formals, body, description2, source) {
  this.rules[name2] = {
    body: body.introduceParams(formals),
    formals,
    description: description2,
    source
  };
  return this;
};
GrammarDecl$1.prototype.withSuperGrammar = function(superGrammar) {
  if (this.superGrammar) {
    throw new Error("the super grammar of a GrammarDecl cannot be set more than once");
  }
  this.superGrammar = superGrammar;
  this.rules = Object.create(superGrammar.rules);
  if (!superGrammar.isBuiltIn()) {
    this.defaultStartRule = superGrammar.defaultStartRule;
  }
  return this;
};
GrammarDecl$1.prototype.withDefaultStartRule = function(ruleName) {
  this.defaultStartRule = ruleName;
  return this;
};
GrammarDecl$1.prototype.withSource = function(source) {
  this.source = new InputStream(source).interval(0, source.length);
  return this;
};
GrammarDecl$1.prototype.build = function() {
  const grammar2 = new Grammar$3(
    this.name,
    this.ensureSuperGrammar(),
    this.rules,
    this.defaultStartRule
  );
  const grammarErrors = [];
  let grammarHasInvalidApplications = false;
  Object.keys(grammar2.rules).forEach((ruleName) => {
    const { body } = grammar2.rules[ruleName];
    try {
      body.assertChoicesHaveUniformArity(ruleName);
    } catch (e) {
      grammarErrors.push(e);
    }
    try {
      body.assertAllApplicationsAreValid(ruleName, grammar2);
    } catch (e) {
      grammarErrors.push(e);
      grammarHasInvalidApplications = true;
    }
  });
  if (!grammarHasInvalidApplications) {
    Object.keys(grammar2.rules).forEach((ruleName) => {
      const { body } = grammar2.rules[ruleName];
      try {
        body.assertIteratedExprsAreNotNullable(grammar2, []);
      } catch (e) {
        grammarErrors.push(e);
      }
    });
  }
  if (grammarErrors.length > 0) {
    errors$1.throwErrors(grammarErrors);
  }
  if (this.source) {
    grammar2.source = this.source;
  }
  return grammar2;
};
GrammarDecl$1.prototype.define = function(name2, formals, body, description2, source) {
  this.ensureSuperGrammar();
  if (this.superGrammar.rules[name2]) {
    throw errors$1.duplicateRuleDeclaration(name2, this.name, this.superGrammar.name, source);
  } else if (this.rules[name2]) {
    throw errors$1.duplicateRuleDeclaration(name2, this.name, this.name, source);
  }
  const duplicateParameterNames2 = common$1.getDuplicates(formals);
  if (duplicateParameterNames2.length > 0) {
    throw errors$1.duplicateParameterNames(name2, duplicateParameterNames2, source);
  }
  return this.install(name2, formals, body, description2, source);
};
GrammarDecl$1.prototype.override = function(name2, formals, body, descIgnored, source) {
  this.ensureSuperGrammarRuleForOverriding(name2, source);
  this.installOverriddenOrExtendedRule(name2, formals, body, source);
  return this;
};
GrammarDecl$1.prototype.extend = function(name2, formals, fragment, descIgnored, source) {
  const ruleInfo = this.ensureSuperGrammar().rules[name2];
  if (!ruleInfo) {
    throw errors$1.cannotExtendUndeclaredRule(name2, this.superGrammar.name, source);
  }
  const body = new pexprs$2.Extend(this.superGrammar, name2, fragment);
  body.source = fragment.source;
  this.installOverriddenOrExtendedRule(name2, formals, body, source);
  return this;
};
var GrammarDecl_1 = GrammarDecl$1;
const Grammar$2 = Grammar_1;
const GrammarDecl = GrammarDecl_1;
const pexprs$1 = pexprs$6;
function Builder$2() {
}
Builder$2.prototype = {
  currentDecl: null,
  currentRuleName: null,
  newGrammar(name2) {
    return new GrammarDecl(name2);
  },
  grammar(metaInfo, name2, superGrammar, defaultStartRule, rules) {
    const gDecl = new GrammarDecl(name2);
    if (superGrammar) {
      gDecl.withSuperGrammar(
        superGrammar instanceof Grammar$2 ? superGrammar : this.fromRecipe(superGrammar)
      );
    }
    if (defaultStartRule) {
      gDecl.withDefaultStartRule(defaultStartRule);
    }
    if (metaInfo && metaInfo.source) {
      gDecl.withSource(metaInfo.source);
    }
    this.currentDecl = gDecl;
    Object.keys(rules).forEach((ruleName) => {
      this.currentRuleName = ruleName;
      const ruleRecipe = rules[ruleName];
      const action = ruleRecipe[0];
      const metaInfo2 = ruleRecipe[1];
      const description2 = ruleRecipe[2];
      const formals = ruleRecipe[3];
      const body = this.fromRecipe(ruleRecipe[4]);
      let source;
      if (gDecl.source && metaInfo2 && metaInfo2.sourceInterval) {
        source = gDecl.source.subInterval(
          metaInfo2.sourceInterval[0],
          metaInfo2.sourceInterval[1] - metaInfo2.sourceInterval[0]
        );
      }
      gDecl[action](ruleName, formals, body, description2, source);
    });
    this.currentRuleName = this.currentDecl = null;
    return gDecl.build();
  },
  terminal(x) {
    return new pexprs$1.Terminal(x);
  },
  range(from, to) {
    return new pexprs$1.Range(from, to);
  },
  param(index) {
    return new pexprs$1.Param(index);
  },
  alt(...termArgs) {
    let terms = [];
    for (let arg of termArgs) {
      if (!(arg instanceof pexprs$1.PExpr)) {
        arg = this.fromRecipe(arg);
      }
      if (arg instanceof pexprs$1.Alt) {
        terms = terms.concat(arg.terms);
      } else {
        terms.push(arg);
      }
    }
    return terms.length === 1 ? terms[0] : new pexprs$1.Alt(terms);
  },
  seq(...factorArgs) {
    let factors = [];
    for (let arg of factorArgs) {
      if (!(arg instanceof pexprs$1.PExpr)) {
        arg = this.fromRecipe(arg);
      }
      if (arg instanceof pexprs$1.Seq) {
        factors = factors.concat(arg.factors);
      } else {
        factors.push(arg);
      }
    }
    return factors.length === 1 ? factors[0] : new pexprs$1.Seq(factors);
  },
  star(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Star(expr);
  },
  plus(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Plus(expr);
  },
  opt(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Opt(expr);
  },
  not(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Not(expr);
  },
  la(expr) {
    return this.lookahead(expr);
  },
  lookahead(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Lookahead(expr);
  },
  lex(expr) {
    if (!(expr instanceof pexprs$1.PExpr)) {
      expr = this.fromRecipe(expr);
    }
    return new pexprs$1.Lex(expr);
  },
  app(ruleName, optParams) {
    if (optParams && optParams.length > 0) {
      optParams = optParams.map(function(param) {
        return param instanceof pexprs$1.PExpr ? param : this.fromRecipe(param);
      }, this);
    }
    return new pexprs$1.Apply(ruleName, optParams);
  },
  // Note that unlike other methods in this class, this method cannot be used as a
  // convenience constructor. It only works with recipes, because it relies on
  // `this.currentDecl` and `this.currentRuleName` being set.
  splice(beforeTerms, afterTerms) {
    return new pexprs$1.Splice(
      this.currentDecl.superGrammar,
      this.currentRuleName,
      beforeTerms.map((term) => this.fromRecipe(term)),
      afterTerms.map((term) => this.fromRecipe(term))
    );
  },
  fromRecipe(recipe) {
    const args = recipe[0] === "grammar" ? recipe.slice(1) : recipe.slice(2);
    const result = this[recipe[0]](...args);
    const metaInfo = recipe[1];
    if (metaInfo) {
      if (metaInfo.sourceInterval && this.currentDecl) {
        result.withSource(this.currentDecl.sourceInterval(...metaInfo.sourceInterval));
      }
    }
    return result;
  }
};
var Builder_1 = Builder$2;
var version$2 = "16.6.0";
var require$$0$1 = {
  version: version$2};
var version$1 = typeof __GLOBAL_OHM_VERSION__ === "string" ? __GLOBAL_OHM_VERSION__ : require$$0$1.version;
var makeRecipe$5 = {};
const Builder$1 = Builder_1;
function makeRecipe$4(recipe) {
  if (typeof recipe === "function") {
    return recipe.call(new Builder$1());
  } else {
    if (typeof recipe === "string") {
      recipe = JSON.parse(recipe);
    }
    return new Builder$1().fromRecipe(recipe);
  }
}
makeRecipe$5.makeRecipe = makeRecipe$4;
var { makeRecipe: makeRecipe$3 } = makeRecipe$5;
var builtInRules = makeRecipe$3(["grammar", { "source": 'BuiltInRules {\n\n  alnum  (an alpha-numeric character)\n    = letter\n    | digit\n\n  letter  (a letter)\n    = lower\n    | upper\n    | unicodeLtmo\n\n  digit  (a digit)\n    = "0".."9"\n\n  hexDigit  (a hexadecimal digit)\n    = digit\n    | "a".."f"\n    | "A".."F"\n\n  ListOf<elem, sep>\n    = NonemptyListOf<elem, sep>\n    | EmptyListOf<elem, sep>\n\n  NonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  EmptyListOf<elem, sep>\n    = /* nothing */\n\n  listOf<elem, sep>\n    = nonemptyListOf<elem, sep>\n    | emptyListOf<elem, sep>\n\n  nonemptyListOf<elem, sep>\n    = elem (sep elem)*\n\n  emptyListOf<elem, sep>\n    = /* nothing */\n\n  // Allows a syntactic rule application within a lexical context.\n  applySyntactic<app> = app\n}' }, "BuiltInRules", null, null, { "alnum": ["define", { "sourceInterval": [18, 78] }, "an alpha-numeric character", [], ["alt", { "sourceInterval": [60, 78] }, ["app", { "sourceInterval": [60, 66] }, "letter", []], ["app", { "sourceInterval": [73, 78] }, "digit", []]]], "letter": ["define", { "sourceInterval": [82, 142] }, "a letter", [], ["alt", { "sourceInterval": [107, 142] }, ["app", { "sourceInterval": [107, 112] }, "lower", []], ["app", { "sourceInterval": [119, 124] }, "upper", []], ["app", { "sourceInterval": [131, 142] }, "unicodeLtmo", []]]], "digit": ["define", { "sourceInterval": [146, 177] }, "a digit", [], ["range", { "sourceInterval": [169, 177] }, "0", "9"]], "hexDigit": ["define", { "sourceInterval": [181, 254] }, "a hexadecimal digit", [], ["alt", { "sourceInterval": [219, 254] }, ["app", { "sourceInterval": [219, 224] }, "digit", []], ["range", { "sourceInterval": [231, 239] }, "a", "f"], ["range", { "sourceInterval": [246, 254] }, "A", "F"]]], "ListOf": ["define", { "sourceInterval": [258, 336] }, null, ["elem", "sep"], ["alt", { "sourceInterval": [282, 336] }, ["app", { "sourceInterval": [282, 307] }, "NonemptyListOf", [["param", { "sourceInterval": [297, 301] }, 0], ["param", { "sourceInterval": [303, 306] }, 1]]], ["app", { "sourceInterval": [314, 336] }, "EmptyListOf", [["param", { "sourceInterval": [326, 330] }, 0], ["param", { "sourceInterval": [332, 335] }, 1]]]]], "NonemptyListOf": ["define", { "sourceInterval": [340, 388] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [372, 388] }, ["param", { "sourceInterval": [372, 376] }, 0], ["star", { "sourceInterval": [377, 388] }, ["seq", { "sourceInterval": [378, 386] }, ["param", { "sourceInterval": [378, 381] }, 1], ["param", { "sourceInterval": [382, 386] }, 0]]]]], "EmptyListOf": ["define", { "sourceInterval": [392, 434] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [438, 438] }]], "listOf": ["define", { "sourceInterval": [438, 516] }, null, ["elem", "sep"], ["alt", { "sourceInterval": [462, 516] }, ["app", { "sourceInterval": [462, 487] }, "nonemptyListOf", [["param", { "sourceInterval": [477, 481] }, 0], ["param", { "sourceInterval": [483, 486] }, 1]]], ["app", { "sourceInterval": [494, 516] }, "emptyListOf", [["param", { "sourceInterval": [506, 510] }, 0], ["param", { "sourceInterval": [512, 515] }, 1]]]]], "nonemptyListOf": ["define", { "sourceInterval": [520, 568] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [552, 568] }, ["param", { "sourceInterval": [552, 556] }, 0], ["star", { "sourceInterval": [557, 568] }, ["seq", { "sourceInterval": [558, 566] }, ["param", { "sourceInterval": [558, 561] }, 1], ["param", { "sourceInterval": [562, 566] }, 0]]]]], "emptyListOf": ["define", { "sourceInterval": [572, 682] }, null, ["elem", "sep"], ["seq", { "sourceInterval": [685, 685] }]], "applySyntactic": ["define", { "sourceInterval": [685, 710] }, null, ["app"], ["param", { "sourceInterval": [707, 710] }, 0]] }]);
const Grammar$1 = Grammar_1;
Grammar$1.BuiltInRules = builtInRules;
var { makeRecipe: makeRecipe$2 } = makeRecipe$5;
var operationsAndAttributes = makeRecipe$2(["grammar", { "source": 'OperationsAndAttributes {\n\n  AttributeSignature =\n    name\n\n  OperationSignature =\n    name Formals?\n\n  Formals\n    = "(" ListOf<name, ","> ")"\n\n  name  (a name)\n    = nameFirst nameRest*\n\n  nameFirst\n    = "_"\n    | letter\n\n  nameRest\n    = "_"\n    | alnum\n\n}' }, "OperationsAndAttributes", null, "AttributeSignature", { "AttributeSignature": ["define", { "sourceInterval": [29, 58] }, null, [], ["app", { "sourceInterval": [54, 58] }, "name", []]], "OperationSignature": ["define", { "sourceInterval": [62, 100] }, null, [], ["seq", { "sourceInterval": [87, 100] }, ["app", { "sourceInterval": [87, 91] }, "name", []], ["opt", { "sourceInterval": [92, 100] }, ["app", { "sourceInterval": [92, 99] }, "Formals", []]]]], "Formals": ["define", { "sourceInterval": [104, 143] }, null, [], ["seq", { "sourceInterval": [118, 143] }, ["terminal", { "sourceInterval": [118, 121] }, "("], ["app", { "sourceInterval": [122, 139] }, "ListOf", [["app", { "sourceInterval": [129, 133] }, "name", []], ["terminal", { "sourceInterval": [135, 138] }, ","]]], ["terminal", { "sourceInterval": [140, 143] }, ")"]]], "name": ["define", { "sourceInterval": [147, 187] }, "a name", [], ["seq", { "sourceInterval": [168, 187] }, ["app", { "sourceInterval": [168, 177] }, "nameFirst", []], ["star", { "sourceInterval": [178, 187] }, ["app", { "sourceInterval": [178, 186] }, "nameRest", []]]]], "nameFirst": ["define", { "sourceInterval": [191, 223] }, null, [], ["alt", { "sourceInterval": [207, 223] }, ["terminal", { "sourceInterval": [207, 210] }, "_"], ["app", { "sourceInterval": [217, 223] }, "letter", []]]], "nameRest": ["define", { "sourceInterval": [227, 257] }, null, [], ["alt", { "sourceInterval": [242, 257] }, ["terminal", { "sourceInterval": [242, 245] }, "_"], ["app", { "sourceInterval": [252, 257] }, "alnum", []]]] }]);
const Semantics = Semantics_1;
const util$1 = util$7;
util$1.awaitBuiltInRules((builtInRules2) => {
  const operationsAndAttributesGrammar = operationsAndAttributes;
  initBuiltInSemantics(builtInRules2);
  initPrototypeParser(operationsAndAttributesGrammar);
});
function initBuiltInSemantics(builtInRules2) {
  const actions = {
    empty() {
      return this.iteration();
    },
    nonEmpty(first, _, rest) {
      return this.iteration([first].concat(rest.children));
    }
  };
  Semantics.BuiltInSemantics = Semantics.createSemantics(builtInRules2, null).addOperation(
    "asIteration",
    {
      emptyListOf: actions.empty,
      nonemptyListOf: actions.nonEmpty,
      EmptyListOf: actions.empty,
      NonemptyListOf: actions.nonEmpty
    }
  );
}
function initPrototypeParser(grammar2) {
  Semantics.prototypeGrammarSemantics = grammar2.createSemantics().addOperation("parse", {
    AttributeSignature(name2) {
      return {
        name: name2.parse(),
        formals: []
      };
    },
    OperationSignature(name2, optFormals) {
      return {
        name: name2.parse(),
        formals: optFormals.children.map((c) => c.parse())[0] || []
      };
    },
    Formals(oparen, fs, cparen) {
      return fs.asIteration().children.map((c) => c.parse());
    },
    name(first, rest) {
      return this.sourceString;
    }
  });
  Semantics.prototypeGrammar = grammar2;
}
var { makeRecipe: makeRecipe$1 } = makeRecipe$5;
var ohmGrammar$1 = makeRecipe$1(["grammar", { "source": `Ohm {

  Grammars
    = Grammar*

  Grammar
    = ident SuperGrammar? "{" Rule* "}"

  SuperGrammar
    = "<:" ident

  Rule
    = ident Formals? ruleDescr? "="  RuleBody  -- define
    | ident Formals?            ":=" OverrideRuleBody  -- override
    | ident Formals?            "+=" RuleBody  -- extend

  RuleBody
    = "|"? NonemptyListOf<TopLevelTerm, "|">

  TopLevelTerm
    = Seq caseName  -- inline
    | Seq

  OverrideRuleBody
    = "|"? NonemptyListOf<OverrideTopLevelTerm, "|">

  OverrideTopLevelTerm
    = "..."  -- superSplice
    | TopLevelTerm

  Formals
    = "<" ListOf<ident, ","> ">"

  Params
    = "<" ListOf<Seq, ","> ">"

  Alt
    = NonemptyListOf<Seq, "|">

  Seq
    = Iter*

  Iter
    = Pred "*"  -- star
    | Pred "+"  -- plus
    | Pred "?"  -- opt
    | Pred

  Pred
    = "~" Lex  -- not
    | "&" Lex  -- lookahead
    | Lex

  Lex
    = "#" Base  -- lex
    | Base

  Base
    = ident Params? ~(ruleDescr? "=" | ":=" | "+=")  -- application
    | oneCharTerminal ".." oneCharTerminal           -- range
    | terminal                                       -- terminal
    | "(" Alt ")"                                    -- paren

  ruleDescr  (a rule description)
    = "(" ruleDescrText ")"

  ruleDescrText
    = (~")" any)*

  caseName
    = "--" (~"\\n" space)* name (~"\\n" space)* ("\\n" | &"}")

  name  (a name)
    = nameFirst nameRest*

  nameFirst
    = "_"
    | letter

  nameRest
    = "_"
    | alnum

  ident  (an identifier)
    = name

  terminal
    = "\\"" terminalChar* "\\""

  oneCharTerminal
    = "\\"" terminalChar "\\""

  terminalChar
    = escapeChar
      | ~"\\\\" ~"\\"" ~"\\n" "\\u{0}".."\\u{10FFFF}"

  escapeChar  (an escape sequence)
    = "\\\\\\\\"                                     -- backslash
    | "\\\\\\""                                     -- doubleQuote
    | "\\\\\\'"                                     -- singleQuote
    | "\\\\b"                                      -- backspace
    | "\\\\n"                                      -- lineFeed
    | "\\\\r"                                      -- carriageReturn
    | "\\\\t"                                      -- tab
    | "\\\\u{" hexDigit hexDigit? hexDigit?
             hexDigit? hexDigit? hexDigit? "}"   -- unicodeCodePoint
    | "\\\\u" hexDigit hexDigit hexDigit hexDigit  -- unicodeEscape
    | "\\\\x" hexDigit hexDigit                    -- hexEscape

  space
   += comment

  comment
    = "//" (~"\\n" any)* &("\\n" | end)  -- singleLine
    | "/*" (~"*/" any)* "*/"  -- multiLine

  tokens = token*

  token = caseName | comment | ident | operator | punctuation | terminal | any

  operator = "<:" | "=" | ":=" | "+=" | "*" | "+" | "?" | "~" | "&"

  punctuation = "<" | ">" | "," | "--"
}` }, "Ohm", null, "Grammars", { "Grammars": ["define", { "sourceInterval": [9, 32] }, null, [], ["star", { "sourceInterval": [24, 32] }, ["app", { "sourceInterval": [24, 31] }, "Grammar", []]]], "Grammar": ["define", { "sourceInterval": [36, 83] }, null, [], ["seq", { "sourceInterval": [50, 83] }, ["app", { "sourceInterval": [50, 55] }, "ident", []], ["opt", { "sourceInterval": [56, 69] }, ["app", { "sourceInterval": [56, 68] }, "SuperGrammar", []]], ["terminal", { "sourceInterval": [70, 73] }, "{"], ["star", { "sourceInterval": [74, 79] }, ["app", { "sourceInterval": [74, 78] }, "Rule", []]], ["terminal", { "sourceInterval": [80, 83] }, "}"]]], "SuperGrammar": ["define", { "sourceInterval": [87, 116] }, null, [], ["seq", { "sourceInterval": [106, 116] }, ["terminal", { "sourceInterval": [106, 110] }, "<:"], ["app", { "sourceInterval": [111, 116] }, "ident", []]]], "Rule_define": ["define", { "sourceInterval": [131, 181] }, null, [], ["seq", { "sourceInterval": [131, 170] }, ["app", { "sourceInterval": [131, 136] }, "ident", []], ["opt", { "sourceInterval": [137, 145] }, ["app", { "sourceInterval": [137, 144] }, "Formals", []]], ["opt", { "sourceInterval": [146, 156] }, ["app", { "sourceInterval": [146, 155] }, "ruleDescr", []]], ["terminal", { "sourceInterval": [157, 160] }, "="], ["app", { "sourceInterval": [162, 170] }, "RuleBody", []]]], "Rule_override": ["define", { "sourceInterval": [188, 248] }, null, [], ["seq", { "sourceInterval": [188, 235] }, ["app", { "sourceInterval": [188, 193] }, "ident", []], ["opt", { "sourceInterval": [194, 202] }, ["app", { "sourceInterval": [194, 201] }, "Formals", []]], ["terminal", { "sourceInterval": [214, 218] }, ":="], ["app", { "sourceInterval": [219, 235] }, "OverrideRuleBody", []]]], "Rule_extend": ["define", { "sourceInterval": [255, 305] }, null, [], ["seq", { "sourceInterval": [255, 294] }, ["app", { "sourceInterval": [255, 260] }, "ident", []], ["opt", { "sourceInterval": [261, 269] }, ["app", { "sourceInterval": [261, 268] }, "Formals", []]], ["terminal", { "sourceInterval": [281, 285] }, "+="], ["app", { "sourceInterval": [286, 294] }, "RuleBody", []]]], "Rule": ["define", { "sourceInterval": [120, 305] }, null, [], ["alt", { "sourceInterval": [131, 305] }, ["app", { "sourceInterval": [131, 170] }, "Rule_define", []], ["app", { "sourceInterval": [188, 235] }, "Rule_override", []], ["app", { "sourceInterval": [255, 294] }, "Rule_extend", []]]], "RuleBody": ["define", { "sourceInterval": [309, 362] }, null, [], ["seq", { "sourceInterval": [324, 362] }, ["opt", { "sourceInterval": [324, 328] }, ["terminal", { "sourceInterval": [324, 327] }, "|"]], ["app", { "sourceInterval": [329, 362] }, "NonemptyListOf", [["app", { "sourceInterval": [344, 356] }, "TopLevelTerm", []], ["terminal", { "sourceInterval": [358, 361] }, "|"]]]]], "TopLevelTerm_inline": ["define", { "sourceInterval": [385, 408] }, null, [], ["seq", { "sourceInterval": [385, 397] }, ["app", { "sourceInterval": [385, 388] }, "Seq", []], ["app", { "sourceInterval": [389, 397] }, "caseName", []]]], "TopLevelTerm": ["define", { "sourceInterval": [366, 418] }, null, [], ["alt", { "sourceInterval": [385, 418] }, ["app", { "sourceInterval": [385, 397] }, "TopLevelTerm_inline", []], ["app", { "sourceInterval": [415, 418] }, "Seq", []]]], "OverrideRuleBody": ["define", { "sourceInterval": [422, 491] }, null, [], ["seq", { "sourceInterval": [445, 491] }, ["opt", { "sourceInterval": [445, 449] }, ["terminal", { "sourceInterval": [445, 448] }, "|"]], ["app", { "sourceInterval": [450, 491] }, "NonemptyListOf", [["app", { "sourceInterval": [465, 485] }, "OverrideTopLevelTerm", []], ["terminal", { "sourceInterval": [487, 490] }, "|"]]]]], "OverrideTopLevelTerm_superSplice": ["define", { "sourceInterval": [522, 543] }, null, [], ["terminal", { "sourceInterval": [522, 527] }, "..."]], "OverrideTopLevelTerm": ["define", { "sourceInterval": [495, 562] }, null, [], ["alt", { "sourceInterval": [522, 562] }, ["app", { "sourceInterval": [522, 527] }, "OverrideTopLevelTerm_superSplice", []], ["app", { "sourceInterval": [550, 562] }, "TopLevelTerm", []]]], "Formals": ["define", { "sourceInterval": [566, 606] }, null, [], ["seq", { "sourceInterval": [580, 606] }, ["terminal", { "sourceInterval": [580, 583] }, "<"], ["app", { "sourceInterval": [584, 602] }, "ListOf", [["app", { "sourceInterval": [591, 596] }, "ident", []], ["terminal", { "sourceInterval": [598, 601] }, ","]]], ["terminal", { "sourceInterval": [603, 606] }, ">"]]], "Params": ["define", { "sourceInterval": [610, 647] }, null, [], ["seq", { "sourceInterval": [623, 647] }, ["terminal", { "sourceInterval": [623, 626] }, "<"], ["app", { "sourceInterval": [627, 643] }, "ListOf", [["app", { "sourceInterval": [634, 637] }, "Seq", []], ["terminal", { "sourceInterval": [639, 642] }, ","]]], ["terminal", { "sourceInterval": [644, 647] }, ">"]]], "Alt": ["define", { "sourceInterval": [651, 685] }, null, [], ["app", { "sourceInterval": [661, 685] }, "NonemptyListOf", [["app", { "sourceInterval": [676, 679] }, "Seq", []], ["terminal", { "sourceInterval": [681, 684] }, "|"]]]], "Seq": ["define", { "sourceInterval": [689, 704] }, null, [], ["star", { "sourceInterval": [699, 704] }, ["app", { "sourceInterval": [699, 703] }, "Iter", []]]], "Iter_star": ["define", { "sourceInterval": [719, 736] }, null, [], ["seq", { "sourceInterval": [719, 727] }, ["app", { "sourceInterval": [719, 723] }, "Pred", []], ["terminal", { "sourceInterval": [724, 727] }, "*"]]], "Iter_plus": ["define", { "sourceInterval": [743, 760] }, null, [], ["seq", { "sourceInterval": [743, 751] }, ["app", { "sourceInterval": [743, 747] }, "Pred", []], ["terminal", { "sourceInterval": [748, 751] }, "+"]]], "Iter_opt": ["define", { "sourceInterval": [767, 783] }, null, [], ["seq", { "sourceInterval": [767, 775] }, ["app", { "sourceInterval": [767, 771] }, "Pred", []], ["terminal", { "sourceInterval": [772, 775] }, "?"]]], "Iter": ["define", { "sourceInterval": [708, 794] }, null, [], ["alt", { "sourceInterval": [719, 794] }, ["app", { "sourceInterval": [719, 727] }, "Iter_star", []], ["app", { "sourceInterval": [743, 751] }, "Iter_plus", []], ["app", { "sourceInterval": [767, 775] }, "Iter_opt", []], ["app", { "sourceInterval": [790, 794] }, "Pred", []]]], "Pred_not": ["define", { "sourceInterval": [809, 824] }, null, [], ["seq", { "sourceInterval": [809, 816] }, ["terminal", { "sourceInterval": [809, 812] }, "~"], ["app", { "sourceInterval": [813, 816] }, "Lex", []]]], "Pred_lookahead": ["define", { "sourceInterval": [831, 852] }, null, [], ["seq", { "sourceInterval": [831, 838] }, ["terminal", { "sourceInterval": [831, 834] }, "&"], ["app", { "sourceInterval": [835, 838] }, "Lex", []]]], "Pred": ["define", { "sourceInterval": [798, 862] }, null, [], ["alt", { "sourceInterval": [809, 862] }, ["app", { "sourceInterval": [809, 816] }, "Pred_not", []], ["app", { "sourceInterval": [831, 838] }, "Pred_lookahead", []], ["app", { "sourceInterval": [859, 862] }, "Lex", []]]], "Lex_lex": ["define", { "sourceInterval": [876, 892] }, null, [], ["seq", { "sourceInterval": [876, 884] }, ["terminal", { "sourceInterval": [876, 879] }, "#"], ["app", { "sourceInterval": [880, 884] }, "Base", []]]], "Lex": ["define", { "sourceInterval": [866, 903] }, null, [], ["alt", { "sourceInterval": [876, 903] }, ["app", { "sourceInterval": [876, 884] }, "Lex_lex", []], ["app", { "sourceInterval": [899, 903] }, "Base", []]]], "Base_application": ["define", { "sourceInterval": [918, 979] }, null, [], ["seq", { "sourceInterval": [918, 963] }, ["app", { "sourceInterval": [918, 923] }, "ident", []], ["opt", { "sourceInterval": [924, 931] }, ["app", { "sourceInterval": [924, 930] }, "Params", []]], ["not", { "sourceInterval": [932, 963] }, ["alt", { "sourceInterval": [934, 962] }, ["seq", { "sourceInterval": [934, 948] }, ["opt", { "sourceInterval": [934, 944] }, ["app", { "sourceInterval": [934, 943] }, "ruleDescr", []]], ["terminal", { "sourceInterval": [945, 948] }, "="]], ["terminal", { "sourceInterval": [951, 955] }, ":="], ["terminal", { "sourceInterval": [958, 962] }, "+="]]]]], "Base_range": ["define", { "sourceInterval": [986, 1041] }, null, [], ["seq", { "sourceInterval": [986, 1022] }, ["app", { "sourceInterval": [986, 1001] }, "oneCharTerminal", []], ["terminal", { "sourceInterval": [1002, 1006] }, ".."], ["app", { "sourceInterval": [1007, 1022] }, "oneCharTerminal", []]]], "Base_terminal": ["define", { "sourceInterval": [1048, 1106] }, null, [], ["app", { "sourceInterval": [1048, 1056] }, "terminal", []]], "Base_paren": ["define", { "sourceInterval": [1113, 1168] }, null, [], ["seq", { "sourceInterval": [1113, 1124] }, ["terminal", { "sourceInterval": [1113, 1116] }, "("], ["app", { "sourceInterval": [1117, 1120] }, "Alt", []], ["terminal", { "sourceInterval": [1121, 1124] }, ")"]]], "Base": ["define", { "sourceInterval": [907, 1168] }, null, [], ["alt", { "sourceInterval": [918, 1168] }, ["app", { "sourceInterval": [918, 963] }, "Base_application", []], ["app", { "sourceInterval": [986, 1022] }, "Base_range", []], ["app", { "sourceInterval": [1048, 1056] }, "Base_terminal", []], ["app", { "sourceInterval": [1113, 1124] }, "Base_paren", []]]], "ruleDescr": ["define", { "sourceInterval": [1172, 1231] }, "a rule description", [], ["seq", { "sourceInterval": [1210, 1231] }, ["terminal", { "sourceInterval": [1210, 1213] }, "("], ["app", { "sourceInterval": [1214, 1227] }, "ruleDescrText", []], ["terminal", { "sourceInterval": [1228, 1231] }, ")"]]], "ruleDescrText": ["define", { "sourceInterval": [1235, 1266] }, null, [], ["star", { "sourceInterval": [1255, 1266] }, ["seq", { "sourceInterval": [1256, 1264] }, ["not", { "sourceInterval": [1256, 1260] }, ["terminal", { "sourceInterval": [1257, 1260] }, ")"]], ["app", { "sourceInterval": [1261, 1264] }, "any", []]]]], "caseName": ["define", { "sourceInterval": [1270, 1338] }, null, [], ["seq", { "sourceInterval": [1285, 1338] }, ["terminal", { "sourceInterval": [1285, 1289] }, "--"], ["star", { "sourceInterval": [1290, 1304] }, ["seq", { "sourceInterval": [1291, 1302] }, ["not", { "sourceInterval": [1291, 1296] }, ["terminal", { "sourceInterval": [1292, 1296] }, "\n"]], ["app", { "sourceInterval": [1297, 1302] }, "space", []]]], ["app", { "sourceInterval": [1305, 1309] }, "name", []], ["star", { "sourceInterval": [1310, 1324] }, ["seq", { "sourceInterval": [1311, 1322] }, ["not", { "sourceInterval": [1311, 1316] }, ["terminal", { "sourceInterval": [1312, 1316] }, "\n"]], ["app", { "sourceInterval": [1317, 1322] }, "space", []]]], ["alt", { "sourceInterval": [1326, 1337] }, ["terminal", { "sourceInterval": [1326, 1330] }, "\n"], ["lookahead", { "sourceInterval": [1333, 1337] }, ["terminal", { "sourceInterval": [1334, 1337] }, "}"]]]]], "name": ["define", { "sourceInterval": [1342, 1382] }, "a name", [], ["seq", { "sourceInterval": [1363, 1382] }, ["app", { "sourceInterval": [1363, 1372] }, "nameFirst", []], ["star", { "sourceInterval": [1373, 1382] }, ["app", { "sourceInterval": [1373, 1381] }, "nameRest", []]]]], "nameFirst": ["define", { "sourceInterval": [1386, 1418] }, null, [], ["alt", { "sourceInterval": [1402, 1418] }, ["terminal", { "sourceInterval": [1402, 1405] }, "_"], ["app", { "sourceInterval": [1412, 1418] }, "letter", []]]], "nameRest": ["define", { "sourceInterval": [1422, 1452] }, null, [], ["alt", { "sourceInterval": [1437, 1452] }, ["terminal", { "sourceInterval": [1437, 1440] }, "_"], ["app", { "sourceInterval": [1447, 1452] }, "alnum", []]]], "ident": ["define", { "sourceInterval": [1456, 1489] }, "an identifier", [], ["app", { "sourceInterval": [1485, 1489] }, "name", []]], "terminal": ["define", { "sourceInterval": [1493, 1531] }, null, [], ["seq", { "sourceInterval": [1508, 1531] }, ["terminal", { "sourceInterval": [1508, 1512] }, '"'], ["star", { "sourceInterval": [1513, 1526] }, ["app", { "sourceInterval": [1513, 1525] }, "terminalChar", []]], ["terminal", { "sourceInterval": [1527, 1531] }, '"']]], "oneCharTerminal": ["define", { "sourceInterval": [1535, 1579] }, null, [], ["seq", { "sourceInterval": [1557, 1579] }, ["terminal", { "sourceInterval": [1557, 1561] }, '"'], ["app", { "sourceInterval": [1562, 1574] }, "terminalChar", []], ["terminal", { "sourceInterval": [1575, 1579] }, '"']]], "terminalChar": ["define", { "sourceInterval": [1583, 1660] }, null, [], ["alt", { "sourceInterval": [1602, 1660] }, ["app", { "sourceInterval": [1602, 1612] }, "escapeChar", []], ["seq", { "sourceInterval": [1621, 1660] }, ["not", { "sourceInterval": [1621, 1626] }, ["terminal", { "sourceInterval": [1622, 1626] }, "\\"]], ["not", { "sourceInterval": [1627, 1632] }, ["terminal", { "sourceInterval": [1628, 1632] }, '"']], ["not", { "sourceInterval": [1633, 1638] }, ["terminal", { "sourceInterval": [1634, 1638] }, "\n"]], ["range", { "sourceInterval": [1639, 1660] }, "\0", ""]]]], "escapeChar_backslash": ["define", { "sourceInterval": [1703, 1758] }, null, [], ["terminal", { "sourceInterval": [1703, 1709] }, "\\\\"]], "escapeChar_doubleQuote": ["define", { "sourceInterval": [1765, 1822] }, null, [], ["terminal", { "sourceInterval": [1765, 1771] }, '\\"']], "escapeChar_singleQuote": ["define", { "sourceInterval": [1829, 1886] }, null, [], ["terminal", { "sourceInterval": [1829, 1835] }, "\\'"]], "escapeChar_backspace": ["define", { "sourceInterval": [1893, 1948] }, null, [], ["terminal", { "sourceInterval": [1893, 1898] }, "\\b"]], "escapeChar_lineFeed": ["define", { "sourceInterval": [1955, 2009] }, null, [], ["terminal", { "sourceInterval": [1955, 1960] }, "\\n"]], "escapeChar_carriageReturn": ["define", { "sourceInterval": [2016, 2076] }, null, [], ["terminal", { "sourceInterval": [2016, 2021] }, "\\r"]], "escapeChar_tab": ["define", { "sourceInterval": [2083, 2132] }, null, [], ["terminal", { "sourceInterval": [2083, 2088] }, "\\t"]], "escapeChar_unicodeCodePoint": ["define", { "sourceInterval": [2139, 2243] }, null, [], ["seq", { "sourceInterval": [2139, 2221] }, ["terminal", { "sourceInterval": [2139, 2145] }, "\\u{"], ["app", { "sourceInterval": [2146, 2154] }, "hexDigit", []], ["opt", { "sourceInterval": [2155, 2164] }, ["app", { "sourceInterval": [2155, 2163] }, "hexDigit", []]], ["opt", { "sourceInterval": [2165, 2174] }, ["app", { "sourceInterval": [2165, 2173] }, "hexDigit", []]], ["opt", { "sourceInterval": [2188, 2197] }, ["app", { "sourceInterval": [2188, 2196] }, "hexDigit", []]], ["opt", { "sourceInterval": [2198, 2207] }, ["app", { "sourceInterval": [2198, 2206] }, "hexDigit", []]], ["opt", { "sourceInterval": [2208, 2217] }, ["app", { "sourceInterval": [2208, 2216] }, "hexDigit", []]], ["terminal", { "sourceInterval": [2218, 2221] }, "}"]]], "escapeChar_unicodeEscape": ["define", { "sourceInterval": [2250, 2309] }, null, [], ["seq", { "sourceInterval": [2250, 2291] }, ["terminal", { "sourceInterval": [2250, 2255] }, "\\u"], ["app", { "sourceInterval": [2256, 2264] }, "hexDigit", []], ["app", { "sourceInterval": [2265, 2273] }, "hexDigit", []], ["app", { "sourceInterval": [2274, 2282] }, "hexDigit", []], ["app", { "sourceInterval": [2283, 2291] }, "hexDigit", []]]], "escapeChar_hexEscape": ["define", { "sourceInterval": [2316, 2371] }, null, [], ["seq", { "sourceInterval": [2316, 2339] }, ["terminal", { "sourceInterval": [2316, 2321] }, "\\x"], ["app", { "sourceInterval": [2322, 2330] }, "hexDigit", []], ["app", { "sourceInterval": [2331, 2339] }, "hexDigit", []]]], "escapeChar": ["define", { "sourceInterval": [1664, 2371] }, "an escape sequence", [], ["alt", { "sourceInterval": [1703, 2371] }, ["app", { "sourceInterval": [1703, 1709] }, "escapeChar_backslash", []], ["app", { "sourceInterval": [1765, 1771] }, "escapeChar_doubleQuote", []], ["app", { "sourceInterval": [1829, 1835] }, "escapeChar_singleQuote", []], ["app", { "sourceInterval": [1893, 1898] }, "escapeChar_backspace", []], ["app", { "sourceInterval": [1955, 1960] }, "escapeChar_lineFeed", []], ["app", { "sourceInterval": [2016, 2021] }, "escapeChar_carriageReturn", []], ["app", { "sourceInterval": [2083, 2088] }, "escapeChar_tab", []], ["app", { "sourceInterval": [2139, 2221] }, "escapeChar_unicodeCodePoint", []], ["app", { "sourceInterval": [2250, 2291] }, "escapeChar_unicodeEscape", []], ["app", { "sourceInterval": [2316, 2339] }, "escapeChar_hexEscape", []]]], "space": ["extend", { "sourceInterval": [2375, 2394] }, null, [], ["app", { "sourceInterval": [2387, 2394] }, "comment", []]], "comment_singleLine": ["define", { "sourceInterval": [2412, 2458] }, null, [], ["seq", { "sourceInterval": [2412, 2443] }, ["terminal", { "sourceInterval": [2412, 2416] }, "//"], ["star", { "sourceInterval": [2417, 2429] }, ["seq", { "sourceInterval": [2418, 2427] }, ["not", { "sourceInterval": [2418, 2423] }, ["terminal", { "sourceInterval": [2419, 2423] }, "\n"]], ["app", { "sourceInterval": [2424, 2427] }, "any", []]]], ["lookahead", { "sourceInterval": [2430, 2443] }, ["alt", { "sourceInterval": [2432, 2442] }, ["terminal", { "sourceInterval": [2432, 2436] }, "\n"], ["app", { "sourceInterval": [2439, 2442] }, "end", []]]]]], "comment_multiLine": ["define", { "sourceInterval": [2465, 2501] }, null, [], ["seq", { "sourceInterval": [2465, 2487] }, ["terminal", { "sourceInterval": [2465, 2469] }, "/*"], ["star", { "sourceInterval": [2470, 2482] }, ["seq", { "sourceInterval": [2471, 2480] }, ["not", { "sourceInterval": [2471, 2476] }, ["terminal", { "sourceInterval": [2472, 2476] }, "*/"]], ["app", { "sourceInterval": [2477, 2480] }, "any", []]]], ["terminal", { "sourceInterval": [2483, 2487] }, "*/"]]], "comment": ["define", { "sourceInterval": [2398, 2501] }, null, [], ["alt", { "sourceInterval": [2412, 2501] }, ["app", { "sourceInterval": [2412, 2443] }, "comment_singleLine", []], ["app", { "sourceInterval": [2465, 2487] }, "comment_multiLine", []]]], "tokens": ["define", { "sourceInterval": [2505, 2520] }, null, [], ["star", { "sourceInterval": [2514, 2520] }, ["app", { "sourceInterval": [2514, 2519] }, "token", []]]], "token": ["define", { "sourceInterval": [2524, 2600] }, null, [], ["alt", { "sourceInterval": [2532, 2600] }, ["app", { "sourceInterval": [2532, 2540] }, "caseName", []], ["app", { "sourceInterval": [2543, 2550] }, "comment", []], ["app", { "sourceInterval": [2553, 2558] }, "ident", []], ["app", { "sourceInterval": [2561, 2569] }, "operator", []], ["app", { "sourceInterval": [2572, 2583] }, "punctuation", []], ["app", { "sourceInterval": [2586, 2594] }, "terminal", []], ["app", { "sourceInterval": [2597, 2600] }, "any", []]]], "operator": ["define", { "sourceInterval": [2604, 2669] }, null, [], ["alt", { "sourceInterval": [2615, 2669] }, ["terminal", { "sourceInterval": [2615, 2619] }, "<:"], ["terminal", { "sourceInterval": [2622, 2625] }, "="], ["terminal", { "sourceInterval": [2628, 2632] }, ":="], ["terminal", { "sourceInterval": [2635, 2639] }, "+="], ["terminal", { "sourceInterval": [2642, 2645] }, "*"], ["terminal", { "sourceInterval": [2648, 2651] }, "+"], ["terminal", { "sourceInterval": [2654, 2657] }, "?"], ["terminal", { "sourceInterval": [2660, 2663] }, "~"], ["terminal", { "sourceInterval": [2666, 2669] }, "&"]]], "punctuation": ["define", { "sourceInterval": [2673, 2709] }, null, [], ["alt", { "sourceInterval": [2687, 2709] }, ["terminal", { "sourceInterval": [2687, 2690] }, "<"], ["terminal", { "sourceInterval": [2693, 2696] }, ">"], ["terminal", { "sourceInterval": [2699, 2702] }, ","], ["terminal", { "sourceInterval": [2705, 2709] }, "--"]]] }]);
const Builder = Builder_1;
const Grammar = Grammar_1;
const Namespace = Namespace_1;
const common = common$l;
const errors = errors$9;
const pexprs = pexprs$6;
const util = util$7;
const version = version$1;
const { makeRecipe } = makeRecipe$5;
let ohmGrammar;
const superSplicePlaceholder = Object.create(pexprs.PExpr.prototype);
const isBuffer = (obj) => !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
function buildGrammar(match, namespace, optOhmGrammarForTesting) {
  const builder = new Builder();
  let decl;
  let currentRuleName;
  let currentRuleFormals;
  let overriding = false;
  const metaGrammar = optOhmGrammarForTesting || ohmGrammar;
  const helpers = metaGrammar.createSemantics().addOperation("visit", {
    Grammars(grammarIter) {
      return grammarIter.children.map((c) => c.visit());
    },
    Grammar(id, s, _open, rules, _close) {
      const grammarName = id.visit();
      decl = builder.newGrammar(grammarName, namespace);
      s.child(0) && s.child(0).visit();
      rules.children.map((c) => c.visit());
      const g = decl.build();
      g.source = this.source.trimmed();
      if (grammarName in namespace) {
        throw errors.duplicateGrammarDeclaration(g, namespace);
      }
      namespace[grammarName] = g;
      return g;
    },
    SuperGrammar(_, n) {
      const superGrammarName = n.visit();
      if (superGrammarName === "null") {
        decl.withSuperGrammar(null);
      } else {
        if (!namespace || !(superGrammarName in namespace)) {
          throw errors.undeclaredGrammar(superGrammarName, namespace, n.source);
        }
        decl.withSuperGrammar(namespace[superGrammarName]);
      }
    },
    Rule_define(n, fs, d, _, b) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.children.map((c) => c.visit())[0] || [];
      if (!decl.defaultStartRule && decl.ensureSuperGrammar() !== Grammar.ProtoBuiltInRules) {
        decl.withDefaultStartRule(currentRuleName);
      }
      const body = b.visit();
      const description2 = d.children.map((c) => c.visit())[0];
      const source = this.source.trimmed();
      return decl.define(currentRuleName, currentRuleFormals, body, description2, source);
    },
    Rule_override(n, fs, _, b) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.children.map((c) => c.visit())[0] || [];
      const source = this.source.trimmed();
      decl.ensureSuperGrammarRuleForOverriding(currentRuleName, source);
      overriding = true;
      const body = b.visit();
      overriding = false;
      return decl.override(currentRuleName, currentRuleFormals, body, null, source);
    },
    Rule_extend(n, fs, _, b) {
      currentRuleName = n.visit();
      currentRuleFormals = fs.children.map((c) => c.visit())[0] || [];
      const body = b.visit();
      const source = this.source.trimmed();
      return decl.extend(currentRuleName, currentRuleFormals, body, null, source);
    },
    RuleBody(_, terms) {
      return builder.alt(...terms.visit()).withSource(this.source);
    },
    OverrideRuleBody(_, terms) {
      const args = terms.visit();
      const expansionPos = args.indexOf(superSplicePlaceholder);
      if (expansionPos >= 0) {
        const beforeTerms = args.slice(0, expansionPos);
        const afterTerms = args.slice(expansionPos + 1);
        afterTerms.forEach((t) => {
          if (t === superSplicePlaceholder) throw errors.multipleSuperSplices(t);
        });
        return new pexprs.Splice(
          decl.superGrammar,
          currentRuleName,
          beforeTerms,
          afterTerms
        ).withSource(this.source);
      } else {
        return builder.alt(...args).withSource(this.source);
      }
    },
    Formals(opointy, fs, cpointy) {
      return fs.visit();
    },
    Params(opointy, ps, cpointy) {
      return ps.visit();
    },
    Alt(seqs) {
      return builder.alt(...seqs.visit()).withSource(this.source);
    },
    TopLevelTerm_inline(b, n) {
      const inlineRuleName = currentRuleName + "_" + n.visit();
      const body = b.visit();
      const source = this.source.trimmed();
      const isNewRuleDeclaration = !(decl.superGrammar && decl.superGrammar.rules[inlineRuleName]);
      if (overriding && !isNewRuleDeclaration) {
        decl.override(inlineRuleName, currentRuleFormals, body, null, source);
      } else {
        decl.define(inlineRuleName, currentRuleFormals, body, null, source);
      }
      const params = currentRuleFormals.map((formal) => builder.app(formal));
      return builder.app(inlineRuleName, params).withSource(body.source);
    },
    OverrideTopLevelTerm_superSplice(_) {
      return superSplicePlaceholder;
    },
    Seq(expr) {
      return builder.seq(...expr.children.map((c) => c.visit())).withSource(this.source);
    },
    Iter_star(x, _) {
      return builder.star(x.visit()).withSource(this.source);
    },
    Iter_plus(x, _) {
      return builder.plus(x.visit()).withSource(this.source);
    },
    Iter_opt(x, _) {
      return builder.opt(x.visit()).withSource(this.source);
    },
    Pred_not(_, x) {
      return builder.not(x.visit()).withSource(this.source);
    },
    Pred_lookahead(_, x) {
      return builder.lookahead(x.visit()).withSource(this.source);
    },
    Lex_lex(_, x) {
      return builder.lex(x.visit()).withSource(this.source);
    },
    Base_application(rule, ps) {
      const params = ps.children.map((c) => c.visit())[0] || [];
      return builder.app(rule.visit(), params).withSource(this.source);
    },
    Base_range(from, _, to) {
      return builder.range(from.visit(), to.visit()).withSource(this.source);
    },
    Base_terminal(expr) {
      return builder.terminal(expr.visit()).withSource(this.source);
    },
    Base_paren(open, x, close) {
      return x.visit();
    },
    ruleDescr(open, t, close) {
      return t.visit();
    },
    ruleDescrText(_) {
      return this.sourceString.trim();
    },
    caseName(_, space1, n, space2, end2) {
      return n.visit();
    },
    name(first, rest) {
      return this.sourceString;
    },
    nameFirst(expr) {
    },
    nameRest(expr) {
    },
    terminal(open, cs, close) {
      return cs.children.map((c) => c.visit()).join("");
    },
    oneCharTerminal(open, c, close) {
      return c.visit();
    },
    escapeChar(c) {
      try {
        return common.unescapeCodePoint(this.sourceString);
      } catch (err) {
        if (err instanceof RangeError && err.message.startsWith("Invalid code point ")) {
          throw errors.invalidCodePoint(c);
        }
        throw err;
      }
    },
    NonemptyListOf(x, _, xs) {
      return [x.visit()].concat(xs.children.map((c) => c.visit()));
    },
    EmptyListOf() {
      return [];
    },
    _terminal() {
      return this.sourceString;
    }
  });
  return helpers(match).visit();
}
function compileAndLoad(source, namespace) {
  const m = ohmGrammar.match(source, "Grammars");
  if (m.failed()) {
    throw errors.grammarSyntaxError(m);
  }
  return buildGrammar(m, namespace);
}
function grammar(source, optNamespace) {
  const ns = grammars(source, optNamespace);
  const grammarNames = Object.keys(ns);
  if (grammarNames.length === 0) {
    throw new Error("Missing grammar definition");
  } else if (grammarNames.length > 1) {
    const secondGrammar = ns[grammarNames[1]];
    const interval = secondGrammar.source;
    throw new Error(
      util.getLineAndColumnMessage(interval.sourceString, interval.startIdx) + "Found more than one grammar definition -- use ohm.grammars() instead."
    );
  }
  return ns[grammarNames[0]];
}
function grammars(source, optNamespace) {
  const ns = Namespace.extend(Namespace.asNamespace(optNamespace));
  if (typeof source !== "string") {
    if (isBuffer(source)) {
      source = source.toString();
    } else {
      throw new TypeError(
        "Expected string as first argument, got " + common.unexpectedObjToString(source)
      );
    }
  }
  compileAndLoad(source, ns);
  return ns;
}
function grammarFromScriptElement(optNode) {
  throw new Error(
    "grammarFromScriptElement was removed in Ohm v16.0. See https://ohmjs.org/d/gfs for more info."
  );
}
function grammarsFromScriptElements(optNodeOrNodeList) {
  throw new Error(
    "grammarsFromScriptElements was removed in Ohm v16.0. See https://ohmjs.org/d/gfs for more info."
  );
}
main$1.exports = {
  createNamespace: Namespace.createNamespace,
  grammar,
  grammars,
  grammarFromScriptElement,
  grammarsFromScriptElements,
  makeRecipe,
  ohmGrammar: null,
  // Initialized below, after Grammar.BuiltInRules.
  pexprs,
  util,
  version
};
main$1.exports._buildGrammar = buildGrammar;
util.announceBuiltInRules(Grammar.BuiltInRules);
main$1.exports.ohmGrammar = ohmGrammar = ohmGrammar$1;
Grammar.initApplicationParser(ohmGrammar, buildGrammar);
var ohm = main$1.exports;
const { assert } = common$l;
function getProp(name2, thing, fn) {
  return fn(thing[name2]);
}
function mapProp(name2, thing, fn) {
  return thing[name2].map(fn);
}
function getPropWalkFn(descriptor) {
  const parts = descriptor.split(/ ?\[\]/);
  if (parts.length === 2) {
    return mapProp.bind(null, parts[0]);
  }
  return getProp.bind(null, descriptor);
}
function getProps(walkFns, thing, fn) {
  return walkFns.map((walkFn) => walkFn(thing, fn));
}
function getWalkFn(shape) {
  if (typeof shape === "string") {
    return getProps.bind(null, [getPropWalkFn(shape)]);
  } else if (Array.isArray(shape)) {
    return getProps.bind(null, shape.map(getPropWalkFn));
  } else {
    assert(typeof shape === "function", "Expected a string, Array, or function");
    assert(shape.length === 2, "Expected a function of arity 2, got " + shape.length);
    return shape;
  }
}
function isRestrictedIdentifier(str) {
  return /^[a-zA-Z_][0-9a-zA-Z_]*$/.test(str);
}
function trim(s) {
  return s.trim();
}
function parseSignature(sig) {
  const parts = sig.split(/[()]/).map(trim);
  if (parts.length === 3 && parts[2] === "") {
    const name2 = parts[0];
    let params = [];
    if (parts[1].length > 0) {
      params = parts[1].split(",").map(trim);
    }
    if (isRestrictedIdentifier(name2) && params.every(isRestrictedIdentifier)) {
      return { name: name2, formals: params };
    }
  }
  throw new Error("Invalid operation signature: " + sig);
}
function VisitorFamily(config) {
  this._shapes = config.shapes;
  this._getTag = config.getTag;
  this.Adapter = function(thing, family) {
    this._adaptee = thing;
    this._family = family;
  };
  this.Adapter.prototype.valueOf = function() {
    throw new Error("heeey!");
  };
  this.operations = {};
  this._arities = /* @__PURE__ */ Object.create(null);
  this._getChildren = /* @__PURE__ */ Object.create(null);
  Object.keys(this._shapes).forEach((k) => {
    const shape = this._shapes[k];
    this._getChildren[k] = getWalkFn(shape);
    if (typeof shape !== "function") {
      this._arities[k] = Array.isArray(shape) ? shape.length : 1;
    }
  });
  this._wrap = (thing) => new this.Adapter(thing, this);
}
VisitorFamily.prototype.wrap = function(thing) {
  return this._wrap(thing);
};
VisitorFamily.prototype._checkActionDict = function(dict) {
  Object.keys(dict).forEach((k) => {
    assert(k in this._getChildren, "Unrecognized action name '" + k + "'");
    const action = dict[k];
    assert(typeof action === "function", "Key '" + k + "': expected function, got " + action);
    if (k in this._arities) {
      const expected = this._arities[k];
      const actual = dict[k].length;
      assert(
        actual === expected,
        "Action '" + k + "' has the wrong arity: expected " + expected + ", got " + actual
      );
    }
  });
};
VisitorFamily.prototype.addOperation = function(signature, actions) {
  const sig = parseSignature(signature);
  const { name: name2 } = sig;
  this._checkActionDict(actions);
  this.operations[name2] = {
    name: name2,
    formals: sig.formals,
    actions
  };
  const family = this;
  this.Adapter.prototype[name2] = function(...args) {
    const tag = family._getTag(this._adaptee);
    assert(tag in family._getChildren, "getTag returned unrecognized tag '" + tag + "'");
    assert(tag in actions, "No action for '" + tag + "' in operation '" + name2 + "'");
    const argsObj = /* @__PURE__ */ Object.create(null);
    for (const [i, val] of Object.entries(args)) {
      argsObj[sig.formals[i]] = val;
    }
    const oldArgs = this.args;
    this.args = argsObj;
    const ans = actions[tag].apply(
      this,
      family._getChildren[tag](this._adaptee, family._wrap)
    );
    this.args = oldArgs;
    return ans;
  };
  return this;
};
var VisitorFamily_1 = VisitorFamily;
const defaultOperation = {
  _terminal() {
    return this.sourceString;
  },
  _nonterminal(...children) {
    const { ctorName } = this._node;
    const { mapping } = this.args;
    if (!Object.prototype.hasOwnProperty.call(mapping, ctorName)) {
      if (this.isLexical()) {
        return this.sourceString;
      }
      const realChildren = children.filter((child) => !child.isTerminal());
      if (realChildren.length === 1) {
        return realChildren[0].toAST(mapping);
      }
    }
    if (typeof mapping[ctorName] === "number") {
      return children[mapping[ctorName]].toAST(mapping);
    }
    const propMap = mapping[ctorName] || children;
    const node = {
      type: ctorName
    };
    for (const prop in propMap) {
      const mappedProp = mapping[ctorName] && mapping[ctorName][prop];
      if (typeof mappedProp === "number") {
        node[prop] = children[mappedProp].toAST(mapping);
      } else if (typeof mappedProp === "string" || typeof mappedProp === "boolean" || mappedProp === null) {
        node[prop] = mappedProp;
      } else if (typeof mappedProp === "object" && mappedProp instanceof Number) {
        node[prop] = Number(mappedProp);
      } else if (typeof mappedProp === "function") {
        node[prop] = mappedProp.call(this, children);
      } else if (mappedProp === void 0) {
        if (children[prop] && !children[prop].isTerminal()) {
          node[prop] = children[prop].toAST(mapping);
        } else {
          delete node[prop];
        }
      }
    }
    return node;
  },
  _iter(...children) {
    if (this._node.isOptional()) {
      if (this.numChildren === 0) {
        return null;
      } else {
        return children[0].toAST(this.args.mapping);
      }
    }
    return children.map(function(child) {
      return child.toAST(this.args.mapping);
    }, this);
  },
  NonemptyListOf(first, sep, rest) {
    return [first.toAST(this.args.mapping)].concat(rest.toAST(this.args.mapping));
  },
  EmptyListOf() {
    return [];
  }
};
function toAST(res, mapping) {
  if (typeof res.failed !== "function" || res.failed()) {
    throw new Error("toAST() expects a succesful MatchResult as first parameter");
  }
  mapping = Object.assign({}, mapping);
  const operation = Object.assign({}, defaultOperation);
  for (const termName in mapping) {
    if (typeof mapping[termName] === "function") {
      operation[termName] = mapping[termName];
      delete mapping[termName];
    }
  }
  const g = res._cst.grammar;
  const s = g.createSemantics().addOperation("toAST(mapping)", operation);
  return s(res).toAST(mapping);
}
function semanticsForToAST(g) {
  if (typeof g.createSemantics !== "function") {
    throw new Error("semanticsToAST() expects a Grammar as parameter");
  }
  return g.createSemantics().addOperation("toAST(mapping)", defaultOperation);
}
var semanticsToAST = {
  helper: toAST,
  semantics: semanticsForToAST
};
var extras = {
  VisitorFamily: VisitorFamily_1,
  semanticsForToAST: semanticsToAST.semantics,
  toAST: semanticsToAST.helper
};

const ohm_esm = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
	__proto__: null,
	default: ohm,
	extras
}, Symbol.toStringTag, { value: 'Module' }));

const require$$0 = /*@__PURE__*/getAugmentedNamespace(ohm_esm);

var parents = {};

var visit = {};

var nodes = {};

var hasRequiredNodes;

function requireNodes () {
	if (hasRequiredNodes) return nodes;
	hasRequiredNodes = 1;
	Object.defineProperty(nodes, "__esModule", { value: true });
	nodes.NumberExpr = nodes.NameExpr = nodes.RefExpr = nodes.NegateExpr = nodes.MathExpr = nodes.MathOperator = nodes.CombinatorExpr = nodes.BuiltinZeroArgs = nodes.BuiltinZeroArgsOperators = nodes.BuiltinOneArgExpr = nodes.BuiltinOneArgOperators = nodes.BuiltinExpr = nodes.CellRefExpr = nodes.CompareExpr = nodes.CompareOperator = nodes.CondExpr = nodes.Expression = nodes.Combinator = nodes.FieldExprDef = nodes.FieldNamedDef = nodes.FieldAnonymousDef = nodes.FieldCurlyExprDef = nodes.FieldBuiltinDef = nodes.FieldBuiltinType = nodes.Field = nodes.Constructor = nodes.Declaration = nodes.Program = nodes.ASTBase = nodes.ASTRootBase = void 0;
	class ASTRootBase {
	}
	nodes.ASTRootBase = ASTRootBase;
	// Attributes of this node, required for `walk` function, don't use directly.
	ASTRootBase._attributes = [];
	class ASTBase extends ASTRootBase {
	}
	nodes.ASTBase = ASTBase;
	class Program extends ASTRootBase {
	    constructor(declarations) {
	        super();
	        this.declarations = declarations;
	        this.parent = null;
	    }
	}
	nodes.Program = Program;
	Program._attributes = ['declarations'];
	class Declaration extends ASTBase {
	    constructor(constructorDef, fields, combinator) {
	        super();
	        this.constructorDef = constructorDef;
	        this.fields = fields;
	        this.combinator = combinator;
	    }
	}
	nodes.Declaration = Declaration;
	Declaration._attributes = [
	    'constructorDef', 'fields', 'combinator',
	];
	class Constructor extends ASTBase {
	    constructor(name, tag) {
	        super();
	        this.name = name;
	        this.tag = tag;
	    }
	    getTagType() {
	        if (this.tag === null) {
	            return null;
	        }
	        return this.tag.startsWith('$') ? 'binary' : 'hex';
	    }
	}
	nodes.Constructor = Constructor;
	class Field extends ASTBase {
	}
	nodes.Field = Field;
	nodes.FieldBuiltinType = ['#', 'Type'];
	class FieldBuiltinDef extends Field {
	    constructor(name, type) {
	        super();
	        this.name = name;
	        this.type = type;
	    }
	}
	nodes.FieldBuiltinDef = FieldBuiltinDef;
	class FieldCurlyExprDef extends Field {
	    constructor(expr) {
	        super();
	        this.expr = expr;
	    }
	}
	nodes.FieldCurlyExprDef = FieldCurlyExprDef;
	FieldCurlyExprDef._attributes = ['expr'];
	// TODO: I am not sure that `name` is allowed. Maybe it can only be `_`
	// See https://github.com/ton-blockchain/ton/issues/540
	class FieldAnonymousDef extends Field {
	    constructor(name, isRef, fields) {
	        super();
	        this.name = name;
	        this.isRef = isRef;
	        this.fields = fields;
	    }
	}
	nodes.FieldAnonymousDef = FieldAnonymousDef;
	FieldAnonymousDef._attributes = ['fields'];
	class FieldNamedDef extends Field {
	    constructor(name, expr) {
	        super();
	        this.name = name;
	        this.expr = expr;
	    }
	}
	nodes.FieldNamedDef = FieldNamedDef;
	FieldNamedDef._attributes = ['expr'];
	class FieldExprDef extends Field {
	    constructor(expr) {
	        super();
	        this.expr = expr;
	    }
	}
	nodes.FieldExprDef = FieldExprDef;
	FieldExprDef._attributes = ['expr'];
	// Combinators
	// -----------
	class Combinator extends ASTBase {
	    constructor(name, args) {
	        super();
	        this.name = name;
	        this.args = args;
	    }
	}
	nodes.Combinator = Combinator;
	Combinator._attributes = ['args'];
	// Expressions
	// -----------
	class Expression extends ASTBase {
	}
	nodes.Expression = Expression;
	// TODO: add validation that `dotExpr` cannot be set without `condExpr`
	class CondExpr extends Expression {
	    constructor(left, dotExpr, condExpr) {
	        super();
	        this.left = left;
	        this.dotExpr = dotExpr;
	        this.condExpr = condExpr;
	    }
	}
	nodes.CondExpr = CondExpr;
	CondExpr._attributes = ['left', 'condExpr'];
	nodes.CompareOperator = ['<=', '>=', '!=', '=', '<', '>'];
	class CompareExpr extends Expression {
	    constructor(left, op, right) {
	        super();
	        this.left = left;
	        this.op = op;
	        this.right = right;
	    }
	}
	nodes.CompareExpr = CompareExpr;
	CompareExpr._attributes = ['left', 'right'];
	class CellRefExpr extends Expression {
	    constructor(expr) {
	        super();
	        this.expr = expr;
	    }
	}
	nodes.CellRefExpr = CellRefExpr;
	CellRefExpr._attributes = ['expr'];
	class BuiltinExpr extends Expression {
	}
	nodes.BuiltinExpr = BuiltinExpr;
	nodes.BuiltinOneArgOperators = ['#<=', '#<', '##'];
	class BuiltinOneArgExpr extends BuiltinExpr {
	    constructor(name, arg) {
	        super();
	        this.name = name;
	        this.arg = arg;
	    }
	}
	nodes.BuiltinOneArgExpr = BuiltinOneArgExpr;
	BuiltinOneArgExpr._attributes = ['arg'];
	nodes.BuiltinZeroArgsOperators = ['#'];
	class BuiltinZeroArgs extends BuiltinExpr {
	    constructor(name) {
	        super();
	        this.name = name;
	    }
	}
	nodes.BuiltinZeroArgs = BuiltinZeroArgs;
	class CombinatorExpr extends Expression {
	    constructor(name, args) {
	        super();
	        this.name = name;
	        this.args = args;
	    }
	}
	nodes.CombinatorExpr = CombinatorExpr;
	CombinatorExpr._attributes = ['args'];
	nodes.MathOperator = ['*', '+'];
	class MathExpr extends Expression {
	    // TODO: narrower type for `left` and `right`?
	    // TODO: use `SimpleExpr` and `number`?
	    constructor(left, op, right) {
	        super();
	        this.left = left;
	        this.op = op;
	        this.right = right;
	    }
	}
	nodes.MathExpr = MathExpr;
	MathExpr._attributes = ['left', 'right'];
	class NegateExpr extends Expression {
	    constructor(expr) {
	        super();
	        this.expr = expr;
	    }
	}
	nodes.NegateExpr = NegateExpr;
	NegateExpr._attributes = ['expr'];
	class RefExpr extends Expression {
	}
	nodes.RefExpr = RefExpr;
	class NameExpr extends RefExpr {
	    constructor(name) {
	        super();
	        this.name = name;
	    }
	}
	nodes.NameExpr = NameExpr;
	class NumberExpr extends RefExpr {
	    constructor(num) {
	        super();
	        this.num = num;
	    }
	}
	nodes.NumberExpr = NumberExpr;
	return nodes;
}

var hasRequiredVisit;

function requireVisit () {
	if (hasRequiredVisit) return visit;
	hasRequiredVisit = 1;
	Object.defineProperty(visit, "__esModule", { value: true });
	visit.NodeVisitor = void 0;
	visit.iterChildNodes = iterChildNodes;
	visit.walk = walk;
	const nodes_1 = requireNodes();
	function* iterChildNodes(node) {
	    const type = Object.getPrototypeOf(node).constructor;
	    for (let attributeName of type._attributes) {
	        // @ts-ignore
	        const attribute = node[attributeName];
	        if (attribute instanceof Array) {
	            for (let arrayItem of attribute) {
	                if (arrayItem instanceof nodes_1.ASTRootBase) {
	                    yield arrayItem;
	                }
	            }
	        }
	        else if (attribute instanceof nodes_1.ASTRootBase) {
	            yield attribute;
	        }
	    }
	}
	function* walk(node) {
	    const todo = [node];
	    while (todo.length > 0) {
	        const current = todo.shift();
	        todo.push(...iterChildNodes(current));
	        yield current;
	    }
	}
	class NodeVisitor {
	    visit(node) {
	        const name = node.constructor.name;
	        // @ts-ignore
	        const handler = this[`visit${name}`];
	        if (handler === undefined) {
	            return this.genericVisit(node);
	        }
	        else {
	            return handler(node);
	        }
	    }
	    genericVisit(node) {
	        for (let attribute of iterChildNodes(node)) {
	            this.visit(attribute);
	        }
	    }
	}
	visit.NodeVisitor = NodeVisitor;
	return visit;
}

var hasRequiredParents;

function requireParents () {
	if (hasRequiredParents) return parents;
	hasRequiredParents = 1;
	Object.defineProperty(parents, "__esModule", { value: true });
	parents.withParents = withParents;
	const visit_1 = requireVisit();
	function withParents(tree) {
	    for (let parent of (0, visit_1.walk)(tree)) {
	        for (let child of (0, visit_1.iterChildNodes)(parent)) {
	            // We only set it here, so ignore
	            // @ts-ignore
	            child.parent = parent;
	        }
	    }
	    return tree;
	}
	return parents;
}

var tlb = {};

var hasRequiredTlb;

function requireTlb () {
	if (hasRequiredTlb) return tlb;
	hasRequiredTlb = 1;
	Object.defineProperty(tlb, "__esModule", { value: true });
	const grammar = String.raw `
TLB {
  // See:
  // https://github.com/andreypfau/TL-B-docs

  // Root definition
  Program = SourceElement*

  // Utilities
  // Override Ohm's built-in definition of space.
  space := whitespace | lineTerminator | comment

  whitespace =
    | "\t"
    | "\x0B"    -- verticalTab
    | "\x0C"    -- formFeed
    | " "
    | "\u00A0"  -- noBreakSpace
    | "\uFEFF"  -- byteOrderMark
    | "\u2000".."\u200B"
    | "\u3000"

  sourceCharacter = any
  lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"

  // Comments
  comment = multiLineComment | singleLineComment
  multiLineComment = "/*" (~"*/" sourceCharacter)* "*/"
  singleLineComment = "//" (~lineTerminator sourceCharacter)*

  // Data types
  binaryDigit = "0" | "1"
  decimalDigit = "0".."9"
  hex = hexChar* "_"?
  hexChar = decimalDigit | letter

  // Identifiers
  identifier = identifierStart identifierPart*
  identifierStart = "_" | letter
  identifierPart = identifierStart | digit

  // Primitives
  number = digit+

  // Builtins
  builtins_one_arg = "#<=" | "#<" | "##"
  builtins_zero_args = "#"
  builtins_field = "#" | "Type"


  // ----------
  // Base rules
  // ----------
  SourceElement = Declaration | comment
  Declaration = Constructor Fields "=" Combinator ";"


  // Constructors
  // ~~~~~~~~~~~~
  Constructor = ConstructorStart ConstructorTag?
  ConstructorStart = "!"? ("_" | identifier)
  ConstructorTag =
  	| "$" ("_" | binaryDigit+)  -- binary
    | "#" ("_" | hex)           -- hex


  // Fields
  // ~~~~~~
  Fields = FieldDefinition*
  FieldDefinition =
    | FieldBuiltinDef
    | FieldCurlyExprDef
    | FieldAnonymousDef
    | FieldNamedDef
    | FieldExprDef

  FieldBuiltinDef = "{" identifier ":" builtins_field "}"
  FieldCurlyExprDef = "{" CurlyExpression "}"
  FieldAnonymousDef = FieldAnonRef | FieldNamedAnonRef
  FieldNamedDef = identifier ":" CondExpr
  FieldExprDef = CondExpr

  FieldAnonRef = "^"? "[" FieldDefinition* "]"
  FieldNamedAnonRef = identifier ":" FieldAnonRef


  // Combinators
  // ~~~~~~~~~~~

  Combinator = identifier SimpleExpr*


  // Expressions
  // ~~~~~~~~~~~

  // First come the complex rules we only use to define fields.
  // The line between fields definition and expressions is blury at this point.
  CurlyExpression = CompareExpr
  CondExpr =
    | CondDotAndQuestionExpr
    | CondQuestionExpr
    | CondTypeExpr

  CondDotted = TypeExpr "." number
  CondDotAndQuestionExpr = ( CondDotted | Parens<CondDotted> ) "?" TypeExpr
  CondQuestionExpr = TypeExpr "?" TypeExpr
  CondTypeExpr = TypeExpr

  // Compares:
  CompareExpr =
    | CompareOperatorExpr
    | Parens<CompareExpr>
    | MathExpr

  CompareOperatorExpr =
    | MathExpr "<=" MathExpr
    | MathExpr ">=" MathExpr
    | MathExpr "!=" MathExpr
    | MathExpr "=" MathExpr
    | MathExpr "<" MathExpr
    | MathExpr ">" MathExpr

  // Base rule for field defining expressions:
  TypeExpr =
    | CellRefExpr
    | BuiltinExpr
    | CombinatorExpr
    | SimpleExpr
    | Parens<TypeExpr>

  // Math:
  MathExpr = MulExpr ("+" MulExpr)*
  // You can multiply by constant values only: 'Bit' and numbers, basically
  MulExpr = SimpleExpr ("*" RefExpr)*

  // TypeExpr's items:
  CellRefExpr = "^" ( CellRefInner | Parens<CellRefInner> )
  CellRefInner = CombinatorExpr | identifier

  BuiltinExpr = BuiltinOneArg | BuiltinZeroArgs
  // This needs extra 'Parens' because of '(##)' expr:
  BuiltinOneArg = "(" ( builtins_one_arg | Parens<builtins_one_arg> ) RefExpr ")"
  BuiltinZeroArgs = builtins_zero_args

  // It is different from 'Combinator' only in the quantity part:
  // we always need at least one argument here and it can be complex.
  CombinatorExpr = "(" identifier TypeExpr+ ")"

  SimpleExpr =
    | NegateExpr
    | MathExpr
    | RefExpr
    | Parens<SimpleExpr>

  NegateExpr = "~" SimpleExpr
  RefExpr = RefInner | Parens<RefInner>
  RefInner = identifier | number


  // Helpers
  // ~~~~~~~

  // Generic rule to allow parens around some expressions:
  Parens<expr> = "(" expr ")"
}
`;
	tlb.default = grammar;
	return tlb;
}

var parsing = {};

var locations = {};

var hasRequiredLocations;

function requireLocations () {
	if (hasRequiredLocations) return locations;
	hasRequiredLocations = 1;
	Object.defineProperty(locations, "__esModule", { value: true });
	locations.withLocations = withLocations;
	function withLocations(astNode, intermediateNode) {
	    // It exists, but is not listed in TS definitions.
	    // @ts-ignore
	    const lineAndColumn = intermediateNode.source.getLineAndColumn();
	    // This is the only place where we set it, ignore the type error
	    // @ts-ignore
	    astNode.locations = {
	        'line': lineAndColumn.lineNum,
	        'column': lineAndColumn.colNum,
	    };
	    return astNode;
	}
	return locations;
}

var hasRequiredParsing;

function requireParsing () {
	if (hasRequiredParsing) return parsing;
	hasRequiredParsing = 1;
	var __createBinding = (parsing && parsing.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (parsing && parsing.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (parsing && parsing.__importStar) || (function () {
	    var ownKeys = function(o) {
	        ownKeys = Object.getOwnPropertyNames || function (o) {
	            var ar = [];
	            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
	            return ar;
	        };
	        return ownKeys(o);
	    };
	    return function (mod) {
	        if (mod && mod.__esModule) return mod;
	        var result = {};
	        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
	        __setModuleDefault(result, mod);
	        return result;
	    };
	})();
	Object.defineProperty(parsing, "__esModule", { value: true });
	parsing.exprNodes = parsing.combinatorNodes = parsing.fieldNodes = parsing.constructorNodes = parsing.rootNodes = void 0;
	const ast = __importStar(requireNodes());
	const locations_1 = requireLocations();
	parsing.rootNodes = {
	    Program(node) {
	        return (0, locations_1.withLocations)(new ast.Program(node.children.map((child) => child['root']())), node);
	    },
	    SourceElement(node) {
	        return (0, locations_1.withLocations)(new ast.Declaration(node.child(0)['Constructor'](), node.child(1)['Field'](), node.child(3)['Combinator']()), node);
	    },
	};
	parsing.constructorNodes = {
	    Constructor(name, tag) {
	        const nameValue = name.sourceString;
	        let tagValue = null;
	        if (tag.numChildren !== 0) {
	            tagValue = tag.child(0)['Constructor']();
	        }
	        return (0, locations_1.withLocations)(new ast.Constructor(nameValue, tagValue), name);
	    },
	    ConstructorTag(node) {
	        // This is a string-only node:
	        return node.sourceString;
	    },
	};
	parsing.fieldNodes = {
	    Fields(node) {
	        return node.children.map((child) => child['Field']());
	    },
	    FieldDefinition(node) {
	        return node['Field'](); // just a wrapper node, unwrapping
	    },
	    FieldBuiltinDef(lpar, name, _sep, type, _rpar) {
	        // TODO: validate `type.sourceString` to be in allowed values.
	        return (0, locations_1.withLocations)(new ast.FieldBuiltinDef(name.sourceString, type.sourceString), lpar);
	    },
	    FieldCurlyExprDef(lpar, expr, _rpar) {
	        return (0, locations_1.withLocations)(new ast.FieldCurlyExprDef(expr['expr']()), lpar);
	    },
	    FieldAnonymousDef(node) {
	        const { name, isRef, fields } = node['Field']();
	        return (0, locations_1.withLocations)(new ast.FieldAnonymousDef(name, isRef, fields), node);
	    },
	    FieldNamedDef(name, _sep, expr) {
	        return (0, locations_1.withLocations)(new ast.FieldNamedDef(name.sourceString, expr['expr']()), name);
	    },
	    FieldExprDef(node) {
	        return (0, locations_1.withLocations)(new ast.FieldExprDef(node['expr']()), node);
	    },
	    // Helpers to parse complex anonymous fields:
	    // TODO: move out of this semantics
	    FieldAnonRef(ref, _lpar, fields, _rpar) {
	        return {
	            'name': null,
	            'isRef': ref.numChildren !== 0,
	            'fields': fields.children.map((field) => field['Field']()),
	        };
	    },
	    FieldNamedAnonRef(name, _sep, fields) {
	        return Object.assign(Object.assign({}, fields['Field']()), { 'name': name.sourceString });
	    },
	};
	parsing.combinatorNodes = {
	    Combinator(name, exprs) {
	        return (0, locations_1.withLocations)(new ast.Combinator(name.sourceString, exprs.children.map((typeExpr) => typeExpr['expr']())), name);
	    },
	};
	parsing.exprNodes = {
	    // Math
	    MathExpr(left, ops, rights) {
	        return parseMath(left, ops, rights);
	    },
	    MulExpr(left, ops, rights) {
	        return parseMath(left, ops, rights);
	    },
	    CompareExpr(node) {
	        return node['expr']();
	    },
	    CompareOperatorExpr(left, op, right) {
	        return (0, locations_1.withLocations)(new ast.CompareExpr(left['expr'](), op.sourceString, right['expr']()), op);
	    },
	    // Conditional types
	    CondExpr(expr) {
	        const { leftExpr, dotExpr, condExpr } = expr['expr']();
	        if (dotExpr === undefined && condExpr === undefined) {
	            return leftExpr;
	        }
	        return (0, locations_1.withLocations)(new ast.CondExpr(leftExpr, dotExpr, condExpr), expr);
	    },
	    // TODO: move out of this semantics
	    CondDotAndQuestionExpr(dotNode, _sep, condNode) {
	        return Object.assign(Object.assign({}, dotNode['expr']()), { 'condExpr': condNode['expr']() });
	    },
	    CondQuestionExpr(left, _sep, condNode) {
	        return {
	            'leftExpr': left['expr'](),
	            'dotExpr': null,
	            'condExpr': condNode['expr'](),
	        };
	    },
	    CondTypeExpr(node) {
	        return {
	            'leftExpr': node['expr'](),
	        };
	    },
	    CondDotted(left, _sep, number) {
	        return {
	            'leftExpr': left['expr'](),
	            'dotExpr': new Number(number.sourceString),
	        };
	    },
	    // TypeExpr
	    CombinatorExpr(lpar, name, args, _rpar) {
	        return (0, locations_1.withLocations)(new ast.CombinatorExpr(name.sourceString, args.children.map((arg) => arg['expr']())), lpar);
	    },
	    CellRefExpr(ref, node) {
	        return (0, locations_1.withLocations)(new ast.CellRefExpr(node['expr']()), ref);
	    },
	    BuiltinExpr(node) {
	        return (0, locations_1.withLocations)(node['expr'](), node);
	    },
	    NegateExpr(op, node) {
	        return (0, locations_1.withLocations)(new ast.NegateExpr(node['expr']()), op);
	    },
	    // Builtins
	    BuiltinOneArg(lpar, expr, arg, _rpar) {
	        // TODO: validate `expr` to be in allowed set of operators
	        return (0, locations_1.withLocations)(new ast.BuiltinOneArgExpr(expr.sourceString, arg['expr']()), lpar);
	    },
	    BuiltinZeroArgs(expr) {
	        // TODO: validate `expr` to be in allowed set of operators
	        return (0, locations_1.withLocations)(new ast.BuiltinZeroArgs(expr.sourceString), expr);
	    },
	    // Base rules
	    identifier(start, rest) {
	        return (0, locations_1.withLocations)(new ast.NameExpr(start.sourceString + rest.sourceString), start);
	    },
	    number(node) {
	        return (0, locations_1.withLocations)(new ast.NumberExpr(parseInt(node.sourceString)), node);
	    },
	    // Helpers
	    Parens(lpar, node, _rpar) {
	        // Just drop `()` around an expression, it should be fine
	        return (0, locations_1.withLocations)(node['expr'](), lpar);
	    },
	};
	function parseMath(left, ops, rights) {
	    const leftExpr = left['expr']();
	    const opsSigns = [];
	    for (let child of ops.children) {
	        // TODO: validate op is in ast.MathOperators
	        opsSigns.push(child.sourceString);
	    }
	    const rightExprs = [];
	    for (let child of rights.children) {
	        const rightExpr = child['expr']();
	        if (rightExpr !== undefined) {
	            rightExprs.push(rightExpr);
	        }
	    }
	    if (opsSigns.length !== rightExprs.length) {
	        throw new Error('Invalid math operation'); // should not happen
	    }
	    if (opsSigns.length === 0) {
	        // This is not a math expr, just the left part
	        return (0, locations_1.withLocations)(leftExpr, left);
	    }
	    // We always use the left part for all the math expressions,
	    // it should be fine for now.
	    let expr = (0, locations_1.withLocations)(new ast.MathExpr(leftExpr, opsSigns[0], rightExprs[0]), left);
	    for (let index = 1; index < opsSigns.length; index++) {
	        expr = (0, locations_1.withLocations)(new ast.MathExpr(expr, opsSigns[index], // validated earlier
	        rightExprs[index]), left);
	    }
	    return expr;
	}
	return parsing;
}

var hasRequiredIntermediate;

function requireIntermediate () {
	if (hasRequiredIntermediate) return intermediate;
	hasRequiredIntermediate = 1;
	var __importDefault = (intermediate && intermediate.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(intermediate, "__esModule", { value: true });
	intermediate.buildGrammar = buildGrammar;
	intermediate.buildAST = buildAST;
	const ohm_js_1 = __importDefault(require$$0);
	const parents_1 = requireParents();
	const tlb_1 = __importDefault(requireTlb());
	const parsing_1 = requireParsing();
	function buildGrammar() {
	    return ohm_js_1.default.grammar(tlb_1.default);
	}
	function buildAST(input, grammar) {
	    const semantics = grammar.createSemantics();
	    semantics.addOperation('root', parsing_1.rootNodes);
	    semantics.addOperation('Constructor', parsing_1.constructorNodes);
	    semantics.addOperation('Field', parsing_1.fieldNodes);
	    semantics.addOperation('Combinator', parsing_1.combinatorNodes);
	    semantics.addOperation('expr', parsing_1.exprNodes);
	    const matchResult = grammar.match(input);
	    const ast = semantics(matchResult)['root']();
	    return (0, parents_1.withParents)(ast);
	}
	return intermediate;
}

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.MathOperator = exports.BuiltinZeroArgsOperators = exports.BuiltinOneArgOperators = exports.CompareOperator = exports.FieldBuiltinType = exports.NumberExpr = exports.NameExpr = exports.RefExpr = exports.NegateExpr = exports.MathExpr = exports.CombinatorExpr = exports.BuiltinZeroArgs = exports.BuiltinOneArgExpr = exports.BuiltinExpr = exports.CellRefExpr = exports.CompareExpr = exports.CondExpr = exports.Expression = exports.Combinator = exports.FieldExprDef = exports.FieldNamedDef = exports.FieldAnonymousDef = exports.FieldCurlyExprDef = exports.FieldBuiltinDef = exports.Field = exports.Constructor = exports.Declaration = exports.Program = exports.ASTBase = exports.ASTRootBase = exports.NodeVisitor = void 0;
		exports.parse = parse;
		exports.ast = ast;
		const intermediate_1 = requireIntermediate();
		function parse(input, grammar = undefined) {
		    if (grammar === undefined) {
		        grammar = (0, intermediate_1.buildGrammar)();
		    }
		    return grammar.match(input);
		}
		function ast(input) {
		    return (0, intermediate_1.buildAST)(input, (0, intermediate_1.buildGrammar)());
		}
		var visit_1 = requireVisit();
		Object.defineProperty(exports, "NodeVisitor", { enumerable: true, get: function () { return visit_1.NodeVisitor; } });
		var nodes_1 = requireNodes();
		Object.defineProperty(exports, "ASTRootBase", { enumerable: true, get: function () { return nodes_1.ASTRootBase; } });
		Object.defineProperty(exports, "ASTBase", { enumerable: true, get: function () { return nodes_1.ASTBase; } });
		Object.defineProperty(exports, "Program", { enumerable: true, get: function () { return nodes_1.Program; } });
		Object.defineProperty(exports, "Declaration", { enumerable: true, get: function () { return nodes_1.Declaration; } });
		Object.defineProperty(exports, "Constructor", { enumerable: true, get: function () { return nodes_1.Constructor; } });
		Object.defineProperty(exports, "Field", { enumerable: true, get: function () { return nodes_1.Field; } });
		Object.defineProperty(exports, "FieldBuiltinDef", { enumerable: true, get: function () { return nodes_1.FieldBuiltinDef; } });
		Object.defineProperty(exports, "FieldCurlyExprDef", { enumerable: true, get: function () { return nodes_1.FieldCurlyExprDef; } });
		Object.defineProperty(exports, "FieldAnonymousDef", { enumerable: true, get: function () { return nodes_1.FieldAnonymousDef; } });
		Object.defineProperty(exports, "FieldNamedDef", { enumerable: true, get: function () { return nodes_1.FieldNamedDef; } });
		Object.defineProperty(exports, "FieldExprDef", { enumerable: true, get: function () { return nodes_1.FieldExprDef; } });
		Object.defineProperty(exports, "Combinator", { enumerable: true, get: function () { return nodes_1.Combinator; } });
		Object.defineProperty(exports, "Expression", { enumerable: true, get: function () { return nodes_1.Expression; } });
		Object.defineProperty(exports, "CondExpr", { enumerable: true, get: function () { return nodes_1.CondExpr; } });
		Object.defineProperty(exports, "CompareExpr", { enumerable: true, get: function () { return nodes_1.CompareExpr; } });
		Object.defineProperty(exports, "CellRefExpr", { enumerable: true, get: function () { return nodes_1.CellRefExpr; } });
		Object.defineProperty(exports, "BuiltinExpr", { enumerable: true, get: function () { return nodes_1.BuiltinExpr; } });
		Object.defineProperty(exports, "BuiltinOneArgExpr", { enumerable: true, get: function () { return nodes_1.BuiltinOneArgExpr; } });
		Object.defineProperty(exports, "BuiltinZeroArgs", { enumerable: true, get: function () { return nodes_1.BuiltinZeroArgs; } });
		Object.defineProperty(exports, "CombinatorExpr", { enumerable: true, get: function () { return nodes_1.CombinatorExpr; } });
		Object.defineProperty(exports, "MathExpr", { enumerable: true, get: function () { return nodes_1.MathExpr; } });
		Object.defineProperty(exports, "NegateExpr", { enumerable: true, get: function () { return nodes_1.NegateExpr; } });
		Object.defineProperty(exports, "RefExpr", { enumerable: true, get: function () { return nodes_1.RefExpr; } });
		Object.defineProperty(exports, "NameExpr", { enumerable: true, get: function () { return nodes_1.NameExpr; } });
		Object.defineProperty(exports, "NumberExpr", { enumerable: true, get: function () { return nodes_1.NumberExpr; } });
		Object.defineProperty(exports, "FieldBuiltinType", { enumerable: true, get: function () { return nodes_1.FieldBuiltinType; } });
		Object.defineProperty(exports, "CompareOperator", { enumerable: true, get: function () { return nodes_1.CompareOperator; } });
		Object.defineProperty(exports, "BuiltinOneArgOperators", { enumerable: true, get: function () { return nodes_1.BuiltinOneArgOperators; } });
		Object.defineProperty(exports, "BuiltinZeroArgsOperators", { enumerable: true, get: function () { return nodes_1.BuiltinZeroArgsOperators; } });
		Object.defineProperty(exports, "MathOperator", { enumerable: true, get: function () { return nodes_1.MathOperator; } }); 
	} (dist));
	return dist;
}

var distExports$1 = requireDist();

var crc32 = {};

/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */

var hasRequiredCrc32;

function requireCrc32 () {
	if (hasRequiredCrc32) return crc32;
	hasRequiredCrc32 = 1;
	(function (exports) {
		(function(factory) {
		  if (typeof DO_NOT_EXPORT_CRC === "undefined") {
		    {
		      factory(exports);
		    }
		  } else {
		    factory({});
		  }
		})(function(CRC322) {
		  CRC322.version = "1.2.2";
		  function signed_crc_table() {
		    var c = 0, table = new Array(256);
		    for (var n = 0; n != 256; ++n) {
		      c = n;
		      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
		      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
		      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
		      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
		      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
		      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
		      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
		      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
		      table[n] = c;
		    }
		    return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
		  }
		  var T0 = signed_crc_table();
		  function slice_by_16_tables(T) {
		    var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
		    for (n = 0; n != 256; ++n) table[n] = T[n];
		    for (n = 0; n != 256; ++n) {
		      v = T[n];
		      for (c = 256 + n; c < 4096; c += 256) v = table[c] = v >>> 8 ^ T[v & 255];
		    }
		    var out = [];
		    for (n = 1; n != 16; ++n) out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
		    return out;
		  }
		  var TT = slice_by_16_tables(T0);
		  var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
		  var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
		  var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
		  function crc32_bstr(bstr, seed) {
		    var C = seed ^ -1;
		    for (var i = 0, L = bstr.length; i < L; ) C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
		    return ~C;
		  }
		  function crc32_buf(B, seed) {
		    var C = seed ^ -1, L = B.length - 15, i = 0;
		    for (; i < L; ) C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
		    L += 15;
		    while (i < L) C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
		    return ~C;
		  }
		  function crc32_str(str, seed) {
		    var C = seed ^ -1;
		    for (var i = 0, L = str.length, c = 0, d = 0; i < L; ) {
		      c = str.charCodeAt(i++);
		      if (c < 128) {
		        C = C >>> 8 ^ T0[(C ^ c) & 255];
		      } else if (c < 2048) {
		        C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
		        C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
		      } else if (c >= 55296 && c < 57344) {
		        c = (c & 1023) + 64;
		        d = str.charCodeAt(i++) & 1023;
		        C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
		        C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
		        C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
		        C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
		      } else {
		        C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
		        C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
		        C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
		      }
		    }
		    return ~C;
		  }
		  CRC322.table = T0;
		  CRC322.bstr = crc32_bstr;
		  CRC322.buf = crc32_buf;
		  CRC322.str = crc32_str;
		}); 
	} (crc32));
	return crc32;
}

var crc32Exports = requireCrc32();

class TLBBinaryOp {
  constructor(left, right, operation, variables = /* @__PURE__ */ new Set([
    ...left.variables,
    ...right.variables
  ]), hasNeg = left.hasNeg || right.hasNeg) {
    this.left = left;
    this.right = right;
    this.operation = operation;
    this.variables = variables;
    this.hasNeg = hasNeg;
  }
}
class TLBNumberExpr {
  constructor(n, variables = /* @__PURE__ */ new Set(), hasNeg = false) {
    this.n = n;
    this.variables = variables;
    this.hasNeg = hasNeg;
  }
}
class TLBUnaryOp {
  constructor(value, operation, variables = value.variables, hasNeg = value.hasNeg) {
    this.value = value;
    this.operation = operation;
    this.variables = variables;
    this.hasNeg = hasNeg;
  }
}
class TLBVarExpr {
  constructor(x, variables = /* @__PURE__ */ new Set(), hasNeg = false) {
    this.x = x;
    this.variables = variables;
    this.hasNeg = hasNeg;
    if (variables.size == 0) {
      variables.add(x);
    }
  }
}
class TLBVariable {
  constructor(isConst, negated, type, name, isField, deriveExpr, initialExpr) {
    this.isConst = isConst;
    this.negated = negated;
    this.type = type;
    this.name = name;
    this.isField = isField;
    this.deriveExpr = deriveExpr;
    this.initialExpr = initialExpr;
  }
}
class TLBParameter {
  constructor(variable, paramExpr, argName) {
    this.variable = variable;
    this.paramExpr = paramExpr;
    this.argName = argName;
  }
}
class TLBConstructor {
  constructor(parameters, variables, variablesMap, parametersMap, name, fields, tag, constraints, declaration, tlbType) {
    this.parameters = parameters;
    this.variables = variables;
    this.variablesMap = variablesMap;
    this.parametersMap = parametersMap;
    this.name = name;
    this.fields = fields;
    this.tag = tag;
    this.constraints = constraints;
    this.declaration = declaration;
    this.tlbType = tlbType;
  }
}
class TLBType {
  constructor(name, constructors) {
    this.name = name;
    this.constructors = constructors;
  }
}
class TLBCode {
  constructor(types) {
    this.types = types;
  }
}

function isNameReserved(name) {
  let tsReserved = [
    "abstract",
    "arguments",
    "await",
    "boolean",
    "break",
    "byte",
    "case",
    "catch",
    "char",
    "class",
    "const",
    "continue",
    "debugger",
    "default",
    "delete",
    "do",
    "double",
    "else",
    "enum",
    "eval",
    "export",
    "extends",
    "false",
    "final",
    "finally",
    "float",
    "for",
    "function",
    "goto",
    "if",
    "implements",
    "import",
    "in",
    "instanceof",
    "int",
    "interface",
    "let",
    "long",
    "native",
    "new",
    "null",
    "package",
    "private",
    "protected",
    "public",
    "return",
    "short",
    "static",
    "super",
    "switch",
    "synchronized",
    "this",
    "throw",
    "throws",
    "transient",
    "true",
    "try",
    "typeof",
    "var",
    "void",
    "volatile",
    "while",
    "with",
    "yield"
  ];
  if (tsReserved.includes(name)) {
    return true;
  }
  if (name.startsWith("slice")) {
    return true;
  }
  if (name.startsWith("cell")) {
    return true;
  }
  if (name == "builder") {
    return true;
  }
  return false;
}
function findNotReservedName(name, possibleSuffix = "0") {
  if (name.startsWith("slice") || name.startsWith("cell")) {
    name = "_" + name;
  }
  while (isNameReserved(name)) {
    name += possibleSuffix;
  }
  return name;
}

function opCodeSetsEqual(a, b) {
  if (a === b) return true;
  if (a == null || b == null) return false;
  if (a.length !== b.length) return false;
  a = a.sort();
  b = b.sort();
  for (var i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
function calculateVariable(variable, constructor) {
  if (variable.calculated) {
    return;
  }
  if (!variable.deriveExpr) {
    return;
  }
  variable.calculated = true;
  variable.deriveExpr = getCalculatedExpression(
    variable.deriveExpr,
    constructor
  );
}
function getCalculatedExpression(expr, constructor) {
  if (expr instanceof TLBVarExpr) {
    let variable = constructor.variablesMap.get(expr.x);
    if (variable) {
      calculateVariable(variable, constructor);
      if (variable.deriveExpr) {
        return variable.deriveExpr;
      }
    }
  }
  if (expr instanceof TLBBinaryOp) {
    let left = getCalculatedExpression(expr.left, constructor);
    let right = getCalculatedExpression(expr.right, constructor);
    return new TLBBinaryOp(
      left,
      right,
      expr.operation,
      expr.variables,
      expr.hasNeg
    );
  }
  return expr;
}
function splitForTypeValue(name, typeName) {
  if (!name.startsWith(typeName)) {
    return void 0;
  }
  let num = parseInt(name.slice(typeName.length));
  if (num == void 0) {
    return void 0;
  }
  if (name != typeName + num.toString()) {
    return void 0;
  }
  return num;
}
function deriveMathExpression(mathExpr) {
  let myMathExpr = convertToMathExpr(mathExpr);
  return {
    name: getVariableName(myMathExpr),
    derived: myMathExpr
  };
}
function getVariableName(myMathExpr) {
  if (myMathExpr instanceof TLBVarExpr) {
    return myMathExpr.x;
  }
  if (myMathExpr instanceof TLBBinaryOp) {
    if (myMathExpr.left.variables.size) {
      return getVariableName(myMathExpr.left);
    } else {
      return getVariableName(myMathExpr.right);
    }
  }
  return void 0;
}
function reorganizeExpression(mathExpr, variable) {
  if (mathExpr instanceof TLBBinaryOp && mathExpr.operation == "=") {
    if (mathExpr.left.variables.has(variable)) {
      mathExpr = new TLBBinaryOp(
        mathExpr.right,
        mathExpr.left,
        "=",
        mathExpr.variables,
        mathExpr.hasNeg
      );
    }
    if (mathExpr.right instanceof TLBVarExpr) {
      return new TLBBinaryOp(
        mathExpr.right,
        mathExpr.left,
        "=",
        mathExpr.variables,
        mathExpr.hasNeg
      );
    }
    let rightSide = mathExpr.right;
    if (rightSide instanceof TLBBinaryOp) {
      let op = "";
      if (rightSide.operation == "*") {
        op = "/";
      } else if (rightSide.operation == "+") {
        op = "-";
      } else {
        throw new Error("invalid operation");
      }
      let withVariable = void 0;
      let other = void 0;
      if (rightSide.left.variables.has(variable)) {
        withVariable = rightSide.left;
        other = rightSide.right;
      } else {
        other = rightSide.left;
        withVariable = rightSide.right;
      }
      let leftSide = new TLBBinaryOp(mathExpr.left, other, op);
      mathExpr = new TLBBinaryOp(
        leftSide,
        withVariable,
        "=",
        /* @__PURE__ */ new Set([...leftSide.variables, ...withVariable.variables]),
        leftSide.hasNeg || rightSide.hasNeg
      );
      return reorganizeExpression(mathExpr, variable);
    }
  }
  throw new Error(`Couldn't reogranize expression: ${mathExpr}`);
}
function getNegatedVariable(mathExpr) {
  if (mathExpr.hasNeg) {
    if (mathExpr instanceof TLBBinaryOp) {
      if (mathExpr.left.hasNeg) {
        return getNegatedVariable(mathExpr.left);
      }
      if (mathExpr.right.hasNeg) {
        return getNegatedVariable(mathExpr.right);
      }
    }
    if (mathExpr instanceof TLBVarExpr) {
      return mathExpr.x;
    }
  }
  return void 0;
}
function convertToMathExpr(mathExpr, negated = false) {
  if (mathExpr instanceof distExports$1.NameExpr) {
    let variables = /* @__PURE__ */ new Set();
    variables.add(mathExpr.name);
    return new TLBVarExpr(mathExpr.name, variables, negated);
  }
  if (mathExpr instanceof distExports$1.NumberExpr) {
    return new TLBNumberExpr(mathExpr.num, /* @__PURE__ */ new Set(), false);
  }
  if (mathExpr instanceof distExports$1.MathExpr) {
    let left = convertToMathExpr(mathExpr.left, negated);
    let right = convertToMathExpr(mathExpr.right, negated);
    return new TLBBinaryOp(left, right, mathExpr.op);
  }
  if (mathExpr instanceof distExports$1.CompareExpr) {
    let left = convertToMathExpr(mathExpr.left, negated);
    let right = convertToMathExpr(mathExpr.right, negated);
    let operation = mathExpr.op;
    return new TLBBinaryOp(left, right, operation);
  }
  if (mathExpr instanceof distExports$1.NegateExpr) {
    if (mathExpr.expr instanceof distExports$1.MathExpr || mathExpr.expr instanceof distExports$1.NameExpr || mathExpr.expr instanceof distExports$1.NumberExpr) {
      let expression = convertToMathExpr(mathExpr.expr, true);
      if (expression instanceof TLBBinaryOp) {
        return new TLBBinaryOp(
          expression.left,
          expression.right,
          expression.operation,
          expression.variables,
          true
        );
      }
      if (expression instanceof TLBVarExpr) {
        return new TLBVarExpr(expression.x, expression.variables, true);
      }
      if (expression instanceof TLBNumberExpr) {
        return new TLBNumberExpr(expression.n, expression.variables, true);
      }
    }
  }
  throw new Error(`Could not convert expression: ${mathExpr}`);
}

function getType(expr, constructor, fieldTypeName) {
  if (expr instanceof distExports$1.BuiltinZeroArgs) {
    if (expr.name == "#") {
      return {
        kind: "TLBNumberType",
        bits: new TLBNumberExpr(32),
        storeBits: new TLBNumberExpr(32),
        signed: false,
        maxBits: 32
      };
    } else {
      throw new Error("Expression not supported" + expr);
    }
  } else if (expr instanceof distExports$1.BuiltinOneArgExpr) {
    if (expr.name.toString() == "##" || expr.name.toString() == "(##)") {
      if (expr.arg instanceof distExports$1.NumberExpr) {
        return {
          kind: "TLBNumberType",
          bits: new TLBNumberExpr(expr.arg.num),
          storeBits: new TLBNumberExpr(expr.arg.num),
          signed: false,
          maxBits: expr.arg.num
        };
      }
      if (expr.arg instanceof distExports$1.NameExpr) {
        let parameter = constructor.parametersMap.get(expr.arg.name);
        if (!parameter || !parameter.variable.deriveExpr || !parameter.variable.initialExpr) {
          throw new Error(`Couldn't handle expression ${expr}`);
        }
        return {
          kind: "TLBNumberType",
          bits: getCalculatedExpression(
            parameter.variable.deriveExpr,
            constructor
          ),
          storeBits: parameter.variable.initialExpr,
          signed: false,
          maxBits: void 0
        };
      } else {
        throw new Error(`Couldn't handle expression ${expr}`);
      }
    } else if (expr.name == "#<") {
      if (expr.arg instanceof distExports$1.NumberExpr || expr.arg instanceof distExports$1.NameExpr) {
        let bits = new TLBUnaryOp(
          new TLBBinaryOp(
            getCalculatedExpression(convertToMathExpr(expr.arg), constructor),
            new TLBNumberExpr(1),
            "-"
          ),
          "."
        );
        return {
          kind: "TLBNumberType",
          bits,
          storeBits: bits,
          signed: false,
          maxBits: 32
        };
      } else {
        throw new Error(`Couldn't handle expression ${expr}`);
      }
    } else if (expr.name == "#<=") {
      if (expr.arg instanceof distExports$1.NumberExpr || expr.arg instanceof distExports$1.NameExpr) {
        let bits = new TLBUnaryOp(
          getCalculatedExpression(convertToMathExpr(expr.arg), constructor),
          "."
        );
        return {
          kind: "TLBNumberType",
          bits,
          storeBits: bits,
          signed: false,
          maxBits: 32
        };
      } else {
        throw new Error(`Couldn't handle expression ${expr}`);
      }
    }
  } else if (expr instanceof distExports$1.CombinatorExpr) {
    if (expr.name == "int" && expr.args.length == 1 && (expr.args[0] instanceof distExports$1.MathExpr || expr.args[0] instanceof distExports$1.NumberExpr || expr.args[0] instanceof distExports$1.NameExpr)) {
      return {
        kind: "TLBNumberType",
        bits: getCalculatedExpression(
          convertToMathExpr(expr.args[0]),
          constructor
        ),
        storeBits: convertToMathExpr(expr.args[0]),
        signed: true,
        maxBits: void 0
      };
    } else if (expr.name == "uint" && expr.args.length == 1 && (expr.args[0] instanceof distExports$1.MathExpr || expr.args[0] instanceof distExports$1.NumberExpr || expr.args[0] instanceof distExports$1.NameExpr)) {
      return {
        kind: "TLBNumberType",
        bits: getCalculatedExpression(
          convertToMathExpr(expr.args[0]),
          constructor
        ),
        storeBits: convertToMathExpr(expr.args[0]),
        signed: false,
        maxBits: void 0
      };
    } else if (expr.name == "bits" && expr.args.length == 1 && (expr.args[0] instanceof distExports$1.MathExpr || expr.args[0] instanceof distExports$1.NumberExpr || expr.args[0] instanceof distExports$1.NameExpr)) {
      return {
        kind: "TLBBitsType",
        bits: getCalculatedExpression(
          convertToMathExpr(expr.args[0]),
          constructor
        )
      };
    } else if (expr.name == "HashmapE") {
      if (expr.args.length != 2) {
        throw new Error("");
      }
      let key = getType(expr.args[0], constructor, fieldTypeName);
      let value = getType(expr.args[1], constructor, fieldTypeName);
      if (key.kind != "TLBExprMathType") {
        throw new Error("Hashmap key should be number");
      }
      return { kind: "TLBHashmapType", key, value, directStore: false };
    } else if (expr.name == "HashmapAugE") {
      if (expr.args.length != 3) {
        throw new Error("Not enough arguments for HashmapAugE");
      }
      let key = getType(expr.args[0], constructor, fieldTypeName);
      let value = getType(expr.args[1], constructor, fieldTypeName);
      let extra = getType(expr.args[2], constructor, fieldTypeName);
      if (key.kind != "TLBExprMathType") {
        throw new Error("Hashmap key should be number");
      }
      return { kind: "TLBHashmapType", key, value, extra, directStore: false };
    } else if (expr.name == "Hashmap" && constructor.tlbType != "HashmapNode") {
      let key = getType(expr.args[0], constructor, fieldTypeName);
      let value = getType(expr.args[1], constructor, fieldTypeName);
      if (key.kind != "TLBExprMathType") {
        throw new Error("Hashmap key should be number");
      }
      return { kind: "TLBHashmapType", key, value, directStore: true };
    } else if (expr.name == "VarUInteger" && (expr.args[0] instanceof distExports$1.MathExpr || expr.args[0] instanceof distExports$1.NumberExpr || expr.args[0] instanceof distExports$1.NameExpr)) {
      return {
        kind: "TLBVarIntegerType",
        n: new TLBUnaryOp(
          new TLBBinaryOp(convertToMathExpr(expr.args[0]), new TLBNumberExpr(1), "-"),
          "."
        ),
        signed: false
      };
    } else if (expr.name == "VarInteger" && (expr.args[0] instanceof distExports$1.MathExpr || expr.args[0] instanceof distExports$1.NumberExpr || expr.args[0] instanceof distExports$1.NameExpr)) {
      return {
        kind: "TLBVarIntegerType",
        n: convertToMathExpr(expr.args[0]),
        signed: true
      };
    } else {
      let argumentTypes = [];
      expr.args.forEach((arg) => {
        let thefield = getType(arg, constructor, fieldTypeName);
        argumentTypes.push(thefield);
      });
      return {
        kind: "TLBNamedType",
        name: expr.name,
        arguments: argumentTypes
      };
    }
  } else if (expr instanceof distExports$1.NameExpr) {
    let theNum;
    if (expr.name == "Int") {
      return {
        kind: "TLBNumberType",
        bits: new TLBNumberExpr(257),
        storeBits: new TLBNumberExpr(257),
        signed: true,
        maxBits: 257
      };
    } else if (expr.name == "VmStack") {
      return {
        kind: "TLBTupleType"
      };
    } else if (expr.name == "Bits") {
      return { kind: "TLBBitsType", bits: new TLBNumberExpr(1023) };
    } else if (expr.name == "Bit") {
      return { kind: "TLBBitsType", bits: new TLBNumberExpr(1) };
    } else if (expr.name == "Uint") {
      return {
        kind: "TLBNumberType",
        bits: new TLBNumberExpr(257),
        storeBits: new TLBNumberExpr(257),
        signed: false,
        maxBits: 257
      };
    } else if (expr.name == "Any" || expr.name == "Cell") {
      return { kind: "TLBCellType" };
    } else if ((theNum = splitForTypeValue(expr.name, "int")) != void 0) {
      return {
        kind: "TLBNumberType",
        bits: new TLBNumberExpr(theNum),
        storeBits: new TLBNumberExpr(theNum),
        signed: true,
        maxBits: theNum
      };
    } else if ((theNum = splitForTypeValue(expr.name, "uint")) != void 0) {
      return {
        kind: "TLBNumberType",
        bits: new TLBNumberExpr(theNum),
        storeBits: new TLBNumberExpr(theNum),
        signed: false,
        maxBits: theNum
      };
    } else if ((theNum = splitForTypeValue(expr.name, "bits")) != void 0) {
      return { kind: "TLBBitsType", bits: new TLBNumberExpr(theNum) };
    } else if (expr.name == "MsgAddressInt") {
      return { kind: "TLBAddressType", addrType: "Internal" };
    } else if (expr.name == "MsgAddressExt") {
      return { kind: "TLBAddressType", addrType: "External" };
    } else if (expr.name == "MsgAddress") {
      return { kind: "TLBAddressType", addrType: "Any" };
    } else if (expr.name == "Bit") {
      return { kind: "TLBBitsType", bits: new TLBNumberExpr(1) };
    } else if (expr.name == "Grams" || expr.name == "Coins") {
      return { kind: "TLBCoinsType" };
    } else if (expr.name == "Bool") {
      return { kind: "TLBBoolType", value: void 0 };
    } else if (expr.name == "BoolFalse") {
      return { kind: "TLBBoolType", value: false };
    } else if (expr.name == "BoolTrue") {
      return { kind: "TLBBoolType", value: true };
    } else {
      if (constructor.variablesMap.get(expr.name)?.type == "#") {
        return {
          kind: "TLBExprMathType",
          expr: getCalculatedExpression(new TLBVarExpr(expr.name), constructor),
          initialExpr: new TLBVarExpr(expr.name)
        };
      } else {
        return { kind: "TLBNamedType", name: expr.name, arguments: [] };
      }
    }
  } else if (expr instanceof distExports$1.NumberExpr) {
    return { kind: "TLBExprMathType", expr: new TLBNumberExpr(expr.num), initialExpr: new TLBNumberExpr(expr.num) };
  } else if (expr instanceof distExports$1.NegateExpr && expr.expr instanceof distExports$1.NameExpr) {
    return { kind: "TLBNegatedType", variableName: expr.expr.name };
  } else if (expr instanceof distExports$1.CellRefExpr) {
    let subExprInfo = getType(expr.expr, constructor, fieldTypeName);
    return { kind: "TLBCellInsideType", value: subExprInfo };
  } else if (expr instanceof distExports$1.MathExpr) {
    if (fieldTypeName == "") {
      if (expr.op == "*") {
        let subExprInfo = getType(expr.right, constructor, fieldTypeName);
        return {
          kind: "TLBMultipleType",
          times: getCalculatedExpression(
            convertToMathExpr(expr.left),
            constructor
          ),
          value: subExprInfo
        };
      } else {
        throw new Error(`Couldn't handle expression ${expr}`);
      }
    } else {
      return {
        kind: "TLBExprMathType",
        expr: getCalculatedExpression(convertToMathExpr(expr), constructor),
        initialExpr: convertToMathExpr(expr)
      };
    }
  } else if (expr instanceof distExports$1.CondExpr) {
    let subExprInfo = getType(expr.condExpr, constructor, fieldTypeName);
    if (expr.left instanceof distExports$1.NameExpr) {
      let condition = getCalculatedExpression(
        convertToMathExpr(expr.left),
        constructor
      );
      if (expr.dotExpr != null) {
        condition = new TLBBinaryOp(
          condition,
          new TLBBinaryOp(
            new TLBNumberExpr(1),
            new TLBNumberExpr(expr.dotExpr),
            "<<"
          ),
          "&"
        );
      }
      return { kind: "TLBCondType", value: subExprInfo, condition };
    }
  } else {
    throw new Error(`Couldn't handle expression ${expr}`);
  }
  throw new Error(`Couldn't handle expression ${expr}`);
}

function getField(field, constructor, fieldIndex) {
  if (field instanceof distExports$1.FieldAnonymousDef) {
    let result = {
      name: "",
      anonymous: true,
      fieldType: { kind: "TLBNamedType", name: "Bool", arguments: [] },
      subFields: []
    };
    let currentFieldIndex = 0;
    field.fields.forEach((field2) => {
      let subField = getField(
        field2,
        constructor,
        fieldIndex + "_" + currentFieldIndex.toString()
      );
      if (subField) {
        result.subFields.push(subField);
      }
      currentFieldIndex++;
    });
    return result;
  }
  if (field instanceof distExports$1.FieldNamedDef || field instanceof distExports$1.FieldExprDef) {
    let fieldName;
    if (field instanceof distExports$1.FieldNamedDef) {
      fieldName = field.name;
    } else {
      fieldName = "anon" + fieldIndex;
    }
    if (field instanceof distExports$1.FieldExprDef && field.expr instanceof distExports$1.NameExpr && field.expr.name == "_") {
      return void 0;
    }
    if (field.expr instanceof distExports$1.CellRefExpr) {
      if (field.expr.expr instanceof distExports$1.CombinatorExpr && (field.expr.expr.name == "MERKLE_UPDATE" || field.expr.expr.name == "MERKLE_ROOT")) {
        return {
          name: fieldName,
          anonymous: true,
          fieldType: { kind: "TLBExoticType" },
          subFields: []
        };
      } else {
        let subField = getField(
          new distExports$1.FieldNamedDef(fieldName, field.expr.expr),
          constructor,
          fieldIndex + "_0"
        );
        if (subField) {
          let result = {
            name: fieldName,
            anonymous: true,
            fieldType: { kind: "TLBNamedType", name: "Bool", arguments: [] },
            subFields: [subField]
          };
          return result;
        }
        return subField;
      }
    }
    if (field.expr instanceof distExports$1.CombinatorExpr || field.expr instanceof distExports$1.NameExpr || field.expr instanceof distExports$1.BuiltinZeroArgs || field.expr instanceof distExports$1.BuiltinOneArgExpr || field.expr instanceof distExports$1.MathExpr || field.expr instanceof distExports$1.CondExpr) {
      let fieldTypeName;
      if (field.expr instanceof distExports$1.MathExpr || field.expr instanceof distExports$1.CondExpr) {
        fieldTypeName = "";
      } else {
        fieldTypeName = field.expr.name;
      }
      let fieldInfo = getType(field.expr, constructor, fieldTypeName);
      return {
        name: fieldName,
        anonymous: !(field instanceof distExports$1.FieldNamedDef),
        fieldType: fieldInfo,
        subFields: []
      };
    }
  }
  return void 0;
}
function fillFields(typeItem, tlbType) {
  let constructor = typeItem.constructor;
  let declaration = typeItem.declaration;
  let fieldIndex = -1;
  declaration.fields.forEach((fieldDecl) => {
    fieldIndex++;
    let field = getField(fieldDecl, constructor, fieldIndex.toString());
    if (field != void 0) {
      constructor.fields.push(field);
    }
  });
}

function fillConstructors(declarations, tlbCode, input) {
  let typeDeclarations = /* @__PURE__ */ new Map();
  declarations.forEach((declaration) => {
    let tlbType = tlbCode.types.get(
      declaration.combinator.name
    );
    if (tlbType == void 0) {
      tlbType = { name: declaration.combinator.name, constructors: [] };
    }
    let constructor = {
      parameters: [],
      parametersMap: /* @__PURE__ */ new Map(),
      name: declaration.constructorDef.name,
      variables: new Array(),
      variablesMap: /* @__PURE__ */ new Map(),
      tag: getConstructorTag(declaration, input),
      constraints: [],
      fields: [],
      declaration: "",
      tlbType: tlbType.name
    };
    tlbType.constructors.push(constructor);
    tlbCode.types.set(tlbType.name, tlbType);
    let currentDecls = typeDeclarations.get(tlbType.name);
    if (!currentDecls) {
      currentDecls = [];
    }
    currentDecls.push({ declaration, constructor });
    typeDeclarations.set(tlbType.name, currentDecls);
  });
  tlbCode.types.forEach((tlbType) => {
    typeDeclarations.get(tlbType.name)?.forEach((typeItem) => {
      let declaration = typeItem.declaration;
      let constructor = typeItem.constructor;
      declaration.fields.forEach((field) => {
        if (field instanceof distExports$1.FieldBuiltinDef) {
          constructor.variables.push({
            name: field.name,
            isConst: false,
            negated: false,
            type: field.type,
            calculated: false,
            isField: false
          });
        }
        if (field instanceof distExports$1.FieldNamedDef) {
          constructor.variables.push({
            name: field.name,
            isConst: false,
            negated: false,
            type: "#",
            calculated: false,
            isField: true
          });
        }
      });
      constructor.variables.forEach((variable) => {
        if (variable.name) {
          constructor.variablesMap.set(variable.name, variable);
        }
      });
      let argumentIndex = -1;
      declaration.combinator.args.forEach((element) => {
        argumentIndex++;
        let parameter = void 0;
        if (element instanceof distExports$1.NameExpr) {
          let variable = constructor.variablesMap.get(element.name);
          if (variable) {
            if (variable.type == "#") {
              variable.deriveExpr = new TLBVarExpr(element.name);
              variable.initialExpr = variable.deriveExpr;
            }
            parameter = {
              variable,
              paramExpr: new TLBVarExpr(element.name)
            };
          } else {
            throw new Error(
              "Field not known before using (should be tagged as implicit): " + element
            );
          }
        } else if (element instanceof distExports$1.MathExpr) {
          let derivedExpr = deriveMathExpression(element);
          if (!derivedExpr.name) {
            throw new Error(`Expression should contain variable ${element}`);
          }
          let variable = constructor.variablesMap.get(derivedExpr.name);
          if (variable && variable.name) {
            parameter = { variable, paramExpr: derivedExpr.derived };
            parameter.argName = "arg" + argumentIndex;
            parameter.variable.deriveExpr = reorganizeWithArg(
              convertToMathExpr(element),
              parameter.argName,
              variable.name
            );
            parameter.variable.initialExpr = new TLBVarExpr(variable.name);
          } else {
            throw new Error(`Variable should have name ${variable}`);
          }
        } else if (element instanceof distExports$1.NegateExpr && (element.expr instanceof distExports$1.MathExpr || element.expr instanceof distExports$1.NumberExpr || element.expr instanceof distExports$1.NameExpr)) {
          let derivedExpr = deriveMathExpression(element.expr);
          let toBeConst = false;
          if (element.expr instanceof distExports$1.NumberExpr) {
            toBeConst = true;
          }
          if (derivedExpr.name == void 0) {
            if (toBeConst) {
              parameter = {
                variable: {
                  negated: true,
                  isConst: toBeConst,
                  type: "#",
                  name: void 0,
                  deriveExpr: derivedExpr.derived,
                  initialExpr: derivedExpr.derived,
                  calculated: false,
                  isField: false
                },
                paramExpr: derivedExpr.derived
              };
            } else {
              throw new Error("Cannot identify combinator arg " + element);
            }
          } else {
            let variable = constructor.variablesMap.get(derivedExpr.name);
            if (variable) {
              variable.negated = true;
              variable.isConst = toBeConst;
              variable.initialExpr = derivedExpr.derived;
              parameter = {
                variable,
                paramExpr: derivedExpr.derived
              };
            } else {
              throw new Error("Cannot identify combinator arg " + element);
            }
          }
        } else if (element instanceof distExports$1.NumberExpr) {
          parameter = {
            variable: {
              negated: false,
              isConst: true,
              type: "#",
              name: void 0,
              deriveExpr: new TLBNumberExpr(element.num),
              initialExpr: new TLBNumberExpr(element.num),
              calculated: false,
              isField: false
            },
            paramExpr: new TLBNumberExpr(element.num)
          };
        } else {
          throw new Error("Cannot identify combinator arg: " + element);
        }
        constructor.parameters.push(parameter);
        if (parameter.variable.name != void 0) {
          constructor.parametersMap.set(parameter.variable.name, parameter);
        }
      });
      constructor.declaration = getStringDeclaration(declaration, input);
      fillConstraintsAndNegationVars(constructor, declaration);
      fillFields(typeItem);
      calculateVariables(constructor);
    });
    fillParameterNames(tlbType);
    fillArgNames(tlbType);
    findConstructorsNaming(tlbType);
    tlbType.constructors.sort(compareConstructors);
  });
  checkAndRemovePrimitives(tlbCode, input, typeDeclarations);
  findAvailableVarNamesForCode(tlbCode);
}
function fillConstraintsAndNegationVars(constructor, declaration) {
  declaration.fields.forEach((field) => {
    if (field instanceof distExports$1.FieldCurlyExprDef && field.expr instanceof distExports$1.CompareExpr) {
      if (field.expr.op == "=") {
        let myMathExpr = convertToMathExpr(field.expr);
        let negatedVariable = getNegatedVariable(myMathExpr);
        if (negatedVariable) {
          myMathExpr = reorganizeExpression(myMathExpr, negatedVariable);
          if (myMathExpr instanceof TLBBinaryOp) {
            myMathExpr = myMathExpr.right;
          }
          let variable = constructor.variablesMap.get(negatedVariable);
          if (variable) {
            variable.negated = true;
            variable.deriveExpr = myMathExpr;
          } else {
            throw new Error(`Variable ${negatedVariable} not defined`);
          }
        } else {
          constructor.constraints.push(myMathExpr);
        }
      } else {
        constructor.constraints.push(convertToMathExpr(field.expr));
      }
    }
  });
}
function fillParameterNames(tlbType) {
  let parameterNames = [];
  tlbType.constructors[0]?.parameters.forEach((element) => {
    parameterNames.push(element.variable.name);
  });
  tlbType.constructors.forEach((constructor) => {
    for (let i = 0; i < constructor.parameters.length; i++) {
      if (parameterNames[i] == void 0) {
        let parameterName = constructor.parameters[i]?.variable.name;
        if (parameterName != void 0) {
          parameterNames[i] = parameterName;
        }
      }
    }
  });
  for (let i = 0; i < parameterNames.length; i++) {
    if (parameterNames[i] == void 0) {
      parameterNames[i] = "arg" + i;
    }
  }
  tlbType.constructors.forEach((constructor) => {
    for (let i = 0; i < constructor.parameters.length; i++) {
      let parameterName = parameterNames[i];
      if (parameterName != void 0 && constructor.parameters[i]?.variable.name == void 0) {
        constructor.parameters[i].variable.name = parameterName;
      }
    }
  });
}
function fillArgNames(tlbType) {
  let argNames = [];
  tlbType.constructors[0]?.parameters.forEach((element) => {
    argNames.push(void 0);
  });
  tlbType.constructors.forEach((constructor) => {
    for (let i = 0; i < constructor.parameters.length; i++) {
      let argName = constructor.parameters[i]?.argName;
      if (argName) {
        argNames[i] = argName;
      }
    }
  });
  tlbType.constructors.forEach((constructor) => {
    for (let i = 0; i < constructor.parameters.length; i++) {
      let argName = argNames[i];
      let parameter = constructor.parameters[i];
      if (argName != void 0 && parameter != void 0) {
        parameter.argName = argName;
        if (parameter.paramExpr instanceof TLBVarExpr) {
          parameter.variable.deriveExpr = new TLBVarExpr(parameter.argName);
          parameter.paramExpr = parameter.variable.deriveExpr;
        }
      }
    }
  });
}
function compareConstructors(a, b) {
  let aPriority = constructorPriority(a);
  let bPriority = constructorPriority(b);
  if (aPriority < bPriority) {
    return 1;
  }
  if (aPriority > bPriority) {
    return -1;
  }
  return 0;
}
function constructorPriority(c) {
  let result = 0;
  if (c.tag.bitLen > 0) {
    result++;
  }
  c.parameters.forEach((parameter) => {
    if (parameter.variable.isConst) {
      result++;
    }
  });
  return result;
}
function reorganizeWithArg(mathExpr, argName, varName) {
  let reorganized = reorganizeExpression(
    new TLBBinaryOp(
      new TLBVarExpr(argName),
      mathExpr,
      "=",
      /* @__PURE__ */ new Set(),
      false
    ),
    varName
  );
  if (reorganized instanceof TLBBinaryOp) {
    return reorganized.right;
  }
  throw new Error(`Couldn't reorganize expression ${mathExpr}`);
}
function getConstructorTag(declaration, input) {
  let tag = declaration.constructorDef.tag;
  if (tag == null && declaration.constructorDef.name == "_" || tag && tag.length > 1 && tag[1] == "_") {
    return {
      bitLen: 0,
      binary: ""
    };
  }
  if (tag == null) {
    let opCode = calculateOpcode(declaration, input);
    return {
      bitLen: 32,
      binary: "0x" + opCode
    };
  }
  if (tag[0] == "$") {
    return {
      bitLen: tag?.length - 1,
      binary: "0b" + tag.slice(1)
    };
  }
  if (tag[0] == "#") {
    return {
      bitLen: (tag?.length - 1) * 4,
      binary: "0x" + tag.slice(1)
    };
  }
  throw new Error("Unknown tag " + tag);
}
function findConstructorsNaming(tlbType) {
  let constructorNames = /* @__PURE__ */ new Set();
  let constructorIndex = 0;
  tlbType.constructors.forEach((current) => {
    while (constructorNames.has(current.name)) {
      current.name += constructorIndex.toString();
    }
    constructorNames.add(current.name);
    constructorIndex++;
  });
}
function checkAndRemovePrimitives(tlbCode, input, typeDeclarations) {
  let toDelete = [];
  let typesToDelete = /* @__PURE__ */ new Map();
  typesToDelete.set("Bool", ["4702fd23", "f0e8d7f"]);
  typesToDelete.set("MsgAddressInt", ["d7b672a", "6d593e8a"]);
  typesToDelete.set("Bit", ["2873c6f5"]);
  typesToDelete.set("Grams", ["2f73160b"]);
  typesToDelete.set("MsgAddressExt", ["44163e94", "2e933043"]);
  typesToDelete.set("MsgAddress", ["606aa05e", "21d0382b"]);
  typesToDelete.set("VarUInteger", ["11d56c2e"]);
  typesToDelete.set("VarInteger", ["d466ed5"]);
  typesToDelete.set("HashmapE", ["32bae5cb", "28fa3979"]);
  typesToDelete.set("HashmapAugE", ["36820dce", "5f71ac75"]);
  typesToDelete.set("BoolTrue", ["943ebb5"]);
  typesToDelete.set("BoolFalse", ["1f5e497d"]);
  typesToDelete.forEach((opCodesExpected, typeName) => {
    let typeItems = typeDeclarations.get(typeName);
    if (typeItems) {
      let opCodesActual = [];
      typeItems.forEach((typeItem) => {
        opCodesActual.push(calculateOpcode(typeItem.declaration, input));
      });
      if (!opCodeSetsEqual(opCodesExpected, opCodesActual)) {
        throw new Error("Bool primitive type is not correct in scheme");
      }
      toDelete.push(typeName);
    }
  });
  toDelete.forEach((name) => {
    tlbCode.types.delete(name);
  });
}
function findAvailableVarNamesForCode(tlbCode) {
  tlbCode.types.forEach((tlbType) => {
    tlbType.constructors.forEach((constructor) => {
      let variablesSet = /* @__PURE__ */ new Set();
      findAvailableFieldsNames(constructor.fields, variablesSet);
    });
  });
}
function findAvailableFieldsNames(fields, variablesSet) {
  fields.forEach((field) => {
    if (field.subFields.length == 0) {
      findAvailableFieldName(field, variablesSet);
    }
    findAvailableFieldsNames(field.subFields, variablesSet);
  });
}
function findAvailableFieldName(field, variablesSet) {
  let index = 0;
  field.name = findNotReservedName(field.name);
  while (variablesSet.has(field.name)) {
    field.name = findNotReservedName(field.name + "_" + index);
    index++;
  }
  variablesSet.add(field.name);
}
function convertCodeToReadonly(tlbCode) {
  let newTypes = /* @__PURE__ */ new Map();
  tlbCode.types.forEach((value, key) => {
    let newConstructors = new Array();
    value.constructors.forEach((value2) => {
      let newVariablesMap = /* @__PURE__ */ new Map();
      value2.variablesMap.forEach((value3, key2) => {
        newVariablesMap.set(key2, convertVariableToReadonly(value3));
      });
      let newParametersMap = /* @__PURE__ */ new Map();
      value2.parametersMap.forEach((value3, key2) => {
        newParametersMap.set(key2, convertParameterToReadonly(value3));
      });
      let newConstructor = new TLBConstructor(
        value2.parameters.map(convertParameterToReadonly),
        value2.variables.map(convertVariableToReadonly),
        newVariablesMap,
        newParametersMap,
        value2.name,
        value2.fields,
        value2.tag,
        value2.constraints,
        value2.declaration,
        value2.tlbType
      );
      newConstructors.push(newConstructor);
    });
    let newType = new TLBType(value.name, newConstructors);
    newTypes.set(key, newType);
  });
  return new TLBCode(newTypes);
}
function convertParameterToReadonly(tlbParameter) {
  return new TLBParameter(
    convertVariableToReadonly(tlbParameter.variable),
    tlbParameter.paramExpr,
    tlbParameter.argName
  );
}
function convertVariableToReadonly(tlbVariable) {
  if (tlbVariable.name == void 0) {
    throw new Error("Variable is undefined");
  }
  return new TLBVariable(
    tlbVariable.isConst,
    tlbVariable.negated,
    tlbVariable.type,
    tlbVariable.name,
    tlbVariable.isField,
    tlbVariable.deriveExpr,
    tlbVariable.initialExpr
  );
}
function calculateOpcode(declaration, input) {
  let scheme = getStringDeclaration(declaration, input);
  let constructor = scheme.substring(0, scheme.indexOf(" "));
  const rest = scheme.substring(scheme.indexOf(" "));
  if (constructor.includes("#")) {
    constructor = constructor.substring(0, constructor.indexOf("#"));
  }
  scheme = constructor + " " + rest.replace(/\(/g, "").replace(/\)/g, "").replace(/\s+/g, " ").replace(/;/g, "").trim();
  return (BigInt(crc32Exports.str(scheme)) & BigInt(2147483647)).toString(16);
}
function getStringDeclaration(declaration, input) {
  let result = "";
  let splittedInput = input;
  let currentLine = declaration.locations.line - 1;
  let currentColumn = 0;
  while (!splittedInput[currentLine]?.includes(";")) {
    result += splittedInput[currentLine]?.substring(currentColumn) + "\n";
    currentLine++;
    currentColumn = 0;
  }
  let currentInput = splittedInput[currentLine];
  if (currentInput) {
    result += currentInput.substring(
      currentColumn,
      currentInput.indexOf(";") + 1
    );
  }
  return result;
}
function calculateVariables(constructor) {
  constructor.variables.forEach((variable) => {
    calculateVariable(variable, constructor);
  });
  constructor.parameters.forEach((parameter) => {
    calculateVariable(parameter.variable, constructor);
  });
}

function getTLBCodeByAST(tree, input) {
  let oldTlbCode = { types: /* @__PURE__ */ new Map() };
  let splittedInput = input.split("\n");
  fillConstructors(tree.declarations, oldTlbCode, splittedInput);
  let tlbCode = convertCodeToReadonly(oldTlbCode);
  return tlbCode;
}

var buffer = {};

var base64Js = {};

var hasRequiredBase64Js;

function requireBase64Js () {
	if (hasRequiredBase64Js) return base64Js;
	hasRequiredBase64Js = 1;

	base64Js.byteLength = byteLength;
	base64Js.toByteArray = toByteArray;
	base64Js.fromByteArray = fromByteArray;

	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i];
	  revLookup[code.charCodeAt(i)] = i;
	}

	// Support decoding URL-safe base64 strings, as Node.js does.
	// See: https://en.wikipedia.org/wiki/Base64#URL_applications
	revLookup['-'.charCodeAt(0)] = 62;
	revLookup['_'.charCodeAt(0)] = 63;

	function getLens (b64) {
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // Trim off extra bytes after placeholder bytes are found
	  // See: https://github.com/beatgammit/base64-js/issues/42
	  var validLen = b64.indexOf('=');
	  if (validLen === -1) validLen = len;

	  var placeHoldersLen = validLen === len
	    ? 0
	    : 4 - (validLen % 4);

	  return [validLen, placeHoldersLen]
	}

	// base64 is 4/3 + up to two characters of the original data
	function byteLength (b64) {
	  var lens = getLens(b64);
	  var validLen = lens[0];
	  var placeHoldersLen = lens[1];
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}

	function _byteLength (b64, validLen, placeHoldersLen) {
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}

	function toByteArray (b64) {
	  var tmp;
	  var lens = getLens(b64);
	  var validLen = lens[0];
	  var placeHoldersLen = lens[1];

	  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

	  var curByte = 0;

	  // if there are placeholders, only get up to the last complete 4 chars
	  var len = placeHoldersLen > 0
	    ? validLen - 4
	    : validLen;

	  var i;
	  for (i = 0; i < len; i += 4) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 18) |
	      (revLookup[b64.charCodeAt(i + 1)] << 12) |
	      (revLookup[b64.charCodeAt(i + 2)] << 6) |
	      revLookup[b64.charCodeAt(i + 3)];
	    arr[curByte++] = (tmp >> 16) & 0xFF;
	    arr[curByte++] = (tmp >> 8) & 0xFF;
	    arr[curByte++] = tmp & 0xFF;
	  }

	  if (placeHoldersLen === 2) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 2) |
	      (revLookup[b64.charCodeAt(i + 1)] >> 4);
	    arr[curByte++] = tmp & 0xFF;
	  }

	  if (placeHoldersLen === 1) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 10) |
	      (revLookup[b64.charCodeAt(i + 1)] << 4) |
	      (revLookup[b64.charCodeAt(i + 2)] >> 2);
	    arr[curByte++] = (tmp >> 8) & 0xFF;
	    arr[curByte++] = tmp & 0xFF;
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] +
	    lookup[num >> 12 & 0x3F] +
	    lookup[num >> 6 & 0x3F] +
	    lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp =
	      ((uint8[i] << 16) & 0xFF0000) +
	      ((uint8[i + 1] << 8) & 0xFF00) +
	      (uint8[i + 2] & 0xFF);
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    parts.push(
	      lookup[tmp >> 2] +
	      lookup[(tmp << 4) & 0x3F] +
	      '=='
	    );
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
	    parts.push(
	      lookup[tmp >> 10] +
	      lookup[(tmp >> 4) & 0x3F] +
	      lookup[(tmp << 2) & 0x3F] +
	      '='
	    );
	  }

	  return parts.join('')
	}
	return base64Js;
}

var ieee754 = {};

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredIeee754;

function requireIeee754 () {
	if (hasRequiredIeee754) return ieee754;
	hasRequiredIeee754 = 1;
	ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = (nBytes * 8) - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	};

	ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = (nBytes * 8) - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = ((value * c) - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	};
	return ieee754;
}

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

var hasRequiredBuffer;

function requireBuffer () {
	if (hasRequiredBuffer) return buffer;
	hasRequiredBuffer = 1;
	(function (exports) {

		var base64 = requireBase64Js();
		var ieee754 = requireIeee754();
		var customInspectSymbol =
		  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
		    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
		    : null;

		exports.Buffer = Buffer;
		exports.SlowBuffer = SlowBuffer;
		exports.INSPECT_MAX_BYTES = 50;

		var K_MAX_LENGTH = 0x7fffffff;
		exports.kMaxLength = K_MAX_LENGTH;

		/**
		 * If `Buffer.TYPED_ARRAY_SUPPORT`:
		 *   === true    Use Uint8Array implementation (fastest)
		 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
		 *               implementation (most compatible, even IE6)
		 *
		 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
		 * Opera 11.6+, iOS 4.2+.
		 *
		 * We report that the browser does not support typed arrays if the are not subclassable
		 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
		 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
		 * for __proto__ and has a buggy typed array implementation.
		 */
		Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

		if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
		    typeof console.error === 'function') {
		  console.error(
		    'This browser lacks typed array (Uint8Array) support which is required by ' +
		    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
		  );
		}

		function typedArraySupport () {
		  // Can typed array instances can be augmented?
		  try {
		    var arr = new Uint8Array(1);
		    var proto = { foo: function () { return 42 } };
		    Object.setPrototypeOf(proto, Uint8Array.prototype);
		    Object.setPrototypeOf(arr, proto);
		    return arr.foo() === 42
		  } catch (e) {
		    return false
		  }
		}

		Object.defineProperty(Buffer.prototype, 'parent', {
		  enumerable: true,
		  get: function () {
		    if (!Buffer.isBuffer(this)) return undefined
		    return this.buffer
		  }
		});

		Object.defineProperty(Buffer.prototype, 'offset', {
		  enumerable: true,
		  get: function () {
		    if (!Buffer.isBuffer(this)) return undefined
		    return this.byteOffset
		  }
		});

		function createBuffer (length) {
		  if (length > K_MAX_LENGTH) {
		    throw new RangeError('The value "' + length + '" is invalid for option "size"')
		  }
		  // Return an augmented `Uint8Array` instance
		  var buf = new Uint8Array(length);
		  Object.setPrototypeOf(buf, Buffer.prototype);
		  return buf
		}

		/**
		 * The Buffer constructor returns instances of `Uint8Array` that have their
		 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
		 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
		 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
		 * returns a single octet.
		 *
		 * The `Uint8Array` prototype remains unmodified.
		 */

		function Buffer (arg, encodingOrOffset, length) {
		  // Common case.
		  if (typeof arg === 'number') {
		    if (typeof encodingOrOffset === 'string') {
		      throw new TypeError(
		        'The "string" argument must be of type string. Received type number'
		      )
		    }
		    return allocUnsafe(arg)
		  }
		  return from(arg, encodingOrOffset, length)
		}

		Buffer.poolSize = 8192; // not used by this implementation

		function from (value, encodingOrOffset, length) {
		  if (typeof value === 'string') {
		    return fromString(value, encodingOrOffset)
		  }

		  if (ArrayBuffer.isView(value)) {
		    return fromArrayView(value)
		  }

		  if (value == null) {
		    throw new TypeError(
		      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
		      'or Array-like Object. Received type ' + (typeof value)
		    )
		  }

		  if (isInstance(value, ArrayBuffer) ||
		      (value && isInstance(value.buffer, ArrayBuffer))) {
		    return fromArrayBuffer(value, encodingOrOffset, length)
		  }

		  if (typeof SharedArrayBuffer !== 'undefined' &&
		      (isInstance(value, SharedArrayBuffer) ||
		      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
		    return fromArrayBuffer(value, encodingOrOffset, length)
		  }

		  if (typeof value === 'number') {
		    throw new TypeError(
		      'The "value" argument must not be of type number. Received type number'
		    )
		  }

		  var valueOf = value.valueOf && value.valueOf();
		  if (valueOf != null && valueOf !== value) {
		    return Buffer.from(valueOf, encodingOrOffset, length)
		  }

		  var b = fromObject(value);
		  if (b) return b

		  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
		      typeof value[Symbol.toPrimitive] === 'function') {
		    return Buffer.from(
		      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
		    )
		  }

		  throw new TypeError(
		    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
		    'or Array-like Object. Received type ' + (typeof value)
		  )
		}

		/**
		 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
		 * if value is a number.
		 * Buffer.from(str[, encoding])
		 * Buffer.from(array)
		 * Buffer.from(buffer)
		 * Buffer.from(arrayBuffer[, byteOffset[, length]])
		 **/
		Buffer.from = function (value, encodingOrOffset, length) {
		  return from(value, encodingOrOffset, length)
		};

		// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
		// https://github.com/feross/buffer/pull/148
		Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
		Object.setPrototypeOf(Buffer, Uint8Array);

		function assertSize (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('"size" argument must be of type number')
		  } else if (size < 0) {
		    throw new RangeError('The value "' + size + '" is invalid for option "size"')
		  }
		}

		function alloc (size, fill, encoding) {
		  assertSize(size);
		  if (size <= 0) {
		    return createBuffer(size)
		  }
		  if (fill !== undefined) {
		    // Only pay attention to encoding if it's a string. This
		    // prevents accidentally sending in a number that would
		    // be interpreted as a start offset.
		    return typeof encoding === 'string'
		      ? createBuffer(size).fill(fill, encoding)
		      : createBuffer(size).fill(fill)
		  }
		  return createBuffer(size)
		}

		/**
		 * Creates a new filled Buffer instance.
		 * alloc(size[, fill[, encoding]])
		 **/
		Buffer.alloc = function (size, fill, encoding) {
		  return alloc(size, fill, encoding)
		};

		function allocUnsafe (size) {
		  assertSize(size);
		  return createBuffer(size < 0 ? 0 : checked(size) | 0)
		}

		/**
		 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
		 * */
		Buffer.allocUnsafe = function (size) {
		  return allocUnsafe(size)
		};
		/**
		 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
		 */
		Buffer.allocUnsafeSlow = function (size) {
		  return allocUnsafe(size)
		};

		function fromString (string, encoding) {
		  if (typeof encoding !== 'string' || encoding === '') {
		    encoding = 'utf8';
		  }

		  if (!Buffer.isEncoding(encoding)) {
		    throw new TypeError('Unknown encoding: ' + encoding)
		  }

		  var length = byteLength(string, encoding) | 0;
		  var buf = createBuffer(length);

		  var actual = buf.write(string, encoding);

		  if (actual !== length) {
		    // Writing a hex string, for example, that contains invalid characters will
		    // cause everything after the first invalid character to be ignored. (e.g.
		    // 'abxxcd' will be treated as 'ab')
		    buf = buf.slice(0, actual);
		  }

		  return buf
		}

		function fromArrayLike (array) {
		  var length = array.length < 0 ? 0 : checked(array.length) | 0;
		  var buf = createBuffer(length);
		  for (var i = 0; i < length; i += 1) {
		    buf[i] = array[i] & 255;
		  }
		  return buf
		}

		function fromArrayView (arrayView) {
		  if (isInstance(arrayView, Uint8Array)) {
		    var copy = new Uint8Array(arrayView);
		    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
		  }
		  return fromArrayLike(arrayView)
		}

		function fromArrayBuffer (array, byteOffset, length) {
		  if (byteOffset < 0 || array.byteLength < byteOffset) {
		    throw new RangeError('"offset" is outside of buffer bounds')
		  }

		  if (array.byteLength < byteOffset + (length || 0)) {
		    throw new RangeError('"length" is outside of buffer bounds')
		  }

		  var buf;
		  if (byteOffset === undefined && length === undefined) {
		    buf = new Uint8Array(array);
		  } else if (length === undefined) {
		    buf = new Uint8Array(array, byteOffset);
		  } else {
		    buf = new Uint8Array(array, byteOffset, length);
		  }

		  // Return an augmented `Uint8Array` instance
		  Object.setPrototypeOf(buf, Buffer.prototype);

		  return buf
		}

		function fromObject (obj) {
		  if (Buffer.isBuffer(obj)) {
		    var len = checked(obj.length) | 0;
		    var buf = createBuffer(len);

		    if (buf.length === 0) {
		      return buf
		    }

		    obj.copy(buf, 0, 0, len);
		    return buf
		  }

		  if (obj.length !== undefined) {
		    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
		      return createBuffer(0)
		    }
		    return fromArrayLike(obj)
		  }

		  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
		    return fromArrayLike(obj.data)
		  }
		}

		function checked (length) {
		  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
		  // length is NaN (which is otherwise coerced to zero.)
		  if (length >= K_MAX_LENGTH) {
		    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
		                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
		  }
		  return length | 0
		}

		function SlowBuffer (length) {
		  if (+length != length) { // eslint-disable-line eqeqeq
		    length = 0;
		  }
		  return Buffer.alloc(+length)
		}

		Buffer.isBuffer = function isBuffer (b) {
		  return b != null && b._isBuffer === true &&
		    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
		};

		Buffer.compare = function compare (a, b) {
		  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
		  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
		  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
		    throw new TypeError(
		      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
		    )
		  }

		  if (a === b) return 0

		  var x = a.length;
		  var y = b.length;

		  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
		    if (a[i] !== b[i]) {
		      x = a[i];
		      y = b[i];
		      break
		    }
		  }

		  if (x < y) return -1
		  if (y < x) return 1
		  return 0
		};

		Buffer.isEncoding = function isEncoding (encoding) {
		  switch (String(encoding).toLowerCase()) {
		    case 'hex':
		    case 'utf8':
		    case 'utf-8':
		    case 'ascii':
		    case 'latin1':
		    case 'binary':
		    case 'base64':
		    case 'ucs2':
		    case 'ucs-2':
		    case 'utf16le':
		    case 'utf-16le':
		      return true
		    default:
		      return false
		  }
		};

		Buffer.concat = function concat (list, length) {
		  if (!Array.isArray(list)) {
		    throw new TypeError('"list" argument must be an Array of Buffers')
		  }

		  if (list.length === 0) {
		    return Buffer.alloc(0)
		  }

		  var i;
		  if (length === undefined) {
		    length = 0;
		    for (i = 0; i < list.length; ++i) {
		      length += list[i].length;
		    }
		  }

		  var buffer = Buffer.allocUnsafe(length);
		  var pos = 0;
		  for (i = 0; i < list.length; ++i) {
		    var buf = list[i];
		    if (isInstance(buf, Uint8Array)) {
		      if (pos + buf.length > buffer.length) {
		        Buffer.from(buf).copy(buffer, pos);
		      } else {
		        Uint8Array.prototype.set.call(
		          buffer,
		          buf,
		          pos
		        );
		      }
		    } else if (!Buffer.isBuffer(buf)) {
		      throw new TypeError('"list" argument must be an Array of Buffers')
		    } else {
		      buf.copy(buffer, pos);
		    }
		    pos += buf.length;
		  }
		  return buffer
		};

		function byteLength (string, encoding) {
		  if (Buffer.isBuffer(string)) {
		    return string.length
		  }
		  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
		    return string.byteLength
		  }
		  if (typeof string !== 'string') {
		    throw new TypeError(
		      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
		      'Received type ' + typeof string
		    )
		  }

		  var len = string.length;
		  var mustMatch = (arguments.length > 2 && arguments[2] === true);
		  if (!mustMatch && len === 0) return 0

		  // Use a for loop to avoid recursion
		  var loweredCase = false;
		  for (;;) {
		    switch (encoding) {
		      case 'ascii':
		      case 'latin1':
		      case 'binary':
		        return len
		      case 'utf8':
		      case 'utf-8':
		        return utf8ToBytes(string).length
		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return len * 2
		      case 'hex':
		        return len >>> 1
		      case 'base64':
		        return base64ToBytes(string).length
		      default:
		        if (loweredCase) {
		          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
		        }
		        encoding = ('' + encoding).toLowerCase();
		        loweredCase = true;
		    }
		  }
		}
		Buffer.byteLength = byteLength;

		function slowToString (encoding, start, end) {
		  var loweredCase = false;

		  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
		  // property of a typed array.

		  // This behaves neither like String nor Uint8Array in that we set start/end
		  // to their upper/lower bounds if the value passed is out of range.
		  // undefined is handled specially as per ECMA-262 6th Edition,
		  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
		  if (start === undefined || start < 0) {
		    start = 0;
		  }
		  // Return early if start > this.length. Done here to prevent potential uint32
		  // coercion fail below.
		  if (start > this.length) {
		    return ''
		  }

		  if (end === undefined || end > this.length) {
		    end = this.length;
		  }

		  if (end <= 0) {
		    return ''
		  }

		  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
		  end >>>= 0;
		  start >>>= 0;

		  if (end <= start) {
		    return ''
		  }

		  if (!encoding) encoding = 'utf8';

		  while (true) {
		    switch (encoding) {
		      case 'hex':
		        return hexSlice(this, start, end)

		      case 'utf8':
		      case 'utf-8':
		        return utf8Slice(this, start, end)

		      case 'ascii':
		        return asciiSlice(this, start, end)

		      case 'latin1':
		      case 'binary':
		        return latin1Slice(this, start, end)

		      case 'base64':
		        return base64Slice(this, start, end)

		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return utf16leSlice(this, start, end)

		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = (encoding + '').toLowerCase();
		        loweredCase = true;
		    }
		  }
		}

		// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
		// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
		// reliably in a browserify context because there could be multiple different
		// copies of the 'buffer' package in use. This method works even for Buffer
		// instances that were created from another copy of the `buffer` package.
		// See: https://github.com/feross/buffer/issues/154
		Buffer.prototype._isBuffer = true;

		function swap (b, n, m) {
		  var i = b[n];
		  b[n] = b[m];
		  b[m] = i;
		}

		Buffer.prototype.swap16 = function swap16 () {
		  var len = this.length;
		  if (len % 2 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 16-bits')
		  }
		  for (var i = 0; i < len; i += 2) {
		    swap(this, i, i + 1);
		  }
		  return this
		};

		Buffer.prototype.swap32 = function swap32 () {
		  var len = this.length;
		  if (len % 4 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 32-bits')
		  }
		  for (var i = 0; i < len; i += 4) {
		    swap(this, i, i + 3);
		    swap(this, i + 1, i + 2);
		  }
		  return this
		};

		Buffer.prototype.swap64 = function swap64 () {
		  var len = this.length;
		  if (len % 8 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 64-bits')
		  }
		  for (var i = 0; i < len; i += 8) {
		    swap(this, i, i + 7);
		    swap(this, i + 1, i + 6);
		    swap(this, i + 2, i + 5);
		    swap(this, i + 3, i + 4);
		  }
		  return this
		};

		Buffer.prototype.toString = function toString () {
		  var length = this.length;
		  if (length === 0) return ''
		  if (arguments.length === 0) return utf8Slice(this, 0, length)
		  return slowToString.apply(this, arguments)
		};

		Buffer.prototype.toLocaleString = Buffer.prototype.toString;

		Buffer.prototype.equals = function equals (b) {
		  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
		  if (this === b) return true
		  return Buffer.compare(this, b) === 0
		};

		Buffer.prototype.inspect = function inspect () {
		  var str = '';
		  var max = exports.INSPECT_MAX_BYTES;
		  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
		  if (this.length > max) str += ' ... ';
		  return '<Buffer ' + str + '>'
		};
		if (customInspectSymbol) {
		  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
		}

		Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
		  if (isInstance(target, Uint8Array)) {
		    target = Buffer.from(target, target.offset, target.byteLength);
		  }
		  if (!Buffer.isBuffer(target)) {
		    throw new TypeError(
		      'The "target" argument must be one of type Buffer or Uint8Array. ' +
		      'Received type ' + (typeof target)
		    )
		  }

		  if (start === undefined) {
		    start = 0;
		  }
		  if (end === undefined) {
		    end = target ? target.length : 0;
		  }
		  if (thisStart === undefined) {
		    thisStart = 0;
		  }
		  if (thisEnd === undefined) {
		    thisEnd = this.length;
		  }

		  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
		    throw new RangeError('out of range index')
		  }

		  if (thisStart >= thisEnd && start >= end) {
		    return 0
		  }
		  if (thisStart >= thisEnd) {
		    return -1
		  }
		  if (start >= end) {
		    return 1
		  }

		  start >>>= 0;
		  end >>>= 0;
		  thisStart >>>= 0;
		  thisEnd >>>= 0;

		  if (this === target) return 0

		  var x = thisEnd - thisStart;
		  var y = end - start;
		  var len = Math.min(x, y);

		  var thisCopy = this.slice(thisStart, thisEnd);
		  var targetCopy = target.slice(start, end);

		  for (var i = 0; i < len; ++i) {
		    if (thisCopy[i] !== targetCopy[i]) {
		      x = thisCopy[i];
		      y = targetCopy[i];
		      break
		    }
		  }

		  if (x < y) return -1
		  if (y < x) return 1
		  return 0
		};

		// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
		// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
		//
		// Arguments:
		// - buffer - a Buffer to search
		// - val - a string, Buffer, or number
		// - byteOffset - an index into `buffer`; will be clamped to an int32
		// - encoding - an optional encoding, relevant is val is a string
		// - dir - true for indexOf, false for lastIndexOf
		function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
		  // Empty buffer means no match
		  if (buffer.length === 0) return -1

		  // Normalize byteOffset
		  if (typeof byteOffset === 'string') {
		    encoding = byteOffset;
		    byteOffset = 0;
		  } else if (byteOffset > 0x7fffffff) {
		    byteOffset = 0x7fffffff;
		  } else if (byteOffset < -2147483648) {
		    byteOffset = -2147483648;
		  }
		  byteOffset = +byteOffset; // Coerce to Number.
		  if (numberIsNaN(byteOffset)) {
		    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
		    byteOffset = dir ? 0 : (buffer.length - 1);
		  }

		  // Normalize byteOffset: negative offsets start from the end of the buffer
		  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
		  if (byteOffset >= buffer.length) {
		    if (dir) return -1
		    else byteOffset = buffer.length - 1;
		  } else if (byteOffset < 0) {
		    if (dir) byteOffset = 0;
		    else return -1
		  }

		  // Normalize val
		  if (typeof val === 'string') {
		    val = Buffer.from(val, encoding);
		  }

		  // Finally, search either indexOf (if dir is true) or lastIndexOf
		  if (Buffer.isBuffer(val)) {
		    // Special case: looking for empty string/buffer always fails
		    if (val.length === 0) {
		      return -1
		    }
		    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
		  } else if (typeof val === 'number') {
		    val = val & 0xFF; // Search for a byte value [0-255]
		    if (typeof Uint8Array.prototype.indexOf === 'function') {
		      if (dir) {
		        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
		      } else {
		        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
		      }
		    }
		    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
		  }

		  throw new TypeError('val must be string, number or Buffer')
		}

		function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
		  var indexSize = 1;
		  var arrLength = arr.length;
		  var valLength = val.length;

		  if (encoding !== undefined) {
		    encoding = String(encoding).toLowerCase();
		    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
		        encoding === 'utf16le' || encoding === 'utf-16le') {
		      if (arr.length < 2 || val.length < 2) {
		        return -1
		      }
		      indexSize = 2;
		      arrLength /= 2;
		      valLength /= 2;
		      byteOffset /= 2;
		    }
		  }

		  function read (buf, i) {
		    if (indexSize === 1) {
		      return buf[i]
		    } else {
		      return buf.readUInt16BE(i * indexSize)
		    }
		  }

		  var i;
		  if (dir) {
		    var foundIndex = -1;
		    for (i = byteOffset; i < arrLength; i++) {
		      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
		        if (foundIndex === -1) foundIndex = i;
		        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
		      } else {
		        if (foundIndex !== -1) i -= i - foundIndex;
		        foundIndex = -1;
		      }
		    }
		  } else {
		    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
		    for (i = byteOffset; i >= 0; i--) {
		      var found = true;
		      for (var j = 0; j < valLength; j++) {
		        if (read(arr, i + j) !== read(val, j)) {
		          found = false;
		          break
		        }
		      }
		      if (found) return i
		    }
		  }

		  return -1
		}

		Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
		  return this.indexOf(val, byteOffset, encoding) !== -1
		};

		Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
		  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
		};

		Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
		  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
		};

		function hexWrite (buf, string, offset, length) {
		  offset = Number(offset) || 0;
		  var remaining = buf.length - offset;
		  if (!length) {
		    length = remaining;
		  } else {
		    length = Number(length);
		    if (length > remaining) {
		      length = remaining;
		    }
		  }

		  var strLen = string.length;

		  if (length > strLen / 2) {
		    length = strLen / 2;
		  }
		  for (var i = 0; i < length; ++i) {
		    var parsed = parseInt(string.substr(i * 2, 2), 16);
		    if (numberIsNaN(parsed)) return i
		    buf[offset + i] = parsed;
		  }
		  return i
		}

		function utf8Write (buf, string, offset, length) {
		  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
		}

		function asciiWrite (buf, string, offset, length) {
		  return blitBuffer(asciiToBytes(string), buf, offset, length)
		}

		function base64Write (buf, string, offset, length) {
		  return blitBuffer(base64ToBytes(string), buf, offset, length)
		}

		function ucs2Write (buf, string, offset, length) {
		  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
		}

		Buffer.prototype.write = function write (string, offset, length, encoding) {
		  // Buffer#write(string)
		  if (offset === undefined) {
		    encoding = 'utf8';
		    length = this.length;
		    offset = 0;
		  // Buffer#write(string, encoding)
		  } else if (length === undefined && typeof offset === 'string') {
		    encoding = offset;
		    length = this.length;
		    offset = 0;
		  // Buffer#write(string, offset[, length][, encoding])
		  } else if (isFinite(offset)) {
		    offset = offset >>> 0;
		    if (isFinite(length)) {
		      length = length >>> 0;
		      if (encoding === undefined) encoding = 'utf8';
		    } else {
		      encoding = length;
		      length = undefined;
		    }
		  } else {
		    throw new Error(
		      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
		    )
		  }

		  var remaining = this.length - offset;
		  if (length === undefined || length > remaining) length = remaining;

		  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
		    throw new RangeError('Attempt to write outside buffer bounds')
		  }

		  if (!encoding) encoding = 'utf8';

		  var loweredCase = false;
		  for (;;) {
		    switch (encoding) {
		      case 'hex':
		        return hexWrite(this, string, offset, length)

		      case 'utf8':
		      case 'utf-8':
		        return utf8Write(this, string, offset, length)

		      case 'ascii':
		      case 'latin1':
		      case 'binary':
		        return asciiWrite(this, string, offset, length)

		      case 'base64':
		        // Warning: maxLength not taken into account in base64Write
		        return base64Write(this, string, offset, length)

		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return ucs2Write(this, string, offset, length)

		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = ('' + encoding).toLowerCase();
		        loweredCase = true;
		    }
		  }
		};

		Buffer.prototype.toJSON = function toJSON () {
		  return {
		    type: 'Buffer',
		    data: Array.prototype.slice.call(this._arr || this, 0)
		  }
		};

		function base64Slice (buf, start, end) {
		  if (start === 0 && end === buf.length) {
		    return base64.fromByteArray(buf)
		  } else {
		    return base64.fromByteArray(buf.slice(start, end))
		  }
		}

		function utf8Slice (buf, start, end) {
		  end = Math.min(buf.length, end);
		  var res = [];

		  var i = start;
		  while (i < end) {
		    var firstByte = buf[i];
		    var codePoint = null;
		    var bytesPerSequence = (firstByte > 0xEF)
		      ? 4
		      : (firstByte > 0xDF)
		          ? 3
		          : (firstByte > 0xBF)
		              ? 2
		              : 1;

		    if (i + bytesPerSequence <= end) {
		      var secondByte, thirdByte, fourthByte, tempCodePoint;

		      switch (bytesPerSequence) {
		        case 1:
		          if (firstByte < 0x80) {
		            codePoint = firstByte;
		          }
		          break
		        case 2:
		          secondByte = buf[i + 1];
		          if ((secondByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
		            if (tempCodePoint > 0x7F) {
		              codePoint = tempCodePoint;
		            }
		          }
		          break
		        case 3:
		          secondByte = buf[i + 1];
		          thirdByte = buf[i + 2];
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
		            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
		              codePoint = tempCodePoint;
		            }
		          }
		          break
		        case 4:
		          secondByte = buf[i + 1];
		          thirdByte = buf[i + 2];
		          fourthByte = buf[i + 3];
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
		            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
		              codePoint = tempCodePoint;
		            }
		          }
		      }
		    }

		    if (codePoint === null) {
		      // we did not generate a valid codePoint so insert a
		      // replacement char (U+FFFD) and advance only 1 byte
		      codePoint = 0xFFFD;
		      bytesPerSequence = 1;
		    } else if (codePoint > 0xFFFF) {
		      // encode to utf16 (surrogate pair dance)
		      codePoint -= 0x10000;
		      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
		      codePoint = 0xDC00 | codePoint & 0x3FF;
		    }

		    res.push(codePoint);
		    i += bytesPerSequence;
		  }

		  return decodeCodePointsArray(res)
		}

		// Based on http://stackoverflow.com/a/22747272/680742, the browser with
		// the lowest limit is Chrome, with 0x10000 args.
		// We go 1 magnitude less, for safety
		var MAX_ARGUMENTS_LENGTH = 0x1000;

		function decodeCodePointsArray (codePoints) {
		  var len = codePoints.length;
		  if (len <= MAX_ARGUMENTS_LENGTH) {
		    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
		  }

		  // Decode in chunks to avoid "call stack size exceeded".
		  var res = '';
		  var i = 0;
		  while (i < len) {
		    res += String.fromCharCode.apply(
		      String,
		      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
		    );
		  }
		  return res
		}

		function asciiSlice (buf, start, end) {
		  var ret = '';
		  end = Math.min(buf.length, end);

		  for (var i = start; i < end; ++i) {
		    ret += String.fromCharCode(buf[i] & 0x7F);
		  }
		  return ret
		}

		function latin1Slice (buf, start, end) {
		  var ret = '';
		  end = Math.min(buf.length, end);

		  for (var i = start; i < end; ++i) {
		    ret += String.fromCharCode(buf[i]);
		  }
		  return ret
		}

		function hexSlice (buf, start, end) {
		  var len = buf.length;

		  if (!start || start < 0) start = 0;
		  if (!end || end < 0 || end > len) end = len;

		  var out = '';
		  for (var i = start; i < end; ++i) {
		    out += hexSliceLookupTable[buf[i]];
		  }
		  return out
		}

		function utf16leSlice (buf, start, end) {
		  var bytes = buf.slice(start, end);
		  var res = '';
		  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
		  for (var i = 0; i < bytes.length - 1; i += 2) {
		    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
		  }
		  return res
		}

		Buffer.prototype.slice = function slice (start, end) {
		  var len = this.length;
		  start = ~~start;
		  end = end === undefined ? len : ~~end;

		  if (start < 0) {
		    start += len;
		    if (start < 0) start = 0;
		  } else if (start > len) {
		    start = len;
		  }

		  if (end < 0) {
		    end += len;
		    if (end < 0) end = 0;
		  } else if (end > len) {
		    end = len;
		  }

		  if (end < start) end = start;

		  var newBuf = this.subarray(start, end);
		  // Return an augmented `Uint8Array` instance
		  Object.setPrototypeOf(newBuf, Buffer.prototype);

		  return newBuf
		};

		/*
		 * Need to make sure that buffer isn't trying to write out of bounds.
		 */
		function checkOffset (offset, ext, length) {
		  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
		  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
		}

		Buffer.prototype.readUintLE =
		Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) checkOffset(offset, byteLength, this.length);

		  var val = this[offset];
		  var mul = 1;
		  var i = 0;
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul;
		  }

		  return val
		};

		Buffer.prototype.readUintBE =
		Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) {
		    checkOffset(offset, byteLength, this.length);
		  }

		  var val = this[offset + --byteLength];
		  var mul = 1;
		  while (byteLength > 0 && (mul *= 0x100)) {
		    val += this[offset + --byteLength] * mul;
		  }

		  return val
		};

		Buffer.prototype.readUint8 =
		Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 1, this.length);
		  return this[offset]
		};

		Buffer.prototype.readUint16LE =
		Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  return this[offset] | (this[offset + 1] << 8)
		};

		Buffer.prototype.readUint16BE =
		Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  return (this[offset] << 8) | this[offset + 1]
		};

		Buffer.prototype.readUint32LE =
		Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return ((this[offset]) |
		      (this[offset + 1] << 8) |
		      (this[offset + 2] << 16)) +
		      (this[offset + 3] * 0x1000000)
		};

		Buffer.prototype.readUint32BE =
		Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return (this[offset] * 0x1000000) +
		    ((this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    this[offset + 3])
		};

		Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) checkOffset(offset, byteLength, this.length);

		  var val = this[offset];
		  var mul = 1;
		  var i = 0;
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul;
		  }
		  mul *= 0x80;

		  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

		  return val
		};

		Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) checkOffset(offset, byteLength, this.length);

		  var i = byteLength;
		  var mul = 1;
		  var val = this[offset + --i];
		  while (i > 0 && (mul *= 0x100)) {
		    val += this[offset + --i] * mul;
		  }
		  mul *= 0x80;

		  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

		  return val
		};

		Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 1, this.length);
		  if (!(this[offset] & 0x80)) return (this[offset])
		  return ((0xff - this[offset] + 1) * -1)
		};

		Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  var val = this[offset] | (this[offset + 1] << 8);
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		};

		Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 2, this.length);
		  var val = this[offset + 1] | (this[offset] << 8);
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		};

		Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return (this[offset]) |
		    (this[offset + 1] << 8) |
		    (this[offset + 2] << 16) |
		    (this[offset + 3] << 24)
		};

		Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);

		  return (this[offset] << 24) |
		    (this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    (this[offset + 3])
		};

		Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);
		  return ieee754.read(this, offset, true, 23, 4)
		};

		Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 4, this.length);
		  return ieee754.read(this, offset, false, 23, 4)
		};

		Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 8, this.length);
		  return ieee754.read(this, offset, true, 52, 8)
		};

		Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
		  offset = offset >>> 0;
		  if (!noAssert) checkOffset(offset, 8, this.length);
		  return ieee754.read(this, offset, false, 52, 8)
		};

		function checkInt (buf, value, offset, ext, max, min) {
		  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
		  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
		  if (offset + ext > buf.length) throw new RangeError('Index out of range')
		}

		Buffer.prototype.writeUintLE =
		Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) {
		    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
		    checkInt(this, value, offset, byteLength, maxBytes, 0);
		  }

		  var mul = 1;
		  var i = 0;
		  this[offset] = value & 0xFF;
		  while (++i < byteLength && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeUintBE =
		Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  byteLength = byteLength >>> 0;
		  if (!noAssert) {
		    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
		    checkInt(this, value, offset, byteLength, maxBytes, 0);
		  }

		  var i = byteLength - 1;
		  var mul = 1;
		  this[offset + i] = value & 0xFF;
		  while (--i >= 0 && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeUint8 =
		Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
		  this[offset] = (value & 0xff);
		  return offset + 1
		};

		Buffer.prototype.writeUint16LE =
		Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
		  this[offset] = (value & 0xff);
		  this[offset + 1] = (value >>> 8);
		  return offset + 2
		};

		Buffer.prototype.writeUint16BE =
		Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
		  this[offset] = (value >>> 8);
		  this[offset + 1] = (value & 0xff);
		  return offset + 2
		};

		Buffer.prototype.writeUint32LE =
		Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
		  this[offset + 3] = (value >>> 24);
		  this[offset + 2] = (value >>> 16);
		  this[offset + 1] = (value >>> 8);
		  this[offset] = (value & 0xff);
		  return offset + 4
		};

		Buffer.prototype.writeUint32BE =
		Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
		  this[offset] = (value >>> 24);
		  this[offset + 1] = (value >>> 16);
		  this[offset + 2] = (value >>> 8);
		  this[offset + 3] = (value & 0xff);
		  return offset + 4
		};

		Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    var limit = Math.pow(2, (8 * byteLength) - 1);

		    checkInt(this, value, offset, byteLength, limit - 1, -limit);
		  }

		  var i = 0;
		  var mul = 1;
		  var sub = 0;
		  this[offset] = value & 0xFF;
		  while (++i < byteLength && (mul *= 0x100)) {
		    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
		      sub = 1;
		    }
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    var limit = Math.pow(2, (8 * byteLength) - 1);

		    checkInt(this, value, offset, byteLength, limit - 1, -limit);
		  }

		  var i = byteLength - 1;
		  var mul = 1;
		  var sub = 0;
		  this[offset + i] = value & 0xFF;
		  while (--i >= 0 && (mul *= 0x100)) {
		    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
		      sub = 1;
		    }
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
		  }

		  return offset + byteLength
		};

		Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
		  if (value < 0) value = 0xff + value + 1;
		  this[offset] = (value & 0xff);
		  return offset + 1
		};

		Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
		  this[offset] = (value & 0xff);
		  this[offset + 1] = (value >>> 8);
		  return offset + 2
		};

		Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
		  this[offset] = (value >>> 8);
		  this[offset + 1] = (value & 0xff);
		  return offset + 2
		};

		Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
		  this[offset] = (value & 0xff);
		  this[offset + 1] = (value >>> 8);
		  this[offset + 2] = (value >>> 16);
		  this[offset + 3] = (value >>> 24);
		  return offset + 4
		};

		Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
		  if (value < 0) value = 0xffffffff + value + 1;
		  this[offset] = (value >>> 24);
		  this[offset + 1] = (value >>> 16);
		  this[offset + 2] = (value >>> 8);
		  this[offset + 3] = (value & 0xff);
		  return offset + 4
		};

		function checkIEEE754 (buf, value, offset, ext, max, min) {
		  if (offset + ext > buf.length) throw new RangeError('Index out of range')
		  if (offset < 0) throw new RangeError('Index out of range')
		}

		function writeFloat (buf, value, offset, littleEndian, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 4);
		  }
		  ieee754.write(buf, value, offset, littleEndian, 23, 4);
		  return offset + 4
		}

		Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, true, noAssert)
		};

		Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, false, noAssert)
		};

		function writeDouble (buf, value, offset, littleEndian, noAssert) {
		  value = +value;
		  offset = offset >>> 0;
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 8);
		  }
		  ieee754.write(buf, value, offset, littleEndian, 52, 8);
		  return offset + 8
		}

		Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, true, noAssert)
		};

		Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, false, noAssert)
		};

		// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
		Buffer.prototype.copy = function copy (target, targetStart, start, end) {
		  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
		  if (!start) start = 0;
		  if (!end && end !== 0) end = this.length;
		  if (targetStart >= target.length) targetStart = target.length;
		  if (!targetStart) targetStart = 0;
		  if (end > 0 && end < start) end = start;

		  // Copy 0 bytes; we're done
		  if (end === start) return 0
		  if (target.length === 0 || this.length === 0) return 0

		  // Fatal error conditions
		  if (targetStart < 0) {
		    throw new RangeError('targetStart out of bounds')
		  }
		  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
		  if (end < 0) throw new RangeError('sourceEnd out of bounds')

		  // Are we oob?
		  if (end > this.length) end = this.length;
		  if (target.length - targetStart < end - start) {
		    end = target.length - targetStart + start;
		  }

		  var len = end - start;

		  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
		    // Use built-in when available, missing from IE11
		    this.copyWithin(targetStart, start, end);
		  } else {
		    Uint8Array.prototype.set.call(
		      target,
		      this.subarray(start, end),
		      targetStart
		    );
		  }

		  return len
		};

		// Usage:
		//    buffer.fill(number[, offset[, end]])
		//    buffer.fill(buffer[, offset[, end]])
		//    buffer.fill(string[, offset[, end]][, encoding])
		Buffer.prototype.fill = function fill (val, start, end, encoding) {
		  // Handle string cases:
		  if (typeof val === 'string') {
		    if (typeof start === 'string') {
		      encoding = start;
		      start = 0;
		      end = this.length;
		    } else if (typeof end === 'string') {
		      encoding = end;
		      end = this.length;
		    }
		    if (encoding !== undefined && typeof encoding !== 'string') {
		      throw new TypeError('encoding must be a string')
		    }
		    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
		      throw new TypeError('Unknown encoding: ' + encoding)
		    }
		    if (val.length === 1) {
		      var code = val.charCodeAt(0);
		      if ((encoding === 'utf8' && code < 128) ||
		          encoding === 'latin1') {
		        // Fast path: If `val` fits into a single byte, use that numeric value.
		        val = code;
		      }
		    }
		  } else if (typeof val === 'number') {
		    val = val & 255;
		  } else if (typeof val === 'boolean') {
		    val = Number(val);
		  }

		  // Invalid ranges are not set to a default, so can range check early.
		  if (start < 0 || this.length < start || this.length < end) {
		    throw new RangeError('Out of range index')
		  }

		  if (end <= start) {
		    return this
		  }

		  start = start >>> 0;
		  end = end === undefined ? this.length : end >>> 0;

		  if (!val) val = 0;

		  var i;
		  if (typeof val === 'number') {
		    for (i = start; i < end; ++i) {
		      this[i] = val;
		    }
		  } else {
		    var bytes = Buffer.isBuffer(val)
		      ? val
		      : Buffer.from(val, encoding);
		    var len = bytes.length;
		    if (len === 0) {
		      throw new TypeError('The value "' + val +
		        '" is invalid for argument "value"')
		    }
		    for (i = 0; i < end - start; ++i) {
		      this[i + start] = bytes[i % len];
		    }
		  }

		  return this
		};

		// HELPER FUNCTIONS
		// ================

		var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

		function base64clean (str) {
		  // Node takes equal signs as end of the Base64 encoding
		  str = str.split('=')[0];
		  // Node strips out invalid characters like \n and \t from the string, base64-js does not
		  str = str.trim().replace(INVALID_BASE64_RE, '');
		  // Node converts strings with length < 2 to ''
		  if (str.length < 2) return ''
		  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
		  while (str.length % 4 !== 0) {
		    str = str + '=';
		  }
		  return str
		}

		function utf8ToBytes (string, units) {
		  units = units || Infinity;
		  var codePoint;
		  var length = string.length;
		  var leadSurrogate = null;
		  var bytes = [];

		  for (var i = 0; i < length; ++i) {
		    codePoint = string.charCodeAt(i);

		    // is surrogate component
		    if (codePoint > 0xD7FF && codePoint < 0xE000) {
		      // last char was a lead
		      if (!leadSurrogate) {
		        // no lead yet
		        if (codePoint > 0xDBFF) {
		          // unexpected trail
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		          continue
		        } else if (i + 1 === length) {
		          // unpaired lead
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		          continue
		        }

		        // valid lead
		        leadSurrogate = codePoint;

		        continue
		      }

		      // 2 leads in a row
		      if (codePoint < 0xDC00) {
		        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		        leadSurrogate = codePoint;
		        continue
		      }

		      // valid surrogate pair
		      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
		    } else if (leadSurrogate) {
		      // valid bmp char, but last char was a lead
		      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
		    }

		    leadSurrogate = null;

		    // encode utf8
		    if (codePoint < 0x80) {
		      if ((units -= 1) < 0) break
		      bytes.push(codePoint);
		    } else if (codePoint < 0x800) {
		      if ((units -= 2) < 0) break
		      bytes.push(
		        codePoint >> 0x6 | 0xC0,
		        codePoint & 0x3F | 0x80
		      );
		    } else if (codePoint < 0x10000) {
		      if ((units -= 3) < 0) break
		      bytes.push(
		        codePoint >> 0xC | 0xE0,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      );
		    } else if (codePoint < 0x110000) {
		      if ((units -= 4) < 0) break
		      bytes.push(
		        codePoint >> 0x12 | 0xF0,
		        codePoint >> 0xC & 0x3F | 0x80,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      );
		    } else {
		      throw new Error('Invalid code point')
		    }
		  }

		  return bytes
		}

		function asciiToBytes (str) {
		  var byteArray = [];
		  for (var i = 0; i < str.length; ++i) {
		    // Node's code seems to be doing this and not & 0x7F..
		    byteArray.push(str.charCodeAt(i) & 0xFF);
		  }
		  return byteArray
		}

		function utf16leToBytes (str, units) {
		  var c, hi, lo;
		  var byteArray = [];
		  for (var i = 0; i < str.length; ++i) {
		    if ((units -= 2) < 0) break

		    c = str.charCodeAt(i);
		    hi = c >> 8;
		    lo = c % 256;
		    byteArray.push(lo);
		    byteArray.push(hi);
		  }

		  return byteArray
		}

		function base64ToBytes (str) {
		  return base64.toByteArray(base64clean(str))
		}

		function blitBuffer (src, dst, offset, length) {
		  for (var i = 0; i < length; ++i) {
		    if ((i + offset >= dst.length) || (i >= src.length)) break
		    dst[i + offset] = src[i];
		  }
		  return i
		}

		// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
		// the `instanceof` check but they should be treated as of that type.
		// See: https://github.com/feross/buffer/issues/166
		function isInstance (obj, type) {
		  return obj instanceof type ||
		    (obj != null && obj.constructor != null && obj.constructor.name != null &&
		      obj.constructor.name === type.name)
		}
		function numberIsNaN (obj) {
		  // For IE11 support
		  return obj !== obj // eslint-disable-line no-self-compare
		}

		// Create lookup table for `toString('hex')`
		// See: https://github.com/feross/buffer/issues/219
		var hexSliceLookupTable = (function () {
		  var alphabet = '0123456789abcdef';
		  var table = new Array(256);
		  for (var i = 0; i < 16; ++i) {
		    var i16 = i * 16;
		    for (var j = 0; j < 16; ++j) {
		      table[i16 + j] = alphabet[i] + alphabet[j];
		    }
		  }
		  return table
		})(); 
	} (buffer));
	return buffer;
}

var bufferExports = requireBuffer();

function stringToBits(text) {
    const bytes = bufferExports.Buffer.from(text, 'utf-8');
    return new distExports$2.BitString(bytes, 0, bytes.length * 8);
}
function bitsToString(bits) {
    if (bits.length % 8 !== 0) {
        throw new Error('Bits must be at least 8 bits');
    }
    let text = '';
    for (let offset = 0; offset < bits.length; offset += 8) {
        text += String.fromCharCode(parseInt(`0x${bits.substring(offset, 8).toString()}`));
    }
    return text;
}
function normalizeBitString(bits) {
    const length = bits.length;
    const newBuffer = bufferExports.Buffer.alloc(Math.ceil(length / 8));
    for (let i = 0; i < length; i++) {
        const byteIndex = Math.floor(i / 8);
        const bitIndex = 7 - (i % 8);
        if (bits.at(i)) {
            newBuffer[byteIndex] |= 1 << bitIndex;
        }
    }
    return new distExports$2.BitString(newBuffer, 0, length);
}

// Interpreter to evaluate TLBMathExpr at runtime
class MathExprEvaluator {
    variables;
    constructor(variables = new Map()) {
        this.variables = variables;
    }
    evaluate(expr) {
        if (expr instanceof TLBNumberExpr) {
            return expr.n;
        }
        if (expr instanceof TLBVarExpr) {
            const value = this.variables.get(expr.x);
            if (value === undefined) {
                throw new Error(`Variable ${expr.x} is not defined`);
            }
            return value;
        }
        if (expr instanceof TLBBinaryOp) {
            const left = this.evaluate(expr.left);
            const right = this.evaluate(expr.right);
            switch (expr.operation) {
                case '+':
                    return left + right;
                case '-':
                    return left - right;
                case '*':
                    return left * right;
                case '/':
                    return Math.floor(left / right);
                case '%':
                    return left % right;
                case '<<':
                    return left << right;
                case '>>':
                    return left >> right;
                case '&':
                    return left & right;
                case '|':
                    return left | right;
                case '^':
                    return left ^ right;
                case '==':
                    return left === right ? 1 : 0;
                case '!=':
                    return left !== right ? 1 : 0;
                case '<':
                    return left < right ? 1 : 0;
                case '<=':
                    return left <= right ? 1 : 0;
                case '>':
                    return left > right ? 1 : 0;
                case '>=':
                    return left >= right ? 1 : 0;
                case '=':
                    return left === right ? 1 : 0;
                default:
                    throw new Error(`Unknown operation: ${expr.operation}`);
            }
        }
        // TLBUnaryOp
        // FIXME
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const value = this.evaluate(expr.value);
        // FIXME
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const operation = expr.operation;
        switch (operation) {
            case '-':
                return -value;
            case '~':
                return ~value;
            case '!':
                return value ? 0 : 1;
            case '.':
                return value;
            default:
                throw new Error(`Unknown unary operation: ${operation}`);
        }
    }
}

class TLBRuntimeError extends Error {
}
class TLBSchemaError extends TLBRuntimeError {
}
class TLBDataError extends TLBRuntimeError {
}
function tagKey(tag) {
    return `0b${BigInt(tag.binary).toString(2).padStart(tag.bitLen, '0')}`;
}
// Runtime TL-B serialization/deserialization
class TLBRuntime {
    types;
    lastTypeName;
    config;
    tagMap = new Map();
    maxSizeTag = 0;
    constructor(types, lastTypeName, config = {}) {
        this.types = types;
        this.lastTypeName = lastTypeName;
        this.config = config;
        config.autoText = config.autoText || true;
        for (const type of this.types.values()) {
            for (const item of type.constructors) {
                if (item.tag.bitLen > 0) {
                    if (item.tag.bitLen > this.maxSizeTag) {
                        this.maxSizeTag = item.tag.bitLen;
                    }
                    const key = tagKey(item.tag);
                    this.tagMap.set(key, { type, item });
                }
            }
        }
    }
    static from(tlbSource) {
        /* eslint no-empty: ["error", { "allowEmptyCatch": true }] */
        try {
            const tree = distExports$1.ast(tlbSource);
            const code = getTLBCodeByAST(tree, tlbSource);
            const pared = tlbSource.split('=');
            const lastTypeName = pared[pared.length - 1].split(';')[0].trim().split(' ')[0].trim();
            if (lastTypeName) {
                return {
                    ok: true,
                    value: new TLBRuntime(code.types, lastTypeName),
                };
            }
        }
        catch (_) { }
        return { ok: false, error: new TLBSchemaError('Bad Schema') };
    }
    findByTag(slice) {
        const savedBits = slice.remainingBits;
        const maxLen = Math.min(this.maxSizeTag, savedBits);
        for (let len = maxLen; len >= 1; len--) {
            if (savedBits < len)
                continue;
            const tagValue = slice.preloadUint(len);
            const key = tagKey({
                bitLen: len,
                binary: `0x${tagValue.toString(16)}`,
            });
            const type = this.tagMap.get(key);
            if (type) {
                return type;
            }
        }
        return null;
    }
    deserialize(data, findByTag = false) {
        if (typeof data === 'string') {
            try {
                data = distExports$2.Cell.fromBase64(data);
            }
            catch (_) {
                return { ok: false, error: new TLBDataError('Bad BOC string') };
            }
        }
        const slice = data.asSlice();
        if (findByTag) {
            const find = this.findByTag(slice);
            if (find) {
                return this.deserializeConstructor(find.type, find.item, slice);
            }
        }
        const types = Array.from(this.types.keys());
        try {
            const result = this.deserializeByTypeName(this.lastTypeName, slice.clone());
            if (result.ok) {
                return result;
            }
        }
        catch (_) { }
        for (const typeName of types.slice().reverse()) {
            if (typeName === this.lastTypeName)
                continue; // Already tried
            const result = this.deserializeByTypeName(typeName, slice.clone());
            if (result.ok) {
                return result;
            }
        }
        return { ok: false, error: new TLBDataError('No matching constructor') };
    }
    // Deserialize data from a Slice based on a TL-B type name
    deserializeByTypeName(typeName, slice) {
        const type = this.types.get(typeName);
        if (!type) {
            return {
                ok: false,
                error: new TLBDataError(`Type ${typeName} not found in TL-B schema`),
            };
        }
        return this.deserializeType(type, slice);
    }
    serialize(data) {
        const typeKind = data.kind;
        if (!typeKind) {
            return {
                ok: false,
                error: new TLBDataError('Data must by typed'),
            };
        }
        return this.serializeByTypeName(typeKind, data);
    }
    // Serialize data to a Builder based on a TL-B type name
    serializeByTypeName(typeKind, data) {
        const sep = typeKind.indexOf('_');
        const typeName = sep === -1 ? typeKind : typeKind.slice(0, sep);
        const type = this.types.get(typeName);
        if (!type) {
            return {
                ok: false,
                error: new TLBDataError(`Type ${typeName} not found in TL-B schema`),
            };
        }
        const value = distExports$2.beginCell();
        this.serializeType(type, data, value);
        return {
            ok: true,
            value,
        };
    }
    deserializeType(type, data, args = []) {
        for (const constructor of type.constructors) {
            const prev = data.clone();
            const result = this.deserializeConstructor(type, constructor, prev, args);
            if (result.ok) {
                const bitsUsed = data.remainingBits - prev.remainingBits;
                const refsUsed = data.remainingRefs - prev.remainingRefs;
                if (bitsUsed > 0) {
                    data.skip(bitsUsed);
                }
                for (let i = 0; i < refsUsed; i++) {
                    data.loadRef();
                }
                return result;
            }
        }
        return {
            ok: false,
            error: new TLBDataError(`Failed to deserialize type ${type.name} no matching constructor found`),
        };
    }
    deserializeConstructor(type, constructor, slice, args = []) {
        const kind = type.constructors.length > 1 ? `${type.name}_${constructor.name}` : type.name;
        // Check tag if present
        if (constructor.tag.bitLen > 0) {
            const len = constructor.tag.bitLen;
            if (slice.remainingBits < len) {
                return {
                    ok: false,
                    error: new TLBDataError(`Not enough bits to read tag for ${kind}`),
                };
            }
            const preloadedTag = `0b${slice.loadUint(len).toString(2).padStart(len, '0')}`;
            const expectedTag = tagKey(constructor.tag);
            if (preloadedTag !== expectedTag) {
                return {
                    ok: false,
                    error: new TLBDataError(`Failed to deserialize type ${kind}`),
                };
            }
        }
        // Initialize variables map for constraint evaluation
        const variables = new Map();
        // Initialize variables from constructor parameters
        if (args.length > 0 && constructor.parameters.length > 0) {
            const evaluator = new MathExprEvaluator(variables);
            for (let i = 0; i < Math.min(args.length, constructor.parameters.length); i++) {
                const param = constructor.parameters[i];
                const arg = args[i];
                let argValue;
                try {
                    if (arg.kind === 'TLBExprMathType') {
                        argValue = evaluator.evaluate(arg.initialExpr);
                    }
                    else if (arg.kind === 'TLBNumberType') {
                        argValue = evaluator.evaluate(arg.bits);
                    }
                }
                catch (_) { }
                if (param.argName && typeof argValue === 'number') {
                    variables.set(param.argName, argValue);
                }
                try {
                    if (param.variable?.name && param.variable.deriveExpr) {
                        const derived = new MathExprEvaluator(variables).evaluate(param.variable.deriveExpr);
                        variables.set(param.variable.name, derived);
                    }
                    else if (param.variable?.name && typeof argValue === 'number') {
                        // Simple case: parameter is a plain variable passed directly
                        variables.set(param.variable.name, argValue);
                    }
                }
                catch (_) { }
            }
        }
        // Deserialize fields
        // FIXME
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const value = {
            kind,
        };
        for (const field of constructor.fields) {
            // field.subFields.length
            if (field.subFields.length > 0) {
                if (slice.remainingRefs === 0) {
                    return {
                        ok: false,
                        error: new TLBDataError(`No more references available for field ${field.name}`),
                    };
                }
                const ref = slice.loadRef();
                // Special case: if we have only one subfield, handle it directly
                if (field.subFields.length === 1) {
                    const subfield = field.subFields[0];
                    if (subfield.fieldType.kind === 'TLBCellType') {
                        // ^Cell - just return the cell
                        value[field.name] = ref;
                    }
                    else if (subfield.fieldType.kind === 'TLBNamedType') {
                        // ^SomeType - deserialize the type from the reference
                        const refSlice = ref.beginParse(true);
                        const type = this.types.get(subfield.fieldType.name);
                        if (type) {
                            const result = this.deserializeType(type, refSlice, subfield.fieldType.arguments);
                            if (result.ok) {
                                value[field.name] = result.value;
                            }
                            else {
                                return result;
                            }
                        }
                        else {
                            return {
                                ok: false,
                                error: new TLBDataError(`Type ${subfield.fieldType.name} not found`),
                            };
                        }
                    }
                    else {
                        // Other single subfield types
                        const refSlice = ref.beginParse(true);
                        value[field.name] = this.deserializeField(subfield, refSlice, variables);
                    }
                }
                else {
                    const refSlice = ref.beginParse(true);
                    // FIXME
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const subfields = {};
                    for (const subfield of field.subFields) {
                        subfields[subfield.name] = this.deserializeField(subfield, refSlice, variables);
                    }
                    value[field.name] = subfields;
                }
            }
            else {
                if (field.fieldType.kind === 'TLBNamedType' && constructor.parametersMap.get(field.fieldType.name)) {
                    const param = constructor.parametersMap.get(field.fieldType.name);
                    const paramIndex = constructor.parameters.findIndex((p) => p.variable.name === param.variable.name);
                    field.fieldType = args[paramIndex];
                }
                value[field.name] = this.deserializeField(field, slice, variables);
            }
        }
        // Check constraints
        const evaluator = new MathExprEvaluator(variables);
        for (const constraint of constructor.constraints) {
            if (evaluator.evaluate(constraint) !== 1) {
                return {
                    ok: false,
                    error: new TLBDataError(`Failed to deserialize type ${kind} due to constraint`),
                };
            }
        }
        if (kind === 'ExprType' && typeof value.x === 'number') {
            // For ExprType, tests expect bigints for numeric payload even if small
            value.x = BigInt(value.x);
        }
        // Reorder output: kind, parameters, then fields (stable and predictable JSON order for tests)
        // Collect parameters
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const orderedValue = { kind };
        for (const param of constructor.parameters) {
            const val = variables.get(param.variable.name);
            if (typeof val === 'number') {
                orderedValue[param.variable.name] = val;
            }
        }
        for (const field of constructor.fields) {
            orderedValue[field.name] = value[field.name];
        }
        return {
            ok: true,
            value: orderedValue,
        };
    }
    // FIXME
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    deserializeField(field, slice, variables) {
        const value = this.deserializeFieldType(field.fieldType, slice, variables);
        if (field.name &&
            (field.fieldType.kind === 'TLBNumberType' ||
                field.fieldType.kind === 'TLBVarIntegerType' ||
                field.fieldType.kind === 'TLBBoolType')) {
            variables.set(field.name, Number(value));
        }
        return value;
    }
    // FIXME
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    deserializeFieldType(fieldType, slice, variables) {
        const evaluator = new MathExprEvaluator(variables);
        switch (fieldType.kind) {
            case 'TLBNumberType': {
                let bits;
                try {
                    bits = evaluator.evaluate(fieldType.bits);
                }
                catch (e) {
                    // If a constructor parameter (e.g., n) is not yet defined, infer it from remaining bits
                    if (e instanceof Error) {
                        const m = /Variable\s+([^\s]+)\s+is\s+not\s+defined/.exec(e.message);
                        if (m && m[1]) {
                            const name = m[1];
                            // Heuristic: for simple cases like x:(## n) assume n from next tag or external context
                            // Fallback to remainingBits but clamp to sane limits (1..256)
                            const inferred = Math.max(1, Math.min(256, slice.remainingBits));
                            variables.set(name, inferred);
                            bits = new MathExprEvaluator(variables).evaluate(fieldType.bits);
                        }
                        else {
                            throw e;
                        }
                    }
                    else {
                        throw e;
                    }
                }
                const value = this.loadBigInt(slice, bits, fieldType.signed);
                if (bits <= 32) {
                    return Number(value);
                }
                return value;
            }
            case 'TLBBoolType': {
                if (fieldType.value !== undefined) {
                    return fieldType.value;
                }
                return slice.loadBit();
            }
            case 'TLBBitsType': {
                let bits;
                try {
                    bits = evaluator.evaluate(fieldType.bits);
                }
                catch (e) {
                    if (e instanceof Error) {
                        const m = /Variable\s+([^\s]+)\s+is\s+not\s+defined/.exec(e.message);
                        if (m && m[1]) {
                            const name = m[1];
                            const inferred = Math.max(1, Math.min(1023, slice.remainingBits));
                            variables.set(name, inferred);
                            bits = new MathExprEvaluator(variables).evaluate(fieldType.bits);
                        }
                        else {
                            throw e;
                        }
                    }
                    else {
                        throw e;
                    }
                }
                const raw = slice.loadBits(bits);
                if (this.config.autoText && bits % 8 === 0) {
                    return bitsToString(raw);
                }
                if (bits === 1) {
                    return raw.at(0);
                }
                return normalizeBitString(raw);
            }
            case 'TLBNamedType': {
                if (fieldType.name === 'Bool') {
                    return slice.loadBit();
                }
                const type = this.types.get(fieldType.name);
                if (!type) {
                    throw new TLBDataError(`Type ${fieldType.name} not found in TL-B schema`);
                }
                return unwrap(this.deserializeType(type, slice, fieldType.arguments));
            }
            case 'TLBCoinsType': {
                return slice.loadCoins();
            }
            case 'TLBAddressType': {
                if (slice.preloadUint(2) !== 2) {
                    if (slice.remainingBits === 2) {
                        return null;
                    }
                    const type = slice.loadUint(2);
                    if (type === 1) {
                        const bits = slice.loadUint(9);
                        return new distExports$2.ExternalAddress(slice.loadUintBig(bits), bits);
                    }
                    // TODO add Anycast type === 3
                }
                return slice.loadAddress();
            }
            case 'TLBCellType': {
                if (slice.remainingRefs === 0) {
                    throw new TLBDataError('No more references available for TLBCellType');
                }
                return slice.loadRef();
            }
            case 'TLBCellInsideType': {
                if (slice.remainingRefs === 0) {
                    throw new TLBDataError('No more references available for TLBCellInsideType');
                }
                const ref = slice.loadRef();
                if (fieldType.value.kind === 'TLBCellType') {
                    return ref;
                }
                const refSlice = ref.beginParse();
                return this.deserializeFieldType(fieldType.value, refSlice, variables);
            }
            case 'TLBHashmapType': {
                const keySize = evaluator.evaluate(fieldType.key.expr);
                const dict = slice.loadDict(distExports$2.Dictionary.Keys.BigInt(keySize), {
                    serialize: () => {
                        /* NO_USED */
                    },
                    parse: (slice) => this.deserializeFieldType(fieldType.value, slice, new Map(variables)),
                });
                return dict;
            }
            case 'TLBVarIntegerType': {
                const size = evaluator.evaluate(fieldType.n);
                if (fieldType.signed) {
                    return slice.loadVarIntBig(size);
                }
                else {
                    return slice.loadVarUintBig(size);
                }
            }
            case 'TLBMultipleType': {
                const times = evaluator.evaluate(fieldType.times);
                const result = [];
                for (let i = 0; i < times; i++) {
                    result.push(this.deserializeFieldType(fieldType.value, slice, variables));
                }
                return result;
            }
            case 'TLBCondType': {
                const condition = evaluator.evaluate(fieldType.condition);
                if (condition) {
                    return this.deserializeFieldType(fieldType.value, slice, variables);
                }
                return undefined;
            }
            case 'TLBTupleType': {
                const cell = slice.loadRef();
                return distExports$2.parseTuple(cell);
            }
            default:
                throw new TLBDataError(`Unsupported field type: ${fieldType.kind}`);
        }
    }
    // FIXME
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    serializeType(type, data, builder) {
        // Find matching constructor by kind
        const typeKind = data.kind;
        if (!typeKind) {
            throw new TLBDataError('Data must by typed');
        }
        const constructorName = typeKind.substring(type.name.length + 1); // Remove TypeName_ prefix
        let constructor;
        if (constructorName) {
            constructor = type.constructors.find((c) => c.name === constructorName);
        }
        else if (type.constructors.length > 0) {
            constructor = type.constructors[0];
        }
        if (!constructor) {
            throw new TLBDataError(`Constructor not found for type ${typeKind}`);
        }
        // Store tag if present
        if (constructor.tag.bitLen > 0) {
            const tag = BigInt(constructor.tag.binary);
            builder.storeUint(tag, constructor.tag.bitLen);
        }
        // Initialize variables map for constraint evaluation
        const variables = new Map();
        // Serialize fields
        for (const field of constructor.fields) {
            if (!field.anonymous) {
                this.serializeField(field, data[field.name], builder, variables);
            }
            else {
                // For anonymous fields, we need to extract from constraints or use default
                // This is a simplified approach, would need more complex logic for real cases
                this.serializeField(field, null, builder, variables);
            }
        }
        // Check constraints
        const evaluator = new MathExprEvaluator(variables);
        for (const constraint of constructor.constraints) {
            if (evaluator.evaluate(constraint) !== 1) {
                throw new TLBDataError(`Constraint failed for type ${type.name}, constructor ${constructor.name}`);
            }
        }
    }
    // FIXME
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    serializeField(field, value, builder, variables) {
        if (field.name &&
            (field.fieldType.kind === 'TLBNumberType' ||
                field.fieldType.kind === 'TLBVarIntegerType' ||
                field.fieldType.kind === 'TLBBoolType')) {
            variables.set(field.name, Number(value));
        }
        this.serializeFieldType(field.fieldType, value, builder, variables);
    }
    serializeFieldType(fieldType, 
    // FIXME
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    value, builder, variables) {
        const evaluator = new MathExprEvaluator(variables);
        switch (fieldType.kind) {
            case 'TLBNumberType': {
                const bits = evaluator.evaluate(fieldType.bits);
                builder.storeUint(value, bits);
                break;
            }
            case 'TLBBoolType': {
                if (fieldType.value !== undefined) {
                    // Fixed value, nothing to store
                    break;
                }
                builder.storeBit(value ? 1 : 0);
                break;
            }
            case 'TLBBitsType': {
                if (typeof value === 'string') {
                    value = stringToBits(value);
                }
                if (value instanceof distExports$2.BitString) {
                    builder.storeBits(value);
                }
                break;
            }
            case 'TLBNamedType': {
                const type = this.types.get(fieldType.name);
                if (!type) {
                    throw new TLBDataError(`Type ${fieldType.name} not found in TL-B schema`);
                }
                this.serializeType(type, value, builder);
                break;
            }
            case 'TLBCoinsType': {
                builder.storeCoins(value);
                break;
            }
            case 'TLBAddressType': {
                builder.storeAddress(value);
                break;
            }
            case 'TLBCellType': {
                builder.storeRef(value);
                break;
            }
            case 'TLBCellInsideType': {
                const nestedBuilder = distExports$2.beginCell();
                this.serializeFieldType(fieldType.value, value, nestedBuilder, variables);
                builder.storeRef(nestedBuilder.endCell());
                break;
            }
            case 'TLBHashmapType': {
                const keySize = evaluator.evaluate(fieldType.key.expr);
                const dict = distExports$2.Dictionary.empty(distExports$2.Dictionary.Keys.BigInt(keySize), distExports$2.Dictionary.Values.Cell());
                if (value) {
                    for (const [key, dictValue] of Object.entries(value)) {
                        const valueBuilder = distExports$2.beginCell();
                        this.serializeFieldType(fieldType.value, dictValue, valueBuilder, new Map(variables));
                        dict.set(BigInt(key), valueBuilder.endCell());
                    }
                }
                builder.storeDict(dict);
                break;
            }
            case 'TLBVarIntegerType': {
                const size = evaluator.evaluate(fieldType.n);
                if (fieldType.signed) {
                    builder.storeVarInt(value, size);
                }
                else {
                    builder.storeVarUint(value, size);
                }
                break;
            }
            case 'TLBMultipleType': {
                const times = evaluator.evaluate(fieldType.times);
                for (let i = 0; i < times; i++) {
                    this.serializeFieldType(fieldType.value, value[i], builder, variables);
                }
                break;
            }
            case 'TLBCondType': {
                const condition = evaluator.evaluate(fieldType.condition);
                if (condition) {
                    this.serializeFieldType(fieldType.value, value, builder, variables);
                }
                break;
            }
            case 'TLBTupleType': {
                const cell = distExports$2.serializeTuple(value);
                builder.storeRef(cell);
                break;
            }
            default:
                throw new TLBDataError(`Unsupported field type: ${fieldType.kind}`);
        }
    }
    loadBigInt(slice, bits, signed = false) {
        if (signed) {
            return slice.loadIntBig(bits);
        }
        return slice.loadUintBig(bits);
    }
}
// Export a simple API for users
function parseTLB(schema) {
    return unwrap(TLBRuntime.from(schema));
}

function unwrap(res) {
    if (res.ok) {
        return res.value;
    }
    throw res.error instanceof Error ? res.error : new TLBRuntimeError(String(res.error));
}

const log$l = globalLogger.createChild("SignDataHandler");
class SignDataHandler extends BasicHandler {
  canHandle(event) {
    return event.method === "signData";
  }
  async handle(event) {
    if (!event.wallet) {
      throw new Error("No wallet found in event");
    }
    const data = this.parseDataToSign(event);
    if (!data) {
      log$l.error("No data to sign found in request", { event });
      throw new Error("No data to sign found in request");
    }
    const preview = this.createDataPreview(data, event);
    if (!preview) {
      log$l.error("No preview found for data", { data });
      throw new Error("No preview found for data");
    }
    const signEvent = {
      from: event.from,
      id: event.id,
      data,
      preview,
      wallet: event.wallet,
      domain: event.domain
    };
    return signEvent;
  }
  /**
   * Parse data to sign from bridge event
   */
  parseDataToSign(event) {
    try {
      const parsed = JSON.parse(event.params[0]);
      const validationResult = validateSignDataPayload(parsed);
      if (validationResult) {
        log$l.error("Invalid data to sign found in request", { validationResult });
        return void 0;
      }
      return parsed;
    } catch (error) {
      log$l.error("Invalid data to sign found in request", { error });
      return void 0;
    }
  }
  /**
   * Create human-readable preview of data to sign
   */
  createDataPreview(data, _event) {
    if (data.type === "text") {
      return {
        kind: "text",
        content: data.text
      };
    }
    if (data.type === "binary") {
      return {
        kind: "binary",
        content: data.bytes
      };
    }
    if (data.type === "cell") {
      if (!data.schema) {
        return {
          kind: "cell",
          content: data.cell
        };
      }
      try {
        const parsed = parseTLB(data.schema).deserialize(data.cell);
        return {
          kind: "cell",
          schema: data.schema,
          content: data.cell,
          parsed
        };
      } catch (error) {
        log$l.error("Error deserializing cell", { error });
        return {
          kind: "cell",
          content: data.cell
        };
      }
    }
    return void 0;
  }
}

// Disconnect event handler
class DisconnectHandler extends BasicHandler {
    sessionManager;
    constructor(notify, sessionManager) {
        super(notify);
        this.sessionManager = sessionManager;
    }
    canHandle(event) {
        return event.method === 'disconnect';
    }
    async handle(event) {
        if (!event.wallet) {
            throw new Error('No wallet found in event');
        }
        const reason = this.extractDisconnectReason(event);
        const disconnectEvent = {
            reason,
            wallet: event.wallet,
        };
        await this.sessionManager.removeSession(event.from);
        return disconnectEvent;
    }
    /**
     * Extract disconnect reason from bridge event
     */
    extractDisconnectReason(event) {
        const params = event.params || {};
        // Check for reason field
        const reason = params.reason;
        if (typeof reason === 'string' && reason.length > 0) {
            return reason.slice(0, 200); // Limit length
        }
        // No specific reason provided
        return undefined;
    }
}

const log$k = globalLogger.createChild("EventRouter");
class EventRouter {
  eventEmitter;
  sessionManager;
  handlers = [];
  // Event callbacks
  connectRequestCallbacks = [];
  transactionRequestCallbacks = [];
  signDataRequestCallbacks = [];
  disconnectCallbacks = [];
  constructor(eventEmitter, sessionManager) {
    this.eventEmitter = eventEmitter;
    this.sessionManager = sessionManager;
    this.setupHandlers();
  }
  /**
   * Route incoming bridge event to appropriate handler
   */
  async routeEvent(event) {
    const validation = validateBridgeEvent(event);
    if (!validation.isValid) {
      log$k.error("Invalid bridge event", { errors: validation.errors });
      return;
    }
    try {
      for (const handler of this.handlers) {
        if (handler.canHandle(event)) {
          const result = await handler.handle(event);
          await handler.notify(result);
          break;
        }
      }
    } catch (error) {
      log$k.error("Error routing event", { error });
    }
  }
  /**
   * Register event callbacks
   */
  onConnectRequest(callback) {
    this.connectRequestCallbacks.push(callback);
  }
  onTransactionRequest(callback) {
    this.transactionRequestCallbacks.push(callback);
  }
  onSignDataRequest(callback) {
    this.signDataRequestCallbacks.push(callback);
  }
  onDisconnect(callback) {
    this.disconnectCallbacks.push(callback);
  }
  /**
   * Remove specific callback
   */
  removeConnectRequestCallback(callback) {
    const index = this.connectRequestCallbacks.indexOf(callback);
    if (index >= 0) {
      this.connectRequestCallbacks.splice(index, 1);
    }
  }
  removeTransactionRequestCallback(callback) {
    const index = this.transactionRequestCallbacks.indexOf(callback);
    if (index >= 0) {
      this.transactionRequestCallbacks.splice(index, 1);
    }
  }
  removeSignDataRequestCallback(callback) {
    const index = this.signDataRequestCallbacks.indexOf(callback);
    if (index >= 0) {
      this.signDataRequestCallbacks.splice(index, 1);
    }
  }
  removeDisconnectCallback(callback) {
    const index = this.disconnectCallbacks.indexOf(callback);
    if (index >= 0) {
      this.disconnectCallbacks.splice(index, 1);
    }
  }
  /**
   * Clear all callbacks
   */
  clearCallbacks() {
    this.connectRequestCallbacks = [];
    this.transactionRequestCallbacks = [];
    this.signDataRequestCallbacks = [];
    this.disconnectCallbacks = [];
  }
  /**
   * Setup event handlers
   */
  setupHandlers() {
    this.handlers = [
      new ConnectHandler(this.notifyConnectRequestCallbacks.bind(this)),
      new TransactionHandler(this.notifyTransactionRequestCallbacks.bind(this), this.eventEmitter),
      new SignDataHandler(this.notifySignDataRequestCallbacks.bind(this)),
      new DisconnectHandler(this.notifyDisconnectCallbacks.bind(this), this.sessionManager)
    ];
  }
  /**
   * Notify connect request callbacks
   */
  notifyConnectRequestCallbacks(event) {
    this.connectRequestCallbacks.forEach((callback) => {
      try {
        callback(event);
      } catch (error) {
        log$k.error("Error in connect request callback", { error });
      }
    });
  }
  /**
   * Notify transaction request callbacks
   */
  notifyTransactionRequestCallbacks(event) {
    this.transactionRequestCallbacks.forEach((callback) => {
      try {
        callback(event);
      } catch (error) {
        log$k.error("Error in transaction request callback", { error });
      }
    });
  }
  /**
   * Notify sign data request callbacks
   */
  notifySignDataRequestCallbacks(event) {
    this.signDataRequestCallbacks.forEach((callback) => {
      try {
        callback(event);
      } catch (error) {
        log$k.error("Error in sign data request callback", { error });
      }
    });
  }
  /**
   * Notify disconnect callbacks
   */
  notifyDisconnectCallbacks(event) {
    this.disconnectCallbacks.forEach((callback) => {
      try {
        callback(event);
      } catch (error) {
        log$k.error("Error in disconnect callback", { error });
      }
    });
  }
  /**
   * Get enabled event types based on registered callbacks
   * Used by durable event processor to filter events
   * TODO - on change, trigger wallet processing restart
   */
  getEnabledEventTypes() {
    const enabledTypes = [];
    if (this.connectRequestCallbacks.length > 0) {
      enabledTypes.push("startConnect");
    }
    if (this.transactionRequestCallbacks.length > 0) {
      enabledTypes.push("sendTransaction");
    }
    if (this.signDataRequestCallbacks.length > 0) {
      enabledTypes.push("signData");
    }
    if (this.disconnectCallbacks.length > 0) {
      enabledTypes.push("disconnect");
    }
    return enabledTypes;
  }
}

var distExports = requireDist$3();

// import { createHash } from 'crypto'
const tonProofPrefix = 'ton-proof-item-v2/';
const tonConnectPrefix = 'ton-connect';
async function CreateTonProofMessageBytes(message) {
    // wc := make([]byte, 4)
    // binary.BigEndian.PutUint32(wc, uint32(message.Workchain))
    const wc = Buffer.alloc(4);
    wc.writeUInt32BE(message.Workchain);
    // ts := make([]byte, 8)
    // binary.LittleEndian.PutUint64(ts, uint64(message.Timstamp))
    const ts = Buffer.alloc(8);
    ts.writeBigUInt64LE(BigInt(message.Timstamp));
    // dl := make([]byte, 4)
    // binary.LittleEndian.PutUint32(dl, message.Domain.LengthBytes)
    const dl = Buffer.alloc(4);
    dl.writeUInt32LE(message.Domain.LengthBytes);
    const m = Buffer.concat([
        Buffer.from(tonProofPrefix),
        wc,
        message.Address,
        dl,
        Buffer.from(message.Domain.Value),
        ts,
        Buffer.from(message.Payload),
    ]);
    // const messageHash =  //sha256.Sum256(m)
    // const messageHash = await crypto.subtle.digest('SHA-256', m)
    // const m = Buffer.from(tonProofPrefix)
    // m.write(ts)
    // m := []byte(tonProofPrefix)
    // m = append(m, wc...)
    // m = append(m, message.Address...)
    // m = append(m, dl...)
    // m = append(m, []byte(message.Domain.Value)...)
    // m = append(m, ts...)
    // m = append(m, []byte(message.Payload)...)
    const messageHash = distExports.sha256_sync(m); // createHash('sha256').update(m).digest()
    const fullMes = Buffer.concat([Buffer.from([0xff, 0xff]), Buffer.from(tonConnectPrefix), Buffer.from(messageHash)]);
    // []byte{0xff, 0xff}
    // fullMes = append(fullMes, []byte(tonConnectPrefix)...)
    // fullMes = append(fullMes, messageHash[:]...)
    // const res = await crypto.subtle.digest('SHA-256', fullMes)
    const res = distExports.sha256_sync(fullMes);
    return Buffer.from(res);
}
function createTonProofMessage({ address, domain, payload, stateInit, timestamp, }) {
    const res = {
        Workchain: address.workChain,
        Address: address.hash,
        Domain: {
            LengthBytes: domain.LengthBytes,
            Value: domain.Value,
        },
        // Signature: Buffer.from(tp.proof.signature, 'base64'),
        Payload: payload,
        StateInit: stateInit,
        Timstamp: timestamp,
    };
    return res;
}

/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
function signed_crc_table() {
  var c = 0, table2 = new Array(256);
  for (var n = 0; n != 256; ++n) {
    c = n;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
    table2[n] = c;
  }
  return typeof Int32Array !== "undefined" ? new Int32Array(table2) : table2;
}
var T0 = signed_crc_table();
function slice_by_16_tables(T) {
  var c = 0, v = 0, n = 0, table2 = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
  for (n = 0; n != 256; ++n)
    table2[n] = T[n];
  for (n = 0; n != 256; ++n) {
    v = T[n];
    for (c = 256 + n; c < 4096; c += 256)
      v = table2[c] = v >>> 8 ^ T[v & 255];
  }
  var out = [];
  for (n = 1; n != 16; ++n)
    out[n - 1] = typeof Int32Array !== "undefined" ? table2.subarray(n * 256, n * 256 + 256) : table2.slice(n * 256, n * 256 + 256);
  return out;
}
var TT = slice_by_16_tables(T0);
var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
function crc32_buf(B, seed) {
  var C = seed ^ -1, L = B.length - 15, i = 0;
  for (; i < L; )
    C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
  L += 15;
  while (i < L)
    C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
  return ~C;
}
const buf = crc32_buf;

/**
 * Creates hash for text or binary payload.
 * Message format:
 * message = 0xffff || "ton-connect/sign-data/" || workchain || address_hash || domain_len || domain || timestamp || payload
 */
function createTextBinaryHash(payload, parsedAddr, domain, timestamp) {
    // Create workchain buffer
    const wcBuffer = Buffer.alloc(4);
    wcBuffer.writeInt32BE(parsedAddr.workChain);
    // Create domain buffer
    const domainBuffer = Buffer.from(domain, 'utf8');
    const domainLenBuffer = Buffer.alloc(4);
    domainLenBuffer.writeUInt32BE(domainBuffer.length);
    // Create timestamp buffer
    const tsBuffer = Buffer.alloc(8);
    tsBuffer.writeBigUInt64BE(BigInt(timestamp));
    // Create payload buffer
    const typePrefix = payload.type === 'text' ? 'txt' : 'bin';
    const content = payload.type === 'text' ? payload.text : payload.bytes;
    const encoding = payload.type === 'text' ? 'utf8' : 'base64';
    const payloadPrefix = Buffer.from(typePrefix);
    const payloadBuffer = Buffer.from(content, encoding);
    const payloadLenBuffer = Buffer.alloc(4);
    payloadLenBuffer.writeUInt32BE(payloadBuffer.length);
    // Build message
    const message = Buffer.concat([
        Buffer.from([0xff, 0xff]),
        Buffer.from('ton-connect/sign-data/'),
        wcBuffer,
        parsedAddr.hash,
        domainLenBuffer,
        domainBuffer,
        tsBuffer,
        payloadPrefix,
        payloadLenBuffer,
        payloadBuffer,
    ]);
    // Hash message with sha256
    return distExports.sha256_sync(message); // crypto.createHash('sha256').update(message).digest()
}
/**
 * Creates hash for Cell payload according to TON Connect specification.
 */
function createCellHash(payload, parsedAddr, domain, timestamp) {
    const cell = distExports$2.Cell.fromBase64(payload.cell);
    const schemaHash = buf(Buffer.from(payload.schema, 'utf8'), undefined) >>> 0; // unsigned crc32 hash
    const tep81Domain = domain.split('.').reverse().join('\0') + '\0';
    const message = distExports$2.beginCell()
        .storeUint(0x75569022, 32) // prefix
        .storeUint(schemaHash, 32) // schema hash
        .storeUint(timestamp, 64) // timestamp
        .storeAddress(parsedAddr) // user wallet address
        .storeStringRefTail(tep81Domain) // app domain
        .storeRef(cell) // payload cell
        .endCell();
    return Buffer.from(message.hash());
}

/**
 * Signs data according to TON Connect sign-data protocol.
 *
 * Supports three payload types:
 * 1. text - for text messages
 * 2. binary - for arbitrary binary data
 * 3. cell - for TON Cell with TL-B schema
 *
 * @param params Signing parameters
 * @returns Signed data with base64 signature
 */
function PrepareTonConnectData(params) {
    const { payload, domain, address } = params;
    const timestamp = Math.floor(Date.now() / 1000);
    const parsedAddr = distExports$2.Address.parse(address);
    // Create hash based on payload type
    const finalHash = payload.type === 'cell'
        ? createCellHash(payload, parsedAddr, domain, timestamp)
        : createTextBinaryHash(payload, parsedAddr, domain, timestamp);
    return {
        address,
        timestamp,
        domain,
        payload,
        hash: new Uint8Array(finalHash),
    };
}

const log$j = globalLogger.createChild("RequestProcessor");
class RequestProcessor {
  sessionManager;
  bridgeManager;
  client;
  network;
  constructor(sessionManager, bridgeManager, client, network) {
    this.sessionManager = sessionManager;
    this.bridgeManager = bridgeManager;
    this.client = client;
    this.network = network;
  }
  /**
   * Process connect request approval
   */
  async approveConnectRequest(event) {
    try {
      if (!event.wallet) {
        throw new Error("Wallet is required");
      }
      const url = new URL(event.dAppUrl);
      const domain = url.hostname;
      const newSession = await this.sessionManager.createSession(event.id, event.dAppName, domain, event.wallet);
      await this.bridgeManager.createSession(newSession.sessionId);
      const response = await this.createConnectApprovalResponse(event);
      await this.bridgeManager.sendResponse(newSession.sessionId, event.id, response.result);
    } catch (error) {
      log$j.error("Failed to approve connect request", { error });
      throw error;
    }
  }
  /**
   * Process connect request rejection
   */
  async rejectConnectRequest(event, reason) {
    try {
      log$j.info("Connect request rejected", {
        id: event.id,
        dAppName: event.dAppName,
        reason: reason || "User rejected connection"
      });
    } catch (error) {
      log$j.error("Failed to reject connect request", { error });
      throw error;
    }
  }
  /**
   * Process transaction request approval
   */
  async approveTransactionRequest(event) {
    try {
      const signedBoc = await this.signTransaction(event);
      const response = {
        result: signedBoc,
        id: event.id
      };
      await CallForSuccess(() => this.client.sendFile(Buffer.from(signedBoc, "base64")));
      await this.bridgeManager.sendResponse(event.from, event.id, response);
      return { signedBoc };
    } catch (error) {
      log$j.error("Failed to approve transaction request", { error });
      throw error;
    }
  }
  /**
   * Process transaction request rejection
   */
  async rejectTransactionRequest(event, reason) {
    try {
      const response = {
        error: {
          code: SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR,
          message: reason || "User rejected transaction"
        },
        id: event.id
      };
      await this.bridgeManager.sendResponse(event.from, event.id, response);
    } catch (error) {
      log$j.error("Failed to reject transaction request", { error });
      throw error;
    }
  }
  /**
   * Process sign data request approval
   */
  async approveSignDataRequest(event) {
    try {
      const signData = PrepareTonConnectData({
        payload: event.data,
        domain: event.domain,
        address: event.wallet.getAddress().toString()
      });
      const signature = await event.wallet.sign(signData.hash);
      const response = {
        id: event.id,
        result: {
          signature: Buffer.from(signature).toString("base64"),
          address: signData.address,
          timestamp: signData.timestamp,
          domain: signData.domain,
          payload: signData.payload
        }
      };
      await this.bridgeManager.sendResponse(event.from, event.id, response);
      return { signature };
    } catch (error) {
      log$j.error("Failed to approve sign data request", { error });
      throw error;
    }
  }
  /**
   * Process sign data request rejection
   */
  async rejectSignDataRequest(event, reason) {
    try {
      const response = {
        error: "USER_REJECTED",
        reason: reason || "User rejected data signing"
      };
      await this.bridgeManager.sendResponse(event.id, event.id, response);
    } catch (error) {
      log$j.error("Failed to reject sign data request", { error });
      throw error;
    }
  }
  /**
   * Create connect approval response
   */
  async createConnectApprovalResponse(event) {
    const wallet = event.wallet;
    if (!wallet) {
      throw new Error("Wallet is required for connect approval");
    }
    const walletStateInit = await wallet.getStateInit();
    const publicKey = Buffer.from(wallet.publicKey).toString("hex");
    const address = wallet.getAddress();
    const connectResponse = {
      event: "connect",
      id: Date.now(),
      payload: {
        device: {
          platform: "browser",
          appName: "tonkeeper",
          appVersion: "1.0.0",
          maxProtocolVersion: 2,
          features: [
            {
              name: "SendTransaction",
              maxMessages: 4,
              // Default for most wallet types
              extraCurrencySupported: true
            },
            {
              name: "SignData",
              types: ["text", "binary", "cell"]
            }
          ]
        },
        items: [
          {
            name: "ton_addr",
            address: distExports$2.Address.parse(address).toRawString(),
            network: this.network,
            walletStateInit,
            publicKey
          }
        ]
      }
    };
    const proofItem = event.request.find((item) => item.name === "ton_proof");
    if (proofItem) {
      let domain = {
        LengthBytes: 0,
        Value: ""
      };
      try {
        const dAppUrl = new URL(event.dAppUrl);
        domain = {
          LengthBytes: Buffer.from(dAppUrl.host).length,
          Value: dAppUrl.host
        };
      } catch (error) {
        log$j.error("Failed to parse domain", { error });
      }
      const timestamp = Math.floor(Date.now() / 1e3);
      const signMessage = createTonProofMessage({
        address: distExports$2.Address.parse(address),
        domain,
        payload: proofItem.payload,
        stateInit: walletStateInit,
        timestamp
      });
      const signature = await wallet.sign(await CreateTonProofMessageBytes(signMessage));
      connectResponse.payload.items.push({
        name: "ton_proof",
        proof: {
          timestamp,
          domain: {
            lengthBytes: domain.LengthBytes,
            value: domain.Value
          },
          payload: proofItem.payload,
          signature: Buffer.from(signature).toString("base64")
        }
      });
    }
    return {
      result: connectResponse
    };
  }
  /**
   * Sign transaction and return BOC
   */
  async signTransaction(event) {
    const signedBoc = await event.wallet.getSignedExternal(event.request, {
      fakeSignature: false
    });
    log$j.debug("Signing transaction", {
      id: event.id,
      messagesCount: event.request.messages.length,
      from: event.request.from,
      validUntil: event.request.valid_until
    });
    return signedBoc;
  }
}

const log$i = globalLogger.createChild("ResponseHandler");
class ResponseHandler {
  bridgeManager;
  sessionManager;
  constructor(bridgeManager, sessionManager) {
    this.bridgeManager = bridgeManager;
    this.sessionManager = sessionManager;
  }
  /**
   * Send success response
   */
  async sendSuccess(requestId, sessionId, result) {
    const response = { result };
    await this.sendResponse(requestId, sessionId, response);
  }
  /**
   * Send error response
   */
  async sendError(requestId, sessionId, error, reason, code) {
    const response = {
      error,
      reason,
      ...code && { code }
    };
    await this.sendResponse(requestId, sessionId, response);
  }
  /**
   * Send user rejection response
   */
  async sendUserRejection(requestId, sessionId, reason) {
    await this.sendError(requestId, sessionId, "USER_REJECTED", reason || "User rejected the request");
  }
  /**
   * Send validation error response
   */
  async sendValidationError(requestId, sessionId, validationErrors) {
    await this.sendError(requestId, sessionId, "VALIDATION_ERROR", validationErrors.join("; "), 400);
  }
  /**
   * Send internal error response
   */
  async sendInternalError(requestId, sessionId, error) {
    const reason = error?.message || "Internal server error";
    await this.sendError(requestId, sessionId, "INTERNAL_ERROR", reason, 500);
  }
  /**
   * Send method not supported error
   */
  async sendMethodNotSupported(requestId, sessionId, method) {
    await this.sendError(requestId, sessionId, "METHOD_NOT_SUPPORTED", `Method '${method}' is not supported`, 501);
  }
  /**
   * Send session not found error
   */
  async sendSessionNotFound(requestId, sessionId) {
    await this.sendError(requestId, sessionId, "SESSION_NOT_FOUND", "Session not found or expired", 404);
  }
  /**
   * Generic response sender with error handling
   */
  async sendResponse(requestId, sessionId, response) {
    try {
      if (sessionId) {
        await this.sessionManager.updateSessionActivity(sessionId);
      }
      await this.bridgeManager.sendResponse(requestId, requestId, response);
      this.logResponse(requestId, sessionId, response, true);
    } catch (error) {
      log$i.error("Failed to send response", {
        requestId,
        sessionId,
        response,
        error
      });
      try {
        await this.bridgeManager.sendResponse(requestId, requestId, {
          error: "RESPONSE_FAILED",
          reason: "Failed to send original response"
        });
      } catch (fallbackError) {
        log$i.error("Failed to send fallback error response", { error: fallbackError });
      }
      throw error;
    }
  }
  /**
   * Log response for debugging/monitoring
   */
  logResponse(requestId, sessionId, response, success) {
    const logData = {
      requestId,
      sessionId,
      responseType: "error" in response ? "error" : "success",
      success,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
    if (success) {
      log$i.debug("Response sent successfully", logData);
    } else {
      log$i.error("Failed to send response", logData);
    }
  }
  /**
   * Get response statistics (for monitoring)
   */
  getStats() {
    return { sent: 0, errors: 0 };
  }
}

function walletV5ConfigToCell(config) {
    return distExports$2.beginCell()
        .storeBit(config.signatureAllowed)
        .storeUint(config.seqno, 32)
        .storeUint(config.walletId, 32)
        .storeBuffer(Buffer.from(config.publicKey), 32)
        .storeDict(config.extensions, distExports$2.Dictionary.Keys.BigUint(256), distExports$2.Dictionary.Values.BigInt(1))
        .endCell();
}
const Opcodes = {
    auth_extension: 0x6578746e};
class WalletId {
    static deserialize(walletId) {
        return new WalletId({
            subwalletNumber: Number(walletId),
        });
    }
    subwalletNumber;
    serialized;
    constructor(args) {
        this.subwalletNumber = args?.subwalletNumber ?? 0;
        this.serialized = BigInt(this.subwalletNumber);
    }
}
class WalletV5 {
    address;
    init;
    subwalletId;
    constructor(address, init) {
        this.address = address;
        this.init = init;
    }
    static createFromAddress(address) {
        return new WalletV5(address);
    }
    static createFromConfig(config, code, workchain = 0) {
        const data = walletV5ConfigToCell(config);
        const init = { code, data };
        const wallet = new WalletV5(distExports$2.contractAddress(workchain, init), init);
        wallet.subwalletId = config.walletId;
        return wallet;
    }
    async sendDeploy(provider, via, value) {
        await provider.internal(via, {
            value,
            sendMode: distExports$2.SendMode.PAY_GAS_SEPARATELY,
            body: distExports$2.beginCell().endCell(),
        });
    }
    async sendInternalSignedMessage(provider, via, opts) {
        await provider.internal(via, {
            value: opts.value,
            sendMode: distExports$2.SendMode.PAY_GAS_SEPARATELY,
            body: distExports$2.beginCell().storeSlice(opts.body.beginParse()).endCell(),
        });
    }
    async sendInternalMessageFromExtension(provider, via, opts) {
        await provider.internal(via, {
            value: opts.value,
            sendMode: distExports$2.SendMode.PAY_GAS_SEPARATELY,
            body: distExports$2.beginCell()
                .storeUint(Opcodes.auth_extension, 32)
                .storeUint(0, 64) // query id
                .storeSlice(opts.body.beginParse())
                .endCell(),
        });
    }
    async sendInternal(provider, via, opts) {
        await provider.internal(via, opts);
    }
    async sendExternalSignedMessage(provider, body) {
        await provider.external(body);
    }
    async sendExternal(provider, body) {
        await provider.external(body);
    }
    async getPublicKey(provider) {
        const result = await provider.get('get_public_key', []);
        return result.stack.readBigNumber();
    }
    async getSeqno(provider) {
        const state = await provider.getState();
        if (state.state.type === 'active') {
            const res = await provider.get('seqno', []);
            return res.stack.readNumber();
        }
        else {
            return 0;
        }
    }
    async getIsSignatureAuthAllowed(provider) {
        const state = await provider.getState();
        if (state.state.type === 'active') {
            const res = await provider.get('is_signature_allowed', []);
            return res.stack.readNumber();
        }
        else {
            return -1;
        }
    }
    async getWalletId(provider) {
        if (this.subwalletId) {
            return WalletId.deserialize(this.subwalletId);
        }
        else {
            const result = await provider.get('get_subwallet_id', []);
            this.subwalletId = result.stack.readBigNumber();
            return WalletId.deserialize(this.subwalletId);
        }
    }
    async getExtensions(provider) {
        const result = await provider.get('get_extensions', []);
        return result.stack.readCellOpt();
    }
    async getExtensionsArray(provider) {
        const extensions = await this.getExtensions(provider);
        if (!extensions) {
            return [];
        }
        const dict = distExports$2.Dictionary.loadDirect(distExports$2.Dictionary.Keys.BigUint(256), distExports$2.Dictionary.Values.BigInt(1), extensions);
        return dict.keys().map((key) => {
            const wc = this.address.workChain;
            const addressHex = key;
            return distExports$2.Address.parseRaw(`${wc}:${addressHex.toString(16).padStart(64, '0')}`);
        });
    }
}

const WalletV5R1CodeBoc = 'b5ee9c7201021401000281000114ff00f4a413f4bcf2c80b01020120020302014804050102f20e02dcd020d749c120915b8f6320d70b1f2082106578746ebd21821073696e74bdb0925f03e082106578746eba8eb48020d72101d074d721fa4030fa44f828fa443058bd915be0ed44d0810141d721f4058307f40e6fa1319130e18040d721707fdb3ce03120d749810280b99130e070e2100f020120060702012008090019be5f0f6a2684080a0eb90fa02c02016e0a0b0201480c0d0019adce76a2684020eb90eb85ffc00019af1df6a2684010eb90eb858fc00017b325fb51341c75c875c2c7e00011b262fb513435c28020011e20d70b1f82107369676ebaf2e08a7f0f01e68ef0eda2edfb218308d722028308d723208020d721d31fd31fd31fed44d0d200d31f20d31fd3ffd70a000af90140ccf9109a28945f0adb31e1f2c087df02b35007b0f2d0845125baf2e0855036baf2e086f823bbf2d0882292f800de01a47fc8ca00cb1f01cf16c9ed542092f80fde70db3cd81003f6eda2edfb02f404216e926c218e4c0221d73930709421c700b38e2d01d72820761e436c20d749c008f2e09320d74ac002f2e09320d71d06c712c2005230b0f2d089d74cd7393001a4e86c128407bbf2e093d74ac000f2e093ed55e2d20001c000915be0ebd72c08142091709601d72c081c12e25210b1e30f20d74a111213009601fa4001fa44f828fa443058baf2e091ed44d0810141d718f405049d7fc8ca0040048307f453f2e08b8e14038307f45bf2e08c22d70a00216e01b3b0f2d090e2c85003cf1612f400c9ed54007230d72c08248e2d21f2e092d200ed44d0d2005113baf2d08f54503091319c01810140d721d70a00f2e08ee2c8ca0058cf16c9ed5493f2c08de20010935bdb31e1d74cd0';
const WalletV5R1CodeCell = distExports$2.Cell.fromBoc(Buffer.from(WalletV5R1CodeBoc, 'hex'))[0];

function DefaultSignature(data, privateKey) {
    return new Uint8Array(distExports.sign(Buffer.from(data), Buffer.from(privateKey)));
}
const fakeKeyPair = distExports.keyPairFromSeed(Buffer.alloc(32, 0));
function FakeSignature(data) {
    return new Uint8Array(distExports.sign(Buffer.from(data), fakeKeyPair.secretKey));
}

async function MnemonicToKeyPair(mnemonic, mnemonicType) {
    const mnemonicArray = Array.isArray(mnemonic) ? mnemonic : mnemonic.split(' ');
    if (mnemonicArray.length !== 24) {
        throw new Error('Invalid mnemonic length: expected 24 words, got ' + mnemonicArray.length);
    }
    if (mnemonicType === 'ton') {
        const key = await distExports.mnemonicToWalletKey(mnemonicArray);
        return {
            publicKey: new Uint8Array(key.publicKey),
            secretKey: new Uint8Array(key.secretKey),
        };
    }
    // TODO bip39 support
    throw new Error('Invalid mnemonic type: expected "ton" or "bip39", got ' + mnemonicType);
}

class ActionSendMsg {
    mode;
    outMsg;
    static tag = 0x0ec3c86d;
    tag = ActionSendMsg.tag;
    constructor(mode, outMsg) {
        this.mode = mode;
        this.outMsg = outMsg;
    }
    serialize() {
        return distExports$2.beginCell()
            .storeUint(this.tag, 32)
            .storeUint(this.mode | distExports$2.SendMode.IGNORE_ERRORS, 8)
            .storeRef(distExports$2.beginCell().store(distExports$2.storeMessageRelaxed(this.outMsg)).endCell())
            .endCell();
    }
}
class ActionAddExtension {
    address;
    static tag = 0x02;
    tag = ActionAddExtension.tag;
    constructor(address) {
        this.address = address;
    }
    serialize() {
        return distExports$2.beginCell().storeUint(this.tag, 8).storeAddress(this.address).endCell();
    }
}
class ActionRemoveExtension {
    address;
    static tag = 0x03;
    tag = ActionRemoveExtension.tag;
    constructor(address) {
        this.address = address;
    }
    serialize() {
        return distExports$2.beginCell().storeUint(this.tag, 8).storeAddress(this.address).endCell();
    }
}
class ActionSetSignatureAuthAllowed {
    allowed;
    static tag = 0x04;
    tag = ActionSetSignatureAuthAllowed.tag;
    constructor(allowed) {
        this.allowed = allowed;
    }
    serialize() {
        return distExports$2.beginCell()
            .storeUint(this.tag, 8)
            .storeUint(this.allowed ? 1 : 0, 1)
            .endCell();
    }
}
function isExtendedAction(action) {
    return (action.tag === ActionAddExtension.tag ||
        action.tag === ActionRemoveExtension.tag ||
        action.tag === ActionSetSignatureAuthAllowed.tag);
}
function packActionsListOut(actions) {
    if (actions.length === 0) {
        return distExports$2.beginCell().endCell();
    }
    const [action, ...rest] = actions;
    if (isExtendedAction(action)) {
        throw new Error('Actions bust be in an order: all extended actions, all out actions');
    }
    return distExports$2.beginCell().storeRef(packActionsListOut(rest)).storeSlice(action.serialize().beginParse()).endCell();
}
function packExtendedActions(extendedActions) {
    const first = extendedActions[0];
    const rest = extendedActions.slice(1);
    let builder = distExports$2.beginCell().storeSlice(first.serialize().beginParse());
    if (rest.length > 0) {
        builder = builder.storeRef(packExtendedActions(extendedActions.slice(1)));
    }
    return builder.endCell();
}
function packActionsListExtended(actions) {
    const extendedActions = [];
    const outActions = [];
    actions.forEach((action) => {
        if (isExtendedAction(action)) {
            extendedActions.push(action);
        }
        else {
            outActions.push(action);
        }
    });
    let builder = distExports$2.beginCell();
    if (outActions.length === 0) {
        builder = builder.storeUint(0, 1);
    }
    else {
        builder = builder.storeMaybeRef(packActionsListOut(outActions.slice().reverse()));
    }
    if (extendedActions.length === 0) {
        builder = builder.storeUint(0, 1);
    }
    else {
        const first = extendedActions[0];
        const rest = extendedActions.slice(1);
        builder = builder.storeUint(1, 1).storeSlice(first.serialize().beginParse());
        if (rest.length > 0) {
            builder = builder.storeRef(packExtendedActions(rest));
        }
    }
    return builder.endCell();
}
function packActionsList(actions) {
    return packActionsListExtended(actions);
}

const log$h = globalLogger.createChild("WalletV5R1Adapter");
class WalletV5R1Adapter {
  keyPair;
  walletContract;
  client;
  config;
  publicKey;
  version = "v5r1";
  constructor(config) {
    this.config = config;
    this.client = config.tonClient;
    const privateKey = this.config.privateKey.length === 32 ? this.config.privateKey : this.config.privateKey.slice(0, 32);
    this.keyPair = distExports.keyPairFromSeed(Buffer.from(privateKey));
    this.publicKey = Uint8Array.from(this.keyPair.publicKey);
    this.walletContract = WalletV5.createFromConfig({
      publicKey: this.keyPair.publicKey,
      seqno: 0,
      signatureAllowed: true,
      walletId: 2147483409n,
      // todo fix
      extensions: distExports$2.Dictionary.empty()
    }, WalletV5R1CodeCell, 0);
  }
  /**
   * Sign raw bytes with wallet's private key
   */
  async sign(bytes) {
    return DefaultSignature(bytes, this.keyPair.secretKey);
  }
  /**
   * Get wallet's TON address
   */
  getAddress(options) {
    return formatWalletAddress(this.walletContract.address, options?.testnet);
  }
  async getSignedExternal(input, options) {
    const actions = packActionsList(input.messages.map((m) => {
      const msg = distExports$2.internal({
        body: m.payload ? distExports$2.Cell.fromBase64(m.payload) : void 0,
        to: m.address,
        value: BigInt(m.amount),
        bounce: false,
        extracurrency: m.extraCurrency ? Object.fromEntries(Object.entries(m.extraCurrency).map(([k, v]) => [Number(k), BigInt(v)])) : void 0
      });
      if (m.stateInit) {
        msg.init = distExports$2.loadStateInit(distExports$2.Cell.fromBase64(m.stateInit).asSlice());
      }
      return new ActionSendMsg(distExports$2.SendMode.PAY_GAS_SEPARATELY + distExports$2.SendMode.IGNORE_ERRORS, msg);
    }));
    let seqno = 0;
    try {
      seqno = await CallForSuccess(async () => this.getSeqno(), 5, 1e3);
    } catch (_) {
    }
    const provider = this.client.provider(this.walletContract.address);
    let walletId;
    try {
      walletId = (await this.walletContract.getWalletId(provider)).serialized;
    } catch (_) {
    }
    if (!walletId) {
      throw new Error("Failed to get seqno or walletId");
    }
    const transfer = await this.createBodyV5(seqno, walletId, actions, options);
    const ext = distExports$2.external({
      to: this.walletContract.address,
      init: this.walletContract.init,
      body: transfer
    });
    return distExports$2.beginCell().store(distExports$2.storeMessage(ext)).endCell().toBoc().toString("base64");
  }
  /**
   * Get wallet's current balance in nanotons
   */
  async getBalance() {
    try {
      const balance = await CallForSuccess(async () => this.client.getBalance(this.walletContract.address), 5, 1e3);
      return balance;
    } catch (error) {
      log$h.warn("Failed to get balance", { error });
      throw error;
    }
  }
  /**
   * Get state init for wallet deployment
   */
  async getStateInit() {
    if (!this.walletContract.init) {
      throw new Error("Wallet contract not properly initialized");
    }
    const stateInit = distExports$2.beginCell().store(distExports$2.storeStateInit(this.walletContract.init)).endCell();
    return stateInit.toBoc().toString("base64");
  }
  /**
   * Get the underlying WalletV5 contract
   */
  getContract() {
    return this.walletContract;
  }
  /**
   * Get current sequence number
   */
  async getSeqno() {
    try {
      const provider = this.client.provider(this.walletContract.address);
      return await this.walletContract.getSeqno(provider);
    } catch (error) {
      log$h.warn("Failed to get seqno", { error });
      throw error;
    }
  }
  /**
   * Get wallet ID
   */
  async getWalletId() {
    try {
      const provider = this.client.provider(this.walletContract.address);
      return await this.walletContract.getWalletId(provider);
    } catch (error) {
      log$h.warn("Failed to get wallet ID", { error });
      return new WalletId({ subwalletNumber: this.config.walletId || 0 });
    }
  }
  /**
   * Check if wallet is deployed on the network
   */
  async isDeployed() {
    try {
      const state = await this.client.getContractState(this.walletContract.address);
      return state.state === "active";
    } catch (error) {
      log$h.warn("Failed to check deployment status", { error });
      return false;
    }
  }
  async createBodyV5(seqno, walletId, actionsList, options) {
    const Opcodes = {
      auth_signed: 1936287598
    };
    const expireAt = Math.floor(Date.now() / 1e3) + 60;
    const payload = distExports$2.beginCell().storeUint(Opcodes.auth_signed, 32).storeUint(walletId, 32).storeUint(expireAt, 32).storeUint(seqno, 32).storeSlice(actionsList.beginParse()).endCell();
    const signingData = payload.hash();
    const signature = options.fakeSignature ? FakeSignature(signingData) : await this.sign(signingData);
    return distExports$2.beginCell().storeSlice(payload.beginParse()).storeBuffer(Buffer.from(signature)).endCell();
  }
}
async function createWalletV5R1(config, options) {
  let keyPair;
  if (config instanceof WalletInitConfigMnemonic) {
    keyPair = await MnemonicToKeyPair(config.mnemonic, config.mnemonicType);
  } else if (config instanceof WalletInitConfigPrivateKey) {
    keyPair = distExports.keyPairFromSeed(Buffer.from(config.privateKey, "hex"));
  } else {
    throw new Error("Unsupported wallet configuration format");
  }
  return new WalletV5R1Adapter({
    privateKey: keyPair.secretKey,
    network: config.network || "mainnet",
    tonClient: options.tonClient,
    walletId: config.walletId
  });
}

const getEventUUID = () => {
  return crypto.randomUUID();
};
const log$g = globalLogger.createChild("EventStore");
const MAX_EVENT_SIZE_BYTES = 100 * 1024;
class StorageEventStore {
  storageAdapter;
  storageKey = "durable_events";
  operationLock = /* @__PURE__ */ new Map();
  constructor(storageAdapter) {
    this.storageAdapter = storageAdapter;
  }
  /**
   * Store a new event from the bridge
   */
  async storeEvent(_rawEvent) {
    const rawEvent = { ..._rawEvent, wallet: void 0 };
    const validation = validateBridgeEvent(rawEvent);
    if (!validation.isValid) {
      throw new Error(`Invalid bridge event: ${validation.errors.join(", ")}`);
    }
    const eventStr = JSON.stringify(rawEvent);
    const sizeBytes = new TextEncoder().encode(eventStr).length;
    if (sizeBytes > MAX_EVENT_SIZE_BYTES) {
      throw new Error(`Event too large: ${sizeBytes} bytes (max: ${MAX_EVENT_SIZE_BYTES})`);
    }
    const eventType = this.extractEventType(rawEvent.method);
    const storedEvent = {
      id: getEventUUID(),
      sessionId: rawEvent.from,
      eventType,
      rawEvent,
      status: "new",
      createdAt: Date.now(),
      sizeBytes
    };
    await this.saveEvent(storedEvent);
    log$g.info("Event stored", {
      eventId: storedEvent.id,
      eventType,
      sizeBytes,
      sessionId: rawEvent.from
    });
    return storedEvent;
  }
  /**
   * Get events for a wallet that are ready for processing
   */
  async getEventsForWallet(_walletAddress, sessionIds, eventTypes) {
    const events = await this.getAllEvents();
    return events.filter((event) => (
      // Only new events
      event.status === "new" && // Must match one of the session IDs
      event.sessionId && sessionIds.includes(event.sessionId) && // Must be one of the requested event types
      eventTypes.includes(event.eventType)
    )).sort((a, b) => a.createdAt - b.createdAt);
  }
  /**
   * Attempt to acquire exclusive lock on an event for processing
   */
  async acquireLock(eventId, walletAddress) {
    return this.withLock("storage", async () => {
      const allEvents = await this.getAllEventsFromStorage();
      const event = allEvents[eventId];
      if (!event) {
        log$g.warn("Cannot lock non-existent event", { eventId });
        return void 0;
      }
      if (event.status !== "new") {
        log$g.debug("Cannot lock event - not in new status", {
          eventId,
          status: event.status,
          lockedBy: event.lockedBy
        });
        return void 0;
      }
      const updatedEvent = {
        ...event,
        status: "processing",
        processingStartedAt: Date.now(),
        lockedBy: walletAddress
      };
      allEvents[eventId] = updatedEvent;
      await this.storageAdapter.set(this.storageKey, allEvents);
      log$g.debug("Event lock acquired", { eventId, walletAddress });
      return updatedEvent;
    });
  }
  /**
   * Update event status and timestamps with optimistic locking
   */
  async updateEventStatus(eventId, status, oldStatus) {
    return this.withLock("storage", async () => {
      const allEvents = await this.getAllEventsFromStorage();
      const event = allEvents[eventId];
      if (!event) {
        throw new Error(`Event not found: ${eventId}`);
      }
      if (event.status !== oldStatus) {
        throw new Error(`Event status mismatch: expected '${oldStatus}', but current status is '${event.status}'`);
      }
      const updatedEvent = {
        ...event,
        status
      };
      if (status === "completed") {
        updatedEvent.completedAt = Date.now();
      }
      allEvents[eventId] = updatedEvent;
      await this.storageAdapter.set(this.storageKey, allEvents);
      log$g.debug("Event status updated", { eventId, oldStatus, newStatus: status });
      return updatedEvent;
    });
  }
  /**
   * Get event by ID
   */
  async getEvent(eventId) {
    try {
      const allEvents = await this.getAllEventsFromStorage();
      return allEvents[eventId] || null;
    } catch (error) {
      log$g.warn("Failed to get event", { eventId, error });
      return null;
    }
  }
  /**
   * Recover stale events that have been processing too long
   */
  async recoverStaleEvents(processingTimeoutMs) {
    const events = await this.getAllEvents();
    const now = Date.now();
    let recoveredCount = 0;
    for (const event of events) {
      if (event.status === "processing" && event.processingStartedAt && now - event.processingStartedAt > processingTimeoutMs) {
        const recoveredEvent = {
          ...event,
          status: "new",
          processingStartedAt: void 0,
          lockedBy: void 0
        };
        await this.saveEvent(recoveredEvent);
        recoveredCount++;
        log$g.info("Recovered stale event", {
          eventId: event.id,
          lockedBy: event.lockedBy,
          staleMinutes: Math.round((now - event.processingStartedAt) / 6e4)
        });
      }
    }
    if (recoveredCount > 0) {
      log$g.info("Event recovery completed", { recoveredCount });
    }
    return recoveredCount;
  }
  /**
   * Clean up old completed events
   */
  async cleanupOldEvents(retentionMs) {
    const events = await this.getAllEvents();
    const cutoffTime = Date.now() - retentionMs;
    let cleanedUpCount = 0;
    const eventsToRemove = [];
    for (const event of events) {
      if (event.status === "completed" && event.completedAt && event.completedAt < cutoffTime) {
        eventsToRemove.push(event.id);
        log$g.debug("Marked event for cleanup", { eventId: event.id });
      }
    }
    if (eventsToRemove.length > 0) {
      await this.withLock("storage", async () => {
        const allEvents = await this.getAllEventsFromStorage();
        for (const eventId of eventsToRemove) {
          delete allEvents[eventId];
          cleanedUpCount++;
        }
        await this.storageAdapter.set(this.storageKey, allEvents);
      });
      log$g.info("Event cleanup completed", { cleanedUpCount });
    }
    return cleanedUpCount;
  }
  /**
   * Get all events (for debugging and internal operations)
   */
  async getAllEvents() {
    try {
      const allEvents = await this.getAllEventsFromStorage();
      return Object.values(allEvents);
    } catch (error) {
      log$g.warn("Failed to get all events", { error });
      return [];
    }
  }
  // Private helper methods
  async withLock(lockKey, operation) {
    const existingLock = this.operationLock.get(lockKey);
    if (existingLock) {
      await existingLock;
    }
    const operationPromise = operation();
    this.operationLock.set(lockKey, operationPromise.then(() => {
    }, () => {
    }));
    try {
      const result = await operationPromise;
      this.operationLock.delete(lockKey);
      return result;
    } catch (error) {
      this.operationLock.delete(lockKey);
      throw error;
    }
  }
  async getAllEventsFromStorage() {
    try {
      const eventsData = await this.storageAdapter.get(this.storageKey);
      return eventsData || {};
    } catch (error) {
      log$g.warn("Failed to get events from storage", { error });
      return {};
    }
  }
  async saveEvent(event) {
    return this.withLock("storage", async () => {
      const allEvents = await this.getAllEventsFromStorage();
      allEvents[event.id] = event;
      await this.storageAdapter.set(this.storageKey, allEvents);
    });
  }
  async removeEvent(eventId) {
    return this.withLock("storage", async () => {
      const allEvents = await this.getAllEventsFromStorage();
      delete allEvents[eventId];
      await this.storageAdapter.set(this.storageKey, allEvents);
    });
  }
  extractEventType(method) {
    switch (method) {
      case "startConnect":
        return "startConnect";
      case "sendTransaction":
        return "sendTransaction";
      case "signData":
        return "signData";
      case "disconnect":
        return "disconnect";
      default:
        throw new Error(`Unknown event method: ${method}`);
    }
  }
}

const log$f = globalLogger.createChild("EventProcessor");
class StorageEventProcessor {
  eventStore;
  config;
  walletManager;
  sessionManager;
  eventRouter;
  eventEmitter;
  // Active processing loops per wallet
  processingLoops = /* @__PURE__ */ new Map();
  // Wake-up promises for processing loops
  wakeUpResolvers = /* @__PURE__ */ new Map();
  // Recovery and cleanup timeouts
  recoveryTimeoutId;
  cleanupTimeoutId;
  constructor(eventStore, config, walletManager, sessionManager, eventRouter, eventEmitter) {
    this.eventStore = eventStore;
    this.config = config;
    this.walletManager = walletManager;
    this.sessionManager = sessionManager;
    this.eventRouter = eventRouter;
    this.eventEmitter = eventEmitter;
    this.eventEmitter.on("bridge-storage-updated", () => {
      this.triggerProcessingForAllWallets();
    });
  }
  /**
   * Start processing events for a wallet
   */
  async startProcessing(walletAddress) {
    if (this.processingLoops.get(walletAddress)) {
      log$f.debug("Processing already active for wallet", { walletAddress });
      return;
    }
    this.processingLoops.set(walletAddress, true);
    log$f.info("Started event processing for wallet", { walletAddress });
    this.processEventsLoop(walletAddress);
  }
  /**
   * Stop processing events for a wallet
   */
  async stopProcessing(walletAddress) {
    this.processingLoops.set(walletAddress, false);
    const wakeUpResolver = this.wakeUpResolvers.get(walletAddress);
    if (wakeUpResolver) {
      wakeUpResolver();
      this.wakeUpResolvers.delete(walletAddress);
    }
    log$f.info("Stopped event processing for wallet", { walletAddress });
  }
  /**
   * Process next available event for a wallet
   */
  async processNextEvent(walletAddress) {
    try {
      const sessions = this.sessionManager.getSessionsForAPI().filter((session) => session.walletAddress === walletAddress);
      if (sessions.length === 0) {
        log$f.debug("No active sessions for wallet", { walletAddress });
        return false;
      }
      const sessionIds = sessions.map((session) => session.sessionId);
      const enabledEventTypes = this.getEnabledEventTypes();
      const events = await this.eventStore.getEventsForWallet(walletAddress, sessionIds, enabledEventTypes);
      if (events.length === 0) {
        return false;
      }
      const eventToUse = events[0];
      const acquiredEvent = await this.eventStore.acquireLock(eventToUse.id, walletAddress);
      if (!acquiredEvent) {
        log$f.debug("Failed to acquire lock on event", { eventId: eventToUse.id, walletAddress });
        return false;
      }
      log$f.info("Processing event", {
        eventId: acquiredEvent.id,
        eventType: acquiredEvent.eventType,
        walletAddress,
        sessionId: acquiredEvent.sessionId
      });
      try {
        await this.eventRouter.routeEvent({
          ...acquiredEvent.rawEvent,
          wallet: this.walletManager.getWallet(walletAddress)
        });
        await this.eventStore.updateEventStatus(acquiredEvent.id, "completed", "processing");
        log$f.info("Event processing completed", { eventId: acquiredEvent.id });
        return true;
      } catch (error) {
        log$f.error("Error processing event", {
          eventId: acquiredEvent.id,
          error: error.message
        });
        return false;
      }
    } catch (error) {
      log$f.error("Error in processNextEvent", {
        walletAddress,
        error: error.message
      });
      return false;
    }
  }
  /**
   * Mark an event as completed after successful processing
   */
  async completeEvent(eventId) {
    try {
      await this.eventStore.updateEventStatus(eventId, "completed", "processing");
      log$f.debug("Event marked as completed", { eventId });
    } catch (error) {
      log$f.error("Failed to mark event as completed", {
        eventId,
        error: error.message
      });
    }
  }
  /**
   * Start the recovery process for stale events
   */
  startRecoveryLoop() {
    if (this.recoveryTimeoutId) {
      log$f.debug("Recovery loop already running");
      return;
    }
    const recoveryLoop = async () => {
      try {
        const recoveredCount = await this.eventStore.recoverStaleEvents(this.config.processingTimeoutMs);
        if (recoveredCount > 0) {
          this.triggerProcessingForAllWallets();
        }
      } catch (error) {
        log$f.error("Error in recovery loop", { error: error.message });
      }
      if (this.recoveryTimeoutId !== void 0) {
        this.recoveryTimeoutId = setTimeout(recoveryLoop, this.config.recoveryIntervalMs);
      }
    };
    const cleanupLoop = async () => {
      try {
        await this.eventStore.cleanupOldEvents(this.config.retentionMs);
      } catch (error) {
        log$f.error("Error in cleanup loop", { error: error.message });
      }
      if (this.cleanupTimeoutId !== void 0) {
        this.cleanupTimeoutId = setTimeout(cleanupLoop, this.config.cleanupIntervalMs);
      }
    };
    this.recoveryTimeoutId = setTimeout(recoveryLoop, this.config.recoveryIntervalMs);
    this.cleanupTimeoutId = setTimeout(cleanupLoop, this.config.cleanupIntervalMs);
    log$f.info("Recovery and cleanup loops started");
  }
  /**
   * Stop the recovery process
   */
  stopRecoveryLoop() {
    if (this.recoveryTimeoutId) {
      clearTimeout(this.recoveryTimeoutId);
      this.recoveryTimeoutId = void 0;
    }
    if (this.cleanupTimeoutId) {
      clearTimeout(this.cleanupTimeoutId);
      this.cleanupTimeoutId = void 0;
    }
    log$f.info("Recovery and cleanup loops stopped");
  }
  // Private helper methods
  /**
   * Main processing loop for a wallet
   */
  async processEventsLoop(walletAddress) {
    while (this.processingLoops.get(walletAddress)) {
      try {
        const processed = await this.processNextEvent(walletAddress);
        if (!processed) {
          await this.waitForWakeUpOrTimeout(walletAddress, 1e3);
        }
      } catch (error) {
        log$f.error("Error in processing loop", {
          walletAddress,
          error: error.message
        });
        await this.waitForWakeUpOrTimeout(walletAddress, 5e3);
      }
    }
    this.wakeUpResolvers.delete(walletAddress);
    log$f.debug("Processing loop ended for wallet", { walletAddress });
  }
  /**
   * Trigger processing for all active wallets
   */
  triggerProcessingForAllWallets() {
    for (const [walletAddress, isActive] of this.processingLoops.entries()) {
      if (isActive) {
        const wakeUpResolver = this.wakeUpResolvers.get(walletAddress);
        if (wakeUpResolver) {
          log$f.debug("Waking up processing loop for wallet", { walletAddress });
          wakeUpResolver();
        } else {
          log$f.debug("No wake-up resolver found for wallet", { walletAddress });
        }
      }
    }
  }
  /**
   * Wait for either a wake-up signal or timeout
   */
  async waitForWakeUpOrTimeout(walletAddress, timeoutMs) {
    return new Promise((resolve) => {
      const timeoutId = setTimeout(() => {
        this.wakeUpResolvers.delete(walletAddress);
        resolve();
      }, timeoutMs);
      const wakeUpResolver = () => {
        clearTimeout(timeoutId);
        this.wakeUpResolvers.delete(walletAddress);
        resolve();
      };
      this.wakeUpResolvers.set(walletAddress, wakeUpResolver);
    });
  }
  /**
   * Get enabled event types based on registered handlers in EventRouter
   */
  getEnabledEventTypes() {
    return this.eventRouter.getEnabledEventTypes();
  }
}

const log$e = globalLogger.createChild("Initializer");
class Initializer {
  // private config: InitializationConfig;
  tonClient;
  eventEmitter;
  network;
  retryAttempts;
  retryDelay;
  timeoutMs;
  constructor(config = {}, eventEmitter) {
    this.network = config.network ?? CHAIN.MAINNET;
    this.retryAttempts = config.retryAttempts ?? 3;
    this.retryDelay = config.retryDelay ?? 1e3;
    this.timeoutMs = config.timeoutMs ?? 1e4;
    this.eventEmitter = eventEmitter;
  }
  /**
   * Initialize all components
   */
  async initialize(options) {
    try {
      log$e.info("Initializing TonWalletKit...");
      this.tonClient = this.initializeTonClient(options);
      const storageAdapter = this.initializeStorage(options);
      const { walletManager, sessionManager, bridgeManager, eventRouter, eventProcessor } = await this.initializeManagers(options, storageAdapter);
      const { requestProcessor, responseHandler } = this.initializeProcessors(sessionManager, bridgeManager);
      log$e.info("TonWalletKit initialized successfully");
      return {
        walletManager,
        sessionManager,
        bridgeManager,
        eventRouter,
        requestProcessor,
        responseHandler,
        storageAdapter,
        tonClient: this.tonClient,
        eventProcessor
      };
    } catch (error) {
      log$e.error("Failed to initialize TonWalletKit", { error });
      throw error;
    }
  }
  /**
   * Initialize TON client (single provider for all downstream classes)
   */
  initializeTonClient(options) {
    const endpoint = options.apiUrl || "https://toncenter.com/api/v2/jsonRPC";
    const clientConfig = {
      endpoint
    };
    if (options.apiKey) {
      clientConfig.apiKey = options.apiKey;
    }
    return new distExports$3.TonClient(clientConfig);
  }
  /**
   * Initialize storage adapter
   */
  initializeStorage(options) {
    if (options.storage) {
      return options.storage;
    }
    return createStorageAdapter({
      prefix: "tonwalletkit:"
    });
  }
  /**
   * Initialize core managers
   */
  async initializeManagers(options, storageAdapter) {
    const walletManager = new WalletManager(storageAdapter);
    await walletManager.initialize();
    if (options.wallets && options.wallets.length > 0) {
      await this.initializeWallets(walletManager, {
        ...options,
        wallets: options.wallets
      });
    }
    const sessionManager = new SessionManager(storageAdapter, walletManager);
    await sessionManager.initialize();
    const eventStore = new StorageEventStore(storageAdapter);
    const bridgeManager = new BridgeManager({
      bridgeUrl: options.bridgeUrl
    }, sessionManager, storageAdapter, eventStore, this.eventEmitter);
    await bridgeManager.start();
    const eventRouter = new EventRouter(this.eventEmitter, sessionManager);
    const eventProcessor = new StorageEventProcessor(eventStore, DEFAULT_DURABLE_EVENTS_CONFIG, walletManager, sessionManager, eventRouter, this.eventEmitter);
    return {
      walletManager,
      sessionManager,
      bridgeManager,
      eventRouter,
      eventProcessor
    };
  }
  /**
   * Initialize processors
   */
  initializeProcessors(sessionManager, bridgeManager) {
    const requestProcessor = new RequestProcessor(sessionManager, bridgeManager, this.tonClient, this.network);
    const responseHandler = new ResponseHandler(bridgeManager, sessionManager);
    return {
      requestProcessor,
      responseHandler
    };
  }
  /**
   * Initialize with provided wallets
   */
  async initializeWallets(walletManager, options) {
    const results = await Promise.allSettled(options.wallets.map(async (walletConfig) => {
      try {
        const wallet = await createWalletFromConfig(walletConfig, this.tonClient);
        const validation = validateWallet(wallet);
        if (!validation.isValid) {
          log$e.warn("Invalid wallet detected", {
            publicKey: wallet.publicKey,
            errors: validation.errors
          });
          return;
        }
        await walletManager.addWallet(wallet);
      } catch (error) {
        log$e.error("Failed to create wallet from config", { error });
        throw error;
      }
    }));
    const successful = results.filter((r) => r.status === "fulfilled").length;
    const failed = results.filter((r) => r.status === "rejected").length;
    log$e.info("Wallet initialization complete", { successful, failed });
  }
  /**
   * Cleanup resources during shutdown
   */
  async cleanup(components) {
    try {
      log$e.info("Cleaning up TonWalletKit components...");
      if (components.eventProcessor) {
        components.eventProcessor.stopRecoveryLoop();
      }
      if (components.bridgeManager) {
        await components.bridgeManager.close();
      }
      if (components.eventRouter) {
        components.eventRouter.clearCallbacks();
      }
      log$e.info("TonWalletKit cleanup completed");
    } catch (error) {
      log$e.error("Error during cleanup", { error });
    }
  }
}
function isWalletInterface(config) {
  return typeof config === "object" && config !== null && "publicKey" in config && "version" in config && typeof config?.sign === "function" && typeof config?.getAddress === "function" && typeof config?.getBalance === "function" && typeof config?.getStateInit === "function";
}
async function createWalletFromConfig(config, tonClient) {
  if (config instanceof WalletInitConfigMnemonic) {
    if (config.version === "v5r1") {
      return createWalletV5R1(config, {
        tonClient
      });
    }
    throw new Error(`Unsupported wallet version for mnemonic: ${config.version}`);
  }
  if (config instanceof WalletInitConfigPrivateKey) {
    if (config.version === "v5r1") {
      return createWalletV5R1(config, {
        tonClient
      });
    }
    throw new Error(`Unsupported wallet version for private key: ${config.version}`);
  }
  if (isWalletInterface(config)) {
    return config;
  }
  throw new Error("Unsupported wallet configuration format");
}

const perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
const warned = /* @__PURE__ */ new Set();
const PROCESS = typeof process === "object" && !!process ? process : {};
const emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS();
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
const shouldWarn = (code) => !warned.has(code);
const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
const getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
class ZeroArray extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
}
class Stack {
  heap;
  length;
  // private constructor
  static #constructing = false;
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    Stack.#constructing = true;
    const s = new Stack(max, HeapCls);
    Stack.#constructing = false;
    return s;
  }
  constructor(max, HeapCls) {
    if (!Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
}
class LRUCache {
  // options that cannot be changed without disaster
  #max;
  #maxSize;
  #dispose;
  #onInsert;
  #disposeAfter;
  #fetchMethod;
  #memoMethod;
  /**
   * {@link LRUCache.OptionsBase.ttl}
   */
  ttl;
  /**
   * {@link LRUCache.OptionsBase.ttlResolution}
   */
  ttlResolution;
  /**
   * {@link LRUCache.OptionsBase.ttlAutopurge}
   */
  ttlAutopurge;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnGet}
   */
  updateAgeOnGet;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnHas}
   */
  updateAgeOnHas;
  /**
   * {@link LRUCache.OptionsBase.allowStale}
   */
  allowStale;
  /**
   * {@link LRUCache.OptionsBase.noDisposeOnSet}
   */
  noDisposeOnSet;
  /**
   * {@link LRUCache.OptionsBase.noUpdateTTL}
   */
  noUpdateTTL;
  /**
   * {@link LRUCache.OptionsBase.maxEntrySize}
   */
  maxEntrySize;
  /**
   * {@link LRUCache.OptionsBase.sizeCalculation}
   */
  sizeCalculation;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
   */
  noDeleteOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
   */
  noDeleteOnStaleGet;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
   */
  allowStaleOnFetchAbort;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
   */
  allowStaleOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.ignoreFetchAbort}
   */
  ignoreFetchAbort;
  // computed properties
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  #hasOnInsert;
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: c.#starts,
      ttls: c.#ttls,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      // methods
      isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
      backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
      moveToTail: (index) => c.#moveToTail(index),
      indexes: (options) => c.#indexes(options),
      rindexes: (options) => c.#rindexes(options),
      isStale: (index) => c.#isStale(index)
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return this.#max;
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return this.#maxSize;
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return this.#calculatedSize;
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return this.#size;
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return this.#fetchMethod;
  }
  get memoMethod() {
    return this.#memoMethod;
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return this.#dispose;
  }
  /**
   * {@link LRUCache.OptionsBase.onInsert} (read-only)
   */
  get onInsert() {
    return this.#onInsert;
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    this.#max = max;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (memoMethod !== void 0 && typeof memoMethod !== "function") {
      throw new TypeError("memoMethod must be a function if defined");
    }
    this.#memoMethod = memoMethod;
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = /* @__PURE__ */ new Map();
    this.#keyList = new Array(max).fill(void 0);
    this.#valList = new Array(max).fill(void 0);
    this.#next = new UintArray(max);
    this.#prev = new UintArray(max);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof onInsert === "function") {
      this.#onInsert = onInsert;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = void 0;
      this.#disposed = void 0;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasOnInsert = !!this.#onInsert;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
      }
    }
  }
  /**
   * Return the number of ms left in the item's TTL. If item is not in cache,
   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
   */
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    this.#setItemTTL = (index, ttl, start = perf.now()) => {
      starts[index] = ttl !== 0 ? start : 0;
      ttls[index] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.#isStale(index)) {
            this.#delete(this.#keyList[index], "expire");
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
      }
    };
    this.#updateItemAge = (index) => {
      starts[index] = ttls[index] !== 0 ? perf.now() : 0;
    };
    this.#statusTTL = (status, index) => {
      if (ttls[index]) {
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start)
          return;
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n;
    };
    this.getRemainingTTL = (key) => {
      const index = this.#keyMap.get(key);
      if (index === void 0) {
        return 0;
      }
      const ttl = ttls[index];
      const start = starts[index];
      if (!ttl || !start) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index) => {
      const s = starts[index];
      const t = ttls[index];
      return !!t && !!s && (cachedNow || getNow()) - s > t;
    };
  }
  // conditionally set private methods related to TTL
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  /* c8 ignore stop */
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index) => {
      this.#calculatedSize -= sizes[index];
      sizes[index] = 0;
    };
    this.#requireSize = (k, v, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v, k);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size;
    };
    this.#addItemSize = (index, size, status) => {
      sizes[index] = size;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#tail; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#head) {
          break;
        } else {
          i = this.#prev[i];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#head; true; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#tail) {
          break;
        } else {
          i = this.#next[i];
        }
      }
    }
  }
  #isValidIndex(index) {
    return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i of this.#indexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i of this.#rindexes()) {
      if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i of this.#indexes()) {
      const k = this.#keyList[i];
      if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k = this.#keyList[i];
      if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * A String value that is used in the creation of the default string
   * description of an object. Called by the built-in method
   * `Object.prototype.toString`.
   */
  [Symbol.toStringTag] = "LRUCache";
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
   */
  find(fn, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      if (fn(value, this.#keyList[i], this)) {
        return this.get(this.#keyList[i], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from most
   * recently used to least recently used.
   *
   * `fn` is called as `fn(value, key, cache)`.
   *
   * If `thisp` is provided, function will be called in the `this`-context of
   * the provided object, or the cache if no `thisp` object is provided.
   *
   * Does not update age or recenty of use, or iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i)) {
        this.#delete(this.#keyList[i], "expire");
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Returns `undefined` if the key is not present.
   *
   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
   * serialization, the `start` value is always the current timestamp, and the
   * `ttl` is a calculated remaining time to live (negative if expired).
   *
   * Always returns stale values, if their info is found in the cache, so be
   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
   * if relevant.
   */
  info(key) {
    const i = this.#keyMap.get(key);
    if (i === void 0)
      return void 0;
    const v = this.#valList[i];
    const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    if (value === void 0)
      return void 0;
    const entry = { value };
    if (this.#ttls && this.#starts) {
      const ttl = this.#ttls[i];
      const start = this.#starts[i];
      if (ttl && start) {
        const remain = ttl - (perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (this.#sizes) {
      entry.size = this.#sizes[i];
    }
    return entry;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to {@link LRUCache#load}.
   *
   * The `start` fields are calculated relative to a portable `Date.now()`
   * timestamp, even if `performance.now()` is available.
   *
   * Stale entries are always included in the `dump`, even if
   * {@link LRUCache.OptionsBase.allowStale} is false.
   *
   * Note: this returns an actual array, not a generator, so it can be more
   * easily passed around.
   */
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i];
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        const age = perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   *
   * The shape of the resulting cache may be different if the same options are
   * not used in both caches.
   *
   * The `start` fields are assumed to be calculated relative to a portable
   * `Date.now()` timestamp, even if `performance.now()` is available.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   *
   * Fields on the {@link LRUCache.SetOptions} options param will override
   * their corresponding values in the constructor options for the scope
   * of this single `set()` operation.
   *
   * If `start` is provided, then that will set the effective start
   * time for the TTL calculation. Note that this must be a previous
   * value of `performance.now()` if supported, or a previous value of
   * `Date.now()` if not.
   *
   * Options object may also include `size`, which will prevent
   * calling the `sizeCalculation` function and just use the specified
   * number if it is a positive integer, and `noDisposeOnSet` which
   * will prevent calling a `dispose` function in the case of
   * overwrites.
   *
   * If the `size` (or return value of `sizeCalculation`) for a given
   * entry is greater than `maxEntrySize`, then the item will not be
   * added to the cache.
   *
   * Will update the recency of the entry.
   *
   * If the value is `undefined`, then this is an alias for
   * `cache.delete(key)`. `undefined` is never stored in the cache.
   */
  set(k, v, setOptions = {}) {
    if (v === void 0) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.#delete(k, "set");
      return this;
    }
    let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
    if (index === void 0) {
      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index] = k;
      this.#valList[index] = v;
      this.#keyMap.set(k, index);
      this.#next[this.#tail] = index;
      this.#prev[index] = this.#tail;
      this.#tail = index;
      this.#size++;
      this.#addItemSize(index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
      if (this.#hasOnInsert) {
        this.#onInsert?.(v, k, "add");
      }
    } else {
      this.#moveToTail(index);
      const oldVal = this.#valList[index];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== void 0 && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k, "set"]);
          }
        }
        this.#removeItemSize(index);
        this.#addItemSize(index, size, status);
        this.#valList[index] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
      if (this.#hasOnInsert) {
        this.onInsert?.(v, k, v === oldVal ? "update" : "replace");
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index, ttl, start);
      }
      if (status)
        this.#statusTTL(status, index);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head = this.#head;
    const k = this.#keyList[head];
    const v = this.#valList[head];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
      v.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v, k, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v, k, "evict"]);
      }
    }
    this.#removeItemSize(head);
    if (free) {
      this.#keyList[head] = void 0;
      this.#valList[head] = void 0;
      this.#free.push(head);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head];
    }
    this.#keyMap.delete(k);
    this.#size--;
    return head;
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Check if a key is in the cache, without updating the recency of
   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
   * to `true` in either the options or the constructor.
   *
   * Will return `false` if the item is stale, even though it is technically in
   * the cache. The difference can be determined (if it matters) by using a
   * `status` argument, and inspecting the `has` field.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = this.#keyMap.get(k);
    if (index !== void 0) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
        return false;
      }
      if (!this.#isStale(index)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = this.#keyMap.get(k);
    if (index === void 0 || !allowStale && this.#isStale(index)) {
      return;
    }
    const v = this.#valList[index];
    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
  }
  #backgroundFetch(k, index, options, context) {
    const v = index === void 0 ? void 0 : this.#valList[index];
    if (this.#isBackgroundFetch(v)) {
      return v;
    }
    const ac = new AC();
    const { signal } = options;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v2, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p;
      if (this.#valList[index] === p) {
        if (v2 === void 0) {
          if (bf2.__staleWhileFetching) {
            this.#valList[index] = bf2.__staleWhileFetching;
          } else {
            this.#delete(k, "fetch");
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k, v2, fetchOpts.options);
        }
      }
      return v2;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p;
      if (this.#valList[index] === p) {
        const del = !noDelete || bf2.__staleWhileFetching === void 0;
        if (del) {
          this.#delete(k, "fetch");
        } else if (!allowStaleAborted) {
          this.#valList[index] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== void 0) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k, v, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(void 0);
          if (options.allowStaleOnFetchAbort) {
            res = (v2) => cb(v2, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: void 0
    });
    if (index === void 0) {
      this.set(k, bf, { ...fetchOpts.options, status: void 0 });
      index = this.#keyMap.get(k);
    } else {
      this.#valList[index] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p) {
    if (!this.#hasFetchMethod)
      return false;
    const b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = this.#keyMap.get(k);
    if (index === void 0) {
      if (status)
        status.fetch = "miss";
      const p = this.#backgroundFetch(k, index, options, context);
      return p.__returned = p;
    } else {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        const stale = allowStale && v.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = this.#isStale(index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        if (status)
          this.#statusTTL(status, index);
        return v;
      }
      const p = this.#backgroundFetch(k, index, options, context);
      const hasStale = p.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  async forceFetch(k, fetchOptions = {}) {
    const v = await this.fetch(k, fetchOptions);
    if (v === void 0)
      throw new Error("fetch() returned undefined");
    return v;
  }
  memo(k, memoOptions = {}) {
    const memoMethod = this.#memoMethod;
    if (!memoMethod) {
      throw new Error("no memoMethod provided to constructor");
    }
    const { context, forceRefresh, ...options } = memoOptions;
    const v = this.get(k, options);
    if (!forceRefresh && v !== void 0)
      return v;
    const vv = memoMethod(k, v, {
      options,
      context
    });
    this.set(k, vv, options);
    return vv;
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = this.#keyMap.get(k);
    if (index !== void 0) {
      const value = this.#valList[index];
      const fetching = this.#isBackgroundFetch(value);
      if (status)
        this.#statusTTL(status, index);
      if (this.#isStale(index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.#delete(k, "expire");
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p, n) {
    this.#prev[n] = p;
    this.#next[p] = n;
  }
  #moveToTail(index) {
    if (index !== this.#tail) {
      if (index === this.#head) {
        this.#head = this.#next[index];
      } else {
        this.#connect(this.#prev[index], this.#next[index]);
      }
      this.#connect(this.#tail, index);
      this.#tail = index;
    }
  }
  /**
   * Deletes a key out of the cache.
   *
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k) {
    return this.#delete(k, "delete");
  }
  #delete(k, reason) {
    let deleted = false;
    if (this.#size !== 0) {
      const index = this.#keyMap.get(k);
      if (index !== void 0) {
        deleted = true;
        if (this.#size === 1) {
          this.#clear(reason);
        } else {
          this.#removeItemSize(index);
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v, k, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, reason]);
            }
          }
          this.#keyMap.delete(k);
          this.#keyList[index] = void 0;
          this.#valList[index] = void 0;
          if (index === this.#tail) {
            this.#tail = this.#prev[index];
          } else if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            const pi = this.#prev[index];
            this.#next[pi] = this.#next[index];
            const ni = this.#next[index];
            this.#prev[ni] = this.#prev[index];
          }
          this.#size--;
          this.#free.push(index);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    return this.#clear("delete");
  }
  #clear(reason) {
    for (const index of this.#rindexes({ allowStale: true })) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("deleted"));
      } else {
        const k = this.#keyList[index];
        if (this.#hasDispose) {
          this.#dispose?.(v, k, reason);
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, reason]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(void 0);
    this.#keyList.fill(void 0);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
}

const log$d = globalLogger.createChild("JettonsManager");
class JettonsManager {
  eventEmitter;
  apiKey;
  cache;
  TONCENTER_V3_BASE = "https://toncenter.com/api/v3";
  DEFAULT_TIMEOUT = 1e4;
  // 10 seconds
  constructor(cacheSize = 1e4, eventEmitter, apiKey) {
    this.eventEmitter = eventEmitter;
    this.apiKey = apiKey;
    this.cache = new LRUCache({
      max: cacheSize,
      ttl: 1e3 * 60 * 10
      // 10 minutes TTL
    });
    this.cache.set("TON", {
      address: "TON",
      name: "TON",
      symbol: "TON",
      description: "The Open Network native token",
      decimals: 9,
      totalSupply: "5000000000000000000",
      image: "https://asset.ston.fi/img/EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c/ee9fb21d17bc8d75c2a5f7b5f5f62d2bacec6b128f58b63cb841e98f7b74c4fc",
      verification: {
        verified: true,
        source: "manual"
      }
    });
    log$d.info("JettonsManager initialized", { cacheSize });
    this.eventEmitter.on("emulation:result", (emulationResult) => {
      if (emulationResult && typeof emulationResult === "object" && "metadata" in emulationResult) {
        this.addJettonsFromEmulationMetadata(emulationResult.metadata);
      }
    });
  }
  /**
   * Get jetton information by address (sync - cache only)
   */
  getJettonInfo(jettonAddress) {
    try {
      const normalizedAddress = this.normalizeAddress(jettonAddress);
      const cachedInfo = this.cache.get(normalizedAddress);
      if (cachedInfo) {
        log$d.debug("Jetton info found in cache", { jettonAddress: normalizedAddress });
        return cachedInfo;
      }
      log$d.debug("Jetton info not found in cache", { jettonAddress: normalizedAddress });
      return null;
    } catch (error) {
      log$d.error("Error getting jetton info", { error, jettonAddress });
      return null;
    }
  }
  /**
   * Get jettons for a specific address
   */
  async getAddressJettons(userAddress, offset = 0, limit = 50) {
    try {
      const normalizedAddress = this.normalizeAddress(userAddress);
      log$d.debug("Getting address jettons", { userAddress: normalizedAddress, offset, limit });
      const response = await this.makeApiRequest(`/jetton/wallets?offset=${offset}&limit=${limit}&owner_address=${normalizedAddress}`);
      if (!response.jetton_wallets) {
        return [];
      }
      const addressJettons = [];
      for (const item of response.jetton_wallets) {
        try {
          const jettonMetadata = response.metadata[item.jetton];
          const metadataJettonInfo = jettonMetadata?.token_info?.find((info) => typeof info === "object" && info !== null && "type" in info && info.type === "jetton_masters");
          const jettonInfo = metadataJettonInfo ? {
            address: normalizedAddress,
            name: metadataJettonInfo.name,
            symbol: metadataJettonInfo.symbol,
            description: metadataJettonInfo.description,
            image: metadataJettonInfo.image,
            decimals: typeof metadataJettonInfo.extra.decimals === "string" ? parseInt(metadataJettonInfo.extra.decimals, 10) : metadataJettonInfo.extra.decimals,
            image_data: metadataJettonInfo.extra.image_data,
            uri: metadataJettonInfo.extra.uri
          } : await this.getJettonInfo(item.jetton);
          if (jettonInfo) {
            const addressJetton = {
              address: item.jetton,
              name: jettonInfo.name,
              symbol: jettonInfo.symbol,
              description: jettonInfo.description,
              decimals: jettonInfo.decimals,
              balance: item.balance,
              jettonWalletAddress: item.address,
              usdValue: "0",
              image: jettonInfo.image,
              verification: jettonInfo.verification,
              metadata: jettonInfo.metadata,
              totalSupply: jettonInfo.totalSupply,
              uri: jettonInfo.uri,
              image_data: jettonInfo.image_data
              // lastActivity: item.last_transaction_lt,
            };
            addressJettons.push(addressJetton);
          }
        } catch (error) {
          log$d.warn("Failed to get jetton info for address jetton", {
            jettonAddress: item.jetton,
            error
          });
        }
      }
      log$d.debug("Retrieved address jettons", { count: addressJettons.length });
      return addressJettons;
    } catch (error) {
      log$d.error("Failed to get address jettons", { error, userAddress });
      throw new JettonError(`Failed to get jettons for address: ${error instanceof Error ? error.message : "Unknown error"}`, JettonErrorCode.NETWORK_ERROR, error);
    }
  }
  /**
   * Add jetton info to cache from emulation data
   */
  addJettonFromEmulation(jettonAddress, emulationInfo) {
    try {
      const normalizedAddress = this.normalizeAddress(jettonAddress);
      const jettonInfo = {
        address: normalizedAddress,
        name: emulationInfo.name,
        symbol: emulationInfo.symbol,
        description: emulationInfo.description,
        image: emulationInfo.image,
        decimals: typeof emulationInfo.extra.decimals === "string" ? parseInt(emulationInfo.extra.decimals, 10) : emulationInfo.extra.decimals,
        uri: emulationInfo.extra.uri
      };
      this.cache.set(normalizedAddress, jettonInfo);
      log$d.debug("Added jetton info from emulation to cache", {
        jettonAddress: normalizedAddress,
        name: jettonInfo.name,
        symbol: jettonInfo.symbol
      });
    } catch (error) {
      log$d.error("Error adding jetton from emulation", { error, jettonAddress });
    }
  }
  /**
   * Add multiple jettons from emulation metadata
   */
  addJettonsFromEmulationMetadata(metadata) {
    try {
      let addedCount = 0;
      for (const [jettonAddress, addressMetadata] of Object.entries(metadata)) {
        if (!addressMetadata.is_indexed || !addressMetadata.token_info) {
          continue;
        }
        const jettonMasterInfo = addressMetadata.token_info.find((info) => typeof info === "object" && info !== null && "type" in info && info.type === "jetton_masters");
        if (jettonMasterInfo) {
          log$d.debug("Adding jetton from emulation metadata", { jettonAddress });
          this.addJettonFromEmulation(jettonAddress, jettonMasterInfo);
          addedCount++;
        }
      }
      if (addedCount > 0) {
        log$d.info("Added jettons from emulation metadata", { addedCount });
      }
    } catch (error) {
      log$d.error("Error adding jettons from emulation metadata", { error });
    }
  }
  /**
   * Normalize jetton address for consistent caching
   */
  normalizeAddress(address) {
    if (address === "TON") {
      return "TON";
    }
    return distExports$2.Address.parse(address).toRawString().toLocaleUpperCase();
  }
  /**
   * Get cache statistics
   */
  getCacheStats() {
    return {
      size: this.cache.size,
      capacity: this.cache.max
    };
  }
  /**
   * Get user's jetton wallet address for a specific jetton
   */
  async getJettonWalletAddress(jettonMasterAddress, ownerAddress) {
    try {
      const normalizedJettonAddress = this.normalizeAddress(jettonMasterAddress);
      const normalizedOwnerAddress = this.normalizeAddress(ownerAddress);
      const response = await this.makeApiRequest(`/jettons/${normalizedJettonAddress}/wallets/${normalizedOwnerAddress}`);
      if (!response.address) {
        throw new JettonError("Jetton wallet address not found", JettonErrorCode.JETTON_NOT_FOUND);
      }
      return response.address;
    } catch (error) {
      if (error instanceof JettonError) {
        throw error;
      }
      log$d.error("Failed to get jetton wallet address", { error, jettonMasterAddress, ownerAddress });
      throw new JettonError(`Failed to get jetton wallet address: ${error instanceof Error ? error.message : "Unknown error"}`, JettonErrorCode.NETWORK_ERROR, error);
    }
  }
  /**
   * Get jetton balance for a specific jetton wallet
   */
  async getJettonBalance(jettonWalletAddress) {
    try {
      const normalizedAddress = this.normalizeAddress(jettonWalletAddress);
      const response = await this.makeApiRequest(`/jettonWallets/${normalizedAddress}`);
      const balanceInfo = response;
      return {
        balance: balanceInfo.balance,
        jettonAddress: balanceInfo.jetton.address,
        jettonWalletAddress: normalizedAddress,
        lastUpdated: Date.now()
      };
    } catch (error) {
      log$d.error("Failed to get jetton balance", { error, jettonWalletAddress });
      throw new JettonError(`Failed to get jetton balance: ${error instanceof Error ? error.message : "Unknown error"}`, JettonErrorCode.NETWORK_ERROR, error);
    }
  }
  /**
   * Get jetton transfer history for an address
   */
  async getJettonTransfers(ownerAddress, jettonAddress, limit = 50) {
    try {
      const normalizedOwnerAddress = this.normalizeAddress(ownerAddress);
      let endpoint = `/accounts/${normalizedOwnerAddress}/jettons/transfers?limit=${limit}`;
      if (jettonAddress) {
        const normalizedJettonAddress = this.normalizeAddress(jettonAddress);
        endpoint += `&jetton_master=${normalizedJettonAddress}`;
      }
      const response = await this.makeApiRequest(endpoint);
      if (!response.transfers) {
        return [];
      }
      const transfers = [];
      for (const transfer of response.transfers) {
        transfers.push({
          hash: transfer.transaction_hash,
          timestamp: transfer.transaction_now * 1e3,
          // Convert to milliseconds
          from: transfer.source_wallet,
          to: transfer.destination_wallet,
          jettonAddress: transfer.jetton_master,
          amount: transfer.amount,
          comment: transfer.comment,
          successful: transfer.successful
        });
      }
      return transfers;
    } catch (error) {
      log$d.error("Failed to get jetton transfers", { error, ownerAddress, jettonAddress });
      throw new JettonError(`Failed to get jetton transfers: ${error instanceof Error ? error.message : "Unknown error"}`, JettonErrorCode.NETWORK_ERROR, error);
    }
  }
  /**
   * Get detailed transaction info for jetton operation
   */
  async getJettonTransaction(transactionHash) {
    try {
      const response = await this.makeApiRequest(`/transactions/${transactionHash}`);
      if (!response) {
        return null;
      }
      return {
        hash: transactionHash,
        timestamp: (response.now || 0) * 1e3,
        type: response.op_code === "0xf8a7ea5" ? "transfer" : "mint",
        successful: response.success || false,
        participants: response.account ? [response.account] : [],
        jettonAddress: response.jetton_master || "",
        amount: response.amount,
        fees: {
          gasFee: response.compute_fee || "0",
          storageFee: response.storage_fee || "0",
          total: response.total_fees || "0"
        },
        details: {
          opcode: response.op_code,
          exitCode: response.exit_code,
          rawData: response
        }
      };
    } catch (error) {
      log$d.error("Failed to get jetton transaction", { error, transactionHash });
      return null;
    }
  }
  /**
   * Search jettons by name or symbol
   */
  async searchJettons(query, limit = 20) {
    try {
      log$d.debug("Searching jettons (placeholder)", { query, limit });
      const results = [];
      for (const [_, jettonInfo] of this.cache.entries()) {
        if (jettonInfo.name.toLowerCase().includes(query.toLowerCase()) || jettonInfo.symbol.toLowerCase().includes(query.toLowerCase())) {
          results.push(jettonInfo);
          if (results.length >= limit)
            break;
        }
      }
      return results;
    } catch (error) {
      log$d.error("Failed to search jettons", { error, query });
      throw new JettonError(`Failed to search jettons: ${error instanceof Error ? error.message : "Unknown error"}`, JettonErrorCode.NETWORK_ERROR, error);
    }
  }
  /**
   * Get popular/trending jettons
   */
  async getPopularJettons(limit = 20) {
    try {
      log$d.debug("Getting popular jettons (placeholder)", { limit });
      const popularAddresses = [
        "EQD0vdSA_NedR9uvbgN9EikRX-suesDxGeFg69XQMavfLqAk",
        // Example USDT
        "EQBX6K9aXVl3nXINCyPPL86C4ONVmQ8vK360u6dykFKXpHCX"
        // Example USDC
        // Add more popular jetton addresses
      ];
      const results = [];
      for (const address of popularAddresses.slice(0, limit)) {
        try {
          const jettonInfo = await this.getJettonInfo(address);
          if (jettonInfo) {
            results.push(jettonInfo);
          }
        } catch (error) {
          log$d.warn("Failed to get popular jetton info", { address, error });
        }
      }
      return results;
    } catch (error) {
      log$d.error("Failed to get popular jettons", { error });
      throw new JettonError(`Failed to get popular jettons: ${error instanceof Error ? error.message : "Unknown error"}`, JettonErrorCode.NETWORK_ERROR, error);
    }
  }
  /**
   * Get jetton price data
   */
  async getJettonPrice(jettonAddress) {
    try {
      const normalizedAddress = this.normalizeAddress(jettonAddress);
      log$d.debug("Getting jetton price (placeholder)", { jettonAddress: normalizedAddress });
      return null;
    } catch (error) {
      log$d.error("Failed to get jetton price", { error, jettonAddress });
      return null;
    }
  }
  /**
   * Validate jetton address format
   */
  validateJettonAddress(address) {
    try {
      if (address === "TON") {
        return true;
      }
      distExports$2.Address.parse(address);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Check if address is a valid jetton master
   */
  async isJettonMaster(address) {
    try {
      const normalizedAddress = this.normalizeAddress(address);
      const response = await this.makeApiRequest(`/jettons/${normalizedAddress}`);
      return !!response.jetton_content;
    } catch (error) {
      log$d.debug("Address is not a jetton master", { address, error });
      return false;
    }
  }
  /**
   * Make API request to TonCenter v3
   */
  async makeApiRequest(endpoint) {
    const url = `${this.TONCENTER_V3_BASE}${endpoint}`;
    const headers = {
      "Content-Type": "application/json"
    };
    if (this.apiKey) {
      headers["X-API-Key"] = this.apiKey;
    }
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.DEFAULT_TIMEOUT);
    try {
      const response = await CallForSuccess(async () => {
        const res = await fetch(url, {
          method: "GET",
          headers,
          signal: controller.signal
        });
        if (!res.ok) {
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        return res.json();
      }, 20, 500);
      return response;
    } finally {
      clearTimeout(timeoutId);
    }
  }
  /**
   * Enhanced getJettonInfo that tries API if not in cache
   */
  async getJettonInfoAsync(jettonAddress) {
    try {
      const normalizedAddress = this.normalizeAddress(jettonAddress);
      const cached = this.cache.get(normalizedAddress);
      if (cached) {
        return cached;
      }
      const response = await this.makeApiRequest(`/jettons/${normalizedAddress}`);
      if (response.jetton_content) {
        const jettonData = response;
        const jettonInfo = {
          address: normalizedAddress,
          name: jettonData.jetton_content.name || "",
          symbol: jettonData.jetton_content.symbol || "",
          description: jettonData.jetton_content.description || "",
          decimals: parseInt(jettonData.jetton_content.decimals || "9", 10),
          totalSupply: jettonData.total_supply,
          image: jettonData.jetton_content.image,
          uri: jettonData.jetton_content.uri,
          verification: {
            verified: false,
            source: "toncenter"
          }
        };
        this.cache.set(normalizedAddress, jettonInfo);
        return jettonInfo;
      }
      return null;
    } catch (error) {
      log$d.debug("Failed to get jetton info from API", { error, jettonAddress });
      return null;
    }
  }
  /**
   * Clear the jetton cache
   */
  clearCache() {
    this.cache.clear();
    this.cache.set("TON", {
      address: "TON",
      name: "TON",
      symbol: "TON",
      description: "The Open Network native token",
      decimals: 9,
      totalSupply: "5000000000000000000",
      image: "https://asset.ston.fi/img/EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c/ee9fb21d17bc8d75c2a5f7b5f5f62d2bacec6b128f58b63cb841e98f7b74c4fc",
      verification: {
        verified: true,
        source: "manual"
      }
    });
    log$d.info("Jetton cache cleared");
  }
}

const log$c = globalLogger.createChild("EventEmitter");
class EventEmitter {
  listeners = /* @__PURE__ */ new Map();
  /**
   * Subscribe to an event
   */
  on(eventName, listener) {
    if (!this.listeners.has(eventName)) {
      this.listeners.set(eventName, /* @__PURE__ */ new Set());
    }
    this.listeners.get(eventName).add(listener);
    log$c.debug("Event listener added", { eventName, totalListeners: this.listeners.get(eventName).size });
  }
  /**
   * Subscribe to an event once (automatically removes after first emission)
   */
  once(eventName, listener) {
    const onceListener = (data) => {
      this.off(eventName, onceListener);
      listener(data);
    };
    this.on(eventName, onceListener);
  }
  /**
   * Unsubscribe from an event
   */
  off(eventName, listener) {
    const eventListeners = this.listeners.get(eventName);
    if (eventListeners) {
      eventListeners.delete(listener);
      log$c.debug("Event listener removed", { eventName, totalListeners: eventListeners.size });
      if (eventListeners.size === 0) {
        this.listeners.delete(eventName);
      }
    }
  }
  /**
   * Emit an event to all subscribers
   */
  emit(eventName, data) {
    const eventListeners = this.listeners.get(eventName);
    if (eventListeners) {
      log$c.debug("Emitting event", { eventName, listenerCount: eventListeners.size });
      eventListeners.forEach((listener) => {
        try {
          listener(data);
        } catch (error) {
          log$c.error("Error in event listener", { eventName, error });
        }
      });
    }
  }
  /**
   * Remove all listeners for a specific event
   */
  removeAllListeners(eventName) {
    if (eventName) {
      this.listeners.delete(eventName);
      log$c.debug("All listeners removed for event", { eventName });
    } else {
      this.listeners.clear();
      log$c.debug("All event listeners cleared");
    }
  }
  /**
   * Get the number of listeners for an event
   */
  listenerCount(eventName) {
    return this.listeners.get(eventName)?.size || 0;
  }
  /**
   * Get all event names that have listeners
   */
  eventNames() {
    return Array.from(this.listeners.keys());
  }
}

const log$b = globalLogger.createChild("TonWalletKit");
class TonWalletKit {
  // Component references
  walletManager;
  sessionManager;
  eventRouter;
  requestProcessor;
  responseHandler;
  tonClient;
  jettonsManager;
  initializer;
  eventProcessor;
  bridgeManager;
  // Event emitter for this kit instance
  eventEmitter;
  // State
  isInitialized = false;
  initializationPromise;
  constructor(options) {
    this.eventEmitter = new EventEmitter();
    this.initializer = new Initializer({}, this.eventEmitter);
    this.jettonsManager = new JettonsManager(1e4, this.eventEmitter, options.apiKey);
    this.initializationPromise = this.initialize(options);
  }
  // === Initialization ===
  /**
   * Initialize all components
   */
  async initialize(options) {
    if (this.isInitialized)
      return;
    try {
      const components = await this.initializer.initialize(options);
      this.assignComponents(components);
      this.setupEventRouting();
      this.eventProcessor.startRecoveryLoop();
      this.isInitialized = true;
    } catch (error) {
      log$b.error("TonWalletKit initialization failed", { error });
      throw error;
    }
  }
  /**
   * Assign initialized components
   */
  assignComponents(components) {
    this.walletManager = components.walletManager;
    this.sessionManager = components.sessionManager;
    this.eventRouter = components.eventRouter;
    this.requestProcessor = components.requestProcessor;
    this.responseHandler = components.responseHandler;
    this.tonClient = components.tonClient;
    this.eventProcessor = components.eventProcessor;
    this.bridgeManager = components.bridgeManager;
  }
  /**
   * Setup event routing from bridge to handlers
   */
  setupEventRouting() {
    this.startProcessingForExistingWallets();
  }
  /**
   * Start event processing for all existing wallets
   */
  async startProcessingForExistingWallets() {
    const wallets = this.walletManager.getWallets();
    for (const wallet of wallets) {
      try {
        await this.eventProcessor.startProcessing(wallet.getAddress());
      } catch (error) {
        log$b.error("Failed to start event processing for wallet", {
          walletAddress: wallet.getAddress(),
          error
        });
      }
    }
  }
  /**
   * Ensure initialization is complete
   */
  async ensureInitialized() {
    if (this.initializationPromise) {
      await this.initializationPromise;
    }
  }
  // === Wallet Management API (Delegated) ===
  getWallets() {
    if (!this.isInitialized) {
      log$b.warn("TonWalletKit not yet initialized, returning empty array");
      return [];
    }
    return this.walletManager.getWallets();
  }
  /**
   * Get wallet by address
   */
  getWallet(address) {
    if (!this.isInitialized) {
      log$b.warn("TonWalletKit not yet initialized, returning undefined");
      return void 0;
    }
    return this.walletManager.getWallet(address);
  }
  async addWallet(walletConfig) {
    await this.ensureInitialized();
    const wallet = await createWalletFromConfig(walletConfig, this.tonClient);
    const walletAdded = await this.walletManager.addWallet(wallet);
    if (!walletAdded) {
      return;
    }
    await this.eventProcessor.startProcessing(wallet.getAddress());
  }
  async removeWallet(wallet) {
    await this.ensureInitialized();
    await this.eventProcessor.stopProcessing(wallet.getAddress());
    await this.walletManager.removeWallet(wallet);
    await this.sessionManager.removeSessionsForWallet(wallet);
  }
  async clearWallets() {
    await this.ensureInitialized();
    const wallets = this.walletManager.getWallets();
    for (const wallet of wallets) {
      await this.eventProcessor.stopProcessing(wallet.getAddress());
    }
    await this.walletManager.clearWallets();
    await this.sessionManager.clearSessions();
  }
  // === Session Management API (Delegated) ===
  async disconnect(sessionId) {
    await this.ensureInitialized();
    const removeSession = async (sessionId2) => {
      await this.bridgeManager.sendResponse(sessionId2, null, {
        event: "disconnect",
        id: Date.now(),
        payload: {}
      });
      await this.sessionManager.removeSession(sessionId2);
    };
    if (sessionId) {
      try {
        await removeSession(sessionId);
      } catch (error) {
        log$b.error("Failed to remove session", { sessionId, error });
      }
    } else {
      const sessions = this.sessionManager.getSessions();
      if (sessions.length > 0) {
        for (const session of sessions) {
          try {
            await removeSession(session.sessionId);
          } catch (error) {
            log$b.error("Failed to remove session", { sessionId: session.sessionId, error });
          }
        }
      }
    }
  }
  async listSessions() {
    await this.ensureInitialized();
    return this.sessionManager.getSessionsForAPI();
  }
  // === Event Handler Registration (Delegated) ===
  onConnectRequest(cb) {
    if (this.eventRouter) {
      this.eventRouter.onConnectRequest(cb);
    } else {
      this.ensureInitialized().then(() => {
        this.eventRouter.onConnectRequest(cb);
      });
    }
  }
  onTransactionRequest(cb) {
    if (this.eventRouter) {
      this.eventRouter.onTransactionRequest(cb);
    } else {
      this.ensureInitialized().then(() => {
        this.eventRouter.onTransactionRequest(cb);
      });
    }
  }
  onSignDataRequest(cb) {
    if (this.eventRouter) {
      this.eventRouter.onSignDataRequest(cb);
    } else {
      this.ensureInitialized().then(() => {
        this.eventRouter.onSignDataRequest(cb);
      });
    }
  }
  onDisconnect(cb) {
    if (this.eventRouter) {
      this.eventRouter.onDisconnect(cb);
    } else {
      this.ensureInitialized().then(() => {
        this.eventRouter.onDisconnect(cb);
      });
    }
  }
  removeConnectRequestCallback(cb) {
    this.eventRouter.removeConnectRequestCallback(cb);
  }
  removeTransactionRequestCallback(cb) {
    this.eventRouter.removeTransactionRequestCallback(cb);
  }
  removeSignDataRequestCallback(cb) {
    this.eventRouter.removeSignDataRequestCallback(cb);
  }
  removeDisconnectCallback(cb) {
    this.eventRouter.removeDisconnectCallback(cb);
  }
  // === URL Processing API ===
  /**
   * Handle pasted TON Connect URL/link
   * Parses the URL and creates a connect request event
   */
  async handleTonConnectUrl(url) {
    await this.ensureInitialized();
    try {
      const parsedUrl = this.parseTonConnectUrl(url);
      if (!parsedUrl) {
        throw new Error("Invalid TON Connect URL format");
      }
      const bridgeEvent = this.createConnectEventFromUrl(parsedUrl);
      if (!bridgeEvent) {
        throw new Error("Invalid TON Connect URL format");
      }
      await this.eventRouter.routeEvent(bridgeEvent);
    } catch (error) {
      log$b.error("Failed to handle TON Connect URL", { error, url });
      throw error;
    }
  }
  /**
   * Parse TON Connect URL to extract connection parameters
   */
  parseTonConnectUrl(url) {
    try {
      let parsedUrl;
      parsedUrl = new URL(url);
      const params = {};
      for (const [key, value] of parsedUrl.searchParams.entries()) {
        params[key] = value;
      }
      if (!params.v || !params.id || !params.r) {
        log$b.warn("Missing required TON Connect URL parameters");
        return null;
      }
      return {
        version: params.v,
        clientId: params.id,
        requestId: params.id,
        returnStrategy: params.ret || "back",
        r: params.r,
        ...params
      };
    } catch (error) {
      log$b.error("Failed to parse TON Connect URL", { error, url });
      return null;
    }
  }
  /**
   * Create bridge event from parsed URL parameters
   */
  createConnectEventFromUrl(params) {
    const rString = params.r;
    const r = rString ? JSON.parse(rString) : void 0;
    if (!r?.manifestUrl || !params.clientId) {
      return void 0;
    }
    return {
      from: params.clientId,
      id: params.requestId,
      method: "startConnect",
      params: {
        manifest: {
          url: r.manifestUrl
        },
        items: r.items,
        returnStrategy: params.returnStrategy
      },
      timestamp: Date.now(),
      domain: ""
    };
  }
  // === Request Processing API (Delegated) ===
  async approveConnectRequest(event) {
    await this.ensureInitialized();
    await this.requestProcessor.approveConnectRequest(event);
  }
  async rejectConnectRequest(event, reason) {
    await this.ensureInitialized();
    await this.requestProcessor.rejectConnectRequest(event, reason);
  }
  async approveTransactionRequest(event) {
    await this.ensureInitialized();
    return this.requestProcessor.approveTransactionRequest(event);
  }
  async rejectTransactionRequest(event, reason) {
    await this.ensureInitialized();
    await this.requestProcessor.rejectTransactionRequest(event, reason);
  }
  async signDataRequest(event) {
    await this.ensureInitialized();
    return this.requestProcessor.approveSignDataRequest(event);
  }
  async rejectSignDataRequest(event, reason) {
    await this.ensureInitialized();
    await this.requestProcessor.rejectSignDataRequest(event, reason);
  }
  // === TON Client Access ===
  /**
   * Get the shared TON client instance
   */
  getTonClient() {
    if (!this.isInitialized) {
      throw new Error("TonWalletKit not yet initialized");
    }
    return this.tonClient;
  }
  // === Lifecycle Management ===
  /**
   * Check if kit is ready for use
   */
  isReady() {
    return this.isInitialized;
  }
  /**
   * Wait for initialization to complete
   */
  async waitForReady() {
    await this.ensureInitialized();
  }
  /**
   * Get initialization status
   */
  getStatus() {
    return {
      initialized: this.isInitialized,
      ready: this.isInitialized
    };
  }
  /**
   * Clean shutdown
   */
  async close() {
    if (this.initializer) {
      await this.initializer.cleanup({
        walletManager: this.walletManager,
        sessionManager: this.sessionManager,
        eventRouter: this.eventRouter,
        requestProcessor: this.requestProcessor,
        responseHandler: this.responseHandler,
        tonClient: this.tonClient,
        eventProcessor: this.eventProcessor
      });
    }
    this.isInitialized = false;
  }
  // === Jettons API ===
  /**
   * Jettons API access
   */
  get jettons() {
    return this.jettonsManager;
  }
  /**
   * Get jettons manager for internal use
   */
  getJettonsManager() {
    return this.jettonsManager;
  }
  /**
   * Get the event emitter for this kit instance
   * Allows external components to listen to and emit events
   */
  getEventEmitter() {
    return this.eventEmitter;
  }
}

class SimpleEncryption {
  static encoder = new TextEncoder();
  static decoder = new TextDecoder();
  static async deriveKey(password, salt) {
    const baseKey = await crypto.subtle.importKey("raw", this.encoder.encode(password), "PBKDF2", false, [
      "deriveKey"
    ]);
    return crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        salt,
        iterations: 1e5,
        hash: "SHA-256"
      },
      baseKey,
      {
        name: "AES-GCM",
        length: 256
      },
      false,
      ["encrypt", "decrypt"]
    );
  }
  static async encrypt(data, password) {
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const key = await this.deriveKey(password, salt);
    const encrypted = await crypto.subtle.encrypt(
      {
        name: "AES-GCM",
        iv
      },
      key,
      this.encoder.encode(data)
    );
    const combined = new Uint8Array(salt.length + iv.length + encrypted.byteLength);
    combined.set(salt, 0);
    combined.set(iv, salt.length);
    combined.set(new Uint8Array(encrypted), salt.length + iv.length);
    return bufferExports$1.Buffer.from(combined).toString("base64");
  }
  static async decrypt(encryptedData, password) {
    const combined = new Uint8Array(bufferExports$1.Buffer.from(encryptedData, "base64"));
    const salt = combined.slice(0, 16);
    const iv = combined.slice(16, 28);
    const data = combined.slice(28);
    const key = await this.deriveKey(password, salt);
    const decrypted = await crypto.subtle.decrypt(
      {
        name: "AES-GCM",
        iv
      },
      key,
      data
    );
    return this.decoder.decode(decrypted);
  }
}

const log$a = createComponentLogger("WalletSlice");
const walletKit = new TonWalletKit({
  bridgeUrl: "https://bridge.tonapi.io/bridge",
  network: "mainnet",
  wallets: [],
  apiKey: "25a9b2326a34b39a5fa4b264fb78fb4709e1bd576fc5e6b176639f5b71e94b0d"
});
const createWalletSlice = (set, get) => ({
  wallet: {
    // Initial state
    isAuthenticated: false,
    hasWallet: false,
    address: void 0,
    balance: void 0,
    mnemonic: void 0,
    publicKey: void 0,
    transactions: [],
    currentWallet: void 0,
    pendingConnectRequest: void 0,
    isConnectModalOpen: false,
    pendingTransactionRequest: void 0,
    isTransactionModalOpen: false,
    pendingSignDataRequest: void 0,
    isSignDataModalOpen: false,
    encryptedMnemonic: void 0,
    disconnectedSessions: []
    // Track recently disconnected sessions
  },
  // Actions
  createWallet: async (mnemonic) => {
    const state = get();
    if (!state.auth.currentPassword) {
      throw new Error("User not authenticated");
    }
    try {
      const encryptedMnemonic = await SimpleEncryption.encrypt(
        JSON.stringify(mnemonic),
        state.auth.currentPassword
      );
      const walletConfig = new WalletInitConfigMnemonic({
        mnemonic,
        version: "v5r1",
        mnemonicType: "ton",
        network: "mainnet"
      });
      await walletKit.addWallet(walletConfig);
      const wallets = walletKit.getWallets();
      const wallet = wallets[0];
      const address = wallet.getAddress();
      const balance = await wallet.getBalance();
      const publicKey = Array.from(wallet.publicKey).map((b) => b.toString(16).padStart(2, "0")).join("");
      set((state2) => {
        state2.wallet.hasWallet = true;
        state2.wallet.isAuthenticated = true;
        state2.wallet.address = address;
        state2.wallet.publicKey = publicKey;
        state2.wallet.balance = balance.toString();
        state2.wallet.encryptedMnemonic = encryptedMnemonic;
        state2.wallet.mnemonic = void 0;
        state2.wallet.currentWallet = wallet;
      });
    } catch (error) {
      log$a.error("Error creating wallet:", error);
      throw new Error("Failed to create wallet");
    }
  },
  importWallet: async (mnemonic) => {
    return get().createWallet(mnemonic);
  },
  loadWallet: async () => {
    const state = get();
    if (!state.auth.currentPassword) {
      throw new Error("User not authenticated");
    }
    try {
      if (!state.wallet.encryptedMnemonic) {
        set((state2) => {
          state2.wallet.hasWallet = false;
          state2.wallet.isAuthenticated = false;
        });
        return;
      }
      const decryptedString = await SimpleEncryption.decrypt(
        state.wallet.encryptedMnemonic,
        state.auth.currentPassword
      );
      const mnemonic = JSON.parse(decryptedString);
      const walletConfig = new WalletInitConfigMnemonic({
        mnemonic,
        version: "v5r1",
        mnemonicType: "ton",
        network: "mainnet"
      });
      await walletKit.addWallet(walletConfig);
      const wallets = walletKit.getWallets();
      const wallet = wallets[0];
      const address = wallet.getAddress();
      const balance = await wallet.getBalance();
      const publicKey = Array.from(wallet.publicKey).map((b) => b.toString(16).padStart(2, "0")).join("");
      set((state2) => {
        state2.wallet.hasWallet = true;
        state2.wallet.isAuthenticated = true;
        state2.wallet.address = address;
        state2.wallet.publicKey = publicKey;
        state2.wallet.balance = balance.toString();
        state2.wallet.currentWallet = wallet;
      });
    } catch (error) {
      log$a.error("Error loading wallet:", error);
      set((state2) => {
        state2.wallet.hasWallet = false;
        state2.wallet.isAuthenticated = false;
      });
    }
  },
  getDecryptedMnemonic: async () => {
    const state = get();
    if (!state.auth.currentPassword) {
      log$a.error("No current password available");
      return null;
    }
    try {
      if (!state.wallet.encryptedMnemonic) {
        log$a.error("No encrypted mnemonic found in state");
        return null;
      }
      const decryptedString = await SimpleEncryption.decrypt(
        state.wallet.encryptedMnemonic,
        state.auth.currentPassword
      );
      const mnemonic = JSON.parse(decryptedString);
      if (!mnemonic || mnemonic.length === 0) {
        log$a.error("Decrypted mnemonic is empty");
        return null;
      }
      return mnemonic;
    } catch (error) {
      log$a.error("Error decrypting mnemonic:", error);
      return null;
    }
  },
  clearWallet: () => {
    set((state) => {
      state.wallet.isAuthenticated = false;
      state.wallet.hasWallet = false;
      state.wallet.address = void 0;
      state.wallet.balance = void 0;
      state.wallet.mnemonic = void 0;
      state.wallet.publicKey = void 0;
      state.wallet.transactions = [];
      state.wallet.currentWallet = void 0;
      state.wallet.encryptedMnemonic = void 0;
      state.wallet.pendingConnectRequest = void 0;
      state.wallet.isConnectModalOpen = false;
      state.wallet.pendingTransactionRequest = void 0;
      state.wallet.isTransactionModalOpen = false;
      state.wallet.pendingSignDataRequest = void 0;
      state.wallet.isSignDataModalOpen = false;
    });
  },
  updateBalance: async () => {
    const state = get();
    if (!state.wallet.currentWallet) {
      log$a.warn("No wallet available to update balance");
      return;
    }
    try {
      const balance = await state.wallet.currentWallet.getBalance();
      const balanceString = balance.toString();
      set((state2) => {
        state2.wallet.balance = balanceString;
      });
    } catch (error) {
      log$a.error("Error updating balance:", error);
      throw new Error("Failed to update balance");
    }
  },
  addTransaction: (transaction) => {
    set((state) => {
      state.wallet.transactions = [transaction, ...state.wallet.transactions];
    });
  },
  // TON Connect URL handling
  handleTonConnectUrl: async (url) => {
    try {
      log$a.info("Handling TON Connect URL:", url);
      await walletKit.handleTonConnectUrl(url);
    } catch (error) {
      log$a.error("Failed to handle TON Connect URL:", error);
      throw new Error("Failed to process TON Connect link");
    }
  },
  // Connect request handling
  showConnectRequest: (request) => {
    set((state) => {
      state.wallet.pendingConnectRequest = request;
      state.wallet.isConnectModalOpen = true;
    });
  },
  approveConnectRequest: async (selectedWallet) => {
    const state = get();
    if (!state.wallet.pendingConnectRequest) {
      log$a.error("No pending connect request to approve");
      return;
    }
    try {
      const updatedRequest = {
        ...state.wallet.pendingConnectRequest,
        wallet: selectedWallet
      };
      await walletKit.approveConnectRequest(updatedRequest);
      set((state2) => {
        state2.wallet.pendingConnectRequest = void 0;
        state2.wallet.isConnectModalOpen = false;
      });
    } catch (error) {
      log$a.error("Failed to approve connect request:", error);
      throw error;
    }
  },
  rejectConnectRequest: async (reason) => {
    const state = get();
    if (!state.wallet.pendingConnectRequest) {
      log$a.error("No pending connect request to reject");
      return;
    }
    try {
      await walletKit.rejectConnectRequest(state.wallet.pendingConnectRequest, reason);
      set((state2) => {
        state2.wallet.pendingConnectRequest = void 0;
        state2.wallet.isConnectModalOpen = false;
      });
    } catch (error) {
      log$a.error("Failed to reject connect request:", error);
      throw error;
    }
  },
  closeConnectModal: () => {
    set((state) => {
      state.wallet.isConnectModalOpen = false;
      state.wallet.pendingConnectRequest = void 0;
    });
  },
  // Transaction request handling
  showTransactionRequest: (request) => {
    set((state) => {
      state.wallet.pendingTransactionRequest = request;
      state.wallet.isTransactionModalOpen = true;
    });
  },
  approveTransactionRequest: async () => {
    const state = get();
    if (!state.wallet.pendingTransactionRequest) {
      log$a.error("No pending transaction request to approve");
      return;
    }
    try {
      await walletKit.approveTransactionRequest(state.wallet.pendingTransactionRequest);
      set((state2) => {
        state2.wallet.pendingTransactionRequest = void 0;
        state2.wallet.isTransactionModalOpen = false;
      });
    } catch (error) {
      log$a.error("Failed to approve transaction request:", error);
      throw error;
    }
  },
  rejectTransactionRequest: async (reason) => {
    const state = get();
    if (!state.wallet.pendingTransactionRequest) {
      log$a.error("No pending transaction request to reject");
      return;
    }
    try {
      await walletKit.rejectTransactionRequest(state.wallet.pendingTransactionRequest, reason);
      set((state2) => {
        state2.wallet.pendingTransactionRequest = void 0;
        state2.wallet.isTransactionModalOpen = false;
      });
    } catch (error) {
      log$a.error("Failed to reject transaction request:", error);
      throw error;
    }
  },
  closeTransactionModal: () => {
    set((state) => {
      state.wallet.isTransactionModalOpen = false;
      state.wallet.pendingTransactionRequest = void 0;
    });
  },
  // Sign data request handling
  showSignDataRequest: (request) => {
    set((state) => {
      state.wallet.pendingSignDataRequest = request;
      state.wallet.isSignDataModalOpen = true;
    });
  },
  approveSignDataRequest: async () => {
    const state = get();
    if (!state.wallet.pendingSignDataRequest) {
      log$a.error("No pending sign data request to approve");
      return;
    }
    try {
      await walletKit.signDataRequest(state.wallet.pendingSignDataRequest);
      set((state2) => {
        state2.wallet.pendingSignDataRequest = void 0;
        state2.wallet.isSignDataModalOpen = false;
      });
    } catch (error) {
      log$a.error("Failed to approve sign data request:", error);
      throw error;
    }
  },
  rejectSignDataRequest: async (reason) => {
    const state = get();
    if (!state.wallet.pendingSignDataRequest) {
      log$a.error("No pending sign data request to reject");
      return;
    }
    try {
      await walletKit.rejectSignDataRequest(state.wallet.pendingSignDataRequest, reason);
      set((state2) => {
        state2.wallet.pendingSignDataRequest = void 0;
        state2.wallet.isSignDataModalOpen = false;
      });
    } catch (error) {
      log$a.error("Failed to reject sign data request:", error);
      throw error;
    }
  },
  closeSignDataModal: () => {
    set((state) => {
      state.wallet.isSignDataModalOpen = false;
      state.wallet.pendingSignDataRequest = void 0;
    });
  },
  // Disconnect event handling
  handleDisconnectEvent: (event) => {
    log$a.info("Disconnect event received:", event);
    set((state) => {
      state.wallet.disconnectedSessions.push({
        walletAddress: event.wallet.getAddress(),
        reason: event.reason,
        timestamp: Date.now()
      });
    });
  },
  // Clear disconnect notifications
  clearDisconnectNotifications: () => {
    set((state) => {
      state.wallet.disconnectedSessions = [];
    });
  },
  // Getters
  getAvailableWallets: () => {
    return walletKit.getWallets();
  }
});
const setupWalletKitListeners = (showConnectRequest, showTransactionRequest, showSignDataRequest, handleDisconnectEvent) => {
  const onTransactionRequest = (event) => {
    log$a.info("Transaction request received:", event);
    showTransactionRequest(event);
  };
  walletKit.onConnectRequest((event) => {
    log$a.info("Connect request received:", event);
    showConnectRequest(event);
  });
  walletKit.onTransactionRequest(onTransactionRequest);
  walletKit.onSignDataRequest((event) => {
    log$a.info("Sign data request received:", event);
    showSignDataRequest(event);
  });
  walletKit.onDisconnect((event) => {
    log$a.info("Disconnect event received:", event);
    handleDisconnectEvent(event);
  });
};

const log$9 = createComponentLogger("JettonsSlice");
const createJettonsSlice = (set, get) => ({
  jettons: {
    // Initial state
    userJettons: [],
    jettonTransfers: [],
    popularJettons: [],
    isLoadingJettons: false,
    isLoadingTransfers: false,
    isLoadingPopular: false,
    isRefreshing: false,
    error: null,
    transferError: null,
    lastJettonsUpdate: 0,
    lastTransfersUpdate: 0,
    lastPopularUpdate: 0
  },
  // Actions
  loadUserJettons: async (userAddress) => {
    const state = get();
    const address = userAddress || state.wallet.address;
    if (!address) {
      log$9.warn("No user address available to load jettons");
      return;
    }
    set((state2) => {
      state2.jettons.isLoadingJettons = true;
      state2.jettons.error = null;
    });
    try {
      log$9.info("Loading user jettons", { address });
      const userJettons = await walletKit.jettons.getAddressJettons(address);
      set((state2) => {
        state2.jettons.userJettons = userJettons;
        state2.jettons.lastJettonsUpdate = Date.now();
        state2.jettons.isLoadingJettons = false;
        state2.jettons.error = null;
      });
      log$9.info("Successfully loaded user jettons", { count: userJettons.length });
    } catch (error) {
      log$9.error("Failed to load user jettons:", error);
      const errorMessage = error instanceof JettonError ? `Jettons error: ${error.message} (${error.code})` : error instanceof Error ? error.message : "Failed to load jettons";
      set((state2) => {
        state2.jettons.isLoadingJettons = false;
        state2.jettons.error = errorMessage;
      });
    }
  },
  refreshJettons: async (userAddress) => {
    const state = get();
    const address = userAddress || state.wallet.address;
    if (!address) {
      return;
    }
    set((state2) => {
      state2.jettons.isRefreshing = true;
    });
    try {
      await get().loadUserJettons(address);
    } finally {
      set((state2) => {
        state2.jettons.isRefreshing = false;
      });
    }
  },
  loadJettonTransfers: async (userAddress, jettonAddress) => {
    const state = get();
    const address = userAddress || state.wallet.address;
    if (!address) {
      log$9.warn("No user address available to load jetton transfers");
      return;
    }
    set((state2) => {
      state2.jettons.isLoadingTransfers = true;
      state2.jettons.error = null;
    });
    try {
      log$9.info("Loading jetton transfers", { address, jettonAddress });
      const transfers = await walletKit.jettons.getJettonTransfers(address, jettonAddress, 50);
      set((state2) => {
        state2.jettons.jettonTransfers = transfers;
        state2.jettons.lastTransfersUpdate = Date.now();
        state2.jettons.isLoadingTransfers = false;
        state2.jettons.error = null;
      });
      log$9.info("Successfully loaded jetton transfers", { count: transfers.length });
    } catch (error) {
      log$9.error("Failed to load jetton transfers:", error);
      const errorMessage = error instanceof JettonError ? `Transfer history error: ${error.message} (${error.code})` : error instanceof Error ? error.message : "Failed to load transfer history";
      set((state2) => {
        state2.jettons.isLoadingTransfers = false;
        state2.jettons.error = errorMessage;
      });
    }
  },
  loadPopularJettons: async () => {
    set((state) => {
      state.jettons.isLoadingPopular = true;
      state.jettons.error = null;
    });
    try {
      log$9.info("Loading popular jettons");
      const popular = await walletKit.jettons.getPopularJettons(20);
      set((state) => {
        state.jettons.popularJettons = popular;
        state.jettons.lastPopularUpdate = Date.now();
        state.jettons.isLoadingPopular = false;
        state.jettons.error = null;
      });
      log$9.info("Successfully loaded popular jettons", { count: popular.length });
    } catch (error) {
      log$9.error("Failed to load popular jettons:", error);
      const errorMessage = error instanceof JettonError ? `Popular jettons error: ${error.message} (${error.code})` : error instanceof Error ? error.message : "Failed to load popular jettons";
      set((state) => {
        state.jettons.isLoadingPopular = false;
        state.jettons.error = errorMessage;
      });
    }
  },
  searchJettons: async (query) => {
    if (!query.trim()) {
      return [];
    }
    try {
      log$9.info("Searching jettons", { query });
      const results = await walletKit.jettons.searchJettons(query, 20);
      log$9.info("Successfully searched jettons", { query, count: results.length });
      return results;
    } catch (error) {
      log$9.error("Failed to search jettons:", error);
      throw error;
    }
  },
  getJettonBalance: async (jettonWalletAddress) => {
    try {
      log$9.info("Getting jetton balance", { jettonWalletAddress });
      const balance = await walletKit.jettons.getJettonBalance(jettonWalletAddress);
      log$9.info("Successfully got jetton balance", { balance: balance.balance });
      return balance;
    } catch (error) {
      log$9.error("Failed to get jetton balance:", error);
      throw error;
    }
  },
  validateJettonAddress: (address) => {
    return walletKit.jettons.validateJettonAddress(address);
  },
  clearJettons: () => {
    set((state) => {
      state.jettons.userJettons = [];
      state.jettons.jettonTransfers = [];
      state.jettons.popularJettons = [];
      state.jettons.isLoadingJettons = false;
      state.jettons.isLoadingTransfers = false;
      state.jettons.isLoadingPopular = false;
      state.jettons.isRefreshing = false;
      state.jettons.error = null;
      state.jettons.transferError = null;
      state.jettons.lastJettonsUpdate = 0;
      state.jettons.lastTransfersUpdate = 0;
      state.jettons.lastPopularUpdate = 0;
    });
  },
  // Utility methods
  getJettonByAddress: (jettonAddress) => {
    const state = get();
    return state.jettons.userJettons.find((j) => j.address === jettonAddress);
  },
  formatJettonAmount: (amount, decimals) => {
    try {
      const amountBigInt = BigInt(amount);
      const divisor = BigInt(10 ** decimals);
      const wholePart = amountBigInt / divisor;
      const fractionalPart = amountBigInt % divisor;
      if (fractionalPart === 0n) {
        return wholePart.toString();
      }
      const fractionalStr = fractionalPart.toString().padStart(decimals, "0");
      const trimmedFractional = fractionalStr.replace(/0+$/, "");
      return trimmedFractional ? `${wholePart}.${trimmedFractional}` : wholePart.toString();
    } catch (error) {
      log$9.error("Error formatting jetton amount:", error);
      return "0";
    }
  }
});

const log$8 = createComponentLogger("AppStore");
const STORE_VERSION = 1;
const migrate = (persistedState, fromVersion) => {
  log$8.info("Migrating store from version", fromVersion, "to", STORE_VERSION);
  if (fromVersion < 1) {
    const state = persistedState;
    const migratedState = {
      auth: {
        isPasswordSet: state.isPasswordSet || false,
        passwordHash: state.passwordHash,
        isUnlocked: false
        // Never persist unlocked state
      },
      wallet: {
        hasWallet: state.hasWallet || false,
        isAuthenticated: false,
        // Never persist authentication
        transactions: state.transactions || [],
        encryptedMnemonic: state.encryptedMnemonic,
        // Migrate encrypted mnemonic
        disconnectedSessions: []
        // Always initialize as empty array
      }
    };
    return migratedState;
  }
  return persistedState;
};
const useStore = create()(
  devtools(
    subscribeWithSelector(
      persist(
        immer((...a) => ({
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          ...createAuthSlice(...a),
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          ...createWalletSlice(...a),
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          ...createJettonsSlice(...a)
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        })),
        {
          name: "demo-wallet-app-store",
          //  one clean key
          storage: createJSONStorage(() => localStorage),
          version: STORE_VERSION,
          migrate,
          // Only persist long-lived data organized by slices:
          partialize: (state) => ({
            auth: {
              isPasswordSet: state.auth.isPasswordSet,
              passwordHash: state.auth.passwordHash
              // isUnlocked: state.auth.isUnlocked,
              // currentPassword: state.auth.currentPassword,
              // isUnlocked: omit - never persist unlocked state for security
            },
            wallet: {
              hasWallet: state.wallet.hasWallet,
              transactions: state.wallet.transactions,
              encryptedMnemonic: state.wallet.encryptedMnemonic
            }
            // jettons: {
            //     userJettons: state.jettons.userJettons,
            //     popularJettons: state.jettons.popularJettons,
            //     lastJettonsUpdate: state.jettons.lastJettonsUpdate,
            //     lastPopularUpdate: state.jettons.lastPopularUpdate,
            //     // Don't persist: loading states, errors, transfer history
            // },
            // isAuthenticated: omit - never persist authentication for security
            // },
            // Never persist these sensitive/runtime values:
            // - currentPassword (security)
            // - currentWallet (contains methods and client instances)
            // - pendingConnectRequest (runtime state)
            // - isConnectModalOpen (UI state)
          }),
          onRehydrateStorage: () => (state, error) => {
            if (error) {
              log$8.error("Store rehydration error:", error);
            } else if (state) {
              log$8.info("Store rehydrated successfully");
              if (!state.wallet.disconnectedSessions) {
                state.wallet.disconnectedSessions = [];
              }
            }
          }
        }
      )
    )
  )
);
if (typeof window !== "undefined") {
  const store = useStore.getState();
  setupWalletKitListeners(
    store.showConnectRequest,
    store.showTransactionRequest,
    store.showSignDataRequest,
    store.handleDisconnectEvent
  );
}
const useAuth = () => useStore(
  useShallow((state) => ({
    isPasswordSet: state.auth.isPasswordSet,
    isUnlocked: state.auth.isUnlocked,
    setPassword: state.setPassword,
    unlock: state.unlock,
    lock: state.lock,
    reset: state.reset
  }))
);
const useWallet = () => useStore(
  useShallow((state) => ({
    isAuthenticated: state.wallet.isAuthenticated,
    hasWallet: state.wallet.hasWallet,
    address: state.wallet.address,
    balance: state.wallet.balance,
    publicKey: state.wallet.publicKey,
    transactions: state.wallet.transactions,
    currentWallet: state.wallet.currentWallet,
    createWallet: state.createWallet,
    importWallet: state.importWallet,
    loadWallet: state.loadWallet,
    clearWallet: state.clearWallet,
    updateBalance: state.updateBalance,
    addTransaction: state.addTransaction,
    getDecryptedMnemonic: state.getDecryptedMnemonic,
    getAvailableWallets: state.getAvailableWallets
  }))
);
const useTonConnect = () => useStore(
  useShallow((state) => ({
    pendingConnectRequest: state.wallet.pendingConnectRequest,
    isConnectModalOpen: state.wallet.isConnectModalOpen,
    handleTonConnectUrl: state.handleTonConnectUrl,
    showConnectRequest: state.showConnectRequest,
    approveConnectRequest: state.approveConnectRequest,
    rejectConnectRequest: state.rejectConnectRequest,
    closeConnectModal: state.closeConnectModal
  }))
);
const useTransactionRequests = () => useStore(
  useShallow((state) => ({
    pendingTransactionRequest: state.wallet.pendingTransactionRequest,
    isTransactionModalOpen: state.wallet.isTransactionModalOpen,
    showTransactionRequest: state.showTransactionRequest,
    approveTransactionRequest: state.approveTransactionRequest,
    rejectTransactionRequest: state.rejectTransactionRequest,
    closeTransactionModal: state.closeTransactionModal
  }))
);
const useSignDataRequests = () => useStore(
  useShallow((state) => ({
    pendingSignDataRequest: state.wallet.pendingSignDataRequest,
    isSignDataModalOpen: state.wallet.isSignDataModalOpen,
    showSignDataRequest: state.showSignDataRequest,
    approveSignDataRequest: state.approveSignDataRequest,
    rejectSignDataRequest: state.rejectSignDataRequest,
    closeSignDataModal: state.closeSignDataModal
  }))
);
const useDisconnectEvents = () => useStore(
  useShallow((state) => ({
    disconnectedSessions: state.wallet.disconnectedSessions || [],
    handleDisconnectEvent: state.handleDisconnectEvent,
    clearDisconnectNotifications: state.clearDisconnectNotifications
  }))
);
const useJettons = () => useStore(
  useShallow((state) => ({
    // Data
    userJettons: state.jettons.userJettons,
    jettonTransfers: state.jettons.jettonTransfers,
    popularJettons: state.jettons.popularJettons,
    // Loading states
    isLoadingJettons: state.jettons.isLoadingJettons,
    isLoadingTransfers: state.jettons.isLoadingTransfers,
    isLoadingPopular: state.jettons.isLoadingPopular,
    isRefreshing: state.jettons.isRefreshing,
    // Error states
    error: state.jettons.error,
    transferError: state.jettons.transferError,
    // Actions
    loadUserJettons: state.loadUserJettons,
    refreshJettons: state.refreshJettons,
    loadJettonTransfers: state.loadJettonTransfers,
    loadPopularJettons: state.loadPopularJettons,
    searchJettons: state.searchJettons,
    getJettonBalance: state.getJettonBalance,
    validateJettonAddress: state.validateJettonAddress,
    clearJettons: state.clearJettons,
    // Utilities
    getJettonByAddress: state.getJettonByAddress,
    formatJettonAmount: state.formatJettonAmount
  }))
);

const ProtectedRoute = ({ children, requiresWallet = false }) => {
  const { isPasswordSet, isUnlocked } = useAuth();
  const { hasWallet } = useWallet();
  if (!isPasswordSet) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/setup-password", replace: true });
  }
  if (!isUnlocked) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/unlock", replace: true });
  }
  if (requiresWallet && !hasWallet) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/setup-wallet", replace: true });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
};

const SetupPassword = () => {
  const [password, setPassword] = reactExports.useState("");
  const [confirmPassword, setConfirmPassword] = reactExports.useState("");
  const [error, setError] = reactExports.useState("");
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const navigate = useNavigate();
  const { setPassword: setStorePassword } = useAuth();
  const validatePassword = (pwd) => {
    const errors = [];
    if (pwd.length < 4) errors.push("Password must be at least 4 characters long");
    return errors;
  };
  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");
    setIsLoading(true);
    try {
      const validationErrors = validatePassword(password);
      if (validationErrors.length > 0) {
        throw new Error(validationErrors[0]);
      }
      if (password !== confirmPassword) {
        throw new Error("Passwords do not match");
      }
      await setStorePassword(password);
      navigate("/setup-wallet");
    } catch (err) {
      setError(err instanceof Error ? err.message : "An error occurred");
    } finally {
      setIsLoading(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, { title: "Setup Password", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-900", children: "Create Password" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-sm text-gray-600", children: "Your password will be used to encrypt your wallet data locally." })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input,
        {
          type: "password",
          label: "Password",
          value: password,
          onChange: (e) => setPassword(e.target.value),
          placeholder: "Enter a strong password",
          required: true,
          helperText: "At least 8 characters with uppercase, lowercase, and numbers"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input,
        {
          type: "password",
          label: "Confirm Password",
          value: confirmPassword,
          onChange: (e) => setConfirmPassword(e.target.value),
          placeholder: "Confirm your password",
          required: true
        }
      ),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-600 text-sm text-center", children: error }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          type: "submit",
          isLoading,
          disabled: !password || !confirmPassword,
          className: "w-full",
          children: "Continue"
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center text-sm text-gray-500", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: " Make sure to remember your password." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "It cannot be recovered if forgotten." })
    ] })
  ] }) });
};

const UnlockWallet = () => {
  const [password, setPassword] = reactExports.useState("");
  const [error, setError] = reactExports.useState("");
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const navigate = useNavigate();
  const { unlock, reset } = useAuth();
  const { loadWallet } = useWallet();
  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");
    setIsLoading(true);
    try {
      const success = await unlock(password);
      if (!success) {
        throw new Error("Invalid password");
      }
      await loadWallet();
      navigate("/wallet");
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to unlock wallet");
    } finally {
      setIsLoading(false);
    }
  };
  const handleReset = () => {
    if (window.confirm("Are you sure you want to reset your wallet? This will delete all wallet data permanently.")) {
      reset();
      navigate("/setup-password");
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, { title: "Unlock Wallet", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-900", children: "Welcome Back" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-sm text-gray-600", children: "Enter your password to unlock your wallet." })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input,
        {
          type: "password",
          label: "Password",
          value: password,
          onChange: (e) => setPassword(e.target.value),
          placeholder: "Enter your password",
          required: true,
          autoFocus: true
        }
      ),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-600 text-sm text-center", children: error }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", isLoading, disabled: !password, className: "w-full", children: "Unlock Wallet" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center flex flex-col items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: handleReset, className: "text-sm", children: "Reset Wallet" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-xs text-gray-500", children: "This will permanently delete your wallet data" })
    ] })
  ] }) });
};

const log$7 = createComponentLogger("useTonWallet");
const useTonWallet = () => {
  const [tonKit, setTonKit] = reactExports.useState(null);
  const [isInitialized, setIsInitialized] = reactExports.useState(false);
  const [error, setError] = reactExports.useState(null);
  const walletStore = useWallet();
  const authStore = useAuth();
  const initializeWallet = reactExports.useCallback(async () => {
    try {
      setError(null);
      const kit = {
        // Mock implementation for demo purposes
        initialized: true
      };
      setTonKit(kit);
      setIsInitialized(true);
      if (walletStore.hasWallet && authStore.isUnlocked) {
        await walletStore.loadWallet();
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Unknown error";
      setError(errorMessage);
      log$7.error("Error initializing TON wallet:", err);
    }
  }, [walletStore, authStore.isUnlocked]);
  const createNewWallet = reactExports.useCallback(async () => {
    if (!tonKit) throw new Error("TON Kit not initialized");
    try {
      setError(null);
      const mnemonic = await distExports.mnemonicNew();
      await walletStore.createWallet(mnemonic);
      return mnemonic;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to create wallet";
      setError(errorMessage);
      throw new Error(errorMessage);
    }
  }, [tonKit, walletStore]);
  const importWallet = reactExports.useCallback(
    async (mnemonic) => {
      if (!tonKit) throw new Error("TON Kit not initialized");
      try {
        setError(null);
        const isValid = mnemonic.length === 12 || mnemonic.length === 24;
        if (!isValid) {
          throw new Error("Invalid mnemonic phrase");
        }
        await walletStore.importWallet(mnemonic);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to import wallet";
        setError(errorMessage);
        throw new Error(errorMessage);
      }
    },
    [tonKit, walletStore]
  );
  const getBalance = reactExports.useCallback(async () => {
    if (!tonKit) throw new Error("TON Kit not initialized");
    try {
      setError(null);
      const mnemonic = await walletStore.getDecryptedMnemonic();
      if (!mnemonic) throw new Error("No wallet available");
      return "1";
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to get balance";
      setError(errorMessage);
      throw new Error(errorMessage);
    }
  }, [tonKit, walletStore]);
  const sendTransaction = reactExports.useCallback(
    async (to, amount) => {
      if (!tonKit) throw new Error("TON Kit not initialized");
      try {
        setError(null);
        const mnemonic = await walletStore.getDecryptedMnemonic();
        if (!mnemonic) throw new Error("No wallet available");
        await new Promise((resolve) => setTimeout(resolve, 1e3));
        walletStore.addTransaction({
          id: Date.now().toString(),
          type: "send",
          amount,
          address: to,
          timestamp: Date.now(),
          status: "confirmed"
          // Mock as confirmed immediately
        });
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : "Failed to send transaction";
        setError(errorMessage);
        throw new Error(errorMessage);
      }
    },
    [tonKit, walletStore]
  );
  reactExports.useEffect(() => {
    if (!isInitialized) {
      initializeWallet();
    }
  }, [initializeWallet, isInitialized]);
  return {
    tonKit,
    isInitialized,
    error,
    initializeWallet,
    createNewWallet,
    importWallet,
    getBalance,
    sendTransaction
  };
};

const SetupWallet = () => {
  const [mode, setMode] = reactExports.useState("select");
  const [mnemonic, setMnemonic] = reactExports.useState([]);
  const [error, setError] = reactExports.useState("");
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [showMnemonic, setShowMnemonic] = reactExports.useState(false);
  const [isSaved, setIsSaved] = reactExports.useState(false);
  const navigate = useNavigate();
  const { createNewWallet, importWallet } = useTonWallet();
  const handleCreateWallet = async () => {
    setError("");
    setIsLoading(true);
    try {
      const newMnemonic = await createNewWallet();
      setMnemonic(newMnemonic);
      setMode("create");
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to create wallet");
    } finally {
      setIsLoading(false);
    }
  };
  const handleImportWallet = async (mnemonicArray) => {
    setError("");
    setIsLoading(true);
    try {
      if (mnemonicArray.length !== 12 && mnemonicArray.length !== 24) {
        throw new Error("Mnemonic must be 12 or 24 words");
      }
      await importWallet(mnemonicArray);
      navigate("/wallet");
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to import wallet");
    } finally {
      setIsLoading(false);
    }
  };
  const handleConfirmMnemonic = async () => {
    try {
      navigate("/wallet");
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to confirm wallet");
    }
  };
  if (mode === "select") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, { title: "Setup Wallet", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-900", children: "Setup Your Wallet" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-sm text-gray-600", children: "Create a new wallet or import an existing one." })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleCreateWallet, isLoading, className: "w-full", children: "Create New Wallet" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-500 text-center", children: "Generate a new 24-word recovery phrase" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: () => setMode("import"), className: "w-full", children: "Import Existing Wallet" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-500 text-center", children: "Restore wallet using recovery phrase" })
        ] }) })
      ] }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-600 text-sm text-center", children: error })
    ] }) });
  }
  if (mode === "create") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, { title: "Your Recovery Phrase", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-900", children: "Save Your Recovery Phrase" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-sm text-gray-600", children: "Write down these 24 words in the exact order shown." })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: !showMnemonic ? "blur-sm" : "", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            MnemonicDisplay,
            {
              mnemonic,
              showWarning: true,
              warningType: "yellow",
              warningText: "Keep this phrase safe and secret. Anyone with access to it can control your wallet."
            }
          ) }),
          !showMnemonic && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => setShowMnemonic(true), size: "sm", children: "Click to reveal" }) })
        ] }),
        showMnemonic && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "checkbox",
                id: "saved",
                checked: isSaved,
                onChange: (e) => setIsSaved(e.target.checked),
                className: "h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "saved", className: "text-sm text-gray-700", children: "I have safely saved my recovery phrase" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleConfirmMnemonic, disabled: !isSaved, className: "w-full", children: "Continue" })
        ] })
      ] }) })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, { title: "Import Wallet", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ImportWallet,
    {
      onImport: handleImportWallet,
      onBack: () => setMode("select"),
      isLoading,
      error
    }
  ) }) });
};

const log$6 = createComponentLogger("WalletDashboard");
const WalletDashboard = () => {
  const [isRefreshing, setIsRefreshing] = reactExports.useState(false);
  const [isCopied, setIsCopied] = reactExports.useState(false);
  const [tonConnectUrl, setTonConnectUrl] = reactExports.useState("");
  const [isConnecting, setIsConnecting] = reactExports.useState(false);
  const navigate = useNavigate();
  const { balance, address, transactions, getAvailableWallets } = useWallet();
  const {
    handleTonConnectUrl,
    pendingConnectRequest,
    isConnectModalOpen,
    approveConnectRequest,
    rejectConnectRequest
  } = useTonConnect();
  const { pendingTransactionRequest, isTransactionModalOpen, approveTransactionRequest, rejectTransactionRequest } = useTransactionRequests();
  const { pendingSignDataRequest, isSignDataModalOpen, approveSignDataRequest, rejectSignDataRequest } = useSignDataRequests();
  const { getBalance, error } = useTonWallet();
  const handleRefreshBalance = reactExports.useCallback(async () => {
    setIsRefreshing(true);
    try {
      await getBalance();
    } catch (err) {
      log$6.error("Error refreshing balance:", err);
    } finally {
      setIsRefreshing(false);
    }
  }, [getBalance]);
  const handleCopyAddress = reactExports.useCallback(async () => {
    if (!address) return;
    try {
      await navigator.clipboard.writeText(address);
      setIsCopied(true);
      setTimeout(() => setIsCopied(false), 2e3);
    } catch (err) {
      log$6.error("Failed to copy address:", err);
    }
  }, [address]);
  const handleConnectDApp = reactExports.useCallback(async () => {
    if (!tonConnectUrl.trim()) return;
    setIsConnecting(true);
    try {
      await handleTonConnectUrl(tonConnectUrl.trim());
      setTonConnectUrl("");
    } catch (err) {
      log$6.error("Failed to connect to dApp:", err);
    } finally {
      setIsConnecting(false);
    }
  }, [tonConnectUrl, handleTonConnectUrl]);
  reactExports.useCallback(async () => {
    try {
      await walletKit.disconnect();
      log$6.info("All sessions disconnected");
    } catch (err) {
      log$6.error("Failed to disconnect sessions:", err);
    }
  }, []);
  const formatTonAmount = (amount) => {
    const tonAmount = parseFloat(amount || "0") / 1e9;
    return tonAmount.toFixed(4);
  };
  const formatAddress = (addr) => {
    if (!addr) return "";
    return `${addr.slice(0, 6)}...${addr.slice(-6)}`;
  };
  const formatTimestamp = (timestamp) => {
    return new Date(timestamp).toLocaleString();
  };
  reactExports.useEffect(() => {
    if (!balance) {
      handleRefreshBalance();
    }
  }, [balance, handleRefreshBalance]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Layout, { title: "TON Wallet", showLogout: true, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-medium text-gray-500 uppercase tracking-wide", children: "Balance" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-3xl font-bold text-gray-900 mt-2", children: [
            formatTonAmount(balance || "0"),
            " TON"
          ] })
        ] }),
        address && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 rounded-md p-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-500 uppercase tracking-wide", children: "Address" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: handleCopyAddress,
                className: "inline-flex items-center px-2 py-1 text-xs font-medium text-gray-600 bg-white border border-gray-200 rounded hover:bg-gray-50 hover:text-gray-700 transition-colors",
                title: "Copy address",
                children: isCopied ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "svg",
                    {
                      className: "w-3 h-3 mr-1",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "path",
                        {
                          strokeLinecap: "round",
                          strokeLinejoin: "round",
                          strokeWidth: 2,
                          d: "M5 13l4 4L19 7"
                        }
                      )
                    }
                  ),
                  "Copied!"
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "svg",
                    {
                      className: "w-3 h-3 mr-1",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "path",
                        {
                          strokeLinecap: "round",
                          strokeLinejoin: "round",
                          strokeWidth: 2,
                          d: "M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
                        }
                      )
                    }
                  ),
                  "Copy"
                ] })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-mono text-gray-700 break-all", children: address })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "secondary",
              onClick: handleRefreshBalance,
              isLoading: isRefreshing,
              className: "flex-1",
              children: "Refresh"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => navigate("/send"), className: "flex-1", children: "Send" })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(JettonsCard, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { title: "Connect to dApp", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "tonconnect-url", className: "block text-sm font-medium text-gray-700 mb-2", children: "Paste TON Connect Link" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              id: "tonconnect-url",
              rows: 3,
              className: "w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 resize-none text-black",
              placeholder: "tc://... or ton://... or https://...",
              value: tonConnectUrl,
              onChange: (e) => setTonConnectUrl(e.target.value)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            onClick: handleConnectDApp,
            isLoading: isConnecting,
            disabled: !tonConnectUrl.trim() || isConnecting,
            className: "w-full",
            children: "Connect to dApp"
          }
        )
      ] }) }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-red-50 border border-red-200 rounded-md p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "h-5 w-5 text-red-400", viewBox: "0 0 20 20", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            fillRule: "evenodd",
            d: "M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z",
            clipRule: "evenodd"
          }
        ) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-red-800", children: error }) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DisconnectNotifications, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { title: "Recent Transactions", children: transactions.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-8", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-400 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "svg",
          {
            className: "w-12 h-12 mx-auto",
            fill: "none",
            stroke: "currentColor",
            viewBox: "0 0 24 24",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                strokeLinecap: "round",
                strokeLinejoin: "round",
                strokeWidth: 2,
                d: "M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"
              }
            )
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-500 text-sm", children: "No transactions yet" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-400 text-xs mt-1", children: "Your transaction history will appear here" })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: transactions.slice(0, 10).map((tx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "flex items-center justify-between p-3 bg-gray-50 rounded-lg",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: `w-8 h-8 rounded-full flex items-center justify-center ${tx.type === "send" ? "bg-red-100" : "bg-green-100"}`,
                  children: tx.type === "send" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "svg",
                    {
                      className: "w-4 h-4 text-red-600",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "path",
                        {
                          strokeLinecap: "round",
                          strokeLinejoin: "round",
                          strokeWidth: 2,
                          d: "M7 11l5-5m0 0l5 5m-5-5v12"
                        }
                      )
                    }
                  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "svg",
                    {
                      className: "w-4 h-4 text-green-600",
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "path",
                        {
                          strokeLinecap: "round",
                          strokeLinejoin: "round",
                          strokeWidth: 2,
                          d: "M17 13l-5 5m0 0l-5-5m5 5V6"
                        }
                      )
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-gray-900", children: tx.type === "send" ? "Sent" : "Received" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-500", children: formatAddress(tx.address) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-400", children: formatTimestamp(tx.timestamp) })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-right", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "p",
                {
                  className: `text-sm font-medium ${tx.type === "send" ? "text-red-600" : "text-green-600"}`,
                  children: [
                    tx.type === "send" ? "-" : "+",
                    formatTonAmount(tx.amount),
                    " TON"
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "p",
                {
                  className: `text-xs ${tx.status === "confirmed" ? "text-green-500" : tx.status === "failed" ? "text-red-500" : "text-yellow-500"}`,
                  children: tx.status
                }
              )
            ] })
          ]
        },
        tx.id
      )) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button,
          {
            variant: "secondary",
            onClick: () => navigate("/receive"),
            className: "h-16 flex flex-col items-center justify-center space-y-1",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 4v16m8-8H4" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm", children: "Receive" })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button,
          {
            variant: "secondary",
            onClick: () => navigate("/history"),
            className: "h-16 flex flex-col items-center justify-center space-y-1",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-5 h-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  strokeLinecap: "round",
                  strokeLinejoin: "round",
                  strokeWidth: 2,
                  d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm", children: "History" })
            ]
          }
        )
      ] }),
      false
    ] }),
    pendingConnectRequest && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ConnectRequestModal,
      {
        request: pendingConnectRequest,
        availableWallets: getAvailableWallets(),
        isOpen: isConnectModalOpen,
        onApprove: approveConnectRequest,
        onReject: rejectConnectRequest
      }
    ),
    pendingTransactionRequest && /* @__PURE__ */ jsxRuntimeExports.jsx(
      TransactionRequestModal,
      {
        request: pendingTransactionRequest,
        isOpen: isTransactionModalOpen,
        onApprove: approveTransactionRequest,
        onReject: rejectTransactionRequest
      }
    ),
    pendingSignDataRequest && /* @__PURE__ */ jsxRuntimeExports.jsx(
      SignDataRequestModal,
      {
        request: pendingSignDataRequest,
        isOpen: isSignDataModalOpen,
        onApprove: approveSignDataRequest,
        onReject: rejectSignDataRequest
      }
    )
  ] });
};

const log$5 = createComponentLogger("SendTransaction");
const SendTransaction = () => {
  const [recipient, setRecipient] = reactExports.useState("");
  const [amount, setAmount] = reactExports.useState("");
  const [error, setError] = reactExports.useState("");
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [selectedToken, setSelectedToken] = reactExports.useState({ type: "TON" });
  const [showTokenSelector, setShowTokenSelector] = reactExports.useState(false);
  const navigate = useNavigate();
  const { balance } = useWallet();
  const { sendTransaction } = useTonWallet();
  const { userJettons, isLoadingJettons, loadUserJettons, formatJettonAmount } = useJettons();
  reactExports.useEffect(() => {
    if (userJettons.length === 0 && !isLoadingJettons) {
      loadUserJettons();
    }
  }, [userJettons.length, isLoadingJettons, loadUserJettons]);
  const formatTonAmount = (amount2) => {
    const tonAmount = parseFloat(amount2 || "0") / 1e9;
    return tonAmount.toFixed(4);
  };
  const validateAddress = (address) => {
    return address.length > 10 && (address.startsWith("EQ") || address.startsWith("UQ"));
  };
  const getCurrentTokenBalance = () => {
    if (selectedToken.type === "TON") {
      return formatTonAmount(balance || "0");
    } else if (selectedToken.data) {
      return formatJettonAmount(selectedToken.data.balance, selectedToken.data.decimals);
    }
    return "0";
  };
  const getCurrentTokenSymbol = () => {
    if (selectedToken.type === "TON") {
      return "TON";
    } else if (selectedToken.data) {
      return selectedToken.data.symbol;
    }
    return "";
  };
  const getCurrentTokenName = () => {
    if (selectedToken.type === "TON") {
      return "TON";
    } else if (selectedToken.data) {
      return selectedToken.data.name || selectedToken.data.symbol;
    }
    return "";
  };
  const handleSend = async (e) => {
    e.preventDefault();
    setError("");
    setIsLoading(true);
    try {
      if (!validateAddress(recipient)) {
        throw new Error("Invalid recipient address");
      }
      const inputAmount = parseFloat(amount);
      if (inputAmount <= 0) {
        throw new Error("Amount must be greater than 0");
      }
      const currentBalance = parseFloat(getCurrentTokenBalance());
      if (inputAmount > currentBalance) {
        throw new Error("Insufficient balance");
      }
      if (selectedToken.type === "TON") {
        const nanoTonAmount = Math.floor(inputAmount * 1e9).toString();
        await sendTransaction(recipient, nanoTonAmount);
      } else if (selectedToken.data) {
        log$5.info("Sending jetton", {
          jettonAddress: selectedToken.data.address,
          amount: inputAmount,
          recipient
        });
        const currentWallet = useWallet().currentWallet;
        const fromAddress = currentWallet.getAddress();
        if (!fromAddress) {
          throw new Error("Wallet address not available");
        }
        throw new Error(
          "Jetton transfers are not yet fully implemented in this demo. Please use the wallet kit's transaction request flow."
        );
      }
      navigate("/wallet", {
        state: { message: `${getCurrentTokenSymbol()} sent successfully!` }
      });
    } catch (err) {
      log$5.error("Send transaction error:", err);
      setError(err instanceof Error ? err.message : "Failed to send transaction");
    } finally {
      setIsLoading(false);
    }
  };
  const handleMaxAmount = () => {
    const currentBalance = parseFloat(getCurrentTokenBalance());
    if (selectedToken.type === "TON") {
      const maxAmount = currentBalance - 0.01;
      if (maxAmount > 0) {
        setAmount(maxAmount.toString());
      }
    } else {
      if (currentBalance > 0) {
        setAmount(currentBalance.toString());
      }
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, { title: `Send ${getCurrentTokenSymbol()}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", size: "sm", onClick: () => navigate("/wallet"), children: " Back" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-xl font-bold text-gray-900", children: [
        "Send ",
        getCurrentTokenName()
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { title: "Select Token", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: () => setShowTokenSelector(!showTokenSelector),
          className: "w-full flex items-center justify-between p-3 border border-gray-300 rounded-lg hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-8 h-8 bg-gray-100 rounded-full flex items-center justify-center", children: selectedToken.type === "TON" ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-bold text-blue-600", children: "T" }) : selectedToken.data?.image ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: selectedToken.data.image,
                  alt: selectedToken.data.name,
                  className: "w-6 h-6 rounded-full object-cover"
                }
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs font-bold text-gray-600", children: selectedToken.data?.symbol.slice(0, 2) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-left", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-gray-900", children: getCurrentTokenName() }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-gray-500", children: [
                  "Balance: ",
                  getCurrentTokenBalance()
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                className: `w-5 h-5 text-gray-400 transition-transform ${showTokenSelector ? "rotate-180" : ""}`,
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" })
              }
            )
          ]
        }
      ),
      showTokenSelector && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border border-gray-200 rounded-lg divide-y divide-gray-200", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => {
              setSelectedToken({ type: "TON" });
              setShowTokenSelector(false);
              setAmount("");
            },
            className: `w-full flex items-center justify-between p-3 hover:bg-gray-50 ${selectedToken.type === "TON" ? "bg-blue-50" : ""}`,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-8 h-8 bg-blue-100 rounded-full flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-bold text-blue-600", children: "T" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-left", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-gray-900", children: "TON" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-500", children: "The Open Network" })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-right", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-gray-900", children: formatTonAmount(balance || "0") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-500", children: "TON" })
              ] })
            ]
          }
        ),
        userJettons.map((jetton) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => {
              setSelectedToken({ type: "JETTON", data: jetton });
              setShowTokenSelector(false);
              setAmount("");
            },
            className: `w-full flex items-center justify-between p-3 hover:bg-gray-50 ${selectedToken.type === "JETTON" && selectedToken.data?.address === jetton.address ? "bg-blue-50" : ""}`,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-8 h-8 bg-gray-100 rounded-full flex items-center justify-center", children: jetton.image ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: jetton.image,
                    alt: jetton.name,
                    className: "w-6 h-6 rounded-full object-cover"
                  }
                ) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs font-bold text-gray-600", children: jetton.symbol.slice(0, 2) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-left", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-gray-900", children: jetton.name || jetton.symbol }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-gray-500", children: [
                    jetton.symbol,
                    jetton.verification?.verified && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-1 text-green-600", children: "" })
                  ] })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-right", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-gray-900", children: formatJettonAmount(jetton.balance, jetton.decimals) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-500", children: jetton.symbol })
              ] })
            ]
          },
          jetton.address
        )),
        userJettons.length === 0 && !isLoadingJettons && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 text-center text-gray-500 text-sm", children: "No jettons found" }),
        isLoadingJettons && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 text-center text-gray-500 text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600 mx-auto mb-2" }),
          "Loading tokens..."
        ] })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500", children: "Available Balance" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-2xl font-bold text-gray-900", children: [
        getCurrentTokenBalance(),
        " ",
        getCurrentTokenSymbol()
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSend, className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input,
        {
          label: "Recipient Address",
          value: recipient,
          onChange: (e) => setRecipient(e.target.value),
          placeholder: "EQxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
          required: true,
          helperText: "Enter the recipient's TON address"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            type: "number",
            step: selectedToken.type === "TON" ? "0.0001" : "0.000001",
            min: "0",
            label: `Amount (${getCurrentTokenSymbol()})`,
            value: amount,
            onChange: (e) => setAmount(e.target.value),
            placeholder: "0.0000",
            required: true,
            helperText: selectedToken.type === "TON" ? "Minimum transaction: 0.0001 TON" : `Enter amount in ${getCurrentTokenSymbol()} units`
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            type: "button",
            variant: "secondary",
            size: "sm",
            onClick: handleMaxAmount,
            className: "mt-2",
            children: "Use Max"
          }
        )
      ] }),
      recipient && amount && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 rounded-md p-4 space-y-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-900", children: "Transaction Summary" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm space-y-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-500", children: "To:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-mono", children: [
              recipient.slice(0, 6),
              "...",
              recipient.slice(-6)
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-500", children: "Amount:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              amount,
              " ",
              getCurrentTokenSymbol()
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-500", children: selectedToken.type === "TON" ? "Network Fee:" : "Jetton Fee:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "~0.01 TON" })
          ] }),
          selectedToken.type === "JETTON" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-500", children: "Forward Fee:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "~0.01 TON" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "my-2" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between font-medium", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "You'll send:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              amount,
              " ",
              getCurrentTokenSymbol()
            ] })
          ] }),
          selectedToken.type === "JETTON" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between font-medium", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "TON fee deducted:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "~0.02 TON" })
          ] }),
          selectedToken.type === "TON" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between font-medium", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Total deducted:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              (parseFloat(amount) + 0.01).toFixed(4),
              " TON"
            ] })
          ] })
        ] }),
        selectedToken.type === "JETTON" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 p-2 bg-blue-50 border border-blue-200 rounded text-xs text-blue-700", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-medium", children: "Note about Jetton transfers:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Jetton transfers require TON for transaction fees. Make sure you have enough TON balance for the fees." })
        ] })
      ] }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-600 text-sm text-center", children: error }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          type: "submit",
          isLoading,
          disabled: !recipient || !amount || parseFloat(amount) <= 0,
          className: "w-full",
          children: isLoading ? `Sending ${getCurrentTokenSymbol()}...` : `Send ${getCurrentTokenSymbol()}`
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-yellow-50 border border-yellow-200 rounded-md p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "h-5 w-5 text-yellow-400", viewBox: "0 0 20 20", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fillRule: "evenodd",
          d: "M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z",
          clipRule: "evenodd"
        }
      ) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-yellow-800", children: "Double-check the recipient address. Blockchain transactions are irreversible." }) })
    ] }) })
  ] }) });
};

const AppRouter = () => {
  const isPasswordSet = useStore((state) => state.auth.isPasswordSet);
  const isUnlocked = useStore((state) => state.auth.isUnlocked);
  const { hasWallet } = useWallet();
  const getInitialRoute = () => {
    if (!isPasswordSet) return "/setup-password";
    if (!isUnlocked) return "/unlock";
    if (!hasWallet) return "/setup-wallet";
    return "/wallet";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/setup-password", element: /* @__PURE__ */ jsxRuntimeExports.jsx(SetupPassword, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/unlock", element: /* @__PURE__ */ jsxRuntimeExports.jsx(UnlockWallet, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Route,
      {
        path: "/setup-wallet",
        element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SetupWallet, {}) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Route,
      {
        path: "/wallet",
        element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { requiresWallet: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(WalletDashboard, {}) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Route,
      {
        path: "/send",
        element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { requiresWallet: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SendTransaction, {}) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: getInitialRoute(), replace: true }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "*", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/", replace: true }) })
  ] }) });
};

const Button = ({
  variant = "primary",
  size = "md",
  isLoading = false,
  children,
  disabled,
  className = "",
  ...props
}) => {
  const baseClasses = "font-medium rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center";
  const variantClasses = {
    primary: "bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500",
    secondary: "bg-gray-200 text-gray-900 hover:bg-gray-300 focus:ring-gray-500",
    danger: "bg-red-600 text-white hover:bg-red-700 focus:ring-red-500"
  };
  const sizeClasses = {
    sm: "px-3 py-2 text-sm",
    md: "px-4 py-2 text-base",
    lg: "px-6 py-3 text-lg"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      className: `${baseClasses} ${variantClasses[variant]} ${sizeClasses[size]} ${className}`,
      disabled: disabled || isLoading,
      ...props,
      children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "animate-spin -ml-1 mr-2 h-4 w-4", fill: "none", viewBox: "0 0 24 24", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              className: "opacity-75",
              fill: "currentColor",
              d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            }
          )
        ] }),
        "Loading..."
      ] }) : children
    }
  );
};

const Card = ({ children, className = "", title }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `bg-white rounded-lg shadow-md border border-gray-200 ${className}`, children: [
    title && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-6 py-4 border-b border-gray-200", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-medium text-gray-900", children: title }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-6", children })
  ] });
};

const log$4 = createComponentLogger("ConnectRequestModal");
const ConnectRequestModal = ({
  request,
  availableWallets,
  isOpen,
  onApprove,
  onReject
}) => {
  const [selectedWallet, setSelectedWallet] = reactExports.useState(availableWallets[0] || null);
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const handleApprove = async () => {
    if (!selectedWallet) return;
    setIsLoading(true);
    try {
      await onApprove(selectedWallet);
    } catch (error) {
      log$4.error("Failed to approve connection:", error);
    } finally {
      setIsLoading(false);
    }
  };
  const handleReject = () => {
    onReject("User rejected the connection");
  };
  const formatAddress = (address) => {
    if (!address) return "";
    return `${address.slice(0, 8)}...${address.slice(-8)}`;
  };
  if (!isOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white rounded-lg max-w-md w-full max-h-[90vh] overflow-y-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-bold text-gray-900", children: "Connect Request" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 text-sm mt-1", children: "A dApp wants to connect to your wallet" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border rounded-lg p-4 bg-gray-50", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-4", children: [
      request.preview.manifest?.iconUrl ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: request.preview.manifest.iconUrl,
          alt: request.dAppName,
          className: "w-12 h-12 rounded-lg object-cover border",
          onError: (e) => {
            e.currentTarget.style.display = "none";
          }
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-12 h-12 rounded-lg bg-gray-200 flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-6 h-6 text-gray-400", fill: "currentColor", viewBox: "0 0 20 20", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fillRule: "evenodd",
          d: "M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z",
          clipRule: "evenodd"
        }
      ) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 min-w-0", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-gray-900 truncate", children: request.dAppName }),
        request.preview.manifest?.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600 mt-1 line-clamp-2", children: request.preview.manifest.description }),
        request.manifestUrl && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-500 mt-1 truncate", children: new URL(request.manifestUrl).hostname })
      ] })
    ] }) }),
    (request.preview.permissions || []).length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-900 mb-3", children: "Requested Permissions:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: request.preview.permissions?.map((permission, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border rounded-lg p-3 bg-gray-50", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start space-x-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-2 h-2 bg-blue-500 rounded-full mt-2 flex-shrink-0" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 min-w-0", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h5", { className: "text-sm font-medium text-gray-900 mb-1", children: permission.title }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-600 leading-relaxed", children: permission.description })
        ] })
      ] }) }, index)) })
    ] }),
    availableWallets.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-900 mb-3", children: "Select Wallet:" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: availableWallets.map((wallet, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "label",
        {
          className: `flex items-center p-3 border rounded-lg cursor-pointer transition-colors ${selectedWallet === wallet ? "border-blue-500 bg-blue-50" : "border-gray-200 hover:border-gray-300"}`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "radio",
                name: "wallet",
                value: index,
                checked: selectedWallet === wallet,
                onChange: () => setSelectedWallet(wallet),
                className: "sr-only"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3 flex-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-8 h-8 bg-gradient-to-br from-blue-500 to-purple-600 rounded-full flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-white text-xs font-bold", children: index + 1 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm font-medium text-gray-900", children: [
                  "Wallet ",
                  index + 1
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-500", children: formatAddress(wallet.getAddress()) })
              ] })
            ] }),
            selectedWallet === wallet && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-5 h-5 bg-blue-500 rounded-full flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                className: "w-3 h-3 text-white",
                fill: "currentColor",
                viewBox: "0 0 20 20",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    fillRule: "evenodd",
                    d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                    clipRule: "evenodd"
                  }
                )
              }
            ) })
          ]
        },
        index
      )) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-yellow-50 border border-yellow-200 rounded-lg p-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "h-5 w-5 text-yellow-400", viewBox: "0 0 20 20", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fillRule: "evenodd",
          d: "M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z",
          clipRule: "evenodd"
        }
      ) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-yellow-800", children: "Only connect to trusted applications. This will give the dApp access to your wallet address and allow it to request transactions." }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: handleReject, disabled: isLoading, className: "flex-1", children: "Reject" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          onClick: handleApprove,
          isLoading,
          disabled: !selectedWallet || isLoading,
          className: "flex-1",
          children: "Connect"
        }
      )
    ] })
  ] }) }) }) });
};

const DisconnectNotifications = ({ className = "" }) => {
  const { disconnectedSessions, clearDisconnectNotifications } = useDisconnectEvents();
  if (!disconnectedSessions || disconnectedSessions.length === 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `bg-yellow-50 border border-yellow-200 rounded-lg p-4 ${className}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start justify-between", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-medium text-yellow-800", children: "Session Disconnected" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2 space-y-2", children: disconnectedSessions.map((session) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "text-sm text-yellow-700",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "font-mono text-xs", children: [
              session.walletAddress.slice(0, 8),
              "...",
              session.walletAddress.slice(-8)
            ] }),
            session.reason && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-yellow-600 mt-1", children: [
              "Reason: ",
              session.reason
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-yellow-500", children: new Date(session.timestamp).toLocaleTimeString() })
          ]
        },
        `${session.walletAddress}-${session.timestamp}`
      )) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        variant: "secondary",
        size: "sm",
        onClick: clearDisconnectNotifications,
        className: "ml-4 text-yellow-800 border-yellow-300 hover:bg-yellow-100",
        children: "Dismiss"
      }
    )
  ] }) });
};

const ImportWallet = ({ onImport, onBack, isLoading, error }) => {
  const [words, setWords] = reactExports.useState(Array(24).fill(""));
  const [activeInput, setActiveInput] = reactExports.useState(0);
  const [pasteMode, setPasteMode] = reactExports.useState(false);
  const [pasteText, setPasteText] = reactExports.useState("");
  const inputRefs = reactExports.useRef([]);
  reactExports.useEffect(() => {
    inputRefs.current = inputRefs.current.slice(0, 24);
  }, []);
  const handleWordChange = (index, value) => {
    const newWords = [...words];
    const cleanValue = value.toLowerCase().replace(/[^a-z]/g, "");
    newWords[index] = cleanValue;
    setWords(newWords);
    if (cleanValue && index < 23) {
      setTimeout(() => {
        inputRefs.current[index + 1]?.focus();
      }, 0);
    }
  };
  const handleKeyDown = (index, event) => {
    if (event.key === "Backspace" && !words[index] && index > 0) {
      inputRefs.current[index - 1]?.focus();
    } else if (event.key === "Enter") {
      event.preventDefault();
      if (index < 23) {
        inputRefs.current[index + 1]?.focus();
      } else {
        handleSubmit();
      }
    } else if (event.key === "ArrowLeft" && index > 0) {
      inputRefs.current[index - 1]?.focus();
    } else if (event.key === "ArrowRight" && index < 23) {
      inputRefs.current[index + 1]?.focus();
    }
  };
  const handlePaste = (event) => {
    event.preventDefault();
    const pastedText = event.clipboardData.getData("text");
    processPastedText(pastedText);
  };
  const processPastedText = (text) => {
    const pastedWords = text.trim().split(/\s+/).map((word) => word.toLowerCase().replace(/[^a-z]/g, "")).filter((word) => word.length > 0);
    if (pastedWords.length >= 12 && pastedWords.length <= 24) {
      const newWords = Array(24).fill("");
      pastedWords.forEach((word, index) => {
        if (index < 24) {
          newWords[index] = word;
        }
      });
      setWords(newWords);
      const lastFilledIndex = Math.min(pastedWords.length - 1, 23);
      setTimeout(() => {
        inputRefs.current[lastFilledIndex]?.focus();
      }, 0);
    }
  };
  const handlePasteModeSubmit = () => {
    processPastedText(pasteText);
    setPasteMode(false);
    setPasteText("");
  };
  const handleSubmit = () => {
    const nonEmptyWords = words.filter((word) => word.trim() !== "");
    if (nonEmptyWords.length >= 12) {
      onImport(nonEmptyWords);
    }
  };
  const clearAll = () => {
    setWords(Array(24).fill(""));
    inputRefs.current[0]?.focus();
  };
  const isValid = words.filter((word) => word.trim() !== "").length >= 12;
  const filledCount = words.filter((word) => word.trim() !== "").length;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold text-gray-900", children: "Import Wallet" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-sm text-gray-600", children: "Enter your 12 or 24-word recovery phrase to restore your TON wallet." })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-center space-x-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => setPasteMode(false),
          className: `px-4 py-2 rounded-md text-sm font-medium transition-colors ${!pasteMode ? "bg-blue-100 text-blue-800 border border-blue-200" : "bg-gray-100 text-gray-600 hover:bg-gray-200"}`,
          children: "Individual Words"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => setPasteMode(true),
          className: `px-4 py-2 rounded-md text-sm font-medium transition-colors ${pasteMode ? "bg-blue-100 text-blue-800 border border-blue-200" : "bg-gray-100 text-gray-600 hover:bg-gray-200"}`,
          children: "Paste All"
        }
      )
    ] }),
    !pasteMode ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm text-gray-500", children: [
        filledCount,
        " of 24 words entered"
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-3 gap-2 sm:grid-cols-4 md:grid-cols-6", children: words.map((word, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            ref: (el) => {
              inputRefs.current[index] = el;
            },
            type: "text",
            value: word,
            onChange: (e) => handleWordChange(index, e.target.value),
            onKeyDown: (e) => handleKeyDown(index, e),
            onPaste: handlePaste,
            onFocus: () => setActiveInput(index),
            placeholder: `${index + 1}`,
            className: `w-full px-2 py-2 text-sm border rounded-md text-center font-mono transition-colors ${word ? "border-green-300 bg-green-50 text-green-800" : activeInput === index ? "border-blue-300 bg-blue-50" : "border-gray-300 bg-white"} focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500`,
            autoComplete: "off",
            spellCheck: false
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute -top-1 left-1 text-xs text-gray-400 bg-white px-1", children: index + 1 })
      ] }, index)) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-center space-x-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: clearAll,
            className: "text-sm text-gray-500 hover:text-gray-700 underline",
            type: "button",
            children: "Clear All"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => navigator.clipboard?.readText().then(processPastedText),
            className: "text-sm text-blue-600 hover:text-blue-800 underline",
            type: "button",
            children: "Paste from Clipboard"
          }
        )
      ] })
    ] }) : (
      /* Paste Mode */
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-2", children: "Recovery Phrase" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              value: pasteText,
              onChange: (e) => setPasteText(e.target.value),
              placeholder: "Paste your entire recovery phrase here...",
              rows: 4,
              className: "w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 font-mono text-sm"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1 text-xs text-gray-500", children: "Separate words with spaces. 12 or 24 words supported." })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handlePasteModeSubmit, disabled: !pasteText.trim(), className: "w-full", children: "Process Words" })
      ] })
    ),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-600 text-sm text-center bg-red-50 p-3 rounded-md", children: error }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: onBack, className: "flex-1", children: "Back" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          onClick: handleSubmit,
          isLoading,
          disabled: !isValid || isLoading,
          className: "flex-1",
          children: "Import Wallet"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center text-xs text-gray-500", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Make sure your recovery phrase is correct. Wrong phrases cannot be recovered." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1", children: "Supports both 12-word (legacy) and 24-word recovery phrases." })
    ] })
  ] });
};

const Input = ({ label, error, helperText, className = "", ...props }) => {
  const inputClasses = `
    w-full px-3 py-2 border rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500
    ${error ? "border-red-300 focus:border-red-500 focus:ring-red-500" : "border-gray-300"}
    ${className}
    text-black
  `;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-1", children: [
    label && /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 text-left", children: label }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("input", { className: inputClasses.trim(), ...props }),
    error && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-red-600", children: error }),
    helperText && !error && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500", children: helperText })
  ] });
};

const JettonRow = ({
  jetton,
  formatJettonAmount,
  formatAddress = (address) => `${address.slice(0, 4)}...${address.slice(-4)}`,
  onClick,
  className = ""
}) => {
  const handleImageError = (e) => {
    const target = e.target;
    target.style.display = "none";
    const parent = target.parentElement;
    if (parent) {
      parent.innerHTML = jetton.symbol.slice(0, 2).toUpperCase();
      parent.className = parent.className.replace("bg-gray-100", "bg-gradient-to-br from-blue-500 to-purple-600");
      parent.className += " text-xs font-bold text-white flex items-center justify-center";
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `group flex items-center p-4 border border-gray-200 rounded-xl 
                hover:border-gray-300 hover:shadow-md transition-all duration-200 cursor-pointer
                bg-white hover:bg-gray-50/50 min-w-0 select-none ${className}`,
      onClick,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3 flex-1 min-w-0", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex-shrink-0 select-none", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "w-12 h-12 bg-gray-100 rounded-full flex items-center justify-center overflow-hidden\n                        ring-2 ring-gray-100 group-hover:ring-gray-200 transition-all duration-200",
                children: jetton.image ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: jetton.image,
                    alt: jetton.name,
                    className: "w-10 h-10 rounded-full object-cover",
                    onError: handleImageError
                  }
                ) : jetton.image_data ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: `${atob(jetton.image_data)}`,
                    alt: jetton.name,
                    className: "w-10 h-10 rounded-full object-cover",
                    onError: handleImageError
                  }
                ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: "w-10 h-10 bg-gradient-to-br from-blue-500 to-purple-600 rounded-full \n                                flex items-center justify-center",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-bold text-white", children: jetton.symbol.slice(0, 2).toUpperCase() })
                  }
                )
              }
            ),
            jetton.verification?.verified && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "absolute -bottom-1 -right-1 w-5 h-5 bg-green-500 rounded-full \n                            flex items-center justify-center ring-2 ring-white select-none",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-3 h-3 text-white", fill: "currentColor", viewBox: "0 0 20 20", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    fillRule: "evenodd",
                    d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
                    clipRule: "evenodd"
                  }
                ) })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 min-w-0 overflow-hidden", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2 min-w-0", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-left text-base font-semibold text-gray-900 truncate", children: jetton.name || jetton.symbol }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs font-medium text-gray-500 bg-gray-100 px-2 py-0.5 rounded-md flex-shrink-0 select-none", children: jetton.symbol.length > 6 ? `${jetton.symbol.slice(0, 6)}...` : jetton.symbol })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-left text-sm text-gray-500 font-mono truncate", children: formatAddress(jetton.address) }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-right flex-shrink-0 ml-4 min-w-0 max-w-[140px] select-none", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-base font-semibold text-gray-900 truncate", children: formatJettonAmount(jetton.balance, jetton.decimals) }),
            jetton.usdValue && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-500 font-medium truncate", children: [
              " $",
              parseFloat(jetton.usdValue).toLocaleString("en-US", {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
              })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "opacity-0 group-hover:opacity-100 transition-opacity duration-200 mt-1 select-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "svg",
            {
              className: "w-4 h-4 text-gray-400 ml-auto",
              fill: "none",
              stroke: "currentColor",
              viewBox: "0 0 24 24",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M9 5l7 7-7 7" })
            }
          ) })
        ] })
      ]
    }
  );
};

const log$3 = createComponentLogger("JettonsCard");
const JettonsCard = ({ className = "" }) => {
  const { userJettons, isLoadingJettons, error, loadUserJettons, formatJettonAmount } = useJettons();
  reactExports.useEffect(() => {
    log$3.info("userJettons", userJettons);
    log$3.info("isLoadingJettons", isLoadingJettons);
    if (userJettons.length === 0 && !isLoadingJettons) {
      log$3.info("Loading user jettons on mount");
      loadUserJettons();
    }
  }, [userJettons.length, isLoadingJettons, loadUserJettons]);
  const handleViewAll = () => {
  };
  const formatAddress = (address) => {
    return `${address.slice(0, 4)}...${address.slice(-4)}`;
  };
  const topJettons = userJettons.slice(0, 3);
  const totalJettons = userJettons.length;
  const totalValue = userJettons.reduce((sum, jetton) => {
    return sum + (jetton.usdValue ? parseFloat(jetton.usdValue) : 0);
  }, 0);
  if (error) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { title: "Jettons", className, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-400 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-8 h-8 mx-auto", fill: "currentColor", viewBox: "0 0 20 20", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fillRule: "evenodd",
          d: "M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z",
          clipRule: "evenodd"
        }
      ) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-red-600 mb-3", children: "Failed to load jettons" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { size: "sm", variant: "secondary", onClick: () => loadUserJettons(), children: "Try Again" })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { title: "Jettons", className, children: isLoadingJettons ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center py-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-3 text-sm text-gray-600", children: "Loading jettons..." })
  ] }) : totalJettons === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center py-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-400 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-10 h-10 mx-auto", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        strokeWidth: 2,
        d: "M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1"
      }
    ) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500", children: "No jettons yet" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-400 mt-1", children: "Your token balances will appear here" })
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-4 bg-gradient-to-r from-blue-50 to-purple-50 rounded-xl border border-blue-100", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-base font-semibold text-gray-900", children: [
          totalJettons,
          " ",
          totalJettons === 1 ? "Token" : "Tokens"
        ] }),
        totalValue > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-600 font-medium", children: [
          " $",
          totalValue.toLocaleString("en-US", {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
          }),
          " ",
          "USD"
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { size: "sm", variant: "secondary", onClick: handleViewAll, children: "View All" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: topJettons.map((jetton) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      JettonRow,
      {
        jetton,
        formatJettonAmount,
        formatAddress,
        onClick: () => {
          log$3.info("Jetton clicked:", jetton.name || jetton.symbol);
        }
      },
      jetton.address
    )) }),
    totalJettons > 3 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center pt-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-gray-500", children: [
      "Showing 3 of ",
      totalJettons,
      " tokens"
    ] }) })
  ] }) });
};

createComponentLogger("JettonsList");

const MnemonicDisplay = ({
  mnemonic,
  showWarning = false,
  warningText = "Keep this phrase safe and secret. Anyone with access to it can control your wallet.",
  warningType = "yellow"
}) => {
  const [copyFeedback, setCopyFeedback] = reactExports.useState("");
  const handleCopyMnemonic = async () => {
    try {
      const mnemonicString = mnemonic.join(" ");
      await navigator.clipboard.writeText(mnemonicString);
      setCopyFeedback("Copied to clipboard!");
      setTimeout(() => setCopyFeedback(""), 2e3);
    } catch (_) {
      setCopyFeedback("Failed to copy");
      setTimeout(() => setCopyFeedback(""), 2e3);
    }
  };
  const warningStyles = warningType === "yellow" ? {
    bgColor: "bg-yellow-50",
    borderColor: "border-yellow-200",
    iconColor: "text-yellow-400",
    textColor: "text-yellow-800"
  } : {
    bgColor: "bg-red-50",
    borderColor: "border-red-200",
    iconColor: "text-red-400",
    textColor: "text-red-800"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
    showWarning && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${warningStyles.bgColor} ${warningStyles.borderColor} rounded-md p-4`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "svg",
        {
          className: `h-5 w-5 ${warningStyles.iconColor}`,
          viewBox: "0 0 20 20",
          fill: "currentColor",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              fillRule: "evenodd",
              d: "M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z",
              clipRule: "evenodd"
            }
          )
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: `text-sm ${warningStyles.textColor}`, children: [
        warningType === "red" && /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Warning: " }),
        warningText
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-4 gap-2", children: mnemonic.map((word, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "bg-gray-50 border border-gray-200 rounded-md p-2 text-center text-sm font-mono",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-500 text-xs", children: [
            index + 1,
            "."
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-medium text-xs text-gray-900", children: word })
        ]
      },
      index
    )) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: handleCopyMnemonic,
        className: "flex items-center space-x-2 px-4 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-md transition-colors border border-gray-300",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              strokeLinecap: "round",
              strokeLinejoin: "round",
              strokeWidth: 2,
              d: "M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Copy Recovery Phrase" })
        ]
      }
    ) }),
    copyFeedback && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `text-center text-sm ${copyFeedback.includes("Failed") ? "text-red-600" : "text-green-600"}`,
        children: copyFeedback
      }
    )
  ] });
};

const log$2 = createComponentLogger("Layout");
const Layout = ({ children, title = "TON Wallet", showLogout = false }) => {
  const { lock, reset } = useAuth();
  const { getDecryptedMnemonic } = useWallet();
  const [isDropdownOpen, setIsDropdownOpen] = reactExports.useState(false);
  const [showMnemonicModal, setShowMnemonicModal] = reactExports.useState(false);
  const [mnemonic, setMnemonic] = reactExports.useState([]);
  const [isLoadingMnemonic, setIsLoadingMnemonic] = reactExports.useState(false);
  const [mnemonicError, setMnemonicError] = reactExports.useState("");
  const dropdownRef = reactExports.useRef(null);
  const handleLockWallet = () => {
    lock();
    setIsDropdownOpen(false);
  };
  const handleDeleteWallet = () => {
    if (window.confirm("Are you sure you want to delete your wallet? This action cannot be undone.")) {
      reset();
      setIsDropdownOpen(false);
    }
  };
  const handleViewRecoveryPhrase = async () => {
    setIsDropdownOpen(false);
    setIsLoadingMnemonic(true);
    setMnemonicError("");
    try {
      const decryptedMnemonic = await getDecryptedMnemonic();
      if (decryptedMnemonic) {
        setMnemonic(decryptedMnemonic);
        setShowMnemonicModal(true);
      } else {
        setMnemonicError("Unable to retrieve recovery phrase. Please ensure you are logged in.");
      }
    } catch (error) {
      setMnemonicError("Failed to decrypt recovery phrase. Please try again.");
      log$2.error("Error retrieving mnemonic:", error);
    } finally {
      setIsLoadingMnemonic(false);
    }
  };
  const handleCloseMnemonicModal = () => {
    setShowMnemonicModal(false);
    setMnemonic([]);
    setMnemonicError("");
  };
  reactExports.useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setIsDropdownOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, []);
  reactExports.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape" && showMnemonicModal) {
        handleCloseMnemonicModal();
      }
    };
    if (showMnemonicModal) {
      document.addEventListener("keydown", handleKeyDown);
      return () => {
        document.removeEventListener("keydown", handleKeyDown);
      };
    }
  }, [showMnemonicModal]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen bg-gray-100", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("header", { className: "bg-white shadow-sm border-b border-gray-200", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sm:w-md md:w-lg mx-auto px-4 py-2 flex justify-between items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-lg font-bold text-gray-900", children: title }),
      showLogout && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", ref: dropdownRef, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setIsDropdownOpen(!isDropdownOpen),
            className: "p-1 rounded-md hover:bg-gray-100 transition-colors",
            "aria-label": "Wallet menu",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                className: "w-5 h-5 text-gray-600",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    strokeLinecap: "round",
                    strokeLinejoin: "round",
                    strokeWidth: 2,
                    d: "M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z"
                  }
                )
              }
            )
          }
        ),
        isDropdownOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute right-0 mt-1 w-56 bg-white rounded-md shadow-lg border border-gray-200 z-10", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "py-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: handleViewRecoveryPhrase,
              disabled: isLoadingMnemonic,
              className: "w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 flex items-center space-x-2 disabled:opacity-50 disabled:cursor-not-allowed",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "svg",
                  {
                    className: "w-4 h-4",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "path",
                        {
                          strokeLinecap: "round",
                          strokeLinejoin: "round",
                          strokeWidth: 2,
                          d: "M15 12a3 3 0 11-6 0 3 3 0 016 0z"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "path",
                        {
                          strokeLinecap: "round",
                          strokeLinejoin: "round",
                          strokeWidth: 2,
                          d: "M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: isLoadingMnemonic ? "Loading..." : "View Recovery Phrase" })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: handleLockWallet,
              className: "w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 flex items-center space-x-2",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "svg",
                  {
                    className: "w-4 h-4",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "path",
                      {
                        strokeLinecap: "round",
                        strokeLinejoin: "round",
                        strokeWidth: 2,
                        d: "M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Lock Wallet" })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: handleDeleteWallet,
              className: "w-full text-left px-4 py-2 text-sm text-red-600 hover:bg-red-50 flex items-center space-x-2",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "svg",
                  {
                    className: "w-4 h-4",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "path",
                      {
                        strokeLinecap: "round",
                        strokeLinejoin: "round",
                        strokeWidth: 2,
                        d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Delete Wallet" })
              ]
            }
          )
        ] }) })
      ] })
    ] }) }),
    showMnemonicModal && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white rounded-lg max-w-md w-full max-h-[90vh] overflow-y-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-bold text-gray-900", children: "Your Recovery Phrase" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: handleCloseMnemonicModal,
            className: "text-gray-400 hover:text-gray-600",
            "aria-label": "Close",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                strokeLinecap: "round",
                strokeLinejoin: "round",
                strokeWidth: 2,
                d: "M6 18L18 6M6 6l12 12"
              }
            ) })
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
        mnemonic.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          MnemonicDisplay,
          {
            mnemonic,
            showWarning: true,
            warningType: "red",
            warningText: "Never share your recovery phrase with anyone. Anyone with access to these words can control your wallet."
          }
        ),
        mnemonicError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-600 text-sm text-center bg-red-50 p-3 rounded-md", children: mnemonicError }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: handleCloseMnemonicModal,
            className: "w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors",
            children: "Close"
          }
        ) })
      ] })
    ] }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: "max-w-md mx-auto px-4 py-6", children })
  ] });
};

const log$1 = createComponentLogger("SignDataRequestModal");
const SignDataRequestModal = ({ request, isOpen, onApprove, onReject }) => {
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const handleApprove = async () => {
    setIsLoading(true);
    try {
      await onApprove();
    } catch (error) {
      log$1.error("Failed to approve sign data request:", error);
    } finally {
      setIsLoading(false);
    }
  };
  const handleReject = () => {
    onReject("User rejected the sign data request");
  };
  const formatAddress = (address) => {
    if (!address) return "";
    return `${address.slice(0, 8)}...${address.slice(-8)}`;
  };
  const renderDataPreview = () => {
    const { preview } = request;
    switch (preview.kind) {
      case "text":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border rounded-lg p-3 bg-blue-50", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-blue-900 mb-2", children: "Text Message" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-blue-800 break-words", children: preview.content })
        ] });
      case "binary":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border rounded-lg p-3 bg-green-50", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-green-900 mb-2", children: "Binary Data" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-green-800", children: [
            "Content: ",
            preview.content
          ] }) })
        ] });
      case "cell":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border rounded-lg p-3 bg-purple-50", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-purple-900 mb-2", children: "TON Cell Data" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-purple-800", children: [
              "Content: ",
              preview.content
            ] }),
            preview.schema && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-purple-800", children: [
              "Schema: ",
              preview.schema
            ] }),
            preview.parsed && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-purple-800 mb-1", children: "Parsed Data:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "text-xs text-purple-700 overflow-x-auto whitespace-pre-wrap", children: JSON.stringify(preview.parsed, null, 2) })
            ] })
          ] })
        ] });
      default:
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border rounded-lg p-3 bg-gray-50", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-900 mb-2", children: "Data to Sign" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600", children: "Unknown data format" })
        ] });
    }
  };
  if (!isOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white rounded-lg max-w-md w-full max-h-[90vh] overflow-y-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-bold text-gray-900", children: "Sign Data Request" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 text-sm mt-1", children: "A dApp wants you to sign data with your wallet" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border rounded-lg p-4 bg-gray-50", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-gray-900 mb-3", children: "Request Details" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-600", children: "From:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-mono text-black", children: formatAddress(request.from) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-600", children: "Wallet:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-mono text-black", children: formatAddress(request.wallet.getAddress()) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-600", children: "Request ID:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm font-mono text-black text-xs", children: [
          request.id.slice(0, 8),
          "..."
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-900 mb-3", children: "Data to Sign" }),
      renderDataPreview()
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-yellow-50 border border-yellow-200 rounded-lg p-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "h-5 w-5 text-yellow-400", viewBox: "0 0 20 20", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fillRule: "evenodd",
          d: "M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z",
          clipRule: "evenodd"
        }
      ) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-yellow-800", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Warning:" }),
        " Only sign data if you trust the requesting dApp and understand what you're signing. Signing data can have security implications."
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: handleReject, disabled: isLoading, className: "flex-1", children: "Reject" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          onClick: handleApprove,
          isLoading,
          disabled: isLoading,
          className: "flex-1",
          children: "Sign Data"
        }
      )
    ] })
  ] }) }) }) });
};

function formatUnits(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative) display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [display.slice(0, display.length - decimals), display.slice(display.length - decimals)];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}

const log = createComponentLogger("TransactionRequestModal");
const TransactionRequestModal = ({
  request,
  isOpen,
  onApprove,
  onReject
}) => {
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const handleApprove = async () => {
    setIsLoading(true);
    try {
      await onApprove();
    } catch (error) {
      log.error("Failed to approve transaction:", error);
    } finally {
      setIsLoading(false);
    }
  };
  const handleReject = () => {
    onReject("User rejected the transaction");
  };
  const formatAddress = (address) => {
    try {
      const addr = typeof address === "string" ? address : address.toString();
      if (!addr) return "";
      return `${addr.slice(0, 8)}...${addr.slice(-8)}`;
    } catch {
      return "";
    }
  };
  if (!isOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white rounded-lg max-w-md w-full max-h-[90vh] overflow-y-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-xl font-bold text-gray-900", children: "Transaction Request" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 text-sm mt-1", children: "A dApp wants to send a transaction from your wallet" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border rounded-lg p-4 bg-gray-50", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-semibold text-gray-900 mb-3", children: "Transaction Summary" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-600", children: "From:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-mono text-black", children: formatAddress(request.wallet?.getAddress() || "") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-600", children: "Network:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-black", children: request.request.network === "-3" ? "Testnet" : request.request.network === "-239" ? "Mainnet" : "Unknown" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-600", children: "Valid Until:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-black", children: new Date(request.request.valid_until * 1e3).toLocaleString() })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-900 mb-3", children: "Transaction Overview" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          JettonFlow,
          {
            jettonTransfers: request.preview.moneyFlow.jettonTransfers,
            ourAddress: request.preview.moneyFlow.ourAddress,
            tonDifference: request.preview.moneyFlow.inputs - request.preview.moneyFlow.outputs
          }
        ),
        request.preview.moneyFlow.outputs === 0n && request.preview.moneyFlow.inputs === 0n && request.preview.moneyFlow.jettonTransfers.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border rounded-lg p-3 bg-gray-50", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600 text-center", children: "This transaction doesn't involve any token transfers" }) })
      ] })
    ] }),
    request.preview.moneyFlow.ourAddress && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border rounded-lg p-4 bg-blue-50", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-900 mb-3", children: "Wallet Information" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-600", children: "Your Wallet:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-mono", children: formatAddress(request.preview.moneyFlow.ourAddress) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-red-50 border border-red-200 rounded-lg p-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "h-5 w-5 text-red-400", viewBox: "0 0 20 20", fill: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fillRule: "evenodd",
          d: "M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z",
          clipRule: "evenodd"
        }
      ) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-red-800", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Warning:" }),
        " This transaction will be irreversible. Only approve if you trust the requesting dApp and understand the transaction details."
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "secondary", onClick: handleReject, disabled: isLoading, className: "flex-1", children: "Reject" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          onClick: handleApprove,
          isLoading,
          disabled: isLoading,
          className: "flex-1",
          children: "Approve & Sign"
        }
      )
    ] })
  ] }) }) }) });
};
function useJettonInfo(jettonAddress) {
  const [jettonInfo, setJettonInfo] = reactExports.useState(null);
  reactExports.useEffect(() => {
    if (!jettonAddress) {
      setJettonInfo(null);
      return;
    }
    const jettonInfo2 = walletKit.jettons.getJettonInfo(jettonAddress.toString());
    setJettonInfo(jettonInfo2);
  }, [jettonAddress]);
  return jettonInfo;
}
function SafeParseAddress(address) {
  try {
    return distExports$3.Address.parse(address).toString();
  } catch {
    return null;
  }
}
const JettonNameDisplay = reactExports.memo(function JettonNameDisplay2({
  jettonAddress
}) {
  const jettonInfo = useJettonInfo(
    jettonAddress ? typeof jettonAddress === "string" && jettonAddress !== "TON" ? SafeParseAddress(jettonAddress) : jettonAddress : null
  );
  const name = jettonInfo?.name;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: name ?? jettonAddress?.toString() ?? "UNKNOWN" });
});
const JettonAmountDisplay = reactExports.memo(function JettonAmountDisplay2({
  amount,
  jettonAddress
}) {
  const jettonInfo = useJettonInfo(
    jettonAddress ? typeof jettonAddress === "string" && jettonAddress !== "TON" ? SafeParseAddress(jettonAddress) : jettonAddress : null
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    formatUnits(amount, jettonInfo?.decimals ?? 9),
    " ",
    jettonInfo?.symbol ?? "UNKWN"
  ] });
});
const JettonImage = reactExports.memo(function JettonImage2({
  jettonAddress
}) {
  const jettonInfo = useJettonInfo(
    jettonAddress ? typeof jettonAddress === "string" && jettonAddress !== "TON" ? SafeParseAddress(jettonAddress) : jettonAddress : null
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: jettonInfo?.image, alt: jettonInfo?.name, className: "w-8 h-8 rounded-full" });
});
const JettonFlowItem = reactExports.memo(function JettonFlowItem2({
  jettonAddress,
  amount
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "truncate max-w-[200px] flex items-center gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(JettonImage, { jettonAddress }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(JettonNameDisplay, { jettonAddress })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex ml-2 font-medium ${amount >= 0n ? "text-green-600" : "text-red-600"}`, children: [
      amount >= 0n ? "+" : "",
      /* @__PURE__ */ jsxRuntimeExports.jsx(JettonAmountDisplay, { amount, jettonAddress })
    ] })
  ] });
});
const JettonFlow = reactExports.memo(function JettonFlow2({
  jettonTransfers,
  tonDifference,
  ourAddress
}) {
  const jettonFlows = reactExports.useMemo(() => {
    return jettonTransfers.reduce((acc, transfer) => {
      const jettonKey = transfer.jetton?.toString() || "unknown";
      if (jettonKey === "EQCM3B12QK1e4yZSf8GtBRT0aLMNyEsBc_DhVfRRtOEffLez") {
        return acc;
      }
      if (jettonKey === "EQBnGWMCf3-FZZq1W4IWcWiGAc3PHuZ0_H-7sad2oY00o83S") {
        return acc;
      }
      const rawKey = distExports$3.Address.parse(jettonKey).toRawString().toLocaleUpperCase();
      if (!acc[rawKey]) {
        acc[rawKey] = 0n;
      }
      if (ourAddress && transfer.to.equals(ourAddress)) {
        acc[rawKey] += transfer.amount;
      }
      if (ourAddress && transfer.from.equals(ourAddress)) {
        acc[rawKey] -= transfer.amount;
      }
      return acc;
    }, {});
  }, [jettonTransfers, ourAddress?.toRawString()]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-semibold mb-1", children: "Money Flow:" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(JettonFlowItem, { jettonAddress: "TON", amount: tonDifference }),
      Object.entries(jettonFlows).length > 0 ? Object.entries(jettonFlows).map(([jettonAddr, amount]) => /* @__PURE__ */ jsxRuntimeExports.jsx(JettonFlowItem, { jettonAddress: jettonAddr, amount }, jettonAddr)) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {})
    ] })
  ] });
});

function App() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AppRouter, {});
}

clientExports.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
);
